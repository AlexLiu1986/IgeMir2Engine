unit ObjBase;

interface
uses
  Windows, Classes, SysUtils, Forms, StrUtils, StdCtrls, Grobal2, Envir, Common, ObjPlayRobot;

type
  PTBaseObject = ^TBaseObject;
  TBaseObject = class
    m_sMapName: string[MAPNAMELEN]; //地图名称
    m_sCharName: string[ACTORNAMELEN]; //人物名称
    m_nCurrX: Integer; //物所在座标X(4字节)
    m_nCurrY: Integer; //人物所在座标Y(4字节)
    m_btDirection: Byte;//人物所在方向(1字节)
    m_btGender: Byte; //人物的性别(1字节)
    m_btHair: Byte; //人物的头发(1字节)
    m_btJob: Byte; //人物的职业 0-战 1-法 2-道 3-刺客
    m_nGold: Integer; //人物金币数(4字节)
    m_Abil: TAbility; //
    m_nCharStatus: Integer; //人物状态
    m_sHomeMap: string[MAPNAMELEN];//回城地图
    m_nHomeX: Integer;//回城座标X
    m_nHomeY: Integer;//回城座标Y
    m_boOnHorse: Boolean; //骑马
    m_btHorseType: Byte; //马的类型
    m_btDressEffType: Byte;//着装效果

    m_nPkPoint: Integer; //人物的PK值(4字节)
    btB2: Byte; //0xB2

    m_nIncHealth: Integer; //增加健康值
    m_nIncSpell: Integer; //增加攻击值
    m_nIncHealing: Integer; //增加治愈值
    m_nFightZoneDieCount: Integer; //在行会战争地图中死亡次数
    //nC4: Integer;//20081007 注释，nC4无实际用处

    m_BonusAbil: TNakedAbility; //人物永久属性
    m_nBonusPoint: Integer; //奖金点

    m_dBodyLuck: Double; //幸运度
    m_nBodyLuckLevel: Integer;//幸运度等级

    m_QuestFlag: TQuestFlag; //脚本变量
    m_nCharStatusEx: Integer;
    m_dwFightExp: LongWord;//怪物经验值
    m_WAbil: TAbility;//角色属性
    m_AddAbil: TAddAbility; //增加的属性
    m_nViewRange: Integer; //可视范围大小
    m_wStatusTimeArr: TStatusTime;//人物状态属性值，一般是持续多少秒
    m_dwStatusArrTick: array[0..MAX_STATUS_ATTRIBUTE - 1] of LongWord; //人物状态持续的开始时间
    m_wStatusArrValue: array[0..MAX_STATUS_ATTRIBUTE - 1] of Word; //攻击力增加  2-无极真气 4-酒气护体
    m_dwStatusArrTimeOutTick: array[0..MAX_STATUS_ATTRIBUTE - 1] of LongWord;  //多少秒  2-无极真气时长  4-酒气护体间隔

    m_wAppr: Word;//形像代码
    m_btRaceServer: Byte; //角色类型
    m_btRaceImg: Byte; //角色外形
    m_btHitPoint: Byte; //人物攻击准确度(Byte)
    m_nHitPlus: ShortInt; //另加攻击伤害(攻杀)
    m_nHitDouble: ShortInt; //双倍攻击伤害
    m_dwGroupRcallTick: LongWord; //记忆使用间隔(Dword)
    m_boRecallSuite: Boolean; //记忆全套
    bo245: Boolean; 
    //m_boTestGa: Boolean; //是否输入Testga 命令(提权,后门) 20081014
    m_nHealthRecover: ShortInt; //体力恢复
    m_nSpellRecover: ShortInt; //魔法恢复
    m_btAntiPoison: Byte; //中毒躲避
    m_nPoisonRecover: ShortInt; //中毒恢复
    m_nAntiMagic: ShortInt; //魔法躲避
    m_nLuck: Integer; //人物的幸运值Luck (爆率机率)
    m_nPerHealth: Integer; //
    m_nPerHealing: Integer; //
    m_nPerSpell: Integer; //
    m_dwIncHealthSpellTick: LongWord; //增加攻击的间隔
    m_btGreenPoisoningPoint: Byte; //中绿毒降HP点数
    m_nGoldMax: Integer; //人物身上最多可带金币数(Dword)
    m_btSpeedPoint: Byte; //人物敏捷度(Byte)
    m_btPermission: Byte; //人物权限等级
    m_nHitSpeed: ShortInt; //攻击速度
    m_btLifeAttrib: Byte; //不死系,1-为不死系
    m_btCoolEye: Word{Byte}; //否可以看到隐身人物(视线范围) 20080623

    m_Master: TBaseObject; //是否被召唤(主人)
    m_dwMasterRoyaltyTick: LongWord; //怪物叛变时间
    m_dwMasterRoyaltyTime: LongWord;//怪物叛变计时 20080813
    m_dwMasterTick: LongWord;
    n294: Integer; //宝宝杀怪计数,用于宝宝升级用
    m_btSlaveExpLevel: Byte; //宝宝等级 1-7
    m_btSlaveMakeLevel: Byte; //召唤等级
    m_SlaveList: TList; //下属列表

    m_boSlaveRelax: Boolean; //宝宝攻击状态(休息/攻击)(Byte)
    m_btAttatckMode: Byte; //下属攻击状态
    m_btNameColor: Byte; //名字的颜色
    m_nLight: Integer; //亮度
    m_boGuildWarArea: Boolean;//行会占争范围
    m_Castle: TObject; //所属城堡
    bo2B0: Boolean; //0x2B0
    m_dw2B4Tick: LongWord; //0x2B4
    m_boSuperMan: Boolean; //无敌模式
    bo2B9: Boolean; //0x2B9
    bo2BA: Boolean; //不进入火墙
    m_boAnimal: Boolean; //是否是动物
    m_boNoItem: Boolean; //人物死亡是否不掉物品
    m_boFixedHideMode: Boolean;//隐身模式
    m_boStickMode: Boolean;//不能冲撞模式(即敌人不能使用野蛮冲撞技能攻击)
    bo2BF: Boolean; //0x2BF
    m_boNoAttackMode: Boolean;//非攻击模式
    bo2C1: Boolean; //0x2C1
    m_boSkeleton: Boolean; //尸体
    m_nMeatQuality: Integer; //挖肉，肉的品质
    m_nBodyLeathery: Integer;//身体坚韧性
    
    m_boHolySeize: Boolean; //不能走动模式
    m_dwHolySeizeTick: LongWord;//不能走动间隔
    m_dwHolySeizeInterval: LongWord;//不能走动时长
    m_boCrazyMode: Boolean; //狂化模式(红名)
    m_dwCrazyModeTick: LongWord; //狂化模式间隔
    m_dwCrazyModeInterval: LongWord; //狂化模式时长
    m_boShowHP: Boolean; //心灵启示
    m_dwShowHPTick: LongWord; //心灵启示检查时间(Dword)
    m_dwShowHPInterval: LongWord; //心灵启示有效时长(Dword)

    bo2F0: Boolean; //0x2F0
    m_dwDupObjTick: LongWord; //0x2F4
    m_PEnvir: TEnvirnoment; //所在地图场景
    m_boGhost: Boolean; //尸体清除
    m_dwGhostTick: LongWord; //尸体清除间隔
    m_boDeath: Boolean; //死亡
    m_dwDeathTick: LongWord; //死亡间隔
    m_btMonsterWeapon: Byte; //怪物所拿的武器
    m_dwStruckTick: LongWord; //弯腰间隔
    m_boWantRefMsg: Boolean; //刷新消息
    m_boAddtoMapSuccess: Boolean; //增加到地图是否成功
    m_bo316: Boolean; //0x316

    m_MyGuild: TObject; //我的行会
    m_nGuildRankNo: Integer; //行会排名
    m_sGuildRankName: string; //行会封号
    
    m_btAttackSkillCount: Byte; //攻杀相关
    m_btAttackSkillPointCount: Byte; //攻杀计数

    m_boMission: Boolean; //怪物向集中点集中
    m_nMissionX: Integer; //集中点坐标X
    m_nMissionY: Integer; //集中点坐标Y

    m_boHideMode: Boolean;//隐身戒指
    m_boStoneMode: Boolean;//石像化
    m_boCoolEye: Boolean; //是否可以看到隐身人物(视线范围)
    m_boUserUnLockDurg: Boolean; //是否用了神水
    m_boTransparent: Boolean; //魔法隐身了
    m_boAdminMode: Boolean; //管理模式
    m_boObMode: Boolean; //隐身模式
    m_boTeleport: Boolean; //传送戒指
    m_boParalysis: Boolean; //麻痹戒指
    m_boUnParalysis: Boolean;//防麻痹
    m_boRevival: Boolean; //复活戒指
    m_boUnRevival: Boolean; //防复活

    m_dwRevivalTick: LongWord; //复活戒指使用间隔计数
    m_boFlameRing: Boolean; //火焰戒指
    m_boRecoveryRing: Boolean; //治愈戒指
    m_boAngryRing: Boolean; //未知戒指
    m_boMagicShield: Boolean; //护身戒指
    m_boUnMagicShield: Boolean; //防护身
    m_boMuscleRing: Boolean; //活力戒指
    m_boFastTrain: Boolean; //技巧项链
    m_boProbeNecklace: Boolean; //探测项链
    m_boGuildMove: Boolean; //行会传送
    m_boSupermanItem: Boolean;//无敌(未完全)物品  
    m_bopirit: Boolean; //触发祈祷

    m_boNoDropItem: Boolean;//掉物品
    m_boNoDropUseItem: Boolean;//死亡是不是掉装备
    m_boExpItem: Boolean;//经验物品
    m_rExpItem: real;//经验物品值
    m_boPowerItem: Boolean;//力量物品(影响力量的物品)
    m_rPowerItem: real;//力量物品值

    m_dwPKDieLostExp: LongWord; //PK 死亡掉经验，不够经验就掉等级
    m_nPKDieLostLevel: Integer; //PK 死亡掉等级

    m_boAbilSeeHealGauge: Boolean; //心灵启示
    m_boAbilMagBubbleDefence: Boolean; //是否使用魔法盾
    m_btMagBubbleDefenceLevel: Byte; //魔法盾等级
    m_boProtectionDefence: Boolean; //是否使用护体神盾 20080107
    m_boProtectionDefenceLevel: Byte;//护体神盾等级 20080929
    m_boProtectionTick:LongWord;//使用护体神盾的结束时间 20080109
    m_boMagChangXYTick:LongWord;//移行换位使用间隔 20080616
    m_dwSearchTime: LongWord; //搜索时间
    m_dwSearchTick: LongWord; //搜索间隔
    m_dwRunTick: LongWord; //运行间隔
    m_nRunTime: Integer; //运行时间
    m_nHealthTick: Integer;//特别指定为 此类型  此处用到 004C7CF8
    m_nSpellTick: Integer; //0x374
    m_TargetCret: TBaseObject; //目标(攻击或加血,等对像)
    m_dwTargetFocusTick: LongWord; //0x37C
    m_LastHiter: TBaseObject; //人物被对方杀害时对方指针
    m_LastHiterTick: LongWord; //0x384
    m_ExpHitter: TBaseObject; //敌人伤害时对方指针
    m_ExpHitterTick: LongWord; //0x38C
    m_dwTeleportTick: LongWord; //传送戒指使用间隔(Dword)
    m_dwProbeTick: LongWord; //探测项链使用间隔(Dword)
    m_dwMapMoveTick: LongWord; //地图传送使用间隔
    m_boPKFlag: Boolean; //人物攻击变色标志(灰色)
    m_dwPKTick: LongWord; //人物攻击变色时间长度(Dword)
    m_nMoXieSuite: Integer; //魔血一套(Dword)
    m_nHongMoSuite: Integer; //虹魔一套(Dword)
 
    m_db3B0: Double; //0x3B0
    m_dwPoisoningTick: LongWord; //中毒处理间隔时间
    m_dwDecPkPointTick: LongWord; //减PK值时间
    m_DecLightItemDrugTick: LongWord; //照明物品使用间隔
    m_dwVerifyTick: LongWord; //0x3C4
    m_dwCheckRoyaltyTick: LongWord; //0x3C8
    m_dwDecHungerPointTick: LongWord; //0x3CC
    m_dwHPMPTick: LongWord; //0x3D0                                         
    m_MsgList: TList; //消息列表
    m_VisibleHumanList: TList; //可见的人物列表
    m_VisibleItems: TList; //可见的物品列表
    m_VisibleEvents: TList; //0x3E0
    m_SendRefMsgTick: LongWord; //发送刷新消息的间隔
    m_boInFreePKArea: Boolean; //是否在开行会战

    dwTick3F4: LongWord; //跑步间隔 20080217
    m_dwHitTick: LongWord; //攻击间隔
    m_dwWalkTick: LongWord; //走路间隔
    m_dwSearchEnemyTick: LongWord; //0x400
    m_boNameColorChanged: Boolean; //名字颜色改变
    m_boIsVisibleActive: Boolean; //是否在可视范围内有人物,及宝宝
    m_nProcessRunCount: ShortInt;
    m_VisibleActors: TList; //可见角色列表
    m_ItemList: TList; //背包列表
    m_MagicList: TList; //技能表
    m_UseItems: THumanUseItems; //装备栏物品
    m_SayMsgList: TList;
    m_nWalkSpeed: Integer;//走路速度
    m_nWalkStep: Integer;//行走步伐
    m_nWalkCount: Integer;//0x504
    m_dwWalkWait: LongWord;//0x508
    m_dwWalkWaitTick: LongWord;//0x50C
    m_boWalkWaitLocked: Boolean;//步行等待锁定
    m_nNextHitTime: Integer; //0x514
    m_MagicOneSwordSkill: pTUserMagic; //基本剑术
    m_MagicPowerHitSkill: pTUserMagic; //攻杀
    m_MagicErgumSkill: pTUserMagic; //刺杀剑法
    m_MagicBanwolSkill: pTUserMagic; //半月弯刀
    m_MagicFireSwordSkill: pTUserMagic;//烈火剑法 20080112
    m_MagicCrsSkill: pTUserMagic; //抱月弯刀
    m_Magic41Skill: pTUserMagic; //狮子吼
    m_Magic42Skill: pTUserMagic; //开天斩
    m_Magic43Skill: pTUserMagic; //龙影剑法
    m_Magic60Skill: pTUserMagic; //破魂斩
    m_Magic67Skill: pTUserMagic; //先天元力 20080626
    m_Magic68Skill: pTUserMagic; //酒气护体 20080625
    m_Magic74Skill: pTUserMagic; //逐日剑法 20080511
    m_Magic75Skill: pTUserMagic; //护体神盾 20080218

    m_boPowerHit: Boolean;//攻杀是否可用
    m_boUseThrusting: Boolean;//刺杀剑法是否可用
    m_boUseHalfMoon: Boolean;//半月弯刀是否可用
    m_boFireHitSkill: Boolean;//烈火剑法是否可用
    m_boDailySkill: Boolean;//逐日剑法是否可用 20080511
    m_boCrsHitkill: Boolean;//抱月弯刀是否可用
    m_bo42kill: Boolean;//开天斩是否可用
    m_n42kill : Byte;//开天斩重轻击 20080212 初始为0,1轻,2重
    m_bo43kill: Boolean;//龙影剑法是否可用
    m_bo60kill: Boolean;//破魂斩是否可用
    m_dwLatestFireHitTick: LongWord; //烈火的间隔
    m_dwLatestDailyTick: LongWord; //逐日剑法的间隔 20080511
    m_dwLatest42Tick: LongWord; //开天斩的间隔 20080202
    m_dwLatest43Tick: LongWord; //龙影剑法间隔 20080202
    m_dwLatest46Tick: LongWord; //分身术的间隔 20080204
    m_boDenyRefStatus: Boolean; //是否刷新在地图上信息；
    m_boAddToMaped: Boolean; //是否增加地图计数(人物或怪物数量) T-不需要再计数,F-需要计数
    m_boDelFormMaped: Boolean; //是否从地图中删除计数
    m_boAutoChangeColor: Boolean; //是否自动变色
    m_dwAutoChangeColorTick: LongWord;//自动变色间隔
    m_nAutoChangeIdx: Integer;//自动改变的索引
    m_nChangeColorType: Integer;//变色的类型
    m_boSetNameColor: Boolean;//是否自定义名字颜色 20080913

    m_boFixColor: Boolean; //固定颜色
    m_nFixColorIdx: Integer;//固定颜色的索引
    m_nFixStatus: Integer;
    m_boFastParalysis: Boolean; //快速麻痹，受攻击后麻痹立即消失

    m_DefMsg: TDefaultMessage;

    m_nCopyHumanLevel: Integer; //复制人辈分等级,显示名字用到
    m_dwStationTick: LongWord; //增加检测人物站立不动时间

    m_btLastOutStatus: Byte; //退出状态 1为死亡
    //m_nDragonPoint: Integer;//黄条气值  20080201  20080619 注释
    m_nWinExp: LongWord;//累计经验,达到一定值,增加英雄的忠诚度(20080110)   20080918 聚灵珠使用
    m_boOperationItemList: Boolean;//正在操作背包列表 20080928
    m_boIsNGMonster: Boolean;//内功怪,打死可以增加内力值 20081001
  private
    function InSafeArea: Boolean;//在安全区
    procedure UpdateVisibleGay(BaseObject: TBaseObject);//更新可见的角色
    function Walk(nIdent: Integer): Boolean;//步行
    function AddToMap(): Boolean;//增加到地图
    procedure UseLamp();//使用灯
    procedure CheckPKStatus();//检测PK状态
    procedure UpdateVisibleItem(wX, wY: Integer; MapItem: PTMapItem);//更新可见的物品
    procedure UpdateVisibleEvent(wX, wY: Integer; MapEvent: TObject);
    procedure GetAccessory(Item: TUserItem; var AddAbility: TAddAbility);//获取装备附加属性
    procedure RecalcHitSpeed();
    procedure AddItemSkill(nIndex: Integer);
    procedure DelItemSkill(nIndex: Integer);
    procedure DecPKPoint(nPoint: Integer);//减少PK点
    procedure HearMsg(sMsg: string);//查询在线人数即 who Total 命令返回
    procedure DoDamageWeapon(nWeaponDamage: Integer);//做损坏的武器
    function MoneyToCharacter(Money:Integer):string; //数字转换为中文大写 20080603
    procedure DieDropItems;//死亡必掉物品 20080614
  public
    procedure AttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word; nDir: Integer); virtual;//攻击目标
    function IsAddWeightAvailable(nWeight: Integer): Boolean;//是可用的增加重量
    procedure DamageSpell(nSpellPoint: Integer);//魔法损害
    function GetCharColor(BaseObject: TBaseObject): Byte;//取名字颜色值
    function GetNamecolor: Byte; virtual;//取名字颜色
    function RecalcBagWeight(): Integer;//刷新包裹重量
    constructor Create(); virtual;
    destructor Destroy; override;
    function GetLevelExp(nLevel: Integer): LongWord;//取等级经验值
    function GetMedicineExp(nLevel: Integer): Word;//取等级所需药力值 20080624
    function GetSkill68Exp(nLevel: Byte): LongWord;//酒气护体 取等级所需经验值 20080625
    function GetSkill69Exp(nLevel: Byte;var nMaxNH: Word): LongWord;//内功心法 取等级所需经验值,内力值上限 20080930
    procedure SendMsg(BaseObject: TBaseObject; wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: string);//发送消息
    procedure SendFirstMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string);//发送第一次消息
    procedure SendDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string;dwDelay: LongWord);//发送延时消息
    procedure SendRefMsg(wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: string);//发送刷新消息
    procedure SendUpdateMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string);//发送更新消息
    procedure SendUpdateDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word;lParam1, lParam2, lParam3: Integer; sMsg: string; dwDelay: LongWord);//发送更新延时的消息

    procedure SendActionMsg(BaseObject: TBaseObject; wIdent, wParam: Word;lParam1, lParam2, lParam3: Integer; sMsg: string);//发送行动的消息
    procedure SendAttackMsg(wIdent: Word; btDir: Byte; nX, nY: Integer);//发送攻击的消息
    procedure SysMsg(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType);
    procedure SysMsg1(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType; FColor, BColor: Byte);
    procedure MonsterSayMsg(AttackBaseObject: TBaseObject; MonStatus: TMonStatus);
    //function IsVisibleHuman(): Boolean;//是可见的人物  未使用 20080329
    procedure RecalcLevelAbilitys;//刷新等级能力
    function PKLevel(): Integer;//PK等级
    function InSafeZone(): Boolean; overload;//在安全区
    function InSafeZone(Envir: TEnvirnoment; nX, nY: Integer): Boolean; overload;//在安全区
    procedure OpenHolySeizeMode(dwInterval: LongWord);//打开圣地模式
    procedure BreakHolySeizeMode;//打破圣地模式
    procedure OpenCrazyMode(nTime: Integer);//开启怪物狂化模式
    procedure BreakCrazyMode();//关闭怪物狂化模式
    procedure HealthSpellChanged();//健康点的改变
    procedure PlugHealthSpellChanged;//插件气血改变血量 20080423
    function _Attack(var wHitMode: Word; AttackTarget: TBaseObject): Boolean;//攻击
    function GetHitStruckDamage(Target: TBaseObject; nDamage: Integer): Integer;//取击中的损坏点
    procedure HasLevelUp(nLevel: Integer);//等级提升

    procedure GoldChanged();//黄金生成
    procedure GameGoldChanged;//游戏币生成
    procedure GameGloryChanged(); //荣誉值改变

    function GetFeatureEx: Word;
    function GetPoseCreate(): TBaseObject;
    function GetGuildRelation(cert1: TBaseObject; cert2: TBaseObject): Integer;
    function IsGoodKilling(Cert: TBaseObject): Boolean;
    procedure IncPkPoint(nPoint: Integer);//增加PK值
    procedure AddBodyLuck(dLuck: Double);//增加宝宝幸运
    procedure MakeWeaponUnlock();
    procedure ScatterGolds(GoldOfCreat: TBaseObject);
    function DropGoldDown(nGold: Integer; boFalg: Boolean; GoldOfCreat, DropGoldCreat: TBaseObject): Boolean;
    function DropItemDown(UserItem: pTUserItem; nScatterRange: Integer; boDieDrop, boCanHit: Boolean; ItemOfCreat, DropCreat: TBaseObject): Boolean;
    procedure DamageHealth(nDamage: Integer);//中毒减血
    function GetAttackPower(nBasePower, nPower: Integer): Integer;//取攻击值
    function CharPushed(nDir, nPushCount: Integer): Integer;
    function GetDropPosition(nOrgX, nOrgY, nRange: Integer; var nDX: Integer; var nDY: Integer): Boolean;//取掉物的位置
    function GetBackDir(nDir: Integer): Integer;
    function GetMapBaseObjects(tEnvir: TEnvirnoment; nX, nY: Integer; nRage: Integer; rList: TList): Boolean;
    function GetDirectionBaseObjects_42(btDir, nRage: Integer; rList: TList): Boolean;//取同方向里的目标(龙影)
    function GetDirectionBaseObjects(btDir, nRage: Integer; rList: TList): Boolean;//取同方向里的目标(开天 破魂)
    function GetDirBaseObjectsCount(btDir, nRage: Integer): Integer;//取同方向的怪数 疾光电影使用判断怪的数量 20080421

    function MagPassThroughMagic(sX, sY, tx, ty, nDir, magpwr,nSccPwr: Integer; undeadattack: Boolean; nCode:Byte): Integer;
    procedure KickException;//踢除异常
    function GetMagStruckDamage(BaseObject: TBaseObject; nDamage: Integer): Integer;
    procedure DamageBubbleDefence(nInt: Integer);//减少打击的损害值
    procedure DamageProtectionDefence(nInt: Integer);//护体神盾 20080108
    procedure BreakOpenHealth;
    function GetCharStatus: Integer;//取角色状态
    procedure MakeOpenHealth;
    procedure IncHealthSpell(nHP, nMP: Integer);//增加HP MP值
    procedure ItemDamageRevivalRing;//复活戒指生效，体力恢复
    function CalcGetExp(nLevel: Integer; nExp: Integer): Integer;
    procedure GainSlaveExp(nLevel: Integer);//宝宝升级
    procedure MapRandomMove(sMapName: string; nInt: Integer);//地图随机移动
    procedure TurnTo(nDir: Integer);//人物转身
    procedure FeatureChanged();//着装改变
    function GetFeatureToLong(): Integer;
    function GetFeature(BaseObject: TBaseObject): Integer;

    procedure AbilCopyToWAbil();
    procedure ChangePKStatus(boWarFlag: Boolean);//改变PK状态
    procedure StruckDamage(nDamage: Integer);virtual;//增加virtual;20080607
    function sub_4C4CD4(sItemName: string; var nCount: Integer): pTUserItem;
    procedure StatusChanged(Str: String);//状态改变
    function GeTBaseObjectInfo(): string;
    procedure TrainSkill(UserMagic: pTUserMagic; nTranPoint: Integer);
    function CheckMagicLevelup(UserMagic: pTUserMagic): Boolean;//检查魔法是否升级
    function MagCanHitTarget(nX, nY: Integer; TargeTBaseObject: TBaseObject): Boolean;//魔法能攻的目标
    procedure sub_4C713C(Magic: pTUserMagic);
    function MagBubbleDefenceUp(nLevel, nSec: Integer): Boolean;//魔法盾
    function MagProtectionDefenceUp(nLevel: Integer): Boolean;//护体神盾 20080107
    procedure ApplyMeatQuality();
    function TakeBagItems(BaseObject: TBaseObject): Boolean;
    function AddItemToBag(UserItem: pTUserItem): Boolean;
    function DelBagItem(nIndex: Integer): Boolean; overload;//删除包裹物品
    function DelBagItem(nItemIndex: Integer; sItemName: string): Boolean; overload;//删除包裹物品
    function DelBagItem(UserItem: pTUserItem): Boolean; overload; //删除包裹物品

    procedure WeightChanged();//重量改变
    function IsTrainingSkill(nIndex: Integer): Boolean;
    procedure SetQuestFlagStatus(nFlag: Integer; nValue: Integer);
    function GetQuestFalgStatus(nFlag: Integer): Integer;
    function GetAttackDir(BaseObject: TBaseObject; var btDir: Byte): Boolean;//取攻击的方向
    function TargetInSpitRange(BaseObject: TBaseObject; var btDir: Byte): Boolean;
    procedure MonsterRecalcAbilitys();//怪物刷新各种能力
    procedure RefNameColor;//刷新名字颜色
    procedure SetPKFlag(BaseObject: TBaseObject);
    procedure SetLastHiter(BaseObject: TBaseObject);
    function EnterAnotherMap(Envir: TEnvirnoment; nDMapX, nDMapY: Integer): Boolean;
    function sub_4DD704(): Boolean;
    function DefenceUp(nSec: Integer): Boolean;//防御力增加
    function MagDefenceUp(nSec: Integer): Boolean;//魔防御力增加
   // function DefenceDown(nSec: Integer): Boolean; //防御力减少 未使用 20080329
   // function MagDefenceDown(nSec: Integer): Boolean; //魔防御力减少 未使用 20080329
    procedure RefShowName;
    function MakeSlave(sMonName: string; nMakeLevel, nExpLevel, nMaxMob: Integer; dwRoyaltySec: LongWord): TBaseObject;
    function MakePosion(nType, nTime, nPoint: Integer): Boolean;
    function MakeSpiderMag( nTime: Integer): Boolean;//中蛛网，不能跑动 20080811
    function GetFrontPosition(var nX: Integer; var nY: Integer): Boolean;
    function GetBackPosition(var nX: Integer; var nY: Integer): Boolean;
    function WalkTo(btDir: Byte; boFlag: Boolean): Boolean;
    procedure SpaceMove(sMAP: string; nX, nY: Integer; nInt: Integer);
    procedure SpaceMove2(nX, nY: Integer; nInt: Integer);
    function sub_4C5370(nX, nY: Integer; nRange: Integer; var nDX, nDY: Integer): Boolean;
    function CheckItems(sItemName: string): pTUserItem;
    function MagMakeDefenceArea(nX, nY, nRange, nSec: Integer; btState: Byte): Integer;
    function MagMakeAbilityArea(nX, nY, nRange, nSec: Integer): Integer;
    procedure MagDownHealth(nType, nTime, nPoint: Integer);

    function sub_4C3538(): Integer;
    function IsGuildMaster(): Boolean;//是行会主人
    procedure LoadSayMsg();
    procedure DisappearA();
    function GetShowName(): string; virtual;
    procedure DropUseItems(BaseObject: TBaseObject); virtual;//掉装备
    procedure ScatterBagItems(ItemOfCreat: TBaseObject); virtual;
    function GetMessage(Msg: pTProcessMessage): Boolean; virtual; //FFFF
    function MessageCount(): Integer;
    procedure Initialize(); virtual; //FFFE
    procedure Disappear(); virtual; //FFFD
    function Operate(ProcessMsg: pTProcessMessage): Boolean; virtual; //FFFC
    procedure SearchViewRange(); virtual; //dynamic;
    procedure Run(); virtual; //dynamic;//FFFB
    procedure ProcessSayMsg(sMsg: string); virtual;
    procedure ProcessSayMsg1(sMsg: string; FColor, BColor: Byte);//加强版文件信息发送函数(供NPC命令-SendMsg使用) 20081214
    procedure MakeGhost; virtual;
    procedure Die(); virtual;
    procedure ReAlive(); virtual; //FFF8;
    procedure RecalcAbilitys(); virtual; //刷新属性
    function IsProtectTarget(BaseObject: TBaseObject): Boolean; virtual; //FFF6
    function IsAttackTarget(BaseObject: TBaseObject): Boolean; virtual; //FFF5
    function IsProperTarget(BaseObject: TBaseObject): Boolean; virtual; //FFF4
    function IsProperFriend(BaseObject: TBaseObject): Boolean; virtual; //FFF3
    procedure SetTargetCreat(BaseObject: TBaseObject); virtual; //设置目标
    procedure DelTargetCreat(); virtual; //删除目标

    function IsProperTargetSKILL_54(BaseObject: TBaseObject): Boolean;
    function IsProperTargetSKILL_55(nLevel: Integer; BaseObject: TBaseObject): Boolean;
    function IsProperTargetSKILL_57(BaseObject: TBaseObject): Boolean;
    //function IsProperTargetSKILL_70(PlayObject: TBaseObject): Boolean;//未使用 20080329

    function RunTo(btDir: Byte; boFlag: Boolean; nDestX, nDestY: Integer): Boolean;
    procedure ThrustingOnOff(boSwitch: Boolean);
    procedure HalfMoonOnOff(boSwitch: Boolean);
    procedure SkillCrsOnOff(boSwitch: Boolean);
   // procedure Skill42OnOff(boSwitch: Boolean);
    function  Skill42OnOff(): Boolean; //20080202 开天斩
    function  Skill43OnOff(): Boolean;//20080619 替换
    function AllowFireHitSkill(): Boolean;
    function AllowDailySkill(): Boolean;//逐日剑法 20080511
    function CretInNearXY(TargeTBaseObject: TBaseObject; nX, nY: Integer): Boolean; overload;
    function CretInNearXY(TargeTBaseObject: TBaseObject; nX, nY: Integer; nRange: Integer): Boolean; overload;

    procedure KillSlave;//清除下属 20080124
    function ItemStruckDamage(nDamage: Integer): Integer;//盛大新戒指,减少受伤值  20080223
    procedure CompareSuitItem(boHint: boolean);//套装与身上装备对比 20080226
    function CheckItemValue(UserItem: pTUserItem; nType: Integer): Boolean;//判断绑定物品的属性 20080314
   // Function IsCastleMaster:Integer;//判断是不是城主或精英团 20080330
    function IsUsesZhuLi: Boolean;//是否使用斗笠 20080424
    function PlugOfCheckCanItem(nCode: Byte; ItemName: String; boCanHit: Boolean; dx, dy:Integer): Boolean;//禁止物品规则(管理插件功能) 20080729
    procedure SendNGData;//发送内功数据 20081005
    function CheckIsOKItem(UserItem: pTUserItem; nType: Integer): Boolean;//检查物品附加属性是否正常 20081006
  end;
  TAnimalObject = class(TBaseObject)
    m_nTargetX: Integer;
    m_nTargetY: Integer;
    m_boRunAwayMode: Boolean; //运行远离模式
    m_dwRunAwayStart: LongWord;//运行远离间隔
    m_dwRunAwayTime: LongWord;//运行远离时间
  private

  public
    constructor Create(); override;
    procedure SearchTarget();//搜索目标
    procedure sub_4C959C;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override;
    procedure Run; override;
    procedure DelTargetCreat(); override;
    procedure SetTargetXY(nX, nY: Integer); virtual;
    procedure GotoTargetXY(); virtual;
    procedure Wondering(); virtual;
    procedure Attack(TargeTBaseObject: TBaseObject; nDir: Integer); virtual;
    procedure Struck(hiter: TBaseObject); virtual;
    procedure HitMagAttackTarget(TargeTBaseObject: TBaseObject; nHitPower: Integer; nMagPower: Integer; boFlag: Boolean);

  end;
  PTPlayObject = ^TPlayObject;
  TPlayObject = class(TAnimalObject)
    m_dwDoMotaeboTick: LongWord; //野蛮冲撞间隔 20080529
    m_sLastMapName: string[MAPNAMELEN]; //人物死亡地图
    m_nLastCurrX: Integer; //人物死亡地图所在座标X(4字节)
    m_nLastCurrY: Integer; //人物死亡地图所在座标Y(4字节)
    m_nSayMsgCount: Integer; //0x560
    m_dwSayMsgTick: LongWord; //0x568
    m_boDisableSayMsg: Boolean; //0x56C
    m_dwDisableSayMsgTick: LongWord; //0x570
    m_dwCheckDupObjTick: LongWord; //0x574
    dwTick578: LongWord; //0x578
    dwTick57C: LongWord; //0x57C
    m_boInSafeArea: Boolean; //0x580
    m_sUserID: string[11]; //登录帐号名
    m_sIPaddr: string[15]; //人物IP地址
    m_sIPLocal: string;//IP所属地区

    m_dLogonTime: TDateTime; //登录时间
    m_dwLogonTick: LongWord; //在线时长
    m_boReadyRun: Boolean; //是否进入游戏完成
    m_nSessionID: Integer;
    m_nPayMent: Integer; //人物当前模式(测试/付费模式)(Dword)
    m_nPayMode: Integer;
    m_nServerIndex: Integer; //人物当前所在服务器序号
    m_boEmergencyClose: Boolean; //掉线标志
    m_boSoftClose: Boolean; //小退
    m_boKickFlag: Boolean; //踢人下线,断线标志(@kick 命令)
    m_boReconnection: Boolean; //重新连接标志
    m_boRcdSaved: Boolean; //是否保存数据
    m_boSwitchData: Boolean; //0x5D9
    m_nWriteChgDataErrCount: Integer; //0x5DC
    m_sSwitchMapName: string; //0x5E0
    m_nSwitchMapX: Integer; //0x5E4
    m_nSwitchMapY: Integer; //0x5E8
    m_boSwitchDataSended: Boolean; //0x5EC
    m_dwChgDataWritedTick: LongWord; //0x5F0                  

    m_nSocket: Integer; //0x59C nSocket
    m_nGSocketIdx: Integer; //人物连接到游戏网关SOCKET ID
    m_nGateIdx: Integer; //人物所在网关号
    m_nSoftVersionDate: Integer; //版本日期

    m_sScriptLable: string; //脚本标签
    m_dwUserTick: array[0..9] of LongWord; //由功能插件调用 0-倒计时传送到回城点(雪域) 1-商铺购买间隔 2-保存地图可以呆的时间(用于雪域续费)
    m_dwSayMyInfoTick: LongWord;

    {m_bo43DragonPoint: Boolean;//黄条气值相关  20080201
    m_dwAddDragonTick: LongWord;//增加黄条气值的间隔  20080201 } //20080619 注释

    m_boDealing: Boolean; //正在交易中
    m_DealLastTick: LongWord; //交易最后操作时间
    m_DealCreat: TPlayObject; //交易的主动方

    m_GroupOwner: TPlayObject; //组队队长
    m_GroupMembers: TStringList; //组成员
    m_boHearWhisper: Boolean; //允许私聊
    m_boBanShout: Boolean; //允许群聊
    m_boBanGmMsg: Boolean; //允许接收所有喊话 20080211
    m_boBanGuildChat: Boolean; //拒绝行会聊天
    m_boAllowDeal: Boolean; //是不允许交易
    m_BlockWhisperList: TStringList; //禁止私聊人员列表

    m_nHungerStatus: Integer; //饥饿状态----注释父类变量  20081014
    m_boAllowGuildReCall: Boolean; //行会合一
    m_wGroupRcallTime: Word; //队传送时间
    m_boAllowGroupReCall: Boolean; //0x10E 

    m_boSellOffOK: Boolean; //确认元宝寄售标志20080316
    m_SellOffItemList: TList; //元宝寄售物品列表 20080316

    m_RefineItemList: TList;//粹练物品列表 20080502

    m_DealItemList: TList; //交易物品列表
    m_nDealGolds: Integer; //交易的金币数量(Dword)
    m_boDealOK: Boolean; //确认交易标志(Byte)  确认元宝寄售标志20080316

    m_boAllowGroup: Boolean; //允许组队
    m_boAllowGuild: Boolean; //允许加入行会

    m_dwShoutMsgTick: LongWord;//喊消息间隔

    m_StorageItemList: TList;//仓库

    //m_dwHitIntervalTime: LongWord; //攻击间隔  20080826 未使用
    m_dwMagicHitIntervalTime: LongWord; //魔法间隔
    m_dwRunIntervalTime: LongWord; //跑步间隔
    m_dwWalkIntervalTime: LongWord; //走路间隔
    m_dwTurnIntervalTime: LongWord; //换方向间隔
    m_dwActionIntervalTime: LongWord; //组合操作间隔
    m_dwRunLongHitIntervalTime: LongWord; //移动刺杀间隔
    m_dwRunHitIntervalTime: LongWord; //跑位攻击间隔
    m_dwWalkHitIntervalTime: LongWord; //走位攻击间隔
    m_dwRunMagicIntervalTime: LongWord; //跑位魔法间隔

    m_dwMagicAttackTick: LongWord; //魔法攻击时间(Dword)
    m_dwMagicAttackInterval: LongWord; //魔法攻击间隔时间(Dword)
    m_dwAttackTick: LongWord; //攻击时间(Dword)
    m_dwMoveTick: LongWord; //人物跑动时间(Dword)
    m_dwAttackCount: LongWord; //人物攻击计数(Dword)
    m_dwAttackCountA: LongWord; //人物攻击计数(Dword)
    m_dwMagicAttackCount: LongWord; //魔法攻击计数(Dword)
    m_dwMoveCount: LongWord; //人物跑计数(Dword)
    m_dwMoveCountA: LongWord; //人物跑计数(Dword)
    m_nOverSpeedCount: Integer; //超速计数(Dword)
    m_boDieInFight3Zone: Boolean; //0x628
    m_Script: pTScript; //0x62C
    m_NPC: TBaseObject; //0x630
    m_nVal: array[0..99] of Integer; //玩家的变量
    m_nMval: array[0..99] of Integer;//玩家的变量
    m_DyVal: array[0..99] of Integer; //玩家的变量
    m_sPlayDiceLabel: string;
    m_boTimeRecall: Boolean; //0x684
    m_dwTimeRecallTick: LongWord;
    m_sMoveMap: string; //0x68C
    m_nMoveX: Integer; //0x690
    m_nMoveY: Integer; //0x694
    m_dwSaveRcdTick: LongWord; //保存人物数据时间间隔
    m_nBright: Integer; //0x6A4
    m_boNewHuman: Boolean; //新人物
    m_boSendNotice: Boolean; //0x6A9
    m_dwWaitLoginNoticeOKTick: LongWord;
    m_boLoginNoticeOK: Boolean; //在游戏公告上点了确定
    bo6AB: Boolean; //0x6AB
    m_boExpire: Boolean; //帐号过期
    m_dwShowLineNoticeTick: LongWord; //0x6B0
    m_nShowLineNoticeIdx: Integer; //当前显示公告的ID

    m_nSoftVersionDateEx: Integer;//客户端版本日期
    m_CanJmpScriptLableList: TStringList; //能跳转脚本标签列表
    m_nScriptGotoCount: Integer; //脚本跳转GOTO数
    m_sScriptCurrLable: string; //用于处理 @back 脚本命令
    m_sScriptGoBackLable: string; //用于处理 @back 脚本命令
    m_dwTurnTick: LongWord;//转向间隔
    m_wOldIdent: Word;//旧的动作消息
    m_btOldDir: Byte;//旧的方向

    //m_boFirstAction: Boolean; //第一个操作  未使用 20080329
    m_dwActionTick: LongWord; //二次操作之间间隔时间
    m_sDearName: string[ACTORNAMELEN]; //配偶名称
    m_DearHuman: TPlayObject;//配偶类
    m_boCanDearRecall: Boolean; //是否允许夫妻传送
    m_boCanMasterRecall: Boolean;//是否允许师徒传送
    m_dwDearRecallTick: LongWord; //夫妻传送间隔
    m_dwMasterRecallTick: LongWord;//师徒传送间隔
    
    m_sMasterName: string[ACTORNAMELEN]; //师傅名称
    m_MasterHuman: TPlayObject;
    m_MasterList: TList;//徒弟列表
    m_boMaster: Boolean;//是否是徒弟  T-有徒弟
    m_nMasterNo: Word; //徒弟排名 20080530
    m_MasterNoList: TStringList;//徒弟排名列表 20080530

    m_btCreditPoint: Integer; //声望点 20080118
    m_btMarryCount: Byte; //离婚次数
    m_btReLevel: Byte; //转生等级
    m_btReColorIdx: Byte;
    m_dwReColorTick: LongWord;
    m_dwGetMsgTick: LongWord; //处理消息循环时间控制

    m_boSetStoragePwd: Boolean;//设置仓库密码
    m_boReConfigPwd: Boolean;
    m_boCheckOldPwd: Boolean;//是否检查旧密码
    m_boUnLockPwd: Boolean;//解锁定
    m_boUnLockStoragePwd: Boolean;//锁定仓仓库密码
    m_boPasswordLocked: Boolean; //锁密码
    m_btPwdFailCount: Byte;
    m_boLockLogon: Boolean; //是否启用锁登录功能
    m_boLockLogoned: Boolean; //是否打开登录锁
    m_sTempPwd: string[7];//临时密码
    m_sStoragePwd: string[7];//仓库密码
    m_PoseBaseObject: TBaseObject;//面对面的角色
    m_boStartMarry: Boolean;
    m_boStartMaster: Boolean;//开始收徒或拜师
    m_boStartUnMarry: Boolean;
    m_boStartUnMaster: Boolean;//开始出师
    m_boFilterSendMsg: Boolean; //禁止发方字(发的文字只能自己看到)
    m_nKillMonExpRate: Integer; //杀怪经验倍数(此数除以 100 为真正倍数)
    m_nOldKillMonExpRate: Integer;//没使用套装前杀怪经验倍数 20080522
    m_nItmeIncMonExpRate: Integer;//使用套装增加的经验 20080607
    m_nPowerRate: Integer; //人物攻击力倍数(此数除以 100 为真正倍数)
    m_dwPowerRateTime: LongWord;//人物攻击力倍数改变恢复正常的时间计数(秒)
    m_dwKillMonExpRateTime: LongWord;//调整杀怪经验倍数后的使用时间(秒)
    m_dwRateTick: LongWord;

    m_boCanUseItem: Boolean; //是否允许使用物品
    m_boCanDeal: Boolean;//能交易
    m_boCanDrop: Boolean;//能扔
    m_boCanGetBackItem: Boolean;//取回升级的物品
    m_boCanWalk: Boolean;//是否能走
    m_boCanRun: Boolean;//是否允许跑
    m_boCanHit: Boolean;//是否允许打击
    m_boCanSpell: Boolean;//是否允许魔法
    m_boCanSendMsg: Boolean;//是否允许发送信息

    m_nMemberType: Integer; //会员类型
    m_nMemberLevel: Integer; //会员等级
    m_boSendMsgFlag: Boolean; //发祝福语标志
    m_boChangeItemNameFlag: Boolean;

    m_nGAMEDIAMOND:Integer;//金刚石 20071226
    m_nGAMEGIRD:Integer;//灵符 20071226
    m_btGameGlory: Byte; //荣誉 20080511

    m_nGameGold: Integer; //游戏币(元宝)
    m_boDecGameGold: Boolean; //是否自动减游戏币
    m_dwDecGameGoldTime: LongWord;//自动减游戏币时间
    m_dwDecGameGoldTick: LongWord;//自动减游戏币间隔
    m_nDecGameGold: Integer; //一次减点数

    m_boIncGameGold: Boolean; //是否自动加游戏币
    m_dwIncGameGoldTime: LongWord;//自动加游戏时间
    m_dwIncGameGoldTick: LongWord;// 自动加游戏间隔
    m_nIncGameGold: Integer; //一次减点数

    m_nGamePoint: Integer; //游戏点数
    m_dwIncGamePointTick: LongWord;//加游戏点的间隔
    m_dwDecGamePointTick: LongWord;//减游戏点的间隔 20080413

    m_nPayMentPoint: Integer;//秒卡点
    m_dwPayMentPointTick: LongWord;//秒卡点间隔

    m_dwDecHPTick: LongWord;//减HP间隔
    m_dwIncHPTick: LongWord;//加HP间隔

    m_GetWhisperHuman: TPlayObject;//侦听私聊对象
    m_dwClearObjTick: LongWord;//清除对像间隔
    m_wContribution: Word; //贡献度
    m_sRankLevelName: string; //显示名称格式串
    m_boFilterAction: Boolean;//动作过滤
    m_boClientFlag: Boolean;//客户端标志
    m_nStep: Byte;
    m_nClientFlagMode: Integer;
    m_dwAutoGetExpTick: LongWord;//自动泡点的时间间隔
    m_nAutoGetExpTime: Integer;//自动泡点时间
    m_nAutoGetExpPoint: Integer;//自动泡点数
    m_AutoGetExpEnvir: TEnvirnoment;//自动泡点地图
    m_boAutoGetExpInSafeZone: Boolean;
    m_DynamicVarList: TList;//自定义变量列表
    m_dwClientTick: LongWord;//客户端间隔
    m_boTestSpeedMode: Boolean; //进入速度测试模式

    m_BigStorageItemList: TList; //无限仓库
    m_boRemoteMsg: Boolean; //是否允许接受消息
    m_boAllowReAlive: Boolean; //是否允许复活

    m_boNotOnlineAddExp: Boolean; //是否是离线挂机人物
    m_dwStartNotOnlineAddExpTime: LongWord; //离线挂机开始时间
    m_dwNotOnlineAddExpTime: LongWord; //离线挂机时长
    m_nNotOnlineAddExpPoint: Integer; //离线挂机每分钟增加经验值
    m_boKickAutoAddExpUser: Boolean;//是否踢出自动挂机人物
    m_dwAutoAddExpPointTick: LongWord;
    m_dwAutoAddExpPointTimeTick: LongWord;
    m_boStartAutoAddExpPoint: Boolean;//是否自动增加经验(挂机)

    m_sAutoSendMsg: string; //自动回复信息
    m_btHearMsgFColor: Byte; //说话字体颜色
    m_btWhisperMsgFColor: Byte; //私聊字体颜色

    m_boTimeGoto: Boolean;
    m_dwTimeGotoTick: LongWord;
    m_sTimeGotoLable: string;
    m_TimeGotoNPC: TObject;//Delaygoto延时跳转

    m_nDealGoldPose: Integer;
    m_nBigStoragePage: Integer;//无限仓库的当前页数
    m_dwDedingUseTick: LongWord;//地钉使用间隔

    m_boRunPlayRobotManage: Boolean; //是否运行个人机器人
    m_PlayRobotManage: TPlayRobotManage; //人物个人机器人

    m_boPlayOffLine: Boolean; //是否下线触发

    m_nInteger: array[0..99] of Integer; //人物变量
    m_sString: array[0..99] of string; //人物变量
    m_wMasterCount: Word; //徒弟数

    m_PlayOrderList: TStringList; //人物排行
    m_nSelPlayOrderType: Integer; //选择排行类型 0-等级 1-战士 2-法师 3-道士 4-名师
    m_nPlayOrderPage: Integer; //选择人物排行页数
    m_boGetMyLevelOrder: Boolean;//取自己的排名

    m_boWaitHeroDate: Boolean;//是否正在读取英雄数据
    m_TargetTime: LongWord;//20080615 锁定目标间隔
    m_boHasHero: Boolean; //是否有英雄(白门英雄)
    m_sHeroCharName: string[ACTORNAMELEN]; //英雄名称
    m_sTempHeroCharName: string[ACTORNAMELEN];//临时英雄名称,创建英雄时保存用
    m_MyHero: TBaseObject; //我的英雄
    m_boCallHero: Boolean;//是否可以召唤英雄 20080124
    n_HeroSave: Byte;//是否存英雄,1-存英雄 20080513
    n_myHeroTpye: Byte;//英雄的类型 20080515 0-白日门英雄 1-卧龙英雄
    m_boPlayDrink: Boolean;//是否请过酒 T-请过酒 20080515
    n_DrinkValue:array[0..1] of Byte;//喝酒的醉酒值 0-NPC 1-玩家 20080517
    n_DrinkCount:Byte;//喝酒的次数(斗酒一次最高6次) 20080517
    m_boHasHeroTwo: Boolean;//是否有卧龙英雄 20080519
    n_tempHeroTpye: Byte;//保存临时英雄类型
    m_boMakeWine: Boolean;//是否酿酒 20080620
    n_MakeWineType:Byte;//酿酒的类型 1-普通酒 2-药酒  20080620
    m_MakeWineTime: Integer;//酿酒的时间,即还有多长时间可以取回酒(秒) 20080620
    n_MakeWineItmeType:Byte;//酿酒后,应该可以得到酒的类型 20080620
    n_MakeWineQuality:Byte;//酿酒后,应该可以得到酒的品质 20080620
    n_MakeWineAlcohol: Byte;//酿酒后,应该可以得到酒的酒精度 20080620
    m_dwAddAlcoholTick: LongWord;//增加酒量进度的间隔  20080623
    m_dwDecWineDrinkValueTick: LongWord;//减少醉酒度的间隔  20080623
    n_DrinkWineQuality: Byte;//饮酒时酒的品质 20080623
    n_DrinkWineAlcohol: Byte;//饮酒时酒的度数 20080624
    n_DrinkWineDrunk:Boolean;//喝酒醉了 20080623
    n_InFountainTime: Word;//站在泉水眼的时间 20080624
    dw_UseMedicineTime: Integer; //使用药酒时间,计算长时间没使用药酒 20080623
    n_MedicineLevel: Word;  //药力值等级 20080623
    m_GiveGuildFountationDate: Integer;//取行会泉水日期
    m_Exp68: LongWord;//酒气护体当前经验 20080625
    m_MaxExp68: LongWord;//酒气护体升级经验 20080625
    bo_NPCMove: Boolean;//是否点击,让NPC走动 20080704

    m_boTrainingNG: Boolean;//是否学习过内功 20081002
    m_NGLevel: Byte;//内功等级 20081002
    m_ExpSkill69: LongWord;//内功心法当前经验 20080930
    m_MaxExpSkill69: LongWord;//内功心法升级经验 20080930
    m_Skill69NH: Word;//当前内力值 20080930
    m_Skill69MaxNH: Word;//最大内力值 20080930
    m_dwIncNHTick: LongWord;//增加内力值计时 20081002

    m_Boxs: TList;//随机取的宝箱物品 20080116
    n_OpenBox: Byte;//转动宝箱的次数 20080407 由integer换成Byte
    n_IncUsesGameGold: Integer;//转宝箱累计消费(元宝)20080116
    n_IncUsesGold: Integer;//转宝箱累计消费(金币)20080116
    n_BoxsItmeID: Integer;//随机给玩家的物品ID
    m_boOpenBox: Boolean;//是否宝箱在打开 20080407

    n_LevelOrder: Integer;//玩家当前等级排名 20080214
    dwGetLevelOrderTick: LongWord;//查询玩家等级排名的间隔 20080214

    dwRunHumanModeTick: LongWord;//穿人模式的间隔 20080221
    dwRunHumanModeTime: LongWord;//穿人模式的时间 20080221
    m_boRunHumanMode: Boolean; //是否可以改变穿人模式  20080221

    n_UsesItemTick: Integer;//聚灵珠聚集时间 20080221
    n_UsesItemTime: Integer;//聚灵珠发送剩余时间消息的时间 20080307
    bo_YBDEAL: Boolean;//是否开通元宝寄售 20080316

    m_nRecallHeroTime: LongWord;//召唤英雄间隔时间 20071203
    AutoTimerTick: Array[0..9] of LongWord;//个人定时器 20080510
    AutoTimerStatus: Array[0..9] of Integer;//个人定时器 时间间隔  20080510

    m_boChallengeing: Boolean; //是否在挑战中 20080705
    m_ChallengeCreat: TPlayObject;//挑战的对像 20080705
    m_ChallengeItemList: TList;//挑战物品列表 20080705
    m_nChallengeGolds: Integer;//挑战的金币数量 20080705
    m_nChallengeGAMEDIAMOND:Integer;//挑战的金刚石 20080705
    m_boChallengeOK: Boolean;//确认开始挑战标志 20080705
    m_ChallengeLastTick: LongWord;//挑战放物品最后操作时间  20080705
    m_ChallengeTime: LongWord;//挑战计时 20080705

    dwRockAddHPTick: LongWord;//魔血石类HP 使用间隔 20080728
    dwRockAddMPTick: LongWord;//魔血石类MP 使用间隔 20080728
    m_boCanQueryBag: Boolean;//是否可以刷新包裹 20080907
    m_boCanQueryShopItme: Boolean;//是否可以刷新商铺 20080907
    m_boHeroLogOut: Boolean;//英雄退出(包裹传递时用于判断) 20080909

    m_MagicSkill_200: pTUserMagic;//怒之攻杀 *
    m_MagicSkill_201: pTUserMagic;//静之攻杀
    m_MagicSkill_202: pTUserMagic;//怒之半月 *
    m_MagicSkill_203: pTUserMagic;//静之半月
    m_MagicSkill_204: pTUserMagic;//怒之烈火 *
    m_MagicSkill_205: pTUserMagic;//静之烈火
    m_MagicSkill_206: pTUserMagic;//怒之逐日 *
    m_MagicSkill_207: pTUserMagic;//静之逐日
    m_MagicSkill_208: pTUserMagic;//怒之火球 *
    m_MagicSkill_209: pTUserMagic;//静之火球
    m_MagicSkill_210: pTUserMagic;//怒之大火球 *
    m_MagicSkill_211: pTUserMagic;//静之大火球
    m_MagicSkill_212: pTUserMagic;//怒之火墙 *
    m_MagicSkill_213: pTUserMagic;//静之火墙
    m_MagicSkill_214: pTUserMagic;//怒之地狱火 *
    m_MagicSkill_215: pTUserMagic;//静之地狱火
    m_MagicSkill_216: pTUserMagic;//怒之疾光电影 *
    m_MagicSkill_217: pTUserMagic;//静之疾光电影
    m_MagicSkill_218: pTUserMagic;//怒之爆裂火焰 *
    m_MagicSkill_219: pTUserMagic;//静之爆裂火焰
    m_MagicSkill_220: pTUserMagic;//怒之冰咆哮 *
    m_MagicSkill_221: pTUserMagic;//静之冰咆哮
    m_MagicSkill_222: pTUserMagic;//怒之雷电 *
    m_MagicSkill_223: pTUserMagic;//静之雷电
    m_MagicSkill_224: pTUserMagic;//怒之地狱雷光 *
    m_MagicSkill_225: pTUserMagic;//静之地狱雷光
    m_MagicSkill_226: pTUserMagic;//怒之寒冰掌 *
    m_MagicSkill_227: pTUserMagic;//静之寒冰掌
    m_MagicSkill_228: pTUserMagic;//怒之灭天火 *
    m_MagicSkill_229: pTUserMagic;//静之灭天火
    m_MagicSkill_230: pTUserMagic;//怒之火符 *
    m_MagicSkill_231: pTUserMagic;//静之火符
    m_MagicSkill_232: pTUserMagic;//怒之噬血 *
    m_MagicSkill_233: pTUserMagic;//静之噬血
    m_MagicSkill_234: pTUserMagic;//怒之流星火雨 *
    m_MagicSkill_235: pTUserMagic;//静之流星火雨
    m_MagicSkill_236: pTUserMagic;//怒之内功剑法 *
    m_MagicSkill_237: pTUserMagic;//静之内功剑法

    m_TagMapInfos: TagMapInfos;//人物记路标石 20081019
    m_GetExp: LongWord;//人物取得的经验,$GetExp变量使用  20081228
  private
    function ClientDropGold(nGold: Integer): Boolean;
    procedure ClientQueryUserState(BaseObject: TBaseObject; nX, nY: Integer);//查看角色装备
    //procedure ClientQueryUserSet(ProcessMsg: pTProcessMessage); //未使用 20080907
    function ClientDropItem(sItemName: string; nItemIdx: Integer): Boolean;
    function ClientPickUpItem: Boolean;
    procedure ClientOpenDoor(nX, nY: Integer);//客户端打开门
    function UseStdmodeFunItem(StdItem: pTStdItem): Boolean;//使用物品触发脚本段
    function CheckStdmodeFunItem(StdItem: pTStdItem): Boolean;//检查包裹是否有指定物品，是否达到指定数 药绳捆使用 20081217
    procedure ClientUseItems(nItemIdx: Integer; sItemName: string);//客户端使用物品
    function ItemDblClick(sItemName: string; nMakeIndex: Integer; var sMapName: string; var nCurrX, nCurrY: Integer): Boolean;
    function ClientGetButchItem(BaseObject: TBaseObject; nX, nY: Integer; btDir: Byte; var dwDelayTime: LongWord): Boolean;
    procedure ClientChangeMagicKey(nSkillIdx, nKey: Integer);
    procedure ClientClickNPC(NPC: Integer);
    procedure ClientMerchantDlgSelect(nParam1: Integer; sMsg: string);
    procedure ClientMerchantQuerySellPrice(nParam1, nMakeIndex: Integer; sMsg: string);
    procedure ClientUserSellItem(nParam1, nMakeIndex: Integer; sMsg: string);
    procedure ClientUserBuyItem(nIdent, nParam1, nInt, nZz: Integer; sMsg: string);
    procedure ClientQueryRepairCost(nParam1, nInt: Integer; sMsg: string);
    procedure ClientRepairItem(nParam1, nInt: Integer; sMsg: string);
    procedure ClientGetShopItemList(nPage,nType: Integer);//客户端取商铺物品 20080730
    procedure ClientBuyShopItem(sItemName: String);//客户端购买商铺物品 20080730
    procedure ClientBuyShopItemGive(sMsg: String);//客户端商铺赠送 20080730
    procedure ClientExchangeGameGird(nGameGird: Integer);//客户端商铺兑换灵符 20080730

   { procedure ClientUserSellOffItem(nParam1, nMakeIndex: Integer; sMsg: string); //拍卖   //20080416 去掉拍卖功能
    procedure ClientUserBuySellOffItem(nIdent, nParam1, nInt, nZz: Integer; sMsg: string); //拍卖 }

    procedure ClientGropuClose();
    procedure ClientCreateGroup(sHumName: string);
    procedure ClientAddGroupMember(sHumName: string);
    procedure ClientDelGroupMember(sHumName: string);
    procedure ClientDealTry(sHumName: string);//开始交易
//----------------挑战(20080704)----------------------
    procedure ClientChallenge;//判断玩家是否面对面,是则弹出抵物品窗口
    procedure OpenChallengeDlg(PlayObject: TPlayObject);//打开挑战抵押物品窗口
    procedure ClientAddChallengeItem(nItemIdx: Integer; sItemName: string);//客户端增加抵押物品到挑战框中
    procedure ClientDelChallengeItem(nItemIdx: Integer; sItemName: string);//客户端删除抵押的挑战物品
    procedure SendAddChallengeItem(UserItem: pTUserItem);//发送抵押的挑战物品
    procedure SendDelChallengeItem(UserItem: pTUserItem);//发送删除挑战框中物品后,给客户端更新
    procedure ChallengeCancel;//取消挑战
    procedure ClientCancelChallenge;//客户端取消挑战
    procedure ClientChangeChallengeGold(nGold: Integer);//客户端把金币放到挑战框中
    procedure ClientChangeChallengeDIAMOND(nDIAMOND: Integer);//客户端把金刚石放到挑战框中
    procedure ClientChallengeEnd;//挑战抵押物品结束
    procedure WinGetChallengeItems;//胜方取得物品
//----------元宝寄售系统( 20080316)-------------------
    procedure ClientAddSellOffItem(nItemIdx: Integer; sItemName: string);//客户端增加寄售物品到出售框中
    procedure ClientDelSellOffItem(nItemIdx: Integer; sItemName: string);//客户端删除寄售出售框中物品
    procedure ClientCancelSellOff();//客户端取消元宝寄售
    procedure ClientSellOffEnd(sBuyCharName:String; nSellGold, nGAMEDIAMOND, nCode:Integer);//客户端元宝寄售结束(出售物品)

    procedure ClientCancelSellOffIng();//出售人取消正在出售中的交易 20080316
    procedure ClientBuyCancelSellOff( DealCharName:String);//购买人取消交易 20080316
    procedure ClientBuySellOffItme( DealCharName:String);//购买寄售物品 20080318
    procedure GetSellOffGlod;//人物上线,检查是否有交易结束还没得到元宝 20080318

    procedure UpdateSellOffInfo(code: integer); //交易成功后修改数据标识 20080319
//-----------------------------------------------------
    procedure ClientAddDealItem(nItemIdx: Integer; sItemName: string);
    procedure ClientDelDealItem(nItemIdx: Integer; sItemName: string);
    procedure ClientCancelDeal();
    procedure ClientChangeDealGold(nGold: Integer);
    procedure ClientDealEnd();
    procedure ClientStorageItem(NPC: TObject; nItemIdx: Integer; sMsg: string);
    procedure ClientTakeBackStorageItem(NPC: TObject; nItemIdx: Integer; sMsg: string);
    procedure ClientGetMinMap();
    procedure ClientMakeDrugItem(NPC: TObject; nItemName: string);
    procedure ClientOpenGuildDlg();
    procedure ClientGuildHome();
    procedure ClientGuildMemberList();
    procedure ClientGuildAddMember(sHumName: string);
    procedure ClientGuildDelMember(sHumName: string);
    procedure ClientGuildUpdateNotice(sNotict: string);
    procedure ClientGuildUpdateRankInfo(sRankInfo: string);
    procedure ClientGuildAlly();
    procedure ClientGuildBreakAlly(sGuildName: string);
    procedure ClientAdjustBonus(nPoint: Integer; sMsg: string);
    function ClientChangeDir(wIdent: Word; nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean;
    function ClientWalkXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
    function ClientHorseRunXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
    function ClientRunXY(wIdent: Word; nX, nY: Integer; nFlag: Integer; var dwDelayTime: LongWord): Boolean;
    function ClientHitXY(wIdent: Word; nX, nY, nDir: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
    function ClientSitDownHit(nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean;
    function ClientSpellXY(wIdent: Word; nKey: Integer; nTargetX, nTargetY: Integer; TargeTBaseObject: TBaseObject; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;

    procedure UserLevelOrder(BaseObject: TObject); //用户等级排行
    function CheckTakeOnItems(nWhere: Integer; var StdItem: TStdItem): Boolean;//检查装备是否可以穿上身
    function GetUserItemWeitht(nWhere: Integer): Integer;//取物品的重量
    procedure SendDelDealItem(UserItem: pTUserItem);//发送删除交易栏里的物品
    procedure SendAddDealItem(UserItem: pTUserItem);//发送放到交易栏里的物品
    procedure OpenDealDlg(PlayObject: TPlayObject); //打开交易对话框
    function EatItems(StdItem: pTStdItem): Boolean;//吃物品
    function EatUseItems(nShape: Integer): Boolean;//吃使用物品
    function ReadBook(StdItem: pTStdItem): Boolean;//读书
    //function DayBright(): Byte;//一天的光明   (未使用 20080329)
    procedure BaseObjectMove(sMAP, sX, sY: string);
    function RepairWeapon(): Boolean;//修理武器
    function SuperRepairWeapon(): Boolean;//超级修理武器
    function WinLottery(): Boolean;//赢彩票
    procedure ChangeServerMakeSlave(SalveInfo: pTSlaveInfo);
    function WeaptonMakeLuck(): Boolean;//武器加幸运
    function PileStones(nX, nY: Integer): Boolean;
    procedure MakeMine();//制造矿
    function GetRangeHumanCount(): Integer;
    procedure GetStartPoint();
    procedure LogonTimcCost;
    procedure SendNotice();
    procedure SendLogon();
    procedure SendUnBind();
    procedure SendServerStatus();
    
    procedure ClientQueryUserName(Target: TBaseObject; x, y: Integer);
    procedure SendUseMagic();//发送使用魔法
    procedure SendSaveItemList(nBaseObject: Integer);//发送仓库物品
    procedure SendSaveBigStorageItemList(nBaseObject: Integer; nPage: Integer);//发送无限仓库物品
    procedure SendDelItemList(ItemList: TStringList);
    procedure SendAdjustBonus();//发送调整的奖金
    procedure SendChangeGuildName();
    procedure SendMapDescription();
    procedure SendGoldInfo(boSendName: Boolean);
    procedure SendGloryInfo();
    procedure ShowMapInfo(sMAP, sX, sY: string);
    function CancelGroup(): Boolean;
    function DoMotaebo(nDir: Byte; nMagicLevel: Integer): Boolean;
    procedure GetOldAbil(var OAbility: TOAbility);
    //procedure ReadAllBook;//未使用 20080329
    function CheckItemsNeed(StdItem: pTStdItem): Boolean;
    function CheckItemBindUse(UserItem: pTUserItem): Boolean;//检查物品是当前账号的物品
    function CheckActionStatus(wIdent: Word; var dwDelayTime: LongWord): Boolean;//检查动作状态
    procedure RecalcAdjusBonus;
    procedure CheckMarry();
    procedure CheckMaster();
    procedure RefMyStatus;
    procedure ProcessClientPassword(ProcessMsg: pTProcessMessage);
    function CheckDenyLogon: Boolean;
    procedure ProcessSpiritSuite;
    function HorseRunTo(btDir: Byte; boFlag: Boolean): Boolean;
{$IF HEROVERSION = 1}
    procedure ClientGetUserOrder(nSortType, nType, nPage: Integer); //用户排行
    procedure ClientHeroUseItems(nItemIdx: Integer; sItemName: string);
    procedure ClientHeroUseSpell;//使用合击
{$IFEND}
    procedure DelMember(PlayObject: TPlayObject);//删除成员
    procedure SendGroupText(sMsg: string);//发送组队文字
    procedure LeaveGroup();
    procedure PlayGatherFountain;//收集泉水 20080624
    procedure PlaySuperRock;//气血石功能 20080729
  public
    constructor Create(); override;
    destructor Destroy; override;
    function GetMagicInfo(sMagicName: string): pTUserMagic; overload;
    function GetMagicInfo(nMagicID: Integer): pTUserMagic; overload;
    procedure ClearViewRange;
    procedure SendUseitems();//发送使用物品
    procedure ClientQueryBagItems();//查询背包物品
    procedure ClientTakeOnItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);//人物装配装备到身上的装备位置
    procedure ClientTakeOffItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
    procedure MoveToHome();//移动到回城点
    function DoSpell(UserMagic: pTUserMagic; nTargetX, nTargetY: Integer; BaseObject: TBaseObject): Boolean;
{$IF HEROVERSION = 1}
    function MakeHero(PlayObject: TPlayObject; HumanRcd: THumDataInfo): TBaseObject;
    procedure ClientRecallHero();
    procedure ClientHeroLogOut(nCode: Byte);//英雄退出
    procedure ClientTakeOnItemsFormBag(nIndex: Integer; btWhere: Byte; nItemIdx: Integer; sItemName: string);
    procedure ClientHeroTakeOnItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);//英雄装配装备到身上的装备位置
    procedure ClientHeroTakeOffItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
    procedure ClientHeroTakeOffItemsToBag(nIndex: Integer; btWhere: Byte; nItemIdx: Integer; sItemName: string);
    procedure ClientBagToBag(nIndex: Integer; nItemIdx: Integer; sItemName: string);
    procedure ClientChgHeroStatus();//改变英雄状态
    procedure ClientHeroProtect(nX, nY: Integer);//英雄守护
    procedure ClientHeroAttack(BaseObject: TBaseObject; nX, nY: Integer);
{$IFEND}
    function MakeSelf(PlayObject: TPlayObject; sMonName: string; nMaxMob: Integer; dwRoyaltySec: LongWord): TBaseObject;
    function AbilityUp(UserMagic: pTUserMagic): Boolean;
    procedure SearchViewRange(); override;
    procedure PKDie(PlayObject: TPlayObject);//PK死亡
    procedure GameTimeChanged();//游戏时间改变
    procedure RunNotice();
    function GetMyStatus(): Integer;//取我的状态
    function IncGold(tGold: Integer): Boolean;//增加金币
    procedure IncGamePoint(nGamePoint: Integer);
    procedure IncGameGold(nGameGold: Integer);
    procedure IncGameDiaMond(nGameDiaMond: Integer); //20071226 增加金刚石
    procedure IncGameGird(nGameGird: Integer);//20071226 增加灵符

    procedure SendSocket(DefMsg: pTDefaultMessage; sMsg: string); virtual;
    procedure SendDefMessage(wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: string); virtual;
    function IsEnoughBag(): Boolean;//包裹是否满
    procedure SendAddItem(UserItem: pTUserItem); virtual;//增加物品
    procedure SendDelItems(UserItem: pTUserItem); virtual;//删除物品
    procedure Whisper(whostr, saystr: string);//私聊
{---------------------------检查未使用过程到此 20080428-----------------------------}  
    function IsBlockWhisper(sName: string): Boolean;
    function QuestCheckItem(sItemName: string; var nCount: Integer; var nParam: Integer; var nDura: Integer): pTUserItem;
    function QuestTakeCheckItem(CheckItem: pTUserItem): Boolean;
    procedure GainExp(dwExp: LongWord; nCode:Byte);
    procedure GetExp(dwExp: LongWord; boItmeExp:Boolean);
    procedure GetNGExp(dwExp: LongWord; Code: Byte);//取得内力经验 20081001
    procedure NGMAGIC_LVEXP(UserMagic: pTUserMagic);//内功技能升级 20081003
    procedure WinExp(dwExp: LongWord);
    procedure GetExpToItem(dwExp: LongWord);//得到的经验累积到聚灵珠 20080221
    procedure SendItemUseTime(dwTime: Integer);//发送聚灵珠使用剩余时间 20080307
    Function IsItem_51(nCode: Integer):Boolean; //是否包裹里有聚龙珠 20080308
    function DecGold(nGold: Integer): Boolean;
    procedure DecGamePoint(nGamePoint: Integer);//减游戏点
    procedure DecGameGold(nGameGold: Integer);
   { procedure DecGameDiaMond(nGameDiaMond: Integer);//20071226 金刚石
    procedure DecGameGird(nGameGird: Integer);//20071226 灵符   }
    procedure Run(); override;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override;
    procedure RecalcAbilitys(); override;//刷新能力
    procedure MakeSaveRcd(var HumanRcd: THumDataInfo);
    procedure SellOffCancel();//元宝寄售取消出售 20060316
    procedure DealCancel();
    procedure DealCancelA();
    function GetShowName(): string; override;
    procedure GetBackDealItems();
    procedure GetBackSellOffItems();//取备份元宝寄信列表物品 20080316
    procedure Disappear(); override;
    procedure GoldChange(sChrName: string; nGold: Integer);
    procedure ProcessUserLineMsg(sData: string);
    procedure ProcessSayMsg(sData: string); override;
    procedure ClearStatusTime();
    procedure UserLogon(); virtual;//人物登陆游戏
    procedure RefRankInfo(nRankNo: Integer; sRankName: string);
    procedure RefUserState;
    procedure SendGroupMembers();
    procedure JoinGroup(PlayObject: TPlayObject);
    function GeTBaseObjectInfo(): string;
    function GetHitMsgCount(): Integer;
    function GetSpellMsgCount(): Integer;
    function GetWalkMsgCount(): Integer;
    function GetRunMsgCount(): Integer;
    function GetTurnMsgCount(): Integer;
    function GetSiteDownMsgCount(): Integer;
    function GetDigUpMsgCount(): Integer;
    procedure SetScriptLabel(sLabel: string);
    procedure GetScriptLabel(sMsg: string);
    function LableIsCanJmp(sLabel: string): Boolean;
    function GetMyInfo(): string;
    procedure MakeGhost; override;
    procedure ScatterBagItems(ItemOfCreat: TBaseObject); override;
    procedure DropUseItems(BaseObject: TBaseObject); override;
    procedure RecallHuman(sHumName: string);
    procedure SendAddMagic(UserMagic: pTUserMagic);
    procedure SendDelMagic(UserMagic: pTUserMagic);
    procedure ReQuestGuildWar(sGuildName: string);
    procedure SendUpdateItem(UserItem: pTUserItem);//发送更新物品 20071228
    procedure GetBagUseItems(var btDc: Byte; var btSc: Byte; var btMc: Byte; var btDura: Byte);
    function  CallMobeItem(): Boolean;//召唤强化卷,把招出的宝宝变成7级  20080221
    procedure RepairAllItem(DureCount: Integer; boDec: Boolean);//修理所有物品
    Function RepairAllItemDura:Integer;//全部修复,需要的持久值 20080325
    procedure RandomMove();//随机移动
    function IsGroupMember(Target: TBaseObject): Boolean;//是组队会员
    procedure SendServerConfig();//发送服务端配置到客户端  20080221 [移动声明位置]
    procedure ClearCopyItem(nCode:Byte; wIndex, MakeIndex: Integer);//清理包裹和仓库复制物品 20080816
    function CheckItemBindDieNoDrop(UserItem: pTUserItem): Boolean;//检查人物装备死亡物品是否爆 20081127
//Cmd开头函数为GM命令
    procedure CmdClearCopyItem(Cmd: pTGameCmd; sName: string);//清理指定玩家复制品 20080816
    procedure CmdShowEffect(Cmd: pTGameCmd; sEffect{, sTime}: string);
    procedure CmdSignMapMove(Cmd: pTGameCmd);
    procedure CmdGetUserItems(Cmd: pTGameCmd; sHumanName, sItemName, sItemCount, sType: string);
    procedure CmdUserCmd(sLable: string);
    Function PlayObjectUserCmd(sLable,sParam: string):Boolean;
    procedure CmdEndGuild();//退出行会
    procedure CmdMemberFunction(sCmd, sParam: string);
    procedure CmdMemberFunctionEx(sCmd, sParam: string);
    procedure CmdSearchDear(sCmd, sParam: string);
    procedure CmdSearchMaster(sCmd, sParam: string);
    procedure CmdDearRecall(sCmd, sParam: string);
    procedure CmdMasterRecall(sCmd, sParam: string);
    procedure CmdClearBagItem(Cmd: pTGameCmd; sHumanName: string);//清理指定玩家背包物品
    procedure CmdShowUseItemInfo(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType: string);
    procedure CmdUnBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType: string);
    procedure CmdLockLogin(Cmd: pTGameCmd);
    //procedure CmdViewDiary(sCmd: string; nFlag: Integer);//未使用 20080823
    procedure CmdUserMoveXY(sCmd, sX, sY: string);
    procedure CmdSearchHuman(sCmd, sHumanName: string);//
    procedure CmdGroupRecall(sCmd: string);
    procedure CmdAllowGroupReCall(sCmd, sParam: string);
    procedure CmdGuildRecall(sCmd, sParam: string);
    procedure CmdChangeAttackMode(nMode: Integer; sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7: string);
    procedure CmdChangeSalveStatus();
    procedure CmdTakeOnHorse(sCmd, sParam: string);
    procedure CmdTakeOffHorse(sCmd, sParam: string);
    procedure CmdPrvMsg(sCmd: string; nPermission: Integer; sHumanName: string);
    procedure CmdHumanLocal(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdMapMove(Cmd: pTGameCmd; sMapName: string);
    procedure CmdPositionMove(Cmd: pTGameCmd; sMapName, sX, sY: string);
    procedure CmdHumanInfo(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdReLoadAdmin(sCmd: string);
    procedure CmdReloadNpc(sParam: string);
    procedure CmdReloadManage(Cmd: pTGameCmd; sParam: string);
    procedure CmdReloadRobotManage;
    procedure CmdReloadRobot;
    procedure CmdReloadMonItems();
    procedure CmdAdjustExp(Human: TPlayObject; nExp: Integer);
    procedure CmdAddGuild(Cmd: pTGameCmd; sGuildName, sGuildChief: string);
    procedure CmdDelGuild(Cmd: pTGameCmd; sGuildName: string);
    //procedure CmdGuildWar(sCmd, sGuildName: string);//20080812 注释
    procedure CmdChangeSabukLord(Cmd: pTGameCmd; sCASTLENAME, sGuildName: string; boFlag: Boolean);
    procedure CmdForcedWallconquestWar(Cmd: pTGameCmd; sCASTLENAME: string);
    //procedure CmdOPTraining(sHumanName, sSkillName: string; nLevel: Integer);//20080812 注释
    //procedure CmdOPDeleteSkill(sHumanName, sSkillName: string);//20080812 注释
    //procedure CmdReloadGuildAll();
    procedure CmdReAlive(Cmd: pTGameCmd; sHumanName: string);//复活
    procedure CmdSysMsg(Cmd: pTGameCmd;Text: string); //千里传音  20071228
    procedure CmdHeroLevel(Cmd: pTGameCmd;sHeroName: string; nLevel: Integer); //调整英雄等级  20071227
    procedure CmdAdjuestLevel(Cmd: pTGameCmd; sHumanName: string; nLevel: Integer);//调整人物等级
    procedure CmdNGLevel(Cmd: pTGameCmd; sHumanName: string; nLevel: Integer);//调整人物内功等级
    procedure CmdAdjuestExp(Cmd: pTGameCmd; sHumanName, sExp: string);
    procedure CmdBackStep(sCmd: string; nType, nCount: Integer);
    procedure CmdFreePenalty(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdPKpoint(Cmd: pTGameCmd; sHumanName: string);//查看人物PK值
    procedure CmdIncPkPoint(Cmd: pTGameCmd; sHumanName: string; nPoint: Integer); //调整人物PK值
    procedure CmdHunger(sCmd, sHumanName: string; nHungerPoint: Integer);
    procedure CmdHair(Cmd: pTGameCmd; sHumanName: string; nHair: Integer);
    procedure CmdTrainingSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string; nLevel: Integer);
    procedure CmdTrainingMagic(Cmd: pTGameCmd; sHumanName, sSkillName: string; nLevel: Integer);
    procedure CmdDelSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string);
    procedure CmdDeleteItem(Cmd: pTGameCmd; sHumanName, sItemName: string; nCount: Integer);
    procedure CmdClearMission(Cmd: pTGameCmd; sHumanName: string);
    //procedure CmdTraining(sSkillName: string; nLevel: Integer);//20080812 注释
    procedure CmdChangeJob(Cmd: pTGameCmd; sHumanName, sJobName: string);
    procedure CmdChangeGender(Cmd: pTGameCmd; sHumanName, sSex: string);
    procedure CmdMission(Cmd: pTGameCmd; sX, sY: string);
    procedure CmdMobPlace(Cmd: pTGameCmd; sX, sY, sMonName, sCount, sNGMon: string);
    procedure CmdMobLevel(Cmd: pTGameCmd; Param: string);
    procedure CmdMobCount(Cmd: pTGameCmd; sMapName: string);
    procedure CmdHumanCount(Cmd: pTGameCmd; sMapName: string);
    procedure CmdDisableFilter(sCmd, sParam1: string);
    procedure CmdChangeUserFull(sCmd, sUserCount: string);
    procedure CmdChangeZenFastStep(sCmd, sFastStep: string);
    procedure CmdReconnection(sCmd, sIPaddr, sPort: string);
    procedure CmdContestPoint(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdStartContest(Cmd: pTGameCmd; sParam1: string);
    procedure CmdEndContest(Cmd: pTGameCmd; sParam1: string);
    procedure CmdAnnouncement(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdKill(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdMakeItem(Cmd: pTGameCmd; sItemName: string; nCount: Integer);//制造物品
    procedure CmdSmakeItem(Cmd: pTGameCmd; nWhere, nValueType, nValue: Integer);//调整身上装备附加属性 @SUPERMAKE
    procedure CmdBonuPoint(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdDelBonuPoint(Cmd: pTGameCmd; sHumName: string);
    procedure CmdRestBonuPoint(Cmd: pTGameCmd; sHumName: string);
    procedure CmdFireBurn(nInt, nTime, nN: Integer);
    procedure CmdTestFire(sCmd: string; nRange, nType, nTime, nPoint: Integer);
    procedure CmdTestStatus(sCmd: string; nType, nTime: Integer);
    procedure CmdDelGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdAddGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdDelGameGold(sCmd, sHumName: string; nPoint: Integer);
    procedure CmdAddGameGold(sCmd, sHumName: string; nPoint: Integer);
    procedure CmdGameGold(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGold: Integer);
    procedure CmdGameDiaMond(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGameDiaMond: Integer); //20071226 金刚石
    procedure CmdGameGird(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGameGird: Integer);//20071226 灵符
    procedure CmdGameGlory(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGameGlory: Byte); //20080511 调整荣誉值
    procedure CmdHeroLoyal(Cmd: pTGameCmd; sHumanName: string; nHeroLoyal: Integer);//20080109 英雄的忠诚度
    procedure CmdGamePoint(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nPoint: Integer);
    procedure CmdCreditPoint(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nPoint: Integer);
    procedure CmdMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel, nMonTpye: Integer);
    procedure CmdRefineWeapon(Cmd: pTGameCmd; nDc, nMc, nSc, nHit: Integer);
    procedure CmdRecallMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel, nAutoChangeColor, nFixColor: Integer);
    procedure CmdRECALLMOBEX(Cmd: pTGameCmd; sMonName: string; nNameColor, nX,nY: Integer);//20080122 召唤宝宝
    procedure CmdGIVEMINE(Cmd: pTGameCmd; sMINEName: string; nMineCount, nDura: Integer);//20080403 给指定纯度的矿石
    procedure CmdMOVEMOBTO(Cmd: pTGameCmd; sMonName,OleMap,NewMap: string; nX,nY,OnX,OnY: Integer);//20080123 将指定坐标的怪物移动到新坐标
    procedure CmdCLEARITEMMAP(Cmd: pTGameCmd; sMap,sItemName: string; nX,nY,nRange: Integer);//20080124 清除地图物品
    procedure CmdLuckPoint(sCmd: string; nPermission: Integer; sHumanName, sCtr, sPoint: string);
    procedure CmdLotteryTicket(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdReloadGuild(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdReloadLineNotice(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdReloadAbuse(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdMobNpc(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3, sParam4: string);
    procedure CmdNpcScript(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3: string);
    procedure CmdDelNpc(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdKickHuman(Cmd: pTGameCmd; sHumName: string);
    procedure CmdTing(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdSuperTing(Cmd: pTGameCmd; sHumanName, sRange: string);
    procedure CmdMapMoveHuman(Cmd: pTGameCmd; sSrcMap, sDenMap: string);
    procedure CmdShutup(Cmd: pTGameCmd; sHumanName, sTime: string);
    procedure CmdShowMapInfo(Cmd: pTGameCmd; sParam1: string);
    procedure CmdShutupRelease(Cmd: pTGameCmd; sHumanName: string; boAll: Boolean);
    procedure CmdShutupList(Cmd: pTGameCmd; sParam1: string);
    procedure CmdShowSbkGold(Cmd: pTGameCmd; sCASTLENAME, sCtr, sGold: string);
    procedure CmdRecallHuman(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdReGotoHuman(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdShowHumanFlag(sCmd: string; nPermission: Integer; sHumanName, sFlag: string);
    //procedure CmdShowHumanUnitOpen(sCmd: string; nPermission: Integer; sHumanName, sUnit: string);
    //procedure CmdShowHumanUnit(sCmd: string; nPermission: Integer; sHumanName, sUnit: string);
    procedure CmdChangeAdminMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
    procedure CmdChangeObMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
    procedure CmdChangeSuperManMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
    procedure CmdChangeLevel(Cmd: pTGameCmd; sParam1: string);
    procedure CmdChangeDearName(Cmd: pTGameCmd; sHumanName: string; sDearName: string);
    procedure CmdChangeMasterName(Cmd: pTGameCmd; sHumanName: string; sMasterName, sIsMaster: string);
    procedure CmdStartQuest(Cmd: pTGameCmd; sQuestName: string);
    procedure CmdSetPermission(Cmd: pTGameCmd; sHumanName, sPermission: string);
    procedure CmdClearMapMonster(Cmd: pTGameCmd; sMapName, sMonName, sItems: string);//清除地图怪物
    procedure CmdReNewLevel(Cmd: pTGameCmd; sHumanName, sLevel: string);

    procedure CmdDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
    procedure CmdDelDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
    procedure CmdShowDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);

    procedure CmdDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
    procedure CmdDelDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
    procedure CmdShowDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);

    procedure CmdDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdDelDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdShowDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdViewWhisper(Cmd: pTGameCmd; sCharName, sParam2: string);
    procedure CmdSpirtStart(sCmd: string; sParam1: string);
    procedure CmdSpirtStop(sCmd: string; sParam1: string);
    procedure CmdSetMapMode(sCmd: string; sMapName, sMapMode, sParam1, sParam2: string);
    procedure CmdShowMapMode(sCmd: string; sMapName: string);
    procedure CmdClearHumanPassword(sCmd: string; nPermission: Integer; sHumanName: string);

    procedure CmdChangeItemName(sCmd, sMakeIndex, sItemIndex, sItemName: string);
    procedure CmdDisableSendMsg(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdEnableSendMsg(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdDisableSendMsgList(Cmd: pTGameCmd);
    procedure CmdTestGetBagItems(Cmd: pTGameCmd; sParam: string);
    procedure CmdMobFireBurn(Cmd: pTGameCmd; sMAP, sX, sY, sType, sTime, sPoint: string);
    procedure CmdTestSpeedMode(Cmd: pTGameCmd);

    procedure ProcessUserCmd(sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7: string);

    function DieFunc: Boolean;
    function AddSkillFunc(MagicID: Integer): Boolean;//人物学技能触发 20080324
    function HeroAddSkillFunc(MagicID: Integer): Boolean;//英雄学技能触发 20080324

    function LevelUpFunc: Boolean;//升级函数
    function KillPlayFunc: Boolean;//杀死角色函数
    function KillMonsterFunc(BaseObject: TBaseObject): Boolean;//杀死怪物函数
    function KillMissionMob: Boolean;//宝宝杀死怪触发   清清20080126
    function DieGotoLable(): Boolean;//死亡触发

    function IsGotoLabel(sMapName: string; nX, nY, nRange, nQuestFalgStatus: Integer; boQuestFalgStatus: Boolean; sItemName1, sItemName2: string; boNeedGroup: Boolean; nRandomCount: Integer): Boolean;
    procedure StartMapEventOfDropItem(sItemName: string);//地图事件触发-掉落物品
    procedure StartMapEventOfPickUpItem(sItemName: string);//地图事件触发-捡起物品
    procedure StartMapEventOfMine();//地图事件触发-挖矿
    procedure StartMapEventOfWalk();//地图事件触发-走
    procedure StartMapEventOfRun();//地图事件触发-跑
//---------------------------------------
//20080102 增加祝福罐.魔令包功能
    function  WearDragon: Boolean;
    procedure RepairDragon(btType: Byte; nItemIdx: Integer; sItemName: string);
//---------------------------------------
    procedure ClientSendBoxItem(BoxsIdx: Integer; str:string);//判断宝箱和钥匙是否对应,20080305
    function ClientOpenBoxs(sBoxsID{宝箱类型,即Source}:Integer):Boolean;//打开宝箱 20080115
    procedure ClientGetBoxs();//转动宝箱,随机给客户端一件物品,并减少一定的金币或元宝 20080116
    procedure ClientGetBoxsItme();//给玩家物品 20080117
    Function GetUserLevelOrder:Integer;//取玩家的等级排名 20080214
    Function SellOffInTime(nCode:Integer):Boolean; //查询玩家是否操作过寄售 20080317
    Function SelectSellDate:String; //查询玩家交易记录  20080318
//--------------------淬炼系统 20080502--------------
    Function ClientAddRefineItem(sItemIdx: string):Boolean;//客户端增加物品到淬炼框中
    //procedure ClientDelRefineItem(nItemIdx: Integer; sItemName: string);//客户端取出粹练框里的物品
    procedure GetBackRefineItem();//取备份淬练列表物品
    procedure GetBackRefineItemName(var sItemName, sItemName1, sItemName2: string);//取备份淬练列表物品的名称
    procedure ClientRefineItem;//淬炼
    function WearRefineItem: Boolean; //是火云石
    procedure RepairRefineItem(nItemIdx: Integer; sItemName: string);//修补火云石
//---------------------------------------------------
    procedure ClientGETHERO(sHeroName: string;nHeroTpye:Byte);//取回英雄 20080514
    procedure ClientPlayDrinkItem(NPC: TObject; nItemIdx: Integer; sMsg: string);//请酒 20080515
    procedure ClientPlayDrinkLable(nParam1: Integer; sMsg: string);//请酒信息跳转 20080515
    procedure ClientPlayDrinkToDrink(nParam1: Integer; nPlayNum: Byte);//比较NPC与玩家出码数,并判断输赢 20080516
    procedure ClientDrinkUpdateValue(nParam1: Integer;nPlayNum,nCode: Byte);//喝酒并增加醉酒值 20080517
    procedure ClientPlayDrink(sMsg: String);//请酒 20080517
    procedure ClientPlayMakeWine(nCode:Byte; sMsg: String);//客户端开始酿酒
//----------------------------------------------------
    Function GetMasterNoList:Boolean;//读取师徒文件 20080530
    procedure SaveMasterNoList();//保存师徒文件 20080530
    procedure AddMaster(MasterName: String); //收徒 20080530
    procedure DelMaster(MasterName: String);//出师 20080530
    procedure MasterNoListQuickSort(sList: TStringList; Order: Boolean);//师徒数据排序 20080530
//----------------------------------------------------
    procedure GetBackChallengeItems;//取回之前抵押物品
    function GetSpellPoint(UserMagic: pTUserMagic): Integer;//取技能消耗的MP值
  end;

implementation

//{$R+}//20081204 检查数组越界

uses M2Share, Guild, HUtil32, EDcode, ObjNpc, IdSrvClient, ItmUnit, Event,
  ObjMon, LocalDB, Castle, EDcodeUnit, svMain, PlugIn, ObjPlayMon, ObjHero, PlugOfEngine;

{ TBaseObject }

constructor TBaseObject.Create;
begin
  inherited;
  m_boGhost := False;
  m_dwGhostTick := 0;
  m_boDeath := False;
  m_dwDeathTick := 0;
  m_SendRefMsgTick := GetTickCount();
  m_btDirection := 4;
  m_btRaceServer := RC_ANIMAL;
  m_btRaceImg := 0;
  m_btHair := 0;
  m_btJob := 0;
  m_nGold := 0;
  m_wAppr := 0;
  bo2B9 := True;
  m_nViewRange := 5;
  m_sHomeMap := '0';
  m_btPermission := 0;
  m_nLight := 0;
  m_btNameColor := 255;
  m_nHitPlus := 0;
  m_nHitDouble := 0;
  m_dBodyLuck := 0;

  m_boRecallSuite := False;
  bo245 := False;
  //m_boTestGa := False;//20081014 注释
  bo2BA := False;
  m_boAbilSeeHealGauge := False;
  m_boPowerHit := False;
  m_boUseThrusting := False;
  m_boUseHalfMoon := False;
  m_boFireHitSkill := False;
  m_boDailySkill := False;//逐日剑法是否可用 20080511
  m_bo42kill:= False; //开天斩是否可用 20080202
  m_bo43kill:= False;//龙影剑法是否可用  20080619
  m_n42kill := 0; //开天斩轻击初始化 20080212 1--为轻 2--为重
  m_btHitPoint := 5;
  m_btSpeedPoint := 15;
  m_nHitSpeed := 0;
  m_btLifeAttrib := 0;
  m_btAntiPoison := 0;
  m_nPoisonRecover := 0;
  m_nHealthRecover := 0;
  m_nSpellRecover := 0;
  m_nAntiMagic := 0;
  m_nLuck := 0;
  m_nIncSpell := 0;
  m_nIncHealth := 0;
  m_nIncHealing := 0;
  m_nPerHealth := 5;
  m_nPerHealing := 5;
  m_nPerSpell := 5;
  m_dwIncHealthSpellTick := GetTickCount();
  m_btGreenPoisoningPoint := 0;
  m_nFightZoneDieCount := 0;
  //  m_nGoldMax       := 5000000;
  m_nGoldMax := g_Config.nHumanMaxGold;
  m_nCharStatus := 0;
  m_nCharStatusEx := 0;
  FillChar(m_wStatusTimeArr, SizeOf(TStatusTime), #0);
  //FillChar(m_wStatusTimeArr2, SizeOf(TStatusTime), #0);
  FillChar(m_BonusAbil, SizeOf(TNakedAbility), #0);
  //FillChar(m_CurBonusAbil, SizeOf(TNakedAbility), #0); //未使用 20080329

  FillChar(m_wStatusArrValue, SizeOf(m_wStatusArrValue), 0);
  FillChar(m_dwStatusArrTimeOutTick, SizeOf(m_dwStatusArrTimeOutTick), #0);

  btB2 := 0;
  m_btAttatckMode := 0;
  m_boInFreePKArea := False;
  m_boGuildWarArea := False;
  bo2B0 := False;
  m_boSuperMan := False;
  m_boSkeleton := False;
  bo2BF := False;
  m_boHolySeize := False;
  m_boCrazyMode := False;
  m_boShowHP := False;
  bo2F0 := False;
  m_boAnimal := False;
  m_boNoItem := False;
  m_nBodyLeathery := 50;
  m_boFixedHideMode := False;
  m_boStickMode := False;
  m_boNoAttackMode := False;
  bo2C1 := False;
  m_boPKFlag := False;
  m_nMoXieSuite := 0;
  m_nHongMoSuite := 0;
  m_db3B0 := 0;
  FillChar(m_AddAbil, SizeOf(TAddAbility), #0);
  m_MsgList := TList.Create;
  m_VisibleHumanList := TList.Create;

  m_VisibleActors := TList.Create;
  m_VisibleItems := TList.Create;
  m_VisibleEvents := TList.Create;
  m_ItemList := TList.Create;
  m_MagicList := TList.Create;
  m_boIsVisibleActive := False;
  m_nProcessRunCount := 0;

  FillChar(m_UseItems, SizeOf(THumanUseItems), 0);
  m_MagicOneSwordSkill := nil;
  m_MagicPowerHitSkill := nil;
  m_MagicErgumSkill := nil;
  m_MagicBanwolSkill := nil;
  m_MagicFireSwordSkill := nil;
  m_Magic74Skill := nil;//逐日剑法 20080511
  m_MagicCrsSkill := nil;
  m_Magic41Skill := nil;
  m_Magic42Skill := nil;
  m_Magic43Skill := nil;

  m_Castle := nil;
  m_Master := nil;
  n294 := 0;
  m_btSlaveExpLevel := 0;
  m_boSetNameColor:= False;//是否自定义名字颜色 20080913

  m_SlaveList := TList.Create;
  FillChar(m_WAbil, SizeOf(TAbility), #0);
  //FillChar(m_QuestUnitOpen, SizeOf(TQuestUnit), #0);
  //FillChar(m_QuestUnit, SizeOf(TQuestUnit), #0);
  m_Abil.Level := 1;
  m_Abil.AC := 0;
  m_Abil.MAC := 0;
  m_Abil.DC := MakeLong(1, 4);
  m_Abil.MC := MakeLong(1, 2);
  m_Abil.SC := MakeLong(1, 2);
  m_Abil.HP := 15;
  m_Abil.MP := 15;
  m_Abil.MaxHP := 15;
  m_Abil.MaxMP := 15;
  m_Abil.Exp := 0;
  m_Abil.MaxExp := 50;
  m_Abil.Weight := 0;
  m_Abil.MaxWeight := 100;
  m_boWantRefMsg := False;

  m_MyGuild := nil;
  m_nGuildRankNo := 0;
  m_sGuildRankName := '';
//m_sScriptLable := '';//20080521 从父类移动人物类中
  m_boMission := False;
  m_boHideMode := False;
  m_boStoneMode := False;
  m_boCoolEye := False;
  m_boUserUnLockDurg := False;
  m_boTransparent := False;
  m_boAdminMode := False;
  m_boObMode := False;
  m_dwRunTick := GetTickCount + LongWord(Random(1500));
  m_nRunTime := 250;
  m_dwSearchTime := Random(2000) + 2000;
  m_dwSearchTick := GetTickCount;
  m_dwDecPkPointTick := GetTickCount;
  m_DecLightItemDrugTick := GetTickCount();
  m_dwPoisoningTick := GetTickCount;
  m_dwVerifyTick := GetTickCount();
  m_dwCheckRoyaltyTick := GetTickCount();
  m_dwDecHungerPointTick := GetTickCount();
  m_dwHPMPTick := GetTickCount();
  //m_dwShoutMsgTick := 0;
  m_dwTeleportTick := 0;
  m_dwProbeTick := 0;
  m_dwMapMoveTick := GetTickCount();
  m_dwMasterTick := 0;
  m_nWalkSpeed := 1400;
  m_nNextHitTime := 2000;
  m_nWalkCount := 0;
  m_dwWalkWaitTick := GetTickCount();
  m_boWalkWaitLocked := False;
  m_nHealthTick := 0;
  m_nSpellTick := 0;
  m_TargetCret := nil;
  m_LastHiter := nil;
  m_ExpHitter := nil;
  m_SayMsgList := nil;
  m_boDenyRefStatus := False;
  m_btHorseType := 0;
  m_btDressEffType := 0;
  m_dwPKDieLostExp := 0;
  m_nPKDieLostLevel := 0;
  m_boAddToMaped := True;//地图是否计数
  m_boAutoChangeColor := False;
  m_dwAutoChangeColorTick := GetTickCount();
  m_nAutoChangeIdx := 0;
  m_nChangeColorType := -1; //是否变色

  m_boFixColor := False;
  m_nFixColorIdx := 0;
  m_nFixStatus := -1;
  m_boFastParalysis := False;

  m_nCopyHumanLevel := 0; //复制人状态
  m_dwStationTick := GetTickCount; //站的时间
  m_btLastOutStatus := 0;
  m_boProtectionDefence :=False;//是否使用护体神盾 20080218
  m_btMagBubbleDefenceLevel:= 0;//魔法盾等级 20080811
  m_boProtectionDefenceLevel:= 0;//护体神盾等级 20080929
  m_boOperationItemList := False;//正在操作背包列表 20080928
  m_boIsNGMonster := False;//内功怪,打死可以增加内力值 20081001
end;

destructor TBaseObject.Destroy;
var
  I: Integer;
  SendMessage: pTSendMessage;
  nCheckCode: Integer;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::Destroy Code: %d CharName: %s';
begin
  nCheckCode := 0;
  try
    nCheckCode := 1;
    if m_MsgList <> nil then begin
      if m_MsgList.Count > 0 then begin
        for I := 0 to m_MsgList.Count - 1 do begin
          nCheckCode := 2;
          SendMessage := m_MsgList.Items[I];
          if (SendMessage.wIdent = RM_SENDDELITEMLIST) and (SendMessage.nParam1 <> 0) then begin
            nCheckCode := 3;
            if TStringList(SendMessage.nParam1) <> nil then begin
              TStringList(SendMessage.nParam1).Free;
              nCheckCode := 4;
            end;
          end;
          if (SendMessage.wIdent = RM_10401) and (SendMessage.nParam1 <> 0) then begin
            nCheckCode := 5;
            Dispose(pTSlaveInfo(SendMessage.nParam1));
          end;
          nCheckCode := 6;
          if (SendMessage.Buff <> nil) then begin
            nCheckCode := 7;
            FreeMem(SendMessage.Buff);
          end;
          Dispose(SendMessage);
          nCheckCode := 8;
        end;
      end;
      nCheckCode := 9;
      FreeAndNil(m_MsgList);
    end;

    nCheckCode := 10;
    try//20080827 增加保护
      if m_VisibleHumanList <> nil then FreeAndNil(m_VisibleHumanList);
    except
    end;

    nCheckCode := 12;
    if m_VisibleActors <> nil then begin
      if m_VisibleActors.Count > 0 then begin
        for I := 0 to m_VisibleActors.Count - 1 do begin
          if pTVisibleBaseObject(m_VisibleActors.Items[I]) <> nil then//20080724
          Dispose(pTVisibleBaseObject(m_VisibleActors.Items[I]));
        end;
      end;
      nCheckCode := 13;
      if m_VisibleActors <> nil then FreeAndNil(m_VisibleActors);//20080908
    end;
    nCheckCode := 14;

    if m_VisibleItems <> nil then begin
      if m_VisibleItems.Count > 0 then begin
        for I := 0 to m_VisibleItems.Count - 1 do begin
          if pTVisibleMapItem(m_VisibleItems.Items[I]) <> nil then//20080724
            Dispose(pTVisibleMapItem(m_VisibleItems.Items[I]));
        end;
      end;
      nCheckCode := 15;
      FreeAndNil(m_VisibleItems);
    end;
    nCheckCode := 16;

    if m_VisibleEvents <> nil then begin
      if m_VisibleEvents.Count > 0 then begin
        nCheckCode := 17;
        for I := 0 to m_VisibleEvents.Count - 1 do begin
          nCheckCode := 18;
          if pTVisibleMapEvent(m_VisibleEvents.Items[I]) <> nil then //20080724
            Dispose(pTVisibleMapEvent(m_VisibleEvents.Items[I]));
        end;
      end;
      nCheckCode := 19;
      FreeAndNil(m_VisibleEvents);
    end;

    nCheckCode := 20;
    if m_MagicList <> nil then begin
      if m_MagicList.Count > 0 then begin
        for I := 0 to m_MagicList.Count - 1 do begin
          if pTUserMagic(m_MagicList.Items[I]) <> nil then
            Dispose(pTUserMagic(m_MagicList.Items[I]));
        end;
      end;
      FreeAndNil(m_MagicList);
    end;

    nCheckCode := 21;
    if m_SlaveList <> nil then FreeAndNil(m_SlaveList);

    nCheckCode := 17;
    if m_ItemList <> nil then begin
      m_boOperationItemList:= True;//20080928 防止同时操作背包列表时保存
      for I := m_ItemList.Count - 1 downto 0 do begin
        if m_ItemList.Count <= 0 then Break;
        nCheckCode := 24;
        Try
          if pTUserItem(m_ItemList.Items[I]) <> nil then Dispose(pTUserItem(m_ItemList.Items[I]));
        except
          m_ItemList.Delete(I);
          MainOutMessage(Format(sExceptionMsg, [nCheckCode, m_sCharName]));
          if m_ItemList.Count > 0 then Continue;
        end;
      end;
      nCheckCode := 18;
      FreeAndNil(m_ItemList);
      m_boOperationItemList:= False;//20080928 防止同时操作背包列表时保存
    end;

  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg, [nCheckCode, m_sCharName]));
    end;
  end;
    {for I := 0 to CertCheck.Count - 1 do begin
    if CertCheck.Items[I] = Self then begin
      CertCheck.Delete(I);
      break;
    end;
  end; }
  inherited;
end;

procedure TBaseObject.ChangePKStatus(boWarFlag: Boolean);
begin
  if m_boInFreePKArea <> boWarFlag then begin
    m_boInFreePKArea := boWarFlag;
    m_boNameColorChanged := True;
  end;
end;
//取掉物的位置 20080124
function TBaseObject.GetDropPosition(nOrgX, nOrgY, nRange: Integer; var nDX: Integer; var nDY: Integer): Boolean; //004C5238
var
  I, II, III: Integer;
  nItemCount, n24, n28, n2C: Integer;
begin
  n24 := 999;
  Result := False;
  n28 := 0; //09/10
  n2C := 0; //09/10
  for I := 1 to nRange do begin
    for II := -I to I do begin
      for III := -I to I do begin
        nDX := nOrgX + III;
        nDY := nOrgY + II;
        if m_PEnvir.GetItemEx(nDX, nDY, nItemCount) = nil then begin
          if m_PEnvir.bo2C then begin
            Result := True;
            Break;
          end;
        end else begin
          if m_PEnvir.bo2C and (n24 > nItemCount) then begin
            n24 := nItemCount;
            n28 := nDX;
            n2C := nDY;
          end;
        end;
      end;
      if Result then Break;
    end;
    if Result then Break;
  end;
  if not Result then begin
    if n24 < 8 then begin
      nDX := n28;
      nDY := n2C;
    end else begin
      nDX := nOrgX;
      nDY := nOrgY;
    end;
  end;
end;
//物品掉落,怪死爆物品 20080126
function TBaseObject.DropItemDown(UserItem: pTUserItem; nScatterRange: Integer; boDieDrop, boCanHit: Boolean; ItemOfCreat, DropCreat: TBaseObject): Boolean;
var
  dx, dy, idura: Integer;
  MapItem, pr: PTMapItem;
  StdItem: pTStdItem;
  logcap: string;
  sUserItemName: string;
  nCode: Byte;
begin
  Result := False;
  nCode:= 0;
  try
    if CheckItemValue(UserItem,5) then Exit;//20080523 禁止爆出
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      if CheckIsOKItem(UserItem, StdItem.StdMode) then Exit;//检查物品附加属性是否正常 20081006
      if StdItem.StdMode = 40 then begin
        idura := UserItem.Dura;
        idura := idura - 2000;
        if idura < 0 then idura := 0;
        UserItem.Dura := idura;
      end;
      New(MapItem);
      MapItem.UserItem := UserItem^;
      MapItem.Name := StdItem.Name;
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then begin
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then MapItem.Name := sUserItemName;
      end;
      nCode:= 7;
      MapItem.Looks := StdItem.Looks;
      if StdItem.StdMode = 45 then begin
        MapItem.Looks := GetRandomLook(MapItem.Looks, StdItem.Shape);
      end;
      nCode:= 8;
      MapItem.AniCount := StdItem.AniCount;
      MapItem.Reserved := 0;
      MapItem.Count := 1;
      MapItem.OfBaseObject := ItemOfCreat;
      MapItem.dwCanPickUpTick := GetTickCount();
      MapItem.DropBaseObject := DropCreat;
      if DropCreat.m_btRaceServer = 136 then begin //20080127
        nCode:= 13;
        GetDropPosition(DropCreat.m_LastHiter.m_nCurrX, DropCreat.m_LastHiter.m_nCurry, nScatterRange, dx, dy);//取掉物的位置
      end else begin
        nCode:= 14;
        GetDropPosition(m_nCurrX, m_nCurrY, nScatterRange, dx, dy);//取掉物的位置
      end;
      nCode:= 15;
      pr := m_PEnvir.AddToMap(dx, dy, OS_ITEMOBJECT, TObject(MapItem));
      if pr = MapItem then begin
        SendRefMsg(RM_ITEMSHOW, MapItem.Looks, Integer(MapItem), dx, dy, MapItem.Name);
        PlugOfCheckCanItem(4, MapItem.Name, boCanHit, dx, dy);//禁止物品规则(掉落物品提示) 20080729
        if boDieDrop then logcap := '15'
        else logcap := '7';
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog(logcap + #9 +
            m_sMapName+'('+BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT)+')'+ #9 +
            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
            '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
            '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
            '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
            '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
            '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
            IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
            IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
            IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
            IntToStr(UserItem.btValue[14])+ #9 + IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax));
        Result := True;
      end else begin
        Dispose(MapItem);
      end;
    end;
  except
    MainOutMessage('{异常} TBaseObject.DropItemDown Code:'+inttostr(nCode));
  end;
end;

procedure TBaseObject.GoldChanged();
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    SendUpdateMsg(Self, RM_GOLDCHANGED, 0, 0, 0, 0, '');
  end;
end;

procedure TBaseObject.GameGoldChanged();
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    SendUpdateMsg(Self, RM_GAMEGOLDCHANGED, 0, 0, 0, 0, '');
  end;
end;
//荣誉值改变 20080511
procedure TBaseObject.GameGloryChanged();
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    SendUpdateMsg(Self, RM_GLORY, 0, 0, 0, 0, '');
  end;
end;

//玩家捡起物品
function TPlayObject.ClientPickUpItem: Boolean;
  function IsSelf(BaseObject: TBaseObject): Boolean;
  begin
    if (BaseObject = nil) or (Self = BaseObject) then Result := True
    else Result := False;
  end;
  function IsOfGroup(BaseObject: TBaseObject): Boolean;
  var
    I: Integer;
    GroupMember: TBaseObject;
  begin
    Result := False;
    if m_GroupOwner = nil then Exit;
    for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
      GroupMember := TBaseObject(m_GroupOwner.m_GroupMembers.Objects[I]);
      if GroupMember = BaseObject then begin
        Result := True;
        Break;
      end;
    end;//for
  end;
var
  UserItem: pTUserItem;
  MapItem: PTMapItem;
  StdItem: pTStdItem;
  PlayObject: TPlayObject;
begin
  Result := False;
  if m_boDealing then Exit;//交易中则退出
  if m_boDeath then Exit;//死亡则退出 20080618
  MapItem := m_PEnvir.GetItem(m_nCurrX, m_nCurrY);
  if MapItem = nil then Exit;

  if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then begin
    MapItem.OfBaseObject := nil;
  end;
  {if (Assigned(zPlugOfEngine.CheckCanPickUpItem)) and (m_btPermission < 10) then begin //进入插件物品规则20080611
    if not zPlugOfEngine.CheckCanPickUpItem(Self, PChar(MapItem.Name)) then begin
      SysMsg(g_sPickUpItemHintMsg, c_Red, t_Hint);//提示 禁止捡起
      Exit;//禁止捡起
    end;
  end; }
  if PlugOfCheckCanItem(9, MapItem.Name, False, 0, 0) then begin//禁止物品规则(管理插件功能) 20080729
    SysMsg(g_sPickUpItemHintMsg, c_Red, t_Hint);//提示 禁止捡起
    Exit;//禁止捡起
  end;

  if not IsSelf(TBaseObject(MapItem.OfBaseObject)) and not IsOfGroup(TBaseObject(MapItem.OfBaseObject)) then begin
    SysMsg(g_sCanotPickUpItem {'在一定时间以内无法捡起此物品！！！'}, c_Red, t_Hint);
    Exit;
  end;
  if CompareText(MapItem.Name, sSTRING_GOLDNAME) = 0 then begin
    if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then begin
      if IncGold(MapItem.Count) then begin
        SendRefMsg(RM_ITEMHIDE, 0, Integer(MapItem), m_nCurrX, m_nCurrY, '');
        if g_boGameLogGold then
          AddGameDataLog('4' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 +
            IntToStr(MapItem.Count) + #9 +
            '1' + #9 + '0');
        GoldChanged;
        Dispose(MapItem);
      end else
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem));
    end;
    Exit;
  end;

  if IsEnoughBag then begin
    if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then begin
      New(UserItem);
      FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
      //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
      UserItem^ := MapItem.UserItem;
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem <> nil) then begin
        if IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex)) then begin
          SendMsg(Self, RM_ITEMHIDE, 0, Integer(MapItem), m_nCurrX, m_nCurrY, '');
          ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
          AddItemToBag(UserItem);
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('4' + #9 + m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 + StdItem.Name + #9 +IntToStr(UserItem.MakeIndex) + #9 +
              '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
              '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
              '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
              '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
              '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
              IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
              IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
              IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
              IntToStr(UserItem.btValue[14])+ #9 +IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax));
          Dispose(MapItem);
          if m_btRaceServer = RC_PLAYOBJECT then begin
            PlayObject := TPlayObject(Self);
            PlayObject.SendAddItem(UserItem);
          end;
          Result := True;
        end else begin
          Dispose(UserItem);
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem));
        end;
      end;//StdItem <> nil
    end;
  end;
end;

procedure TPlayObject.RunNotice;
var
  Msg: TProcessMessage;
resourcestring
  sExceptionMsg = '{异常} TPlayObject::RunNotice';
begin
  if m_boEmergencyClose or m_boKickFlag or m_boSoftClose then begin
    if m_boKickFlag then SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
    MakeGhost();
  end else begin
    try
      if not m_boSendNotice then begin
        SendNotice();
        m_boSendNotice := True;
        m_dwWaitLoginNoticeOKTick := GetTickCount();
      end else begin
        if GetTickCount - m_dwWaitLoginNoticeOKTick > 30000{30 * 1000} then begin
          m_boEmergencyClose := True;
        end;
        while GetMessage(@Msg) do begin
          if Msg.wIdent = CM_LOGINNOTICEOK then begin
            m_boLoginNoticeOK := True;
            m_dwClientTick := Msg.nParam1;
            SysMsg(IntToStr(m_dwClientTick), c_Red, t_Notice);
          end;
        end;
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  end;
end;

procedure TPlayObject.WinExp(dwExp: LongWord);
begin
  if m_Abil.Level > g_Config.nLimitExpLevel then begin//超过限制等级,只给指定的限制经验
    dwExp := g_Config.nLimitExpValue;
    GetExp(dwExp,False);
  end else
    if dwExp > 0 then begin
    if m_nKillMonExpRate <= 0 then m_nKillMonExpRate:= 100;//20081229 防止倍数为负数
    dwExp := g_Config.dwKillMonExpMultiple * dwExp; //系统指定杀怪经验倍数
    dwExp := Round((m_nKillMonExpRate / 100) * dwExp); //人物指定的杀怪经验倍数
    if m_PEnvir.m_boEXPRATE then
      dwExp := Round((m_PEnvir.m_nEXPRATE / 100) * dwExp); //地图上指定杀怪经验倍数
    if m_boExpItem then begin //物品经验倍数
      dwExp := Round(m_rExpItem * dwExp);
    end;
    GetExp(dwExp,False);
  end;
end;

//取得内力经验 20081001  Code:0-杀怪分配 1-非杀怪分配 2-饮酒(谁喝分配给谁)
procedure TPlayObject.GetNGExp(dwExp: LongWord; Code: Byte);
begin
  if m_Abil.Level > g_Config.nLimitExpLevel then begin//超过限制等级,只给指定的限制经验
    dwExp := g_Config.nLimitExpValue;
  end else
  if (dwExp > 0) and (Code = 0) then begin
    dwExp := g_Config.dwKillMonExpMultiple * dwExp; //系统指定杀怪经验倍数
    dwExp := Round((m_nKillMonExpRate / 100) * dwExp); //人物指定的杀怪经验倍数
    if m_PEnvir.m_boEXPRATE then
      dwExp := Round((m_PEnvir.m_nEXPRATE / 100) * dwExp); //地图上指定杀怪经验倍数
    if m_boExpItem then begin //物品经验倍数
      dwExp := Round(m_rExpItem * dwExp);
    end;
  end;

  if m_MyHero <> nil then begin
    if (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) then begin
      case Code of
        0: begin
           THeroObject(m_MyHero).GetNGExp(abs(Round((g_Config.nHeroKillMonExpRate / 100) * dwExp)),3);//20081018 修改
           dwExp:= abs(Round(((100 -  g_Config.nHeroKillMonExpRate) / 100) * dwExp));//20081018 修改
           dwExp := g_Config.dwKillMonNGExpMultiple * dwExp;//杀怪内功经验倍数 20081218
         end;
        1: begin//非杀怪,英雄与主人一样经验 20081020
           //THeroObject(m_MyHero).GetNGExp(abs(Round((g_Config.nHeroNoKillMonExpRate / 100) * dwExp)),1);//20081018 修改
           //dwExp:= abs(Round(((100 - g_Config.nHeroNoKillMonExpRate) / 100) * dwExp));//20081018 修改
           THeroObject(m_MyHero).GetNGExp(dwExp,1);
         end;
      end;
    end;
  end else begin
    if (dwExp > 0) and (Code = 0) then begin
      dwExp := g_Config.dwKillMonNGExpMultiple * dwExp;//杀怪内功经验倍数 20081218
    end;
  end;

  if m_boTrainingNG and (dwExp > 0) then begin
    if m_ExpSkill69 >= LongWord(dwExp) then begin//20090101
      if (High(LongWord) - m_ExpSkill69) < LongWord(dwExp) then begin
        dwExp := High(LongWord) - m_ExpSkill69;
      end;
    end else begin
      if (High(LongWord) - LongWord(dwExp)) < m_ExpSkill69 then begin
        dwExp := High(LongWord) - LongWord(dwExp);
      end;
    end;
    Inc(m_ExpSkill69, dwExp);//内功心法当前经验
    if not m_boNotOnlineAddExp then SendMsg(Self, RM_WINNHEXP, 0, dwExp, 0, 0, '');//只发送给非离线挂机人物
    if m_ExpSkill69 >= m_MaxExpSkill69 then begin
      Dec(m_ExpSkill69, m_MaxExpSkill69);
      Inc(m_NGLevel);
      m_MaxExpSkill69:= GetSkill69Exp(m_NGLevel, m_Skill69MaxNH);//取内功心法升级经验
      m_Skill69NH:= m_Skill69MaxNH;
      SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, ''); //内力值让别人看到 20081002
      SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP,0, 0, 0, ''); //人物升级动画  20081216
    end;
    SendMsg(Self, RM_MAGIC69SKILLEXP, 0, 0, 0, m_NGLevel, EncodeString(Inttostr(m_ExpSkill69)+'/'+Inttostr(m_MaxExpSkill69)));
  end;
end;
//内功技能升级 20081003
procedure TPlayObject.NGMAGIC_LVEXP(UserMagic: pTUserMagic);
begin
  if (UserMagic <> nil) then begin
    if (m_btRaceServer = RC_PLAYOBJECT) and (UserMagic.btLevel < 3) and
       (UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] <= m_NGLevel) then begin
       TrainSkill(UserMagic, Random(3) + 1);
       if not CheckMagicLevelup(UserMagic) then begin
         SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, UserMagic.MagicInfo.wMagicId, UserMagic.btLevel, UserMagic.nTranPoint, '', 3000);
       end;
    end;
  end;
end;

//取得经验 20080221 参数boItmeExp: False-将经验累积到聚灵珠中 True-不累积经验到聚灵珠中
procedure TPlayObject.GetExp(dwExp: LongWord; boItmeExp:Boolean);
var nCode: Byte;//20080730
begin
  nCode:= 0;
  try
    if m_Abil.Exp >= LongWord(dwExp) then begin//20090101
      if (High(LongWord) - m_Abil.Exp) < LongWord(dwExp) then begin
        dwExp := High(LongWord) - m_Abil.Exp;
      end;
    end else begin
      if (High(LongWord) - LongWord(dwExp)) < m_Abil.Exp then begin
        dwExp := High(LongWord) - LongWord(dwExp);
      end;
    end;
    if not boItmeExp then GetExpToItem(dwExp);//取得的经验,累积到聚灵珠 20080221
    nCode:= 1;
    if m_MyHero <> nil then begin //人取得经验,都给英雄分配经验 20080518
      nCode:= 2;
      if (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) then begin//20080826 增加
        nCode:= 10;
        THeroObject(m_MyHero).GetExp(abs(Round((g_Config.nHeroKillMonExpRate / 100) * dwExp)){ + 1});//20081018
        dwExp:= abs(Round(((100 -  g_Config.nHeroKillMonExpRate) / 100) * dwExp));//20081018 修改
      end;
    end;
    nCode:= 3;
    m_GetExp:= dwExp;//人物取得的经验,$GetExp变量使用 20081228
    Inc(m_Abil.Exp, dwExp);
    AddBodyLuck(dwExp * 0.002);
    if not m_boNotOnlineAddExp then //只发送给非离线挂机人物
      SendMsg(Self, RM_WINEXP, 0, dwExp, 0, 0, '');
    nCode:= 4;
    if m_Abil.Exp >= m_Abil.MaxExp then begin
      Dec(m_Abil.Exp, m_Abil.MaxExp);
      if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then Inc(m_Abil.Level);//20080715 增加限制等级
      if m_Abil.Level < g_Config.nLimitExpLevel then HasLevelUp(m_Abil.Level - 1);//20080715 增加限制等级
      nCode:= 5;
      AddBodyLuck(100);
      AddGameDataLog('12' + #9 + m_sMapName + #9 + //人物升级记录日志
        IntToStr(m_Abil.Level) + #9 +
        IntToStr(m_Abil.Exp)+'/'+IntToStr(m_Abil.MaxExp) + #9 +
        m_sCharName + #9 + '0' + #9 + '0' + #9 + '1' + #9 + '0');
      nCode:= 6;
      IncHealthSpell(2000, 2000);  
    end;
    nCode:= 7;
    if m_Magic68Skill <> nil then begin//学过酒气护体 20080625
      if m_Magic68Skill.btLevel < 100 then Inc(m_Exp68, dwExp);
      if m_Exp68 >= m_MaxExp68 then begin//超过升级经验,则升级技能
        Dec(m_Exp68, m_MaxExp68);
        if m_Magic68Skill.btLevel < 100 then Inc(m_Magic68Skill.btLevel);
        nCode:= 8;
        m_MaxExp68 := GetSkill68Exp(m_Magic68Skill.btLevel);
        SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_Magic68Skill.MagicInfo.wMagicId, m_Magic68Skill.btLevel, m_Magic68Skill.nTranPoint, '', 100);
      end;
      nCode:= 9;
      if (Self <> nil) and (m_Magic68Skill.btLevel < 100) then//20080810 增加 20080830 修改
        SendMsg(Self, RM_MAGIC68SKILLEXP, 0, 0, 0, 0, EncodeString(Inttostr(m_Exp68)+'/'+Inttostr(m_MaxExp68)));//发送酒气护体经验
      //发消息更新客户端显示
    end;
  except
    MainOutMessage('{异常} TPlayObject.GetExp Code:'+inttostr(nCode));
  end;
end;
//取得的经验,累积到物品上,-----聚灵珠 20080221
procedure TPlayObject.GetExpToItem(dwExp: LongWord);
var
  I: Integer;
  UserItem: pTUserItem;
  AmuletStdItem: pTStdItem;
  boGetExpToItem,boHeroToItem: Boolean;
  nCode: Byte;//20080730
begin
  nCode:= 0;
  boGetExpToItem:= False;
  boHeroToItem:= False;
  Try
    if m_boDeath or m_boGhost then Exit;//20080730 死亡不再聚
    if m_ItemList.Count > 0 then begin//20080628
      for I := 0 to m_ItemList.Count - 1 do begin //人物包裹不为空
        UserItem := m_ItemList.Items[I];
        AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if AmuletStdItem <> nil then begin
          if (AmuletStdItem.StdMode = 51) and (AmuletStdItem.Shape = 0) and (UserItem.btValue[12] <> 2) and
          (UserItem.Dura < UserItem.DuraMax) then begin //聚灵珠
            nCode:= 3;
            if m_PEnvir <> nil then
              if not m_PEnvir.AllowStdItems(AmuletStdItem.Name) then Exit;//检查地图是否禁用聚灵珠 20081016
            nCode:= 31;
            if UserItem.btValue[20]= 1 then boGetExpToItem:= True;
            if n_UsesItemTick = 0 then begin
               n_UsesItemTick:= AmuletStdItem.AniCount * 86400{24 * 60 * 60} ;//使用时间
               boGetExpToItem:= True;
               UserItem.btValue[20]:= 1;
            end;
            if boGetExpToItem then Break;
          end;
        end;
      end;
    end;
    nCode:= 2;
    if (not boGetExpToItem) and (m_MyHero <> nil) then begin
      if m_MyHero.m_ItemList.Count > 0 then begin//20080628
        for I := 0 to m_MyHero.m_ItemList.Count - 1 do begin //人物包里没有珠,英雄包裹不为空时
          UserItem := m_MyHero.m_ItemList.Items[I];
          AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if AmuletStdItem <> nil then begin
            if (AmuletStdItem.StdMode = 51) and (AmuletStdItem.Shape = 0) and (UserItem.btValue[12] <> 2) and
            (UserItem.Dura < UserItem.DuraMax) then begin //聚灵珠
              nCode:= 32;
              if m_MyHero.m_PEnvir <> nil then
                if not m_MyHero.m_PEnvir.AllowStdItems(AmuletStdItem.Name) then Exit;//检查地图是否禁用聚灵珠 20081016
              nCode:= 33;
              if UserItem.btValue[20]= 1 then boHeroToItem:= True;
              if n_UsesItemTick = 0 then begin
                 n_UsesItemTick:= AmuletStdItem.AniCount * 86400{24 * 60 * 60} ;//使用时间
                 boHeroToItem:= True;
                 UserItem.btValue[20]:= 1;
              end;
              if boHeroToItem then Break;
            end;
          end;
        end;
      end;
    end;
    nCode:= 4;

    if m_nWinExp >= LongWord(dwExp) then begin//20090101
      if (High(LongWord) - m_nWinExp) < LongWord(dwExp) then begin
        dwExp := High(LongWord) - m_nWinExp;
      end;
    end else begin
      if (High(LongWord) - LongWord(dwExp)) < m_nWinExp then begin
        dwExp := High(LongWord) - LongWord(dwExp);
      end;
    end;

    if boGetExpToItem then begin//主人包裹里聚经验
      Inc(m_nWinExp ,dwExp);
      if m_nWinExp >=10000 then begin
         {while True do begin   20081231 修改
           if m_nWinExp < 10000 then break;
           Inc(UserItem.Dura);
           Dec(m_nWinExp, 10000);
           if UserItem.Dura >= UserItem.DuraMax then begin
             UserItem.Dura := UserItem.DuraMax;
             break;
           end;
         end;}
         Inc(UserItem.Dura, m_nWinExp div 10000);
         m_nWinExp:= m_nWinExp mod 10000;
         if UserItem.Dura >= UserItem.DuraMax then begin
           UserItem.Dura := UserItem.DuraMax;
         end;

         SendMsg(self, RM_DURACHANGE,UserItem.wIndex, UserItem.Dura, UserItem.DuraMax, 0, ''{IntToStr(m_nWinExp)});
         SendUpdateItem(UserItem);//更新物品
         SendItemUseTime(n_UsesItemTick);//20080323
      end;
      if UserItem.Dura >= UserItem.DuraMax then begin
        UserItem.Dura:= UserItem.DuraMax;
        n_UsesItemTick:= 0;//20080311
        m_nWinExp:= 0;//20081231
        UserItem.btValue[12]:= 2;//20080404 增加,不能聚集的标识
        SendItemUseTime(n_UsesItemTick); //发送聚灵珠使用剩余时间 20080309
        SysMsg('【聚灵珠】已聚集足够的经验，请双击使用!', c_Green, t_Hint);
      end;
    end else
    if boHeroToItem then begin//英雄包裹里,珠子聚经验 20080427
      nCode:= 5;
      Inc(m_nWinExp ,dwExp);
      if m_nWinExp >=10000 then begin
       {while True do begin    20081231 修改
          if m_nWinExp < 10000 then break;
          Inc(UserItem.Dura);
          Dec(m_nWinExp, 10000);
          if UserItem.Dura >= UserItem.DuraMax then begin
            UserItem.Dura := UserItem.DuraMax;
            break;
          end;
        end;}
        Inc(UserItem.Dura, m_nWinExp div 10000);
        m_nWinExp:= m_nWinExp mod 10000;
        if UserItem.Dura >= UserItem.DuraMax then begin
          UserItem.Dura := UserItem.DuraMax;
        end;

        THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HERODURACHANGE,UserItem.wIndex, UserItem.Dura, UserItem.DuraMax, 0, ''{IntToStr(m_nWinExp)});//20080610 修改
        THeroObject(m_MyHero).SendUpdateItem(UserItem);//更新物品   20080610 修改
        SendItemUseTime(n_UsesItemTick);//20080323
        THeroObject(m_MyHero).SendUpdateItem(UserItem);//更新物品
      end;
      if UserItem.Dura >= UserItem.DuraMax then begin
        UserItem.Dura:= UserItem.DuraMax;
        n_UsesItemTick:= 0;//20080311
        m_nWinExp:= 0;//20081231
        UserItem.btValue[12]:= 2;//20080404 增加,不能聚集的标识
        SendItemUseTime(n_UsesItemTick); //发送聚灵珠使用剩余时间 20080309
        SysMsg('【聚灵珠】已聚集足够的经验，请双击使用!', c_Green, t_Hint);
      end;
    end;
    nCode:= 6;
    if (not boGetExpToItem) and (not boHeroToItem) then n_UsesItemTick:= 0;//20080611 主人英雄都没有珠子,则初始
    if m_nWinExp < 0 then m_nWinExp:= 0;//20080923 
  except
    MainOutMessage('{异常} TPlayObject.GetExpToItem Code:'+inttostr(nCode));
  end;
end;
//发送聚灵珠使用剩余时间 20080307
procedure TPlayObject.SendItemUseTime(dwTime: Integer);
var
  I: Integer;
  UserItem: pTUserItem;
  AmuletStdItem: pTStdItem;
  boGetExpToItem: Boolean;
begin
  boGetExpToItem:= False;
  if m_ItemList.Count > 0 then begin//20080628
    for I := 0 to m_ItemList.Count - 1 do begin //人物包裹不为空
      UserItem := m_ItemList.Items[I];
      AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if AmuletStdItem <> nil then begin
        if (AmuletStdItem.StdMode = 51) and (AmuletStdItem.Shape = 0) and (UserItem.btValue[20]= 1) then begin //聚灵珠
          dwTime:= dwTime div 3600;
          SendMsg(self, RM_EXPTIMEITEMS, 0, UserItem.MakeIndex, dwTime, 0, '');//发送聚灵珠剩于时间 20080307
          boGetExpToItem:= True;
          Break;
        end;
      end;
    end;
  end;
  if (not boGetExpToItem) and (m_MyHero <> nil) then begin
    if m_MyHero.m_ItemList.Count > 0 then begin//20080628
      for I := 0 to m_MyHero.m_ItemList.Count - 1 do begin //英雄包裹不为空
        UserItem := m_MyHero.m_ItemList.Items[I];
        AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if AmuletStdItem <> nil then begin
          if (AmuletStdItem.StdMode = 51) and (AmuletStdItem.Shape = 0) and (UserItem.btValue[20]= 1) then begin //聚灵珠
            dwTime:= dwTime div 3600;
            SendMsg(self, RM_EXPTIMEITEMS, 0, UserItem.MakeIndex, dwTime, 0, '');//发送聚灵珠剩于时间 20080307
            Break;
          end;
        end;
      end;
    end;
  end;
end;
//是否包裹里有聚龙珠 20080308   参数为1时,发送经验值,用于人物上线时发送
Function TPlayObject.IsItem_51(nCode: Integer):Boolean;
var
  I:Integer;
  UserItem: pTUserItem;
  AmuletStdItem: pTStdItem;
  boGetExpToItem: Boolean;
begin
  Result:=False;
  boGetExpToItem:= False;
  if m_ItemList.Count > 0 then begin//20080628
    for I := 0 to m_ItemList.Count - 1 do begin //人物包裹不为空
      UserItem := m_ItemList.Items[I];
      AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if AmuletStdItem <> nil then begin
        if (AmuletStdItem.StdMode = 51) and (AmuletStdItem.Shape = 0) and (UserItem.btValue[12]<> 2) then begin //聚灵珠
          case nCode of
            1:begin
              if UserItem.btValue[20] <> 1 then Continue;
              if m_nWinExp >=10000 then begin
                 Inc(UserItem.Dura);
                 dec(m_nWinExp,10000);
                 boGetExpToItem:= True;
                 if UserItem.Dura > UserItem.DuraMax then UserItem.Dura := UserItem.DuraMax;
              end;
              SendMsg(self, RM_DURACHANGE,UserItem.wIndex, UserItem.Dura, UserItem.DuraMax, 0, ''{IntToStr(m_nWinExp)});
              SendItemUseTime(n_UsesItemTick);//20080412
             end;
            2:begin
              n_UsesItemTick:= 0;//时间初始 20080911
              UserItem.btValue[12]:= 2;//20080522 增加,不能聚集的标识
            end;
          end;
          Result:= True;
          Break;
        end;
      end;
    end;
  end;
  if (nCode = 1) and (not boGetExpToItem) and (m_MyHero <> nil) then begin
    if m_MyHero.m_ItemList.Count > 0 then begin//20080628
      for I := 0 to m_MyHero.m_ItemList.Count - 1 do begin //英雄包裹不为空
        UserItem := m_MyHero.m_ItemList.Items[I];
        AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if AmuletStdItem <> nil then begin
          if (AmuletStdItem.StdMode = 51) and (AmuletStdItem.Shape = 0) and (UserItem.btValue[12]<> 2) then begin //聚灵珠
            if UserItem.btValue[20] <> 1 then Continue;
            if m_nWinExp >=10000 then begin
               Inc(UserItem.Dura);
               dec(m_nWinExp,10000);
               if UserItem.Dura > UserItem.DuraMax then UserItem.Dura := UserItem.DuraMax;
            end;
            THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HERODURACHANGE,UserItem.wIndex, UserItem.Dura, UserItem.DuraMax, 0, ''{IntToStr(m_nWinExp)});//20080610 修改
            SendItemUseTime(n_UsesItemTick);//20080412
            THeroObject(m_MyHero).SendUpdateItem(UserItem);//更新物品
            Result:= True;
            Break;
          end;
        end;
      end;
    end;
  end;
end;

//重新计算角色的等级各属性
procedure TBaseObject.RecalcLevelAbilitys();
var
  nLevel, n: Integer;
begin
  nLevel := m_Abil.Level;
  case m_btJob of
    2: begin
        m_Abil.MaxHP := _MIN(High(Word), 14 + Round(((nLevel / g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) * nLevel)));

        m_Abil.MaxMP := _MIN(High(Word), 13 + Round(((nLevel / g_Config.nLevelValueOfTaosMP) * 2.2 * nLevel)));

        m_Abil.MaxWeight := _MIN(High(Word),50 + Round((nLevel / 4) * nLevel));
        m_Abil.MaxWearWeight := _MIN(High(Word),15 + Round((nLevel / 50) * nLevel));
        m_Abil.MaxHandWeight := _MIN(High(Word),12 + Round((nLevel / 42) * nLevel));

        n := nLevel div 7;
        m_Abil.DC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.MC := 0;
        m_Abil.SC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.AC := 0;

        n := Round(nLevel / 6);
        m_Abil.MAC := MakeLong(n div 2, n + 1);
      end;
    1: begin
        m_Abil.MaxHP := _MIN(High(Word), 14 + Round(((nLevel / g_Config.nLevelValueOfWizardHP + g_Config.nLevelValueOfWizardHPRate) * nLevel)));

        m_Abil.MaxMP := _MIN(High(Word), 13 + Round((nLevel / 5 + 2) * 2.2 * nLevel));
        m_Abil.MaxWeight := _MIN(High(Word),50 + Round((nLevel / 5) * nLevel));
        m_Abil.MaxWearWeight := _MIN(High(Word),15 + Round((nLevel / 100) * nLevel));
        m_Abil.MaxHandWeight := _MIN(High(Word),12 + Round((nLevel / 90) * nLevel));

        n := nLevel div 7;
        m_Abil.DC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.MC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.SC := 0;
        m_Abil.AC := 0;
        m_Abil.MAC := 0;
      end;
    0: begin
        m_Abil.MaxHP := _MIN(High(Word), 14 + Round(((nLevel / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + nLevel / 20) * nLevel)));
        m_Abil.MaxMP := _MIN(High(Word), 11 + Round(nLevel * 3.5));
        m_Abil.MaxWeight := _MIN(High(Word),50 + Round((nLevel / 3) * nLevel));
        m_Abil.MaxWearWeight := _MIN(High(Word),15 + Round((nLevel / 20) * nLevel));
        m_Abil.MaxHandWeight := _MIN(High(Word),12 + Round((nLevel / 13) * nLevel));
        m_Abil.DC := MakeLong(_MAX((nLevel div 5) - 1, 1), _MAX(1, (nLevel div 5)));
        m_Abil.SC := 0;
        m_Abil.MC := 0;
        m_Abil.AC := MakeLong(0, (nLevel div 7));
        m_Abil.MAC := 0;
      end;
   {3: begin//刺客(暂时使用战士参数)
        m_Abil.MaxHP := _MIN(High(Word), 14 + Round(((nLevel / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + nLevel / 20) * nLevel)));
        m_Abil.MaxMP := _MIN(High(Word), 11 + Round(nLevel * 3.5));
        m_Abil.MaxWeight := 50 + Round((nLevel / 3) * nLevel);
        m_Abil.MaxWearWeight := 15 + Round((nLevel / 20) * nLevel);
        m_Abil.MaxHandWeight := 12 + Round((nLevel / 13) * nLevel);
        m_Abil.DC := MakeLong(_MAX((nLevel div 5) - 1, 1), _MAX(1, (nLevel div 5)));
        m_Abil.SC := 0;
        m_Abil.MC := 0;
        m_Abil.AC := MakeLong(0, (nLevel div 7));
        m_Abil.MAC := 0;
      end;}
  end;
 if m_btRaceServer = RC_HEROOBJECT then  //英雄HP值按设置倍数计算 20081219
    m_Abil.MaxHP := _MIN(High(Word),m_Abil.MaxHP * g_Config.nHeroHPRate); 

  if m_Abil.HP > m_Abil.MaxHP then m_Abil.HP := m_Abil.MaxHP;
  if m_Abil.MP > m_Abil.MaxMP then m_Abil.MP := m_Abil.MaxMP;
end;

procedure TBaseObject.HasLevelUp(nLevel: Integer);
begin
  m_Abil.MaxExp := GetLevelExp(m_Abil.Level);
  RecalcLevelAbilitys();//刷新等级各种属性
  RecalcAbilitys();
  CompareSuitItem(False);//200080808 套装
  if nLevel <> 0 then begin //20080305 根据参数来发消息,参数为0不发消息
    if m_btRaceServer = RC_PLAYOBJECT then begin
      if not TPlayObject(Self).m_boNotOnlineAddExp then begin //非挂机人物
        SendMsg(Self, RM_LEVELUP, 0, m_Abil.Exp, 0, 0, '');
        SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP,0, 0, 0, ''); //人物升级动画  20080222
        TPlayObject(Self).LevelUpFunc();//人物升级触发
      end;
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin //发送英雄升级信息
      if (TPlayObject(m_Master) <> nil) and (not TPlayObject(m_Master).m_boNotOnlineAddExp) then begin
        THeroObject(Self).SendMsg(m_Master, RM_HEROLEVELUP, 0, m_Abil.Exp, 0, 0, '');
        SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP,0, 0, 0, ''); //人物升级动画  20080222
        THeroObject(Self).GetBagItemCount; //刷新英雄包裹容量
        THeroObject(Self).LevelUpFunc();//英雄升级触发 20080423
      end;
    end else begin
      SendMsg(Self, RM_LEVELUP, 0, m_Abil.Exp, 0, 0, '');
    end;
  end;
{$IFDEF FOR_ABIL_POINT}
  if prevlevel + 1 = Abil.Level then begin
    BonusPoint := BonusPoint + GetBonusPoint(Job, Abil.Level);
    SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
  end else begin
    if prevlevel <> Abil.Level then begin
      BonusPoint := GetLevelBonusSum(Job, Abil.Level);
      FillChar(BonusAbil, SizeOf(TNakedAbility), #0);
      FillChar(CurBonusAbil, SizeOf(TNakedAbility), #0);
      //if prevlevel <> 0 then begin
      RecalcLevelAbilitys; //刷新等级各种属性
      //end else begin
      //   RecalcLevelAbilitys_old;
      //   BonusPoint := 0;
      //end;
      SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    end;
  end;
{$ENDIF}
end;
//增加金币
function TPlayObject.IncGold(tGold: Integer): Boolean;
begin
  Result := False;
  if m_nGold + tGold <= g_Config.nHumanMaxGold then begin
    Inc(m_nGold, tGold);
    Result := True;
  end;
end;

procedure TPlayObject.IncGameGold(nGameGold: Integer);
begin
  Inc(m_nGameGold, nGameGold);
end;

procedure TPlayObject.IncGameDiaMond(nGameDiaMond: Integer); //20071226 金刚石
begin
  Inc(m_nGameDiaMond, nGameDiaMond);
end;
procedure TPlayObject.IncGameGird(nGameGird: Integer); //20071226 灵符
begin
  Inc(m_nGameGird, nGameGird);
end;
procedure TPlayObject.IncGamePoint(nGamePoint: Integer);
begin
  Inc(m_nGamePoint, nGamePoint);
end;

function TBaseObject.WalkTo(btDir: Byte; boFlag: Boolean): Boolean;
var
  nOX, nOY, nNX, nNY, n20, n24: Integer;
  bo29: Boolean;
  nCode: Byte;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::WalkTo Code:';
begin
  Result := False;
  nCode:= 0;
  if m_boHolySeize then Exit;
  try
    nOX := m_nCurrX;
    nOY := m_nCurrY;
    m_btDirection := btDir;
    nNX := 0;
    nNY := 0;
    nCode:= 1;
    case btDir of
      DR_UP: begin
          nNX := m_nCurrX; nNY := m_nCurrY - 1; end;
      DR_UPRIGHT: begin
          nNX := m_nCurrX + 1; nNY := m_nCurrY - 1; end;
      DR_RIGHT: begin
          nNX := m_nCurrX + 1; nNY := m_nCurrY; end;
      DR_DOWNRIGHT: begin
          nNX := m_nCurrX + 1; nNY := m_nCurrY + 1; end;
      DR_DOWN: begin
          nNX := m_nCurrX; nNY := m_nCurrY + 1; end;
      DR_DOWNLEFT: begin
          nNX := m_nCurrX - 1; nNY := m_nCurrY + 1; end;
      DR_LEFT: begin
          nNX := m_nCurrX - 1; nNY := m_nCurrY; end;
      DR_UPLEFT: begin
          nNX := m_nCurrX - 1; nNY := m_nCurrY - 1; end;
    end;
    nCode:= 2;
    if (nNX >= 0) and ((m_PEnvir.m_nWidth - 1) >= nNX) and
      (nNY >= 0) and ((m_PEnvir.m_nHeight - 1) >= nNY) then begin
      bo29 := True;
      nCode:= 3;
      if bo2BA and not m_PEnvir.CanSafeWalk(nNX, nNY) then bo29 := False;
      nCode:= 4;
      if m_Master <> nil then begin
        if not m_Master.m_boGhost then begin//20081216
          nCode:= 5;
          m_Master.m_PEnvir.GetNextPosition(m_Master.m_nCurrX, m_Master.m_nCurrY, m_Master.m_btDirection, 1, n20, n24);
          nCode:= 6;
          if (nNX = n20) and (nNY = n24) then bo29 := False;
        end;
      end;
      if bo29 then begin
        nCode:= 7;
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nNX, nNY, boFlag) > 0 then begin
          m_nCurrX := nNX;
          m_nCurrY := nNY;
        end;
      end;
    end;
    if (m_nCurrX <> nOX) or (m_nCurrY <> nOY) then begin
      nCode:= 8;
      if Walk(RM_WALK) then begin
        if m_boTransparent and m_boHideMode then m_wStatusTimeArr[STATE_TRANSPARENT {8}] := 1;
        Result := True;
      end else begin
        nCode:= 9;
        m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
        m_nCurrX := nOX;
        m_nCurrY := nOY;
        nCode:= 10;
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
      end;
    end;
  except
    MainOutMessage(sExceptionMsg+ IntToStr(nCode));
  end;
end;
//包裹是否满了
function TPlayObject.IsEnoughBag: Boolean;
begin
  Result := False;
  if m_ItemList.Count < MAXBAGITEM then Result := True;
end;
//是否超过负重
function TBaseObject.IsAddWeightAvailable(nWeight: Integer): Boolean;
begin
  Result := False;
  if (m_WAbil.Weight + nWeight) <= m_WAbil.MaxWeight then
    Result := True;
end;

procedure TPlayObject.SendAddItem(UserItem: pTUserItem);
var
  pStdItem: pTStdItem;
  StdItem: TStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  if m_nSoftVersionDateEx = 0 then begin
    pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if pStdItem = nil then Exit;
    StdItem := pStdItem^;
    ItemUnit.GetItemAddValue(UserItem, StdItem);
    //Move(StdItem,ClientItem.S,SizeOf(TStdItem));
    CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
    //取自定义物品名称
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName <> '' then
      OClientItem.s.Name := sUserItemName;

    OClientItem.MakeIndex := UserItem.MakeIndex;
    OClientItem.Dura := UserItem.Dura;
    OClientItem.DuraMax := UserItem.DuraMax;
    {if StdItem.StdMode = 50 then begin//20080808 注释
      OClientItem.s.Name := OClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
    end;}
    
    if StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26] then begin
      if UserItem.btValue[8] = 0 then OClientItem.s.Shape := 0
      else OClientItem.s.Shape := 130;
    end;

    m_DefMsg := MakeDefaultMsg(SM_ADDITEM, Integer(Self), 0, 0, 1, 0);
    SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
  end else begin
    pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if pStdItem = nil then Exit;
    StdItem := pStdItem^;
    ItemUnit.GetItemAddValue(UserItem, StdItem);
    Move(StdItem, ClientItem.s, SizeOf(TStdItem));
    //取自定义物品名称
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if UserItem.btValue[12] = 1 then ClientItem.s.Reserved1:=1 //物品发光 20080223
     else ClientItem.s.Reserved1:= 0;

    {if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080622
      if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//酒的品质
      if UserItem.btValue[1] <> 0 then ClientItem.s.MAC:=UserItem.btValue[1];//酒的酒精度
    end; 

    if StdItem.StdMode = 8 then begin//酿酒材料 20080702
      if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//材料的品质
    end; }

    if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;

    ClientItem.MakeIndex := UserItem.MakeIndex;
    ClientItem.Dura := UserItem.Dura;
    ClientItem.DuraMax := UserItem.DuraMax;
    {if StdItem.StdMode = 50 then begin //20080808 注释
      ClientItem.s.Name := ClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
    end;}

    case StdItem.StdMode of//20081009 修改
      8: if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//材料的品质
      15, 19..24, 26:if UserItem.btValue[8] <> 0 then ClientItem.s.Shape := 130;//20080315 修改
      51: if (StdItem.Shape = 0) then ClientItem.s.Need:= StdItem.AniCount * 24;//如果是聚灵珠,则换成小时数 20080323
      60: begin
          if (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080622
            if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//酒的品质
            if UserItem.btValue[1] <> 0 then ClientItem.s.MAC:=UserItem.btValue[1];//酒的酒精度
          end;
        end;
    end;
    {if StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26] then begin
     // if UserItem.btValue[8] = 0 then ClientItem.s.Shape := 0
     // else ClientItem.s.Shape := 130;
      if UserItem.btValue[8] <> 0 then ClientItem.s.Shape := 130;//20080315 修改
    end; 
    if (StdItem.StdMode = 51) and (StdItem.Shape = 0) then ClientItem.s.Need:= StdItem.AniCount * 24;//如果是聚灵珠,则换成小时数 20080323
     }
    m_DefMsg := MakeDefaultMsg(SM_ADDITEM, Integer(Self), 0, 0, 1, 0);
    SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
  end;
end;
//是否是组队的成员
function TPlayObject.IsGroupMember(Target: TBaseObject): Boolean;
var
  I: Integer;
  nCode: Byte;
begin
  Result := False;
  nCode:= 0;
try
  if (m_GroupOwner = nil) or (Target = nil) or (Self = nil) then Exit;//20080812 增加
  nCode:= 1;
  for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
    nCode:= 2;
    if m_GroupOwner.m_GroupMembers.Objects[I] = Target then begin
      nCode:= 3;
      Result := True;
      Break;
    end;
  end;
  except
    MainOutMessage('{异常} TPlayObject.IsGroupMember Code:'+inttostr(nCode));
  end;
end;
//私聊  whostr-对谁说的
procedure TPlayObject.Whisper(whostr, saystr: string);
var
  PlayObject: TPlayObject;
  svidx: Integer;
begin
  PlayObject := UserEngine.GetPlayObject(whostr);
  if PlayObject <> nil then begin
    if not PlayObject.m_boReadyRun then begin
      SysMsg(whostr + g_sCanotSendmsg {'无法发送信息.'}, c_Red, t_Hint);
      Exit;
    end;
    if not PlayObject.m_boHearWhisper or PlayObject.IsBlockWhisper(m_sCharName) then begin
      SysMsg(whostr + g_sUserDenyWhisperMsg {' 拒绝私聊！！！'}, c_Red, t_Hint);
      Exit;
    end;
    if g_Config.boRecordClientMsg then begin//记录私聊聊天信息 20081220
      MainOutMessage('[私聊] '+ m_sCharName + '=>' + PlayObject.m_sCharName+':'+ saystr);
    end;
    if (PlayObject.m_boNotOnlineAddExp) and (PlayObject.m_sAutoSendMsg <> '') then begin //离线挂机人物自动回复
      if m_btPermission >= 10 then begin
        SendMsg(Self, RM_WHISPER, 0, g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, PlayObject.m_sCharName + '=>' + ' ' + PlayObject.m_sAutoSendMsg);
      end else begin
        SendMsg(Self, RM_WHISPER, 0, m_btWhisperMsgFColor{g_Config.btWhisperMsgFColor}, g_Config.btWhisperMsgBColor, 0, PlayObject.m_sCharName + '=>' + ' ' + PlayObject.m_sAutoSendMsg);
      end;
      Exit;
    end;
    if m_btPermission > 0 then begin
      PlayObject.SendMsg(PlayObject, RM_WHISPER, 0, g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, m_sCharName + '=> ' + saystr);
      //取得私聊信息
      //m_GetWhisperHuman 侦听私聊对象
      if (m_GetWhisperHuman <> nil) and (not m_GetWhisperHuman.m_boGhost) then
        m_GetWhisperHuman.SendMsg(m_GetWhisperHuman, RM_WHISPER, 0, g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, m_sCharName + '=>' + PlayObject.m_sCharName + ' ' + saystr);
      if (PlayObject.m_GetWhisperHuman <> nil) and (not PlayObject.m_GetWhisperHuman.m_boGhost) then
        PlayObject.m_GetWhisperHuman.SendMsg(PlayObject.m_GetWhisperHuman, RM_WHISPER, 0, g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, m_sCharName + '=>' + PlayObject.m_sCharName + ' ' + saystr);
    end else begin
      PlayObject.SendMsg(PlayObject, RM_WHISPER, 0, {g_Config.btWhisperMsgFColor} m_btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, m_sCharName + '=> ' + saystr);
      if (m_GetWhisperHuman <> nil) and (not m_GetWhisperHuman.m_boGhost) then
        m_GetWhisperHuman.SendMsg(m_GetWhisperHuman, RM_WHISPER, 0, {g_Config.btWhisperMsgFColor} m_btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, m_sCharName + '=>' + PlayObject.m_sCharName + ' ' + saystr);

      if (PlayObject.m_GetWhisperHuman <> nil) and (not PlayObject.m_GetWhisperHuman.m_boGhost) then
        PlayObject.m_GetWhisperHuman.SendMsg(PlayObject.m_GetWhisperHuman, RM_WHISPER, 0, {g_Config.btWhisperMsgFColor} m_btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, m_sCharName + '=>' + PlayObject.m_sCharName + ' ' + saystr);
    end;
  end else begin
    if UserEngine.FindOtherServerUser(whostr, svidx) then begin
      UserEngine.SendServerGroupMsg(SS_WHISPER, svidx, whostr + '/' + m_sCharName + '=> ' + saystr);
    end else begin
      SysMsg(whostr + g_sUserNotOnLine {'  没有在线！！！'}, c_Red, t_Hint);
    end;
  end;
end;

function TPlayObject.IsBlockWhisper(sName: string): Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to m_BlockWhisperList.Count - 1 do begin
    if CompareText(sName, m_BlockWhisperList.Strings[I]) = 0 then begin
      Result := True;
      Break;
    end;
  end;
end;

function TBaseObject.PKLevel(): Integer;
begin
  Result := m_nPkPoint div 100;
end;

procedure TBaseObject.HealthSpellChanged;
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    if not TPlayObject(Self).m_boNotOnlineAddExp then //只发送给非离线挂机人物
      SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
  end else
  if (m_btRaceServer = RC_HEROOBJECT) and (m_Master <> nil) then begin //英雄
    if not TPlayObject(m_Master).m_boNotOnlineAddExp then //只发送给非离线挂机人物
      m_Master.SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, ''); //20081219 替换，估计是这句导致人物等级乱变
  end else begin
    SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
  end;
  if m_boShowHP then begin
    SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
  end;
end;

procedure TBaseObject.PlugHealthSpellChanged;//插件气血改变血量 20080423
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    if not TPlayObject(Self).m_boNotOnlineAddExp then //只发送给非离线挂机人物
      //SendMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
      SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
  end else
  if (m_btRaceServer = RC_HEROOBJECT) and (m_Master <> nil) then begin //英雄
    if not TPlayObject(m_Master).m_boNotOnlineAddExp then //只发送给非离线挂机人物
      //m_Master.SendMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
      m_Master.SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
  end else begin
    //SendMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
    SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');//200080525
  end;
    SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
end;

function TBaseObject.CalcGetExp(nLevel: Integer; nExp: Integer): Integer;
begin
  if g_Config.boHighLevelKillMonFixExp or (m_Abil.Level < (nLevel + 10)) then begin
    Result := nExp;
  end else begin
    Result := nExp - Round((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
  end;
  if Result <= 0 then Result := 1;
end;
//刷新名字颜色
procedure TBaseObject.RefNameColor();
begin
  SendRefMsg(RM_CHANGENAMECOLOR, 0, 0, 0, 0, '');
end;
//宝宝升级
procedure TBaseObject.GainSlaveExp(nLevel: Integer);
  function GetUpKillCount(): Integer;//取升级的杀怪数量
  var
    tCount: Integer;
  begin
    if m_btSlaveExpLevel < SLAVEMAXLEVEL - 2 then begin
      tCount := g_Config.MonUpLvNeedKillCount[m_btSlaveExpLevel];
    end else begin
      tCount := 0;
    end;
    Result := ((m_Abil.Level * g_Config.nMonUpLvRate {16}) - m_Abil.Level) + g_Config.nMonUpLvNeedKillBase {100} + tCount
  end;
begin
  Inc(n294, nLevel);
  if GetUpKillCount() < n294 then begin
    Dec(n294, GetUpKillCount);
    if m_btSlaveExpLevel < (m_btSlaveMakeLevel * 2 + 1) then begin
      Inc(m_btSlaveExpLevel);
      RecalcAbilitys();
      if m_btRaceServer = RC_HEROOBJECT then CompareSuitItem(False);//套装 20081231
      RefNameColor();
    end;
  end;
end;

function TBaseObject.DropGoldDown(nGold: Integer; boFalg: Boolean; GoldOfCreat, DropGoldCreat: TBaseObject): Boolean; //004C5794
var
  MapItem, MapItemA: PTMapItem;
  nX, nY: Integer;
  s20: string;
begin
  Result := False;
  New(MapItem);
  FillChar(MapItem^, SizeOf(TMapItem), #0);
  MapItem.Name := sSTRING_GOLDNAME;
  MapItem.Count := nGold;
  MapItem.Looks := GetGoldShape(nGold);
  MapItem.OfBaseObject := GoldOfCreat;
  MapItem.dwCanPickUpTick := GetTickCount();
  MapItem.DropBaseObject := DropGoldCreat;
  GetDropPosition(m_nCurrX, m_nCurrY, 3, nX, nY);
  MapItemA := m_PEnvir.AddToMap(nX, nY, OS_ITEMOBJECT, TObject(MapItem));
  if MapItemA <> nil then begin
    if MapItemA <> MapItem then begin
      Dispose(MapItem);
      MapItem := MapItemA;
    end;
    SendRefMsg(RM_ITEMSHOW, MapItem.Looks, Integer(MapItem), nX, nY, MapItem.Name);
    if m_btRaceServer = RC_PLAYOBJECT then begin
      if boFalg then s20 := '15'
      else s20 := '7';
      if g_boGameLogGold then
        AddGameDataLog(s20 + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          sSTRING_GOLDNAME + #9 +
          IntToStr(nGold) + #9 +
          BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
          '0');
    end;
    Result := True;
  end else Dispose(MapItem);
end;
//取行会关系,盟友或敌对
function TBaseObject.GetGuildRelation(cert1, cert2: TBaseObject): Integer;
begin
  Result := 0;
  m_boGuildWarArea := False;
  if (cert1.m_MyGuild = nil) or (cert2.m_MyGuild = nil) then Exit;
  if cert1.InSafeArea or (cert2.InSafeArea) then Exit;//由于此处,行会战杀英雄,主体提示谋杀 20081006
  if TGUild(cert1.m_MyGuild).GuildWarList.Count <= 0 then Exit;
  m_boGuildWarArea := True;
  if TGUild(cert1.m_MyGuild).IsWarGuild(TGUild(cert2.m_MyGuild)) and
    TGUild(cert2.m_MyGuild).IsWarGuild(TGUild(cert1.m_MyGuild)) then Result := 2;
  if cert1.m_MyGuild = cert2.m_MyGuild then Result := 1;
  if TGUild(cert1.m_MyGuild).IsAllyGuild(TGUild(cert2.m_MyGuild)) and
    TGUild(cert2.m_MyGuild).IsAllyGuild(TGUild(cert1.m_MyGuild)) then Result := 3;
end;
//增加角色PK值 20080721
procedure TBaseObject.IncPkPoint(nPoint: Integer);
var
  nOldPKLevel: Integer;
begin
  if m_btRaceServer = RC_HEROOBJECT then begin//英雄
    if m_Master <> nil then begin
      nOldPKLevel := m_Master.PKLevel;
      Inc(m_Master.m_nPkPoint, nPoint);
      if m_Master.PKLevel <> nOldPKLevel then begin
        if m_Master.PKLevel <= 2 then m_Master.RefNameColor;
      end;
    end;
    THeroObject(self).m_nLoyal:=_MAX(0,THeroObject(self).m_nLoyal - g_Config.nPKDecLoyal);//PK值增加减少忠诚度 20080214
  end else begin
    nOldPKLevel := PKLevel;
    Inc(m_nPkPoint, nPoint);
    if PKLevel <> nOldPKLevel then begin
      if PKLevel <= 2 then RefNameColor;
    end;
  end;
end;

procedure TBaseObject.AddBodyLuck(dLuck: Double);
var
  n: Integer;
begin
  if (dLuck > 0) and (m_dBodyLuck < 5 * BODYLUCKUNIT) then begin
    m_dBodyLuck := m_dBodyLuck + dLuck;
  end;
  if (dLuck < 0) and (m_dBodyLuck > -(5 * BODYLUCKUNIT)) then begin
    m_dBodyLuck := m_dBodyLuck + dLuck;
  end;
  n := Trunc(m_dBodyLuck / BODYLUCKUNIT);
  if n > 5 then n := 5;
  if n < -10 then n := -10;
  m_nBodyLuckLevel := n;
end;
//武器被诅咒
procedure TBaseObject.MakeWeaponUnlock;
begin
  if m_UseItems[U_WEAPON].wIndex <= 0 then Exit;
  if m_UseItems[U_WEAPON].btValue[3] > 0 then begin
    Dec(m_UseItems[U_WEAPON].btValue[3]);
    SysMsg(g_sTheWeaponIsCursed, c_Red, t_Hint);
  end else begin
    if m_UseItems[U_WEAPON].btValue[4] < 10 then begin
      Inc(m_UseItems[U_WEAPON].btValue[4]);
      SysMsg(g_sTheWeaponIsCursed, c_Red, t_Hint);
    end;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then begin
    RecalcAbilitys();
    CompareSuitItem(False);//200080729 套装
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
  end;
end;
//取攻击点数
function TBaseObject.GetAttackPower(nBasePower, nPower: Integer): Integer;
var
  PlayObject: TPlayObject;
  HeroObject: THeroObject;
begin
  if nPower < 0 then nPower := 0;
  if m_nLuck > 0 then begin
    if Random(10 - _MIN(9, m_nLuck)) = 0 then Result := nBasePower + nPower
    else Result := nBasePower + Random(nPower + 1);
  end else begin
    Result := nBasePower + Random(nPower + 1);
    if m_nLuck < 0 then begin
      if Random(10 - _MAX(0, -m_nLuck)) = 0 then Result := nBasePower;
    end;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then begin
    PlayObject := TPlayObject(Self);
    //Result:=Result * PlayObject.m_nPowerMult + ROUND(Result * (PlayObject.m_nPowerMultPoint / 100));
    if (PlayObject.m_dwPowerRateTime <=0) and (PlayObject.m_nPowerRate > 100) then PlayObject.m_nPowerRate:=100;//20081128 检查人物攻击力倍数是否正确
    Result := Round(Result * (PlayObject.m_nPowerRate / 100));
    if PlayObject.m_boPowerItem then Result := Round(m_rPowerItem * Result);//力量物品
  end;
  if m_btRaceServer = RC_HEROOBJECT then begin
    HeroObject := THeroObject(Self);
    //Result:=Result * PlayObject.m_nPowerMult + ROUND(Result * (PlayObject.m_nPowerMultPoint / 100));
    //Result := Round(Result * (HeroObject.m_nPowerRate / 100));
    if HeroObject.m_boPowerItem then Result := Round(m_rPowerItem * Result);
  end;

  if m_boAutoChangeColor then begin
    Result := Result * m_nAutoChangeIdx + 1;
  end;
  if m_boFixColor then begin
    Result := Result * m_nFixColorIdx + 1;
  end;
end;

procedure TBaseObject.DamageHealth(nDamage: Integer); //减血
var
  nSpdam: Integer;
begin
  if ((m_LastHiter = nil) or not m_LastHiter.m_boUnMagicShield) and m_boMagicShield and (nDamage > 0) and (m_WAbil.MP > 0) then begin
    nSpdam := Round(nDamage * 1.5);
    if Integer(m_WAbil.MP) >= nSpdam then begin
      m_WAbil.MP := m_WAbil.MP - nSpdam;
      nSpdam := 0;
    end else begin
      nSpdam := nSpdam - m_WAbil.MP;
      m_WAbil.MP := 0;
    end;
    nDamage := Round(nSpdam / 1.5);
    HealthSpellChanged();
  end;
  if nDamage > 0 then begin
    if (m_WAbil.HP - nDamage) > 0 then begin
      m_WAbil.HP := m_WAbil.HP - nDamage;
    end else begin
      m_WAbil.HP := 0;
    end;
  end else begin
    if (m_WAbil.HP - nDamage) < m_WAbil.MaxHP then begin
      m_WAbil.HP := m_WAbil.HP - nDamage;
    end else begin
      m_WAbil.HP := m_WAbil.MaxHP;
    end;
  end;
end;

function TBaseObject.GetBackDir(nDir: Integer): Integer;
begin
  Result := 0;
  case nDir of
    DR_UP: Result := DR_DOWN;
    DR_DOWN: Result := DR_UP;
    DR_LEFT: Result := DR_RIGHT;
    DR_RIGHT: Result := DR_LEFT;
    DR_UPLEFT: Result := DR_DOWNRIGHT;
    DR_UPRIGHT: Result := DR_DOWNLEFT;
    DR_DOWNLEFT: Result := DR_UPRIGHT;
    DR_DOWNRIGHT: Result := DR_UPLEFT;
  end;
end;

function TBaseObject.CharPushed(nDir, nPushCount: Integer): Integer; //冲撞人
var
  I, nX, nY, olddir, nBackDir: Integer;
begin
  Result := 0;
  olddir := m_btDirection;
  m_btDirection := nDir;
  nBackDir := GetBackDir(nDir);
  if nPushCount > 0 then begin//20080629
    for I := 0 to nPushCount - 1 do begin
      GetFrontPosition(nX, nY);
      if m_PEnvir.CanWalk(nX, nY, False) then begin
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          //SendRefMsg(RM_PUSH, GetBackDir(ndir), m_nCurrX, m_nCurrY, 0, '');
          SendRefMsg(RM_PUSH, nBackDir, m_nCurrX, m_nCurrY, 0, '');
          Inc(Result);
          if m_btRaceServer >= RC_ANIMAL then
            m_dwWalkTick := m_dwWalkTick + 800;
        end else Break;
      end else Break;
    end;//for
  end;
  //m_btDirection:=GetBackDir(ndir);
  //m_btDirection:=GetBackDir(nBackDir);
  m_btDirection := nBackDir;
  if Result = 0 then m_btDirection := olddir;
end;

function TBaseObject.MoneyToCharacter(Money:Integer):string; //数字转换为中文大写
var
  temp,resu:string;
  i,j,len:integer;
  Num:array[0..9] of string;
  A:array[0..4] of string;
begin

  Try
    Num[0]:='零';
    num[1]:='一';
    Num[2]:='二';
    num[3]:='三';
    Num[4]:='四';
    num[5]:='五';
    Num[6]:='六';
    num[7]:='七';
    Num[8]:='八';
    num[9]:='九';
    a[1]:='十';
    a[2]:='百';
    a[3]:='千';
    a[4]:='万';
  {  a[5]:='十';
    a[6]:='百';
    a[7]:='千';
    a[8]:='亿';
    a[9]:='十';
    a[10]:='百';
    a[11]:='千'; }

    if money = 1 then begin
      result:='大';
      Exit;
    end;
    temp:=trim(inttostr(money));
    len:=length(temp);
    resu:='';
    if (len > 4) or (len=0) then exit;
    for i:=1 to len do begin
      j:=strtoint(copy(temp,i,1));
      if (J=0) and (i=Len) then Continue;
      if (J=0) then resu:=resu+num[j]
      else resu:=resu+num[j]+a[len-i];
    end;
    result:=resu;
  except
    MainOutMessage('{异常} TBaseObject.MoneyToCharacter');
  end;
end;

function TBaseObject.MagPassThroughMagic(sX, sY, tx, ty, nDir, magpwr,nSccPwr: Integer; undeadattack: Boolean; nCode:Byte): Integer;
var
  I, tCount, acpwr, nPwr: Integer;
  BaseObject: TBaseObject;
begin
  tCount := 0;
  for I := 0 to 12 do begin
    BaseObject := TBaseObject(m_PEnvir.GetMovingObject(sX, sY, True));
    if BaseObject <> nil then begin
      if IsProperTarget(BaseObject) then begin
        if Random(10) >= BaseObject.m_nAntiMagic then begin
          if undeadattack then acpwr := Round(magpwr * 1.5)
          else acpwr := magpwr;
          case nCode of
            SKILL_FIRE: begin//地狱火
                if ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and (magpwr > nSccPwr) then begin
                  nPwr:= 0;
                  if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                    nPwr:= MagicManager.GetNGPow(BaseObject, TPlayObject(BaseObject).m_MagicSkill_215,nSccPwr);//静之地狱火
                  end else
                  if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin
                    nPwr:= MagicManager.GetNGPow(BaseObject, THEROOBJECT(BaseObject).m_MagicSkill_215,nSccPwr);//静之地狱火
                  end;
                  acpwr := _MAX(0, acpwr - nPwr);
                end;
              end;
            SKILL_SHOOTLIGHTEN: begin//疾光电影
                if ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and (magpwr > nSccPwr) then begin
                  nPwr:= 0;
                  if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                    nPwr:= MagicManager.GetNGPow(BaseObject, TPlayObject(BaseObject).m_MagicSkill_217,nSccPwr);//静之疾光电影
                  end else
                  if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin
                    nPwr:= MagicManager.GetNGPow(BaseObject, THEROOBJECT(BaseObject).m_MagicSkill_217,nSccPwr);//静之疾光电影
                  end;
                  acpwr := _MAX(0, acpwr - nPwr);
                end;
              end;
          end;
          BaseObject.SendDelayMsg(Self, RM_MAGSTRUCK, 0, acpwr, 0, 0, '', 600);
          Inc(tCount);
        end;
      end;
    end;
    if not ((abs(sX - tx) <= 0) and (abs(sY - ty) <= 0)) then begin
      nDir := GetNextDirection(sX, sY, tx, ty);
      if not m_PEnvir.GetNextPosition(sX, sY, nDir, 1, sX, sY) then Break;
    end else Break;
  end;
  Result := tCount;
end;

procedure TPlayObject.SendSocket(DefMsg: pTDefaultMessage; sMsg: string);
var
  MsgHdr: TMsgHeader;
  nSendBytes: Integer;
  tBuff: PChar;
resourcestring
  sExceptionMsg = '{异常} TPlayObject::SendSocket..';
begin
 { if Assigned(zPlugOfEngine.SendSocket) then begin //20080813 注释
    zPlugOfEngine.SendSocket(Self, DefMsg, PChar(sMsg));
  end else begin }
    tBuff := nil;
    try
      MsgHdr.dwCode := RUNGATECODE;
      MsgHdr.nSocket := m_nSocket;
      MsgHdr.wGSocketIdx := m_nGSocketIdx;
      MsgHdr.wIdent := GM_DATA;
      if DefMsg <> nil then begin
        if sMsg <> '' then begin
          MsgHdr.nLength := Length(sMsg) + SizeOf(TDefaultMessage) + 1;
          nSendBytes := MsgHdr.nLength + SizeOf(TMsgHeader);
          GetMem(tBuff, nSendBytes + SizeOf(Integer));
          Move(nSendBytes, tBuff^, SizeOf(Integer));
          Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
          Move(DefMsg^, tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], SizeOf(TDefaultMessage));
          Move(sMsg[1], tBuff[SizeOf(TDefaultMessage) + SizeOf(TMsgHeader) + SizeOf(Integer)], Length(sMsg) + 1);
        end else begin
          MsgHdr.nLength := SizeOf(TDefaultMessage);
          nSendBytes := MsgHdr.nLength + SizeOf(TMsgHeader);
          GetMem(tBuff, nSendBytes + SizeOf(Integer));
          Move(nSendBytes, tBuff^, SizeOf(Integer));
          Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
          Move(DefMsg^, tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], SizeOf(TDefaultMessage));
        end;
      end else begin
        if sMsg <> '' then begin
          MsgHdr.nLength := -(Length(sMsg) + 1);
          nSendBytes := abs(MsgHdr.nLength) + SizeOf(TMsgHeader);
          GetMem(tBuff, nSendBytes + SizeOf(Integer));
          Move(nSendBytes, tBuff^, SizeOf(Integer));
          Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
          Move(sMsg[1], tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], Length(sMsg) + 1);
        end;
      end;
      if not RunSocket.AddGateBuffer(m_nGateIdx, tBuff) then begin
        FreeMem(tBuff);
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  //end;//20080813 注释
end;

procedure TPlayObject.SendDefMessage(wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: string);
begin
  m_DefMsg := MakeDefaultMsg(wIdent, nRecog, nParam, nTag, nSeries, 0);
  if sMsg <> '' then SendSocket(@m_DefMsg, EncodeString(sMsg))
  else SendSocket(@m_DefMsg, '');
end;

procedure TPlayObject.ClientQueryUserName(Target: TBaseObject; x, y: Integer);
var
  uname: string;
  TagColor: Integer;
  Def: TDefaultMessage;
begin
  if CretInNearXY(Target, x, y) then begin
    TagColor := GetCharColor(Target);
    Def := MakeDefaultMsg(SM_USERNAME, Integer(Target), TagColor, 0, 0, 0);
    uname := Target.GetShowName;
    SendSocket(@Def, EncodeString(uname));
  end else
    SendDefMessage(SM_GHOST, Integer(Target), x, y, 0, '');
end;
//是否使用斗笠 20080424
function TBaseObject.IsUsesZhuLi: Boolean;
var
  StdItem: pTStdItem;
begin
  Result:= False;
  if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then begin
    if m_UseItems[U_ZHULI].wIndex > 0 then begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_ZHULI].wIndex);
      if (StdItem <> nil) and (StdItem.StdMode = 16) then Result:= True;
    end;
  end;
end;

//显示名字 20080330 (包括所以NPC,怪,人物)
function TBaseObject.GetShowName: string;
var
  sShowName,sTemp: string;
  n10: Integer;
  nCode: Byte;
begin
  nCode:= 0;
  Try
    sShowName := m_sCharName;
    nCode:= 1;
    n10 := GetValNameNo(sShowName); //20080406 支持NPC变量显示 A T S 变量
    nCode:= 11;
    if (n10 >= 0) and (m_btRaceServer = RC_NPC) then begin//只检查NPC 20081223
      case n10 of
        600..699: begin
            nCode:= 12;
            sTemp := TPlayObject(self).m_sString[n10 - 600];
            if (sTemp <> '') and (sTemp[1] = '<') and (sTemp[2] = '$') then sTemp:= copy(sTemp,pos('\',sTemp),length(sTemp));//20080421
            if sTemp = '' then sTemp:= TMerchant(self).m_sScript;//20080421
          end;
        700..799: begin
            nCode:= 13;
            sTemp := g_Config.GlobalAVal[n10 - 700];
            if (sTemp <> '') and (sTemp[1] = '<') and (sTemp[2] = '$') then sTemp:= copy(sTemp,pos('\',sTemp),length(sTemp));//20080421
            if sTemp = '' then begin
               if pos('_',TMerchant(self).m_sScript) > 0 then begin//20080509 处理名字为 "比奇/比奇村_第一男战士",客户端只显示"比奇"
                  sTemp:=copy(TMerchant(self).m_sScript,pos('_',TMerchant(self).m_sScript)+ 1,length(TMerchant(self).m_sScript));
               end else sTemp:= TMerchant(self).m_sScript;//20080421
            end;
          end;
        1200..1599:begin//20080903 A变量(100-499)
            nCode:= 14;
            sTemp := g_Config.GlobalAVal[n10 - 1100];
            if (sTemp <> '') and (sTemp[1] = '<') and (sTemp[2] = '$') then sTemp:= copy(sTemp,pos('\',sTemp),length(sTemp));//20080421
            if sTemp = '' then begin
               if pos('_',TMerchant(self).m_sScript) > 0 then begin//处理名字为 "比奇/比奇村_第一男战士",客户端只显示"比奇"
                  sTemp:=copy(TMerchant(self).m_sScript,pos('_',TMerchant(self).m_sScript)+ 1,length(TMerchant(self).m_sScript));
               end else sTemp:= TMerchant(self).m_sScript;
            end;
          end;
      end;
    end;
    nCode:= 15;
    if sTemp <>'' then
      Result := sTemp
    else Result := FilterShowName(sShowName);//过滤有数字的名称

    nCode:= 2;
    if m_nCopyHumanLevel in [0, 1] then begin
      if (m_Master <> nil) then begin
        if not m_Master.m_boObMode then begin
          if g_Config.boUnKnowHum and (m_Master.IsUsesZhuLi) then begin//20080806 主人为神秘人时，宝宝也要显示神秘人
             Result := Result + '(神秘人)';
          end else Result := Result + '(' + m_Master.m_sCharName + ')';
        end;
      end;
    end else begin
      nCode:= 3;
      if (m_nCopyHumanLevel = 2) and (m_Master <> nil) then begin
        if not m_Master.m_boObMode then begin
          if g_Config.boAddMasterName then begin //使用主人名称做前缀
            if g_Config.boUnKnowHum and (m_Master.IsUsesZhuLi) then
               Result := '(神秘人)' + g_Config.sCopyHumName
            else Result := m_Master.m_sCharName + g_Config.sCopyHumName;
          end else begin
            nCode:= 4;
            Result := g_Config.sCopyHumName;
            //人物分身名称支持显示跟人物一样,可以显示行会名 20080421
            if (m_Master.m_btRaceServer = RC_PLAYOBJECT) and (m_btRaceServer = RC_PLAYMOSTER) then begin
              nCode:= 5;
              Result :=  TPlayObject(m_Master).GetShowName;
            end;
          end;
        end;
      end;
    end;
    if g_Config.boUnKnowHum and IsUsesZhuLi then begin
      Result :='神秘人';//带上斗笠即显示神秘人 20080424
    end;
  except
    MainOutMessage('{异常} TBaseObject.GetShowName Code:'+inttostr(nCode));
  end;
{
  if m_btRaceServer <> RC_PLAYOBJECT then begin
    sShowName:=m_sCharName;
    Result:=FilterShowName(sShowName);
    if (m_Master <> nil) and not m_Master.m_boObMode then begin
      Result:=Result + '(' + m_Master.m_sCharName + ')';
    end;
  end else begin//004C1340
    Result:=m_sCharName;
    if m_MyGuild <> nil then begin
      //if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) then begin  TUserCastle.m_sName
      if IsGuildMaster then begin
        Result:=Result + '\' + TGuild(m_MyGuild).sGuildName + '(' + TUserCastle(m_Castle).m_sName + ')';
      end else begin
       // if g_boShowGuildName or(TUserCastle(m_Castle).m_boUnderWar and (m_boInFreePKArea or TUserCastle(m_Castle).IsCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY))) then begin
        if (TUserCastle(m_Castle).m_boUnderWar and m_boInFreePKArea) then begin
          Result:=Result + '\' + TGuild(m_MyGuild).sGuildName + '[' + m_sGuildRankName + ']';
        end;
      end;
    end;
  end;   }
end;

procedure TAnimalObject.Attack(TargeTBaseObject: TBaseObject; nDir: Integer);
begin
  inherited AttackDir(TargeTBaseObject, 0, nDir);
end;

constructor TAnimalObject.Create;
begin
  inherited;
  //m_nNotProcessCount := 0; //未使用 20080329
  m_nTargetX := -1;
  dwTick3F4 := GetTickCount();
  m_btRaceServer := RC_ANIMAL;
  m_dwHitTick := GetTickCount - LongWord(Random(3000));
  m_dwWalkTick := GetTickCount - LongWord(Random(3000));
  m_dwSearchEnemyTick := GetTickCount();
  m_boRunAwayMode := False;
  m_dwRunAwayStart := GetTickCount();
  m_dwRunAwayTime := 0;
  m_nCopyHumanLevel := 0;
end;

procedure TAnimalObject.GotoTargetXY;
var
  I: Integer;
  nDir: Integer;
  n10: Integer;
  n14: Integer;
  n20: Integer;
  nOldX: Integer;
  nOldY: Integer;
begin
  if ((m_nCurrX <> m_nTargetX) or (m_nCurrY <> m_nTargetY)) then begin
    n10 := m_nTargetX;
    n14 := m_nTargetY;
    dwTick3F4 := GetTickCount();
    nDir := DR_DOWN;
    if n10 > m_nCurrX then begin
      nDir := DR_RIGHT;
      if n14 > m_nCurrY then nDir := DR_DOWNRIGHT;
      if n14 < m_nCurrY then nDir := DR_UPRIGHT;
    end else begin
      if n10 < m_nCurrX then begin
        nDir := DR_LEFT;
        if n14 > m_nCurrY then nDir := DR_DOWNLEFT;
        if n14 < m_nCurrY then nDir := DR_UPLEFT;
      end else begin
        if n14 > m_nCurrY then nDir := DR_DOWN
        else if n14 < m_nCurrY then nDir := DR_UP;
      end;
    end;
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    WalkTo(nDir, False);
    n20 := Random(3);
    for I := DR_UP to DR_UPLEFT do begin
      if (nOldX = m_nCurrX) and (nOldY = m_nCurrY) then begin
        if n20 <> 0 then Inc(nDir)
        else if nDir > 0 then Dec(nDir)
        else nDir := DR_UPLEFT;
        if (nDir > DR_UPLEFT) then nDir := DR_UP;
        WalkTo(nDir, False);
      end;
    end;
  end;
end;

function TAnimalObject.Operate(ProcessMsg: pTProcessMessage): Boolean;
begin
  //  Result:=False;
  if ProcessMsg.wIdent = RM_STRUCK then begin
    if (ProcessMsg.BaseObject = Self) and (TBaseObject(ProcessMsg.nParam3 {AttackBaseObject}) <> nil) then begin
      SetLastHiter(TBaseObject(ProcessMsg.nParam3 {AttackBaseObject}));
      Struck(TBaseObject(ProcessMsg.nParam3 {AttackBaseObject}));
      BreakHolySeizeMode();
      if (m_Master <> nil) and
        (TBaseObject(ProcessMsg.nParam3) <> m_Master) and
        ((TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT) or
        (TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_HEROOBJECT)) then begin//英雄灰名 20080721
        if m_Master.m_Master <> nil then begin//20080823 增加
          if m_Master.m_Master <> TBaseObject(ProcessMsg.nParam3) then m_Master.SetPKFlag(TBaseObject(ProcessMsg.nParam3));
        end else m_Master.SetPKFlag(TBaseObject(ProcessMsg.nParam3));
      end;
      if g_Config.boMonSayMsg then MonsterSayMsg(TBaseObject(ProcessMsg.nParam3), s_UnderFire);
    end;
    Result := True;
  end else begin
    Result := inherited Operate(ProcessMsg);
  end;
end;

procedure TAnimalObject.Run;
begin
  inherited;
end;
//被击中
procedure TAnimalObject.Struck(hiter: TBaseObject);
var
  btDir: Byte;
begin
  m_dwStruckTick := GetTickCount;
  if hiter <> nil then begin
    if (m_TargetCret = nil) or GetAttackDir(m_TargetCret, btDir) or (Random(6) = 0) then begin
      if IsProperTarget(hiter) then SetTargetCreat(hiter);
    end;
  end;
  if m_boAnimal then begin//是动物
    m_nMeatQuality := m_nMeatQuality - Random(300);
    if m_nMeatQuality < 0 then m_nMeatQuality := 0;
  end;
  //if m_Abil.Level < 50 then
  m_dwHitTick := m_dwHitTick + LongWord(150 - _MIN(130, m_Abil.Level * 4));
  //WalkTime := WalkTime + (300 - _MIN(200, (Abil.Level div 5) * 20));
end;
//刷新属性
procedure TBaseObject.RecalcAbilitys;
var
  Abil: TAbility;
  boOldHideMode: Boolean;
  nOldLight: Integer;
  I: Integer;
  StdItem: pTStdItem;
  boRecallSuite1: Boolean;
  boRecallSuite2: Boolean;
  boRecallSuite3: Boolean;
  boRecallSuite4: Boolean;
  boMoXieSuite1: Boolean;
  boMoXieSuite2: Boolean;
  boMoXieSuite3: Boolean;
  boHongMoSuite1: Boolean;
  boHongMoSuite2: Boolean;
  boHongMoSuite3: Boolean;
  boSpirit1: Boolean;
  boSpirit2: Boolean;
  boSpirit3: Boolean;
  boSpirit4: Boolean;
  n01, n02, n03, n04: Integer;
  nCode: Byte;
begin
nCode:= 0;
try
  FillChar(m_AddAbil, SizeOf(TAddAbility), #0);
  Abil := m_WAbil;
  m_WAbil := m_Abil;
  m_WAbil.HP := Abil.HP;
  m_WAbil.MP := Abil.MP;
  m_WAbil.Weight := 0;
  m_WAbil.WearWeight := 0;
  m_WAbil.HandWeight := 0;
  m_btAntiPoison := 0;
  m_nPoisonRecover := 0;
  m_nHealthRecover := 0;
  m_nSpellRecover := 0;
  m_nAntiMagic := 1;
  m_nLuck := 0;
  m_nHitSpeed := 0;
  m_boExpItem := False;
  m_rExpItem := 0;
  m_boPowerItem := False;
  m_rPowerItem := 0;
  boOldHideMode := m_boHideMode;
  m_boHideMode := False;
  m_boTeleport := False;//传送
  m_boParalysis := False;//麻痹
  m_boRevival := False;//复活
  m_boUnRevival := False;
  m_boFlameRing := False;
  m_boRecoveryRing := False;
  m_boAngryRing := False;
  m_boMagicShield := False;//护身
  m_boUnMagicShield := False;
  m_boMuscleRing := False;
  m_boFastTrain := False;
  m_boProbeNecklace := False;
  m_boSupermanItem := False;
  m_boGuildMove := False;
  m_boUnParalysis := False;//防麻痹
  m_boExpItem := False;
  m_boPowerItem := False;
  m_boNoDropItem := False;
  m_boNoDropUseItem := False;
  m_bopirit := False;
  m_btHorseType := 0;
  m_btDressEffType := 0;

  m_nMoXieSuite := 0;
  boMoXieSuite1 := False;
  boMoXieSuite2 := False;
  boMoXieSuite3 := False;
  m_db3B0 := 0;
  m_nHongMoSuite := 0;
  boHongMoSuite1 := False;
  boHongMoSuite2 := False;
  boHongMoSuite3 := False;

  boSpirit1 := False;
  boSpirit2 := False;
  boSpirit3 := False;
  boSpirit4 := False;

  m_boRecallSuite := False;
  boRecallSuite1 := False;
  boRecallSuite2 := False;
  boRecallSuite3 := False;
  boRecallSuite4 := False;

  m_dwPKDieLostExp := 0;
  m_nPKDieLostLevel := 0;
  nCode:= 1;
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    if (m_UseItems[I].wIndex <= 0) or (m_UseItems[I].Dura <= 0) then Continue;
    GetAccessory(m_UseItems[I], m_AddAbil);//取物品的附加属性 20080325
    StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
    if StdItem = nil then Continue;
    if (I = U_WEAPON) or (I = U_RIGHTHAND) or (I = U_DRESS) then begin
      if I = U_DRESS then begin
        Inc(m_WAbil.WearWeight, StdItem.Weight);
      end else begin
        Inc(m_WAbil.HandWeight, StdItem.Weight);
      end;
      //新增开始
      if StdItem.AniCount = 120 then m_boFastTrain := True;
      if StdItem.AniCount = 121 then m_boProbeNecklace := True;
      if StdItem.AniCount = 145 then m_boGuildMove := True;
      if StdItem.AniCount = 111 then begin
        m_wStatusTimeArr[STATE_TRANSPARENT] := 60000{6 * 10 * 1000};
        m_boHideMode := True;
      end;
      if StdItem.AniCount = 112 then m_boTeleport := True;
      if StdItem.AniCount = 113 then m_boParalysis := True;
      if StdItem.AniCount = 114 then m_boRevival := True;
      if StdItem.AniCount = 115 then m_boFlameRing := True;
      if StdItem.AniCount = 116 then m_boRecoveryRing := True;
      if StdItem.AniCount = 117 then m_boAngryRing := True;
      if StdItem.AniCount = 118 then m_boMagicShield := True;
      if StdItem.AniCount = 119 then m_boMuscleRing := True;
      if StdItem.AniCount = 135 then begin
        boMoXieSuite1 := True;
        Inc(m_nMoXieSuite, StdItem.Weight div 10);
      end;
      if StdItem.AniCount = 138 then begin
        Inc(m_nHongMoSuite, StdItem.Weight);
      end;
      nCode:= 2;
      if StdItem.AniCount = 139 then m_boUnParalysis := True;
      if StdItem.AniCount = 140 then m_boSupermanItem := True;
      if StdItem.AniCount = 141 then begin
        m_boExpItem := True;
        m_rExpItem := m_rExpItem + (m_UseItems[I].Dura / g_Config.nItemExpRate);
      end;
      if StdItem.AniCount = 142 then begin
        m_boPowerItem := True;
        m_rPowerItem := m_rPowerItem + (m_UseItems[I].Dura / g_Config.nItemPowerRate);
      end;
      if StdItem.AniCount = 182 then begin
        m_boExpItem := True;
        m_rExpItem := m_rExpItem + (m_UseItems[I].DuraMax / g_Config.nItemExpRate);
      end;
      if StdItem.AniCount = 183 then begin//人物攻击力倍数(倍数为持久除以 10000)，不受物品持久太小影响
        m_boPowerItem := True;
        m_rPowerItem := m_rPowerItem + (m_UseItems[I].DuraMax / g_Config.nItemPowerRate);
      end;
      nCode:= 3;
      if StdItem.AniCount = 143 then m_boUnMagicShield := True;
      if StdItem.AniCount = 144 then m_boUnRevival := True;
      if StdItem.AniCount = 170 then m_boAngryRing := True;
      if StdItem.AniCount = 171 then m_boNoDropItem := True;
      if StdItem.AniCount = 172 then m_boNoDropUseItem := True;
      if StdItem.AniCount = 150 then begin //麻痹护身
        m_boParalysis := True;
        m_boMagicShield := True;
      end;
      if StdItem.AniCount = 151 then begin //麻痹火球
        m_boParalysis := True;
        m_boFlameRing := True;
      end;
      if StdItem.AniCount = 152 then begin //麻痹防御
        m_boParalysis := True;
        m_boRecoveryRing := True;
      end;
      if StdItem.AniCount = 153 then begin //麻痹负载
        m_boParalysis := True;
        m_boMuscleRing := True;
      end;
      if StdItem.Shape = 154 then begin //护身火球
        m_boMagicShield := True;
        m_boFlameRing := True;
      end;
      if StdItem.AniCount = 155 then begin //护身防御
        m_boMagicShield := True;
        m_boRecoveryRing := True;
      end;
      if StdItem.AniCount = 156 then begin //护身负载
        m_boMagicShield := True;
        m_boMuscleRing := True;
      end;
      nCode:= 4;
      if StdItem.AniCount = 157 then begin //传送麻痹
        m_boTeleport := True;
        m_boParalysis := True;
      end;

      if StdItem.AniCount = 158 then begin //传送护身
        m_boTeleport := True;
        m_boMagicShield := True;
      end;

      if StdItem.AniCount = 159 then begin //传送探测
        m_boTeleport := True;
        m_boProbeNecklace := True;
      end;
      if StdItem.AniCount = 160 then begin //传送复活
        m_boTeleport := True;
        m_boRevival := True;
      end;
      if StdItem.AniCount = 161 then begin //麻痹复活
        m_boParalysis := True;
        m_boRevival := True;
      end;
      if StdItem.AniCount = 162 then begin //护身复活
        m_boMagicShield := True;
        m_boRevival := True;
      end;
      if StdItem.AniCount = 180 then begin //PK 死亡掉经验
        m_dwPKDieLostExp := StdItem.DuraMax * g_Config.dwPKDieLostExpRate;
        //m_nPKDieLostLevel:=1;
      end;
      if StdItem.AniCount = 181 then begin //PK 死亡掉等级
        m_nPKDieLostLevel := StdItem.DuraMax div g_Config.nPKDieLostLevelRate;
      end;
      //新增结束
    end else begin
      Inc(m_WAbil.WearWeight, StdItem.Weight);
    end;
    nCode:= 5;
    Inc(m_WAbil.Weight, StdItem.Weight);
    if (I = U_WEAPON) then begin//武器
      nCode:= 51;
      if (StdItem.Source - 1 - 10) < 0 then
        m_AddAbil.btWeaponStrong := StdItem.Source; //强度+
      nCode:= 52;
      if (StdItem.Source <= -1) and (StdItem.Source >= -50) then // -1 至 -50
        m_AddAbil.bt1DF := _MIN(High(Byte),m_AddAbil.bt1DF + -StdItem.Source); //神圣+  //20081204 由于 bt1DF为Byte，所以需判断
      nCode:= 53;
      if (StdItem.Source <= -51) and (StdItem.Source >= -100) then // -51 至 - 100
        m_AddAbil.bt1DF := _MIN(High(Byte),m_AddAbil.bt1DF + (StdItem.Source + 50)); //神圣- //20081204 由于 bt1DF为Byte，所以需判断
      Continue;
    end;
    nCode:= 54;
    if (I = U_RIGHTHAND) then begin
      nCode:= 55;
      if StdItem.Shape in [1..50] then m_btDressEffType := StdItem.Shape;
      nCode:= 56;
      if StdItem.Shape in [51..100] then m_btHorseType := StdItem.Shape - 50;
      Continue;
    end;
    nCode:= 6;
    if (I = U_DRESS) then begin
      if m_UseItems[I].btValue[5] > 0 then m_btDressEffType := m_UseItems[I].btValue[5];
      if StdItem.AniCount > 0 then m_btDressEffType := StdItem.AniCount;
      Continue;
    end;
    nCode:= 7;
    //新增开始
    if StdItem.Shape = 139 then m_boUnParalysis := True;
    if StdItem.Shape = 140 then m_boSupermanItem := True;
    if StdItem.Shape = 141 then begin
      m_boExpItem := True;
      m_rExpItem := m_rExpItem + (m_UseItems[I].Dura / g_Config.nItemExpRate);
    end;
    if StdItem.Shape = 142 then begin
      m_boPowerItem := True;
      m_rPowerItem := m_rPowerItem + (m_UseItems[I].Dura / g_Config.nItemPowerRate);
    end;
    if StdItem.Shape = 182 then begin
      m_boExpItem := True;
      m_rExpItem := m_rExpItem + (m_UseItems[I].DuraMax / g_Config.nItemExpRate);
    end;
    if StdItem.Shape = 183 then begin
      m_boPowerItem := True;
      m_rPowerItem := m_rPowerItem + (m_UseItems[I].DuraMax / g_Config.nItemPowerRate);
    end;
    if StdItem.Shape = 143 then m_boUnMagicShield := True;
    if StdItem.Shape = 144 then m_boUnRevival := True;
    if StdItem.Shape = 170 then m_boAngryRing := True;
    if StdItem.Shape = 171 then m_boNoDropItem := True;
    if StdItem.Shape = 172 then m_boNoDropUseItem := True;
    nCode:= 8;
    if StdItem.Shape = 150 then begin //麻痹护身
      m_boParalysis := True;
      m_boMagicShield := True;
    end;
    if StdItem.Shape = 151 then begin //麻痹火球
      m_boParalysis := True;
      m_boFlameRing := True;
    end;
    if StdItem.Shape = 152 then begin //麻痹防御
      m_boParalysis := True;
      m_boRecoveryRing := True;
    end;
    if StdItem.Shape = 153 then begin //麻痹负载
      m_boParalysis := True;
      m_boMuscleRing := True;
    end;
    if StdItem.Shape = 154 then begin //护身火球
      m_boMagicShield := True;
      m_boFlameRing := True;
    end;
    if StdItem.Shape = 155 then begin //护身防御
      m_boMagicShield := True;
      m_boRecoveryRing := True;
    end;
    if StdItem.Shape = 156 then begin //护身负载
      m_boMagicShield := True;
      m_boMuscleRing := True;
    end;

    if StdItem.Shape = 157 then begin //传送麻痹
      m_boTeleport := True;
      m_boParalysis := True;
    end;

    if StdItem.Shape = 158 then begin //传送护身
      m_boTeleport := True;
      m_boMagicShield := True;
    end;

    if StdItem.Shape = 159 then begin //传送探测
      m_boTeleport := True;
      m_boProbeNecklace := True;
    end;
    if StdItem.Shape = 160 then begin //传送复活
      m_boTeleport := True;
      m_boRevival := True;
    end;
    if StdItem.Shape = 161 then begin //麻痹复活
      m_boParalysis := True;
      m_boRevival := True;
    end;
    if StdItem.Shape = 162 then begin //护身复活
      m_boMagicShield := True;
      m_boRevival := True;
    end;

    if StdItem.Shape = 180 then begin //PK 死亡掉经验
      m_dwPKDieLostExp := StdItem.DuraMax * g_Config.dwPKDieLostExpRate;
      //m_nPKDieLostLevel:=1;
    end;
    if StdItem.Shape = 181 then begin //PK 死亡掉等级
      m_nPKDieLostLevel := StdItem.DuraMax div g_Config.nPKDieLostLevelRate;
    end;
    nCode:= 9;
    if I = U_BUJUK then begin
      if (StdItem.StdMode = 25) and (StdItem.Shape = 6) then begin //传送符
        m_boTeleport := True;
      end;
    end;
    //新增结束
  //if (i = U_NECKLACE) then begin
    if StdItem.Shape = 120 then m_boFastTrain := True;
    if StdItem.Shape = 121 then m_boProbeNecklace := True;
    if StdItem.Shape = 123 then boRecallSuite1 := True;
    if StdItem.Shape = 145 then m_boGuildMove := True;
    if StdItem.Shape = 127 then boSpirit1 := True;
    if StdItem.Shape = 135 then begin
      boMoXieSuite1 := True;
      Inc(m_nMoXieSuite, StdItem.AniCount);
    end;
    if StdItem.Shape = 138 then begin
      boHongMoSuite1 := True;
      Inc(m_nHongMoSuite, StdItem.AniCount);
    end;
    //end;
    //if (i = U_RINGR) or (i = U_RINGL) then begin
    if StdItem.Shape = 111 then begin
      m_wStatusTimeArr[STATE_TRANSPARENT] := 60000{6 * 10 * 1000};
      m_boHideMode := True;
    end;
    if StdItem.Shape = 112 then m_boTeleport := True;
    if StdItem.Shape = 113 then m_boParalysis := True;
    if StdItem.Shape = 114 then m_boRevival := True;
    if StdItem.Shape = 115 then m_boFlameRing := True;
    if StdItem.Shape = 116 then m_boRecoveryRing := True;
    if StdItem.Shape = 117 then m_boAngryRing := True;
    if StdItem.Shape = 118 then m_boMagicShield := True;
    if StdItem.Shape = 119 then m_boMuscleRing := True;
    if StdItem.Shape = 122 then boRecallSuite2 := True;
    if StdItem.Shape = 128 then boSpirit2 := True;
    if StdItem.Shape = 133 then begin
      boMoXieSuite2 := True;
      Inc(m_nMoXieSuite, StdItem.AniCount);
    end;
    if StdItem.Shape = 136 then begin
      boHongMoSuite2 := True;
      Inc(m_nHongMoSuite, StdItem.AniCount);
    end;
    //end;
    //if (i = U_ARMRINGL) or (i = U_ARMRINGR) then begin
    if StdItem.Shape = 124 then boRecallSuite3 := True;
    if StdItem.Shape = 126 then boSpirit3 := True;
    if StdItem.Shape = 145 then m_boGuildMove := True;
    if StdItem.Shape = 134 then begin
      boMoXieSuite3 := True;
      Inc(m_nMoXieSuite, StdItem.AniCount);
    end;
    if StdItem.Shape = 137 then begin
      boHongMoSuite3 := True;
      Inc(m_nHongMoSuite, StdItem.AniCount);
    end;
    //end;
    //if (i = U_HELMET) then begin
    if StdItem.Shape = 125 then boRecallSuite4 := True;
    if StdItem.Shape = 129 then boSpirit4 := True;
    //end;
  end;
  nCode:= 10;
  if boRecallSuite1 and boRecallSuite2 and boRecallSuite3 and boRecallSuite4 then m_boRecallSuite := True;
  if boMoXieSuite1 and boMoXieSuite2 and boMoXieSuite3 then Inc(m_nMoXieSuite, 50);
  if boHongMoSuite1 and boHongMoSuite2 and boHongMoSuite3 then Inc(m_AddAbil.wHitPoint, 2);

  if boSpirit1 and boSpirit2 and boSpirit3 and boSpirit4 then m_bopirit := True;
  nCode:= 11;
  m_WAbil.Weight := RecalcBagWeight();

  if m_boTransparent and (m_wStatusTimeArr[STATE_TRANSPARENT {8}] > 0) then m_boHideMode := True;
  nCode:= 12;
  if m_boHideMode then begin
    if not boOldHideMode then begin
      m_nCharStatus := GetCharStatus();
      StatusChanged('');
    end;
  end else begin
    if boOldHideMode then begin
      m_wStatusTimeArr[STATE_TRANSPARENT {8}] := 0;
      m_nCharStatus := GetCharStatus();
      StatusChanged('');
    end;
  end;
  if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then //01-20 增加此行，只有类型为人物的角色才重新计算攻击敏捷
    RecalcHitSpeed();
  nOldLight := m_nLight;
  if (m_UseItems[U_RIGHTHAND].wIndex > 0) and (m_UseItems[U_RIGHTHAND].Dura > 0) then
    m_nLight := 3
  else m_nLight := 0;
  if nOldLight <> m_nLight then SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');
  nCode:= 13;
  Inc(m_btSpeedPoint, m_AddAbil.wSpeedPoint);//敏捷
  Inc(m_btHitPoint, m_AddAbil.wHitPoint);//准确
  Inc(m_btAntiPoison, m_AddAbil.wAntiPoison);//中毒躲避
  Inc(m_nPoisonRecover, m_AddAbil.wPoisonRecover);//中毒恢复
  Inc(m_nHealthRecover, m_AddAbil.wHealthRecover);//体力恢复
  Inc(m_nSpellRecover, m_AddAbil.wSpellRecover);//魔法恢复
  Inc(m_nAntiMagic, m_AddAbil.wAntiMagic);//魔法躲避
  Inc(m_nLuck, m_AddAbil.btLuck);//人物的幸运值Luck (爆率机率)
  Dec(m_nLuck, m_AddAbil.btUnLuck);
  m_nHitSpeed := m_AddAbil.nHitSpeed;//速度
  nCode:= 14;
  m_WAbil.MaxHP := _MIN(High(Word), m_Abil.MaxHP + m_AddAbil.wHP);
  m_WAbil.MaxMP := _MIN(High(Word), m_Abil.MaxMP + m_AddAbil.wMP);

  m_WAbil.AC := MakeLong(LoWord(m_AddAbil.wAC) + LoWord(m_Abil.AC), HiWord(m_AddAbil.wAC) + HiWord(m_Abil.AC));
  m_WAbil.MAC := MakeLong(LoWord(m_AddAbil.wMAC) + LoWord(m_Abil.MAC), HiWord(m_AddAbil.wMAC) + HiWord(m_Abil.MAC));
  m_WAbil.DC := MakeLong(LoWord(m_AddAbil.wDC) + LoWord(m_Abil.DC), HiWord(m_AddAbil.wDC) + HiWord(m_Abil.DC));
  m_WAbil.MC := MakeLong(LoWord(m_AddAbil.wMC) + LoWord(m_Abil.MC), HiWord(m_AddAbil.wMC) + HiWord(m_Abil.MC));
  m_WAbil.SC := MakeLong(LoWord(m_AddAbil.wSC) + LoWord(m_Abil.SC), HiWord(m_AddAbil.wSC) + HiWord(m_Abil.SC));
  m_WAbil.MaxWearWeight := MakeLong(LoWord(m_AddAbil.wWearWeight) + LoWord(m_Abil.MaxWearWeight), HiWord(m_AddAbil.wWearWeight) + HiWord(m_Abil.MaxWearWeight));//20080325 加负重
  nCode:= 15;
  if m_wStatusTimeArr[STATE_DEFENCEUP {9}] > 0 then
    m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), HiWord(m_WAbil.AC) + 2 + (m_Abil.Level div 7));

  if m_wStatusTimeArr[STATE_MAGDEFENCEUP {10}] > 0 then
    m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC) + 2 + (m_Abil.Level div 7));

  {if m_wStatusTimeArr2[STATE_DEFENCEUP] > 0 then
    m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), HiWord(m_WAbil.AC) - 2 - (m_Abil.Level div 7));

  if m_wStatusTimeArr2[STATE_MAGDEFENCEUP] > 0 then
    m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC) - 2 - (m_Abil.Level div 7));}

  if m_wStatusArrValue[11] > 0 then//20080626 增加敏捷
    Inc(m_btSpeedPoint, m_wStatusArrValue[11]);//敏捷

  if m_wStatusArrValue[0] > 0 then
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + 2 + m_wStatusArrValue[0]);

  if m_wStatusArrValue[6] > 0 then begin
    if LoWord(m_WAbil.DC) > (HiWord(m_WAbil.DC) - m_wStatusArrValue[6]) then
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), LoWord(m_WAbil.DC))
    else
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) - m_wStatusArrValue[6])
  end;

  if m_wStatusArrValue[1] > 0 then
    m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + 2 + m_wStatusArrValue[1]);

  if m_wStatusArrValue[7] > 0 then begin
    if LoWord(m_WAbil.MC) > (HiWord(m_WAbil.MC) - m_wStatusArrValue[7]) then
      m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), LoWord(m_WAbil.MC))
    else
      m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) - m_wStatusArrValue[7]);
  end;
  nCode:= 16;
  if m_wStatusArrValue[2] > 0 then
    //m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + 2 + m_wStatusArrValue[2]);
    m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + m_wStatusArrValue[2]);//20080827 修改
  if m_wStatusArrValue[8] > 0 then begin
    if LoWord(m_WAbil.SC) > (HiWord(m_WAbil.SC) - m_wStatusArrValue[8]) then
      m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), LoWord(m_WAbil.SC))
    else
      m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) - m_wStatusArrValue[8]);
  end;

  if m_wStatusArrValue[3] > 0 then Inc(m_nHitSpeed, m_wStatusArrValue[3]);

  if m_wStatusArrValue[4] > 0 then begin//增加生命上线
    m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_wStatusArrValue[4]);
  end;

  if m_wStatusArrValue[5] > 0 then begin
    m_WAbil.MaxMP := _MIN(High(Word), m_WAbil.MaxMP + m_wStatusArrValue[5]);
  end;

  if m_boFlameRing then AddItemSkill(1)
  else DelItemSkill(1);

  if m_boRecoveryRing then AddItemSkill(2)
  else DelItemSkill(2);

  if m_boMuscleRing then begin //活力
    Inc(m_WAbil.MaxWeight, m_WAbil.MaxWeight);
    Inc(m_WAbil.MaxWearWeight, m_WAbil.MaxWearWeight);
    Inc(m_WAbil.MaxHandWeight, m_WAbil.MaxHandWeight);
  end;
  if m_nMoXieSuite > 0 then begin //魔血
    if m_WAbil.MaxMP <= m_nMoXieSuite then m_nMoXieSuite := m_WAbil.MaxMP - 1;
    Dec(m_WAbil.MaxMP, m_nMoXieSuite);
    //Inc(m_WAbil.MaxHP,m_nMoXieSuite);
    m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_nMoXieSuite);
  end;
  nCode:= 17;
  if m_btRaceServer = RC_PLAYOBJECT then begin
    if not TPlayObject(Self).m_boNotOnlineAddExp then
      SendUpdateMsg(Self, RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0, 0, '');
  end;
  if (m_btRaceServer >= RC_ANIMAL) and (m_btRaceServer <> RC_PLAYMOSTER) and (m_btRaceServer <> RC_HEROOBJECT) and (m_btRaceServer <> 135) then begin//20080726 135怪也不刷新能力
    MonsterRecalcAbilitys();//怪物刷新HP上限及攻击力
  end;

  if m_Magic67Skill <> nil then begin//先天元力增加防御,魔御上限 20080626
    if m_Abil.WineDrinkValue >= abs(m_Abil.MaxAlcohol * g_Config.nMinDrinkValue67 div 100) then begin//酒量大于或等于酒量上限的5%时才有效
       if m_Magic67Skill.btLevel > 0 then begin
          m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC),HiWord(m_WAbil.AC)+ m_Magic67Skill.btLevel * (m_Magic67Skill.btLevel + 1));//20080829 修改
          m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC)+ m_Magic67Skill.btLevel * (m_Magic67Skill.btLevel + 1));//20080829 修改
       end;
    end;
  end;
  nCode:= 18;
  //20081020 防止属性下限大于上限
  if LoWord(m_WAbil.AC) > HiWord(m_WAbil.AC) then m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), LoWord(m_WAbil.AC));
  if LoWord(m_WAbil.MAC) > HiWord(m_WAbil.MAC) then m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), LoWord(m_WAbil.MAC));
  if LoWord(m_WAbil.DC) > HiWord(m_WAbil.DC) then m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), LoWord(m_WAbil.DC));
  if LoWord(m_WAbil.MC) > HiWord(m_WAbil.MC) then m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), LoWord(m_WAbil.MC));
  if LoWord(m_WAbil.SC) > HiWord(m_WAbil.SC) then m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), LoWord(m_WAbil.SC));
  //限制最高属性
  m_WAbil.AC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.AC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.AC)));
  m_WAbil.MAC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MAC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.MAC)));
  m_WAbil.DC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.DC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.DC)));
  m_WAbil.MC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.MC)));
  m_WAbil.SC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.SC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.SC)));
except
  MainOutMessage('{异常} TBaseObject.RecalcAbilitys Code:'+inttostr(nCode));
end;
end;

procedure TBaseObject.BreakOpenHealth();
begin
  if m_boShowHP then begin
    m_boShowHP := False;
    m_nCharStatusEx := m_nCharStatusEx xor STATE_OPENHEATH;
    m_nCharStatus := GetCharStatus();
    SendRefMsg(RM_CLOSEHEALTH, 0, 0, 0, 0, '');
  end;
end;

procedure TBaseObject.MakeOpenHealth();
begin
  m_boShowHP := True;
  m_nCharStatusEx := m_nCharStatusEx or STATE_OPENHEATH;
  m_nCharStatus := GetCharStatus();
  SendRefMsg(RM_OPENHEALTH, 0, m_WAbil.HP, m_WAbil.MaxHP, 0, '');
end;
//增加HP,MP 
procedure TBaseObject.IncHealthSpell(nHP, nMP: Integer);
begin
  if (nHP < 0) or (nMP < 0) then Exit;
  if (m_WAbil.HP + nHP) >= m_WAbil.MaxHP then m_WAbil.HP := m_WAbil.MaxHP
  else Inc(m_WAbil.HP, nHP);
  if (m_WAbil.MP + nMP) >= m_WAbil.MaxMP then m_WAbil.MP := m_WAbil.MaxMP
  else Inc(m_WAbil.MP, nMP);
  HealthSpellChanged();
end;
//复活戒指生效，体力恢复
procedure TBaseObject.ItemDamageRevivalRing(); //004C022C
var
  I: Integer;
  pSItem: pTStdItem;
  nDura, tDura: Integer;
  PlayObject: TPlayObject;
begin
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    if m_UseItems[I].wIndex > 0 then begin
      pSItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
      if pSItem <> nil then begin
//        if (i = U_RINGR) or (i = U_RINGL) then begin
        if (pSItem.Shape in [114, 160, 161, 162]) or (((I = U_WEAPON) or (I = U_RIGHTHAND)) and (pSItem.AniCount in [114, 160, 161, 162])) then begin
          nDura := m_UseItems[I].Dura;
          tDura := Round(nDura / 1000 {1.03});
          Dec(nDura, 1000);
          if nDura <= 0 then begin
            nDura := 0;
            m_UseItems[I].Dura := nDura;
            if m_btRaceServer = RC_PLAYOBJECT then begin
              PlayObject := TPlayObject(Self);
              PlayObject.SendDelItems(@m_UseItems[I]);
            end; //004C0310
            m_UseItems[I].wIndex := 0;
            RecalcAbilitys();
            CompareSuitItem(False);//200080729 套装
          end else begin //004C0331
            m_UseItems[I].Dura := nDura;
          end;
          if tDura <> Round(nDura / 1000 {1.03}) then begin
            SendMsg(Self, RM_DURACHANGE, I, nDura, m_UseItems[I].DuraMax, 0, '');
          end;
            //break;
        end; //004C0397
//        end;//004C0397
      end; //004C0397 if pSItem <> nil then begin
    end; //if UseItems[i].wIndex > 0 then begin
  end; // for i:=Low(UseItems) to High(UseItems) do begin
end;
(*procedure TBaseObject.ItemDamageRevivalRing();
var
  I: Integer;
  pSItem: pTStdItem;
  nDura, tDura: Integer;
  PlayObject: TPlayObject;
  HeroObject: THeroObject;
begin
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    if m_UseItems[I].wIndex > 0 then begin
      pSItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
      if pSItem <> nil then begin
        //        if (i = U_RINGR) or (i = U_RINGL) then begin
        if (pSItem.Shape in [114, 160, 161, 162]) or (((I = U_WEAPON) or (I = U_RIGHTHAND)) and (pSItem.AniCount in [114, 160, 161, 162])) then begin
          nDura := m_UseItems[I].Dura;
          tDura := Round(nDura / 1000 {1.03});
          Dec(nDura, 1000);
          if nDura <= 0 then begin
            nDura := 0;
            m_UseItems[I].Dura := nDura;
            if m_btRaceServer = RC_PLAYOBJECT then begin
              PlayObject := TPlayObject(Self);
              PlayObject.SendDelItems(@m_UseItems[I]);
            end else
              if m_btRaceServer = RC_HEROOBJECT then begin
              HeroObject := THeroObject(Self);
              HeroObject.SendDelItems(@m_UseItems[I]);
            end;
            m_UseItems[I].wIndex := 0;
            RecalcAbilitys();
          end else begin //004C0331
            m_UseItems[I].Dura := nDura;
          end;
          if tDura <> Round(nDura / 1000 {1.03}) then begin
            if m_btRaceServer = RC_PLAYOBJECT then begin
              SendMsg(Self, RM_DURACHANGE, I, nDura, m_UseItems[I].DuraMax, 0, '');
            end else
              if m_btRaceServer = RC_HEROOBJECT then begin
              SendMsg(Self, RM_HERODURACHANGE, I, nDura, m_UseItems[I].DuraMax, 0, '');
            end;
          end;
          //break;
        end;
      end; //004C0397 if pSItem <> nil then begin
    end; //if UseItems[i].wIndex > 0 then begin
  end; // for i:=Low(UseItems) to High(UseItems) do begin
end;*)

procedure TBaseObject.Run;
var
  I: Integer;
  boChg: Boolean;
  boNeedRecalc: Boolean;
  nHP, nMP, n18: Integer;
  dwC, dwInChsTime: LongWord;
  ProcessMsg: TProcessMessage;
  BaseObject: TBaseObject;
  nCheckCode: Byte;
  dwRunTick: LongWord;
  nInteger: Integer;
  boChangeColor: Boolean;

  FlowerEvent: TFlowerEvent;
resourcestring
  sExceptionMsg0 = '{异常} TBaseObject::Run 0 Code:';
  sExceptionMsg1 = '{异常} TBaseObject::Run 1 ';
  sExceptionMsg2 = '{异常} TBaseObject::Run 2';
  sExceptionMsg3 = '{异常} TBaseObject::Run 3 ';
  sExceptionMsg4 = '{异常} TBaseObject::Run 4 Code:%d';
  sExceptionMsg5 = '{异常} TBaseObject::Run 5 Code:';
  sExceptionMsg6 = '{异常} TBaseObject::Run 6';
begin
  nCheckCode := 0;
  dwRunTick := GetTickCount();
  try
    while GetMessage(@ProcessMsg) do begin
      nCheckCode := 1;
      Operate(@ProcessMsg);
      nCheckCode := 2;
    end;
  except
    on E: Exception do begin
      MainOutMessage(sExceptionMsg0+inttostr(nCheckCode));
    end;
  end;

  try
    if m_boSuperMan then begin//无敌模式
      m_WAbil.HP := m_WAbil.MaxHP;
      m_WAbil.MP := m_WAbil.MaxMP;
    end;
    if ((nCrackedLevel <> 0) or (nErrorLevel <> 0)) and (dwStartTime > 36000{60 * 60 * 10}) then begin //破解后运行10小时后,所有角色无敌
      m_WAbil.HP := m_WAbil.MaxHP;
      m_WAbil.MP := m_WAbil.MaxMP;
    end;
    dwC := (GetTickCount() - m_dwHPMPTick) div 20;
    m_dwHPMPTick := GetTickCount();
    Inc(m_nHealthTick, dwC);
    Inc(m_nSpellTick, dwC);
    if not m_boDeath then begin//不断增加HP值
      if (m_WAbil.HP < m_WAbil.MaxHP) and (m_nHealthTick >= g_Config.nHealthFillTime) then begin
        n18 := (m_WAbil.MaxHP div 75) + 1;
        if (m_WAbil.HP + n18) < m_WAbil.MaxHP then begin
          Inc(m_WAbil.HP, n18);
        end else begin
          m_WAbil.HP := m_WAbil.MaxHP;
        end;
        nCheckCode := 3;
        HealthSpellChanged;
      end;
      //不断增加MP值
      if (m_WAbil.MP < m_WAbil.MaxMP) and (m_nSpellTick >= g_Config.nSpellFillTime) then begin
        n18 := (m_WAbil.MaxMP div 18) + 1;
        if (m_WAbil.MP + n18) < m_WAbil.MaxMP then begin
          Inc(m_WAbil.MP, n18);
        end else begin
          m_WAbil.MP := m_WAbil.MaxMP;
        end;
        HealthSpellChanged;
        nCheckCode := 4;
      end;
      if m_WAbil.HP = 0 then begin
        if m_LastHiter = nil then begin
          if m_boRevival and (GetTickCount - m_dwRevivalTick > g_Config.dwRevivalTime {60 * 1000}) then begin
            m_dwRevivalTick := GetTickCount();
            nCheckCode := 5;
            ItemDamageRevivalRing;
            nCheckCode := 9;
            m_WAbil.HP := m_WAbil.MaxHP;
            HealthSpellChanged;
            nCheckCode := 10;
            if (m_btRaceServer = RC_HEROOBJECT) then //20080529 英雄复活提示
              THeroObject(self).SysMsg(g_sRevivalRecoverMsg {'复活戒指生效，体力恢复'}, c_Green, t_Hint)
            else SysMsg(g_sRevivalRecoverMsg {'复活戒指生效，体力恢复'}, c_Green, t_Hint);
          end;
        end else
        if m_LastHiter <> nil then begin
          if not m_LastHiter.m_boUnRevival {防复活} and m_boRevival and (GetTickCount - m_dwRevivalTick > g_Config.dwRevivalTime {60 * 1000}) then begin
            m_dwRevivalTick := GetTickCount();
            nCheckCode := 11;
            ItemDamageRevivalRing;
            nCheckCode := 12;
            m_WAbil.HP := m_WAbil.MaxHP;
            HealthSpellChanged;
            nCheckCode := 13;
            if (m_btRaceServer = RC_HEROOBJECT) then //20080529 英雄复活提示
              THeroObject(self).SysMsg(g_sRevivalRecoverMsg {'复活戒指生效，体力恢复'}, c_Green, t_Hint)
            else SysMsg(g_sRevivalRecoverMsg {'复活戒指生效，体力恢复'}, c_Green, t_Hint);
          end;
        end;
        nCheckCode := 14;
        if (m_WAbil.HP = 0) and (not m_boGhost) then Die;
      end;//if m_LastHiter = nil then begin
      if m_nHealthTick >= g_Config.nHealthFillTime then m_nHealthTick := 0;
      if m_nSpellTick >= g_Config.nSpellFillTime then m_nSpellTick := 0;
      nCheckCode := 15;
    end else begin
      nCheckCode := 16;
      if (m_btRaceServer = RC_PLAYMOSTER) and (m_Master = nil) then begin //人形怪尸体清理时间 20080418
        if (GetTickCount() - m_dwDeathTick > g_Config.dwMakeGhostPlayMosterTime) then begin
           if TPlayMonster(self).boIsDieEvent then begin
             FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_DIEEVENT, 4000); //人形退出动画显示 20080914
             g_EventManager.AddEvent(FlowerEvent);
           end else begin
             FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, SM_HEROLOGOUT, 4000); //人形退出动画显示 20080914
             g_EventManager.AddEvent(FlowerEvent);
           end;
           MakeGhost();
        end;
      end else
      if (m_btRaceServer = RC_HEROOBJECT) and (m_Master <> nil) then begin //英雄尸体清理时间 20080418
        if (GetTickCount() - m_dwDeathTick > g_Config.nMakeGhostHeroTime) then MakeGhost();
      end else
      if (m_btRaceServer in [121..125]) and (m_Master = nil) then begin//雷炎怪清理时间 20080810
        if (GetTickCount() - m_dwDeathTick > g_Config.dwMakeGhostPlayMosterTime) then MakeGhost();
      end else
      if (GetTickCount() - m_dwDeathTick > g_Config.dwMakeGhostTime) then begin
        MakeGhost();
      end;
      nCheckCode := 17;
    end;
  except
    on E: Exception do begin
      //if nCheckCode = 2004 then MakeGhost();
      MainOutMessage(sExceptionMsg1 + IntToStr(nCheckCode) + ' ' + IntToStr(m_btRaceServer));
    end;
  end;

  try
    if not m_boDeath and ((m_nIncSpell > 0) or (m_nIncHealth > 0) or (m_nIncHealing > 0)) then begin
      dwInChsTime := 600 - _MIN(400, m_Abil.Level * 10);
      if ((GetTickCount - m_dwIncHealthSpellTick) >= dwInChsTime) and not m_boDeath then begin
        dwC := _MIN(200, (GetTickCount - m_dwIncHealthSpellTick - dwInChsTime));
        m_dwIncHealthSpellTick := GetTickCount() + dwC;
        if (m_nIncSpell > 0) or (m_nIncHealth > 0) or (m_nPerHealing > 0) then begin
          if (m_nPerHealth <= 0) then m_nPerHealth := 1;
          if (m_nPerSpell <= 0) then m_nPerSpell := 1;
          if (m_nPerHealing <= 0) then m_nPerHealing := 1;
          if m_nIncHealth < m_nPerHealth then begin
            nHP := m_nIncHealth;
            m_nIncHealth := 0;
          end else begin
            nHP := m_nPerHealth;
            Dec(m_nIncHealth, m_nPerHealth);
          end;
          if m_nIncSpell < m_nPerSpell then begin
            nMP := m_nIncSpell;
            m_nIncSpell := 0;
          end else begin
            nMP := m_nPerSpell;
            Dec(m_nIncSpell, m_nPerSpell);
          end;
          if m_nIncHealing < m_nPerHealing then begin
            Inc(nHP, m_nIncHealing);
            m_nIncHealing := 0;
          end else begin
            Inc(nHP, m_nPerHealing);
            Dec(m_nIncHealing, m_nPerHealing);
          end;
          m_nPerHealth := (m_Abil.Level div 10 + 5);
          m_nPerSpell := (m_Abil.Level div 10 + 5);
          m_nPerHealing := 5;
          IncHealthSpell(nHP, nMP);
          if m_WAbil.HP = m_WAbil.MaxHP then begin
            m_nIncHealth := 0;
            m_nIncHealing := 0;
          end;
          if m_WAbil.MP = m_WAbil.MaxMP then begin
            m_nIncSpell := 0;
          end;
        end;
      end;
    end else begin
      m_dwIncHealthSpellTick := GetTickCount();
    end;
    if (m_nHealthTick < -g_Config.nHealthFillTime) and (m_WAbil.HP > 1) then begin //Jacky ????
      Dec(m_WAbil.HP);
      Inc(m_nHealthTick, g_Config.nHealthFillTime);
      HealthSpellChanged();
    end;
    //检查HP/MP值是否大于最大值，大于则降低到正常大小
    boNeedRecalc := False;
    if m_WAbil.HP > m_WAbil.MaxHP then begin
      boNeedRecalc := True;
      m_WAbil.HP := m_WAbil.MaxHP - 1;
    end;
    if m_WAbil.MP > m_WAbil.MaxMP then begin
      boNeedRecalc := True;
      m_WAbil.MP := m_WAbil.MaxMP - 1;
    end;
    if boNeedRecalc then HealthSpellChanged();

  except
    MainOutMessage(sExceptionMsg2);
  end;

  try //20080527 增加异常提示
    nCheckCode := 62;
   //TBaseObject.Run 3 清理目标对象
    if (m_TargetCret <> nil) then begin
      if ((GetTickCount() - m_dwTargetFocusTick) > 30000) or
        m_TargetCret.m_boDeath or
        m_TargetCret.m_boGhost or
        (m_TargetCret.m_PEnvir <> m_PEnvir) or // 08/06 增加，弓箭卫士在人物进入房间后再出来，还会攻击人物(人物的攻击目标没清除)
        (abs(m_TargetCret.m_nCurrX - m_nCurrX) > 15) or
        (abs(m_TargetCret.m_nCurrY - m_nCurrY) > 15) then begin
        m_TargetCret := nil;
      end;
    end;
    nCheckCode := 63;
    try//20081214
      if (m_LastHiter <> nil) then begin
        nCheckCode := 66;
        if ((GetTickCount() - m_LastHiterTick) > 30000) or m_LastHiter.m_boDeath or m_LastHiter.m_boGhost then begin
          nCheckCode := 67;
          m_LastHiter := nil;
        end;
      end;
    except
    end;
    nCheckCode := 64;
    try//20081214
      if (m_ExpHitter <> nil) then begin
        nCheckCode := 65;
        if ((GetTickCount() - m_ExpHitterTick) > 6000) or m_ExpHitter.m_boDeath or m_ExpHitter.m_boGhost then begin
          nCheckCode := 68;
          m_ExpHitter := nil;
        end;
      end;
    except
    end;
    nCheckCode := 31;
    boChangeColor := True;
    if m_nChangeColorType >= 0 then begin
      //怪物变色
      boChangeColor := False;
      nCheckCode := 32;
      if m_nChangeColorType = 0 then begin
        nCheckCode := 33;
        if not m_boAutoChangeColor then begin
          nCheckCode := 34;
          m_boAutoChangeColor := True;
          m_dwAutoChangeColorTick := GetTickCount();
        end;
        nCheckCode := 35;
        if m_boAutoChangeColor and (GetTickCount - m_dwAutoChangeColorTick > g_Config.dwBBMonAutoChangeColorTime) then begin
          nCheckCode := 36;
          m_dwAutoChangeColorTick := GetTickCount();
          case m_nAutoChangeIdx of
            0: nInteger := STATE_TRANSPARENT;
            1: nInteger := POISON_STONE;
            2: nInteger := POISON_DONTMOVE;
            3: nInteger := POISON_68;
            4: nInteger := POISON_DECHEALTH;
            5: nInteger := POISON_LOCKSPELL;
            6: nInteger := POISON_DAMAGEARMOR;
          else begin
              m_nAutoChangeIdx := 0;
              nInteger := STATE_TRANSPARENT;
            end;
          end;
          nCheckCode := 37;
          Inc(m_nAutoChangeIdx);
          m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
          StatusChanged('');//状态改变
        end;
        nCheckCode := 38;
        if m_boFixColor and (m_nFixStatus <> m_nCharStatus) then begin
          nCheckCode := 39;
          case m_nFixColorIdx of
            0: nInteger := STATE_TRANSPARENT;
            1: nInteger := POISON_STONE;
            2: nInteger := POISON_DONTMOVE;
            3: nInteger := POISON_68;
            4: nInteger := POISON_DECHEALTH;
            5: nInteger := POISON_LOCKSPELL;
            6: nInteger := POISON_DAMAGEARMOR;
          else begin
              m_nFixColorIdx := 0;
              nInteger := STATE_TRANSPARENT;
            end;
          end;
          nCheckCode := 40;
          m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
          m_nFixStatus := m_nCharStatus;
          StatusChanged('');//状态改变
        end;
      end else begin
        nCheckCode := 41;
        m_boAutoChangeColor := False; //固定颜色
        m_boFixColor := True;
        m_nFixColorIdx := m_nChangeColorType - 1;
        if m_boFixColor and (m_nFixStatus <> m_nCharStatus) then begin
          nCheckCode := 42;
          case m_nFixColorIdx of
            0: nInteger := STATE_TRANSPARENT;
            1: nInteger := POISON_STONE;
            2: nInteger := POISON_DONTMOVE;
            3: nInteger := POISON_68;
            4: nInteger := POISON_DECHEALTH;
            5: nInteger := POISON_LOCKSPELL;
            6: nInteger := POISON_DAMAGEARMOR;
          else begin
              m_nFixColorIdx := 0;
              nInteger := STATE_TRANSPARENT;
            end;
          end;
          nCheckCode := 43;
          m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
          m_nFixStatus := m_nCharStatus;
          StatusChanged('');//状态改变
        end;
      end;
    end;
    nCheckCode := 44;
    if m_Master <> nil then begin
      if m_btRaceServer <> RC_HEROOBJECT then m_boNoItem := True; //20080602  英雄除外,所有宝宝不掉物品
      nCheckCode := 45;
      //宝宝变色
      if m_boAutoChangeColor and (GetTickCount - m_dwAutoChangeColorTick > g_Config.dwBBMonAutoChangeColorTime) and boChangeColor then begin
        nCheckCode := 46;
        m_dwAutoChangeColorTick := GetTickCount();
        case m_nAutoChangeIdx of
          0: nInteger := STATE_TRANSPARENT;
          1: nInteger := POISON_STONE;
          2: nInteger := POISON_DONTMOVE;
          3: nInteger := POISON_68;
          4: nInteger := POISON_DECHEALTH;
          5: nInteger := POISON_LOCKSPELL;
          6: nInteger := POISON_DAMAGEARMOR;
        else begin
            m_nAutoChangeIdx := 0;
            nInteger := STATE_TRANSPARENT;
          end;
        end;
        nCheckCode := 47;
        Inc(m_nAutoChangeIdx);
        m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
        StatusChanged('');//状态改变
      end;
      nCheckCode := 48;
      if m_boFixColor and (m_nFixStatus <> m_nCharStatus) and boChangeColor then begin
        nCheckCode := 49;
        case m_nFixColorIdx of
          0: nInteger := STATE_TRANSPARENT;
          1: nInteger := POISON_STONE;
          2: nInteger := POISON_DONTMOVE;
          3: nInteger := POISON_68;
          4: nInteger := POISON_DECHEALTH;
          5: nInteger := POISON_LOCKSPELL;
          6: nInteger := POISON_DAMAGEARMOR;
        else begin
            m_nFixColorIdx := 0;
            nInteger := STATE_TRANSPARENT;
          end;
        end;
        nCheckCode := 50;
        m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
        m_nFixStatus := m_nCharStatus;
        StatusChanged('');
      end;
      nCheckCode := 51;
      // 宝宝在主人死亡后死亡处理 (20071216 增加人物死亡后,英雄需要继续战斗)
      if m_Master <> nil then begin//20080730
        nCheckCode := 58;
        if not m_Master.m_boGhost then begin//20081216
          if m_Master.m_boDeath and (GetTickCount - m_Master.m_dwDeathTick > 1000) then begin
            nCheckCode := 52;
            if g_Config.boMasterDieMutiny and (m_Master.m_LastHiter <> nil) and (Random(g_Config.nMasterDieMutinyRate) = 0) then begin
              nCheckCode := 53;
              if m_btRaceServer <> RC_HEROOBJECT then begin //除英雄外，其它叛变
                nCheckCode := 54;
                m_Master := nil;
                m_btSlaveExpLevel := High(g_Config.SlaveColor);
                RecalcAbilitys();
                m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) * g_Config.nMasterDieMutinyPower, HiWord(m_WAbil.DC) * g_Config.nMasterDieMutinyPower);
                m_nWalkSpeed := m_nWalkSpeed div g_Config.nMasterDieMutinySpeed;
                RefNameColor;
                RefShowName;
              end else begin
                m_Master := nil;
                //m_WAbil.HP := 0; //主人死亡,英雄也一起死亡 20071226
              end;
            end else begin
              nCheckCode := 55;
              if m_Master.m_btRaceServer = RC_HEROOBJECT then begin//主人(英雄)死亡,英雄下属也一起死亡 20080228
                if (m_btRaceServer = RC_PLAYMOSTER) {and THeroObject(m_Master).boCallLogOut} then begin//收回英雄，英雄的分身，和英雄一样的消失 20081211
                  MakeGhost;
                end else m_WAbil.HP := 0;
              end;
              if m_Master.m_btRaceServer = RC_PLAYOBJECT then begin//20080531 增加
                if m_btRaceServer <> RC_HEROOBJECT then m_WAbil.HP := 0;
              end;
              //m_WAbil.HP := 0; //主人死亡,英雄、宝宝也一起死亡
            end;
          end;
        end;
      end;
      nCheckCode := 56;
      if m_Master <> nil then begin//20080623 增加
        if m_Master.m_boGhost and ((GetTickCount - m_Master.m_dwGhostTick) > 1000) then begin
          nCheckCode := 57;
          MakeGhost;
        end;
      end;
      
     { if (m_Master.m_boDeath and ((GetTickCount - m_Master.m_dwDeathTick) > 1000)) or
         (m_Master.m_boGhost and ((GetTickCount - m_Master.m_dwGhostTick) > 1000)) then begin

        if g_Config.boMasterDieMutiny and (m_Master.m_LastHiter = nil) and (Random(g_Config.nMasterDieMutinyRate) = 0) then begin
          m_Master:=nil;
          m_btSlaveExpLevel:=High(g_Config.SlaveColor);
          RecalcAbilitys();
          m_WAbil.DC:=MakeLong(LoWord(m_WAbil.DC) * g_Config.nMasterDieMutinyPower,HiWord(m_WAbil.DC) * g_Config.nMasterDieMutinyPower);
          m_nWalkSpeed:=m_nWalkSpeed div g_Config.nMasterDieMutinySpeed;
          RefNameColor;
          RefShowName;
        end else begin
          //004C7EFF
          m_WAbil.HP:=0;
        end;
      end; }
      
    end;

    //清除宝宝列表中已经死亡及叛变的宝宝信息
    nCheckCode := 18;
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then begin//20080712 增加
      for I := m_SlaveList.Count - 1 downto 0 do begin
        if m_SlaveList.Count <= 0 then Break;
        if TBaseObject(m_SlaveList.Items[I]) <> nil then begin
          if TBaseObject(m_SlaveList.Items[I]).m_boDeath or
             TBaseObject(m_SlaveList.Items[I]).m_boGhost or
            (TBaseObject(m_SlaveList.Items[I]).m_Master <> Self) then begin
              nCheckCode := 20;
              m_SlaveList.Delete(I);
              m_dwLatest46Tick:= GetTickCount; //20080204 召唤分身间隔
            end;
        end;
      end;
    end;
    if m_boHolySeize and ((GetTickCount() - m_dwHolySeizeTick) > m_dwHolySeizeInterval) then begin
      BreakHolySeizeMode();
    end;
    if m_boCrazyMode and ((GetTickCount() - m_dwCrazyModeTick) > m_dwCrazyModeInterval) then begin
      BreakCrazyMode();
    end;
    if m_boShowHP and ((GetTickCount() - m_dwShowHPTick) > m_dwShowHPInterval) then begin
      BreakOpenHealth();
    end;
  except
    MainOutMessage(sExceptionMsg3 + IntToStr(nCheckCode)+'  Name:' + m_sCharName);
  end;

  try
    // 减少PK值开始
    if (GetTickCount() - m_dwDecPkPointTick) > g_Config.dwDecPkPointTime {120000} then begin
      m_dwDecPkPointTick := GetTickCount();
      if m_nPkPoint > 0 then begin
        DecPKPoint(g_Config.nDecPkPointCount {1});
      end;
    end;
    // 减少PK值结束

    //检查照明物品及PK状态 开始
    nCheckCode := 24;
    if (GetTickCount - m_DecLightItemDrugTick) > g_Config.dwDecLightItemDrugTime {1000} then begin
      Inc(m_DecLightItemDrugTick, g_Config.dwDecLightItemDrugTime {1000});
      if m_btRaceServer = RC_PLAYOBJECT then begin
        UseLamp();//使用照明物品
        CheckPKStatus();//检查PK状态
      end else
      if m_btRaceServer = RC_HEROOBJECT then begin//20080725 英雄灰名变为正常
        CheckPKStatus();//检查PK状态
      end else
      if (m_btRaceServer = RC_PLAYMOSTER) and (m_Master <> nil) then begin//20081023 分身灰名变为正常
        CheckPKStatus();//检查PK状态
      end;
    end;
    //检查照明物品及PK状态 结束

    nCheckCode := 25;
    if ((GetTickCount - m_dwCheckRoyaltyTick) > 10000) and (m_btRaceServer <> RC_HEROOBJECT) {英雄不叛变} then begin
      m_dwCheckRoyaltyTick := GetTickCount();
      if m_Master <> nil then begin
        if (m_btRaceServer <> RC_PLAYMOSTER) then begin//宝宝叛变
          if (g_dwSpiritMutinyTick > GetTickCount) and (m_btSlaveExpLevel < 5) then begin
            m_dwMasterRoyaltyTick := 0;
          end;
          //宝宝叛变  开始
          nCheckCode := 26;
          if (GetTickCount - m_dwMasterRoyaltyTime > m_dwMasterRoyaltyTick) and (m_Master <> nil) then begin//20080813修改
            if not m_Master.m_boGhost then begin//20081216
              nCheckCode := 29;
              for I := m_Master.m_SlaveList.Count - 1 downto 0 do begin
                if m_Master.m_SlaveList.Count <= 0 then Break;
                nCheckCode := 27;
                if m_Master.m_SlaveList.Items[I] = Self then begin
                  nCheckCode := 28;
                  m_Master.m_SlaveList.Delete(I);
                  m_Master.m_dwLatest46Tick:= GetTickCount; //20080204 召唤分身间隔
                  Break;
                end;
              end;//for
            end;
            m_Master := nil;
            m_WAbil.HP := m_WAbil.HP div 10;
            RefShowName();
          end;
          //宝宝叛变 结束
          nCheckCode := 30;
          if m_dwMasterTick <> 0 then begin
            if (GetTickCount - m_dwMasterTick) > 43200000{12 * 60 * 60 * 1000} then  m_WAbil.HP := 0;
          end;
        end else begin//分身时间到直接消失 20080404
          if (GetTickCount - m_dwMasterRoyaltyTime > m_dwMasterRoyaltyTick) then begin //20080813 修改
            for I := m_Master.m_SlaveList.Count - 1 downto 0 do begin
              if m_Master.m_SlaveList.Count <= 0 then Break;
              nCheckCode := 31;
              if m_Master.m_SlaveList.Items[I] = Self then begin
                nCheckCode := 32;
                m_Master.m_SlaveList.Delete(I);
                m_Master.m_dwLatest46Tick:= GetTickCount; //召唤分身间隔
                Break;
              end;
            end;//for
            m_Master := nil;
            FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_DIEEVENT, 4000); //人物分身时间到，显示退出动画 20081211
            g_EventManager.AddEvent(FlowerEvent);
            m_WAbil.HP := 0;
            MakeGhost;
            nCheckCode := 33;
          end;
        end;
      end;//if m_Master <> nil then begin
    end;
    if (GetTickCount - m_dwVerifyTick) > 30000{30 * 1000} then begin
      m_dwVerifyTick := GetTickCount();
      if not m_boDenyRefStatus then m_PEnvir.VerifyMapTime(m_nCurrX, m_nCurrY, Self); //刷新在地图上位置的时间
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg4, [nCheckCode]));
      //MainOutMessage(E.Message);
    end;
  end;

  try
    nCheckCode := 65;
    boChg := False;
    boNeedRecalc := False;
    for I := Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do begin
      if (m_wStatusTimeArr[I] > 0) and (m_wStatusTimeArr[I] < 60000) then begin
        if (GetTickCount() - m_dwStatusArrTick[I]) > 1000 then begin
          Dec(m_wStatusTimeArr[I]);
          Inc(m_dwStatusArrTick[I], 1000);
          nCheckCode := 66;
          if (m_wStatusTimeArr[I] = 0) then begin
            boChg := True;
            case I of
              STATE_TRANSPARENT: m_boHideMode := False;
              STATE_DEFENCEUP: begin
                  boNeedRecalc := True;
                  if m_btRaceServer = RC_HEROOBJECT then//20080602 英雄加提示
                    THeroObject(Self).SysMsg('(英雄) '+g_sDefenceUpTimeOver, c_Green, t_Hint)
                  else SysMsg(g_sDefenceUpTimeOver{'防御力回复正常'}, c_Green, t_Hint);
                end;
              STATE_MAGDEFENCEUP: begin
                  boNeedRecalc := True;
                  if m_btRaceServer = RC_HEROOBJECT then//20080602 英雄加提示
                    THeroObject(Self).SysMsg('(英雄) '+g_sMagDefenceUpTimeOver, c_Green, t_Hint)
                  else SysMsg(g_sMagDefenceUpTimeOver{'魔御力回复正常'}, c_Green, t_Hint);
                end;
              STATE_BUBBLEDEFENCEUP: begin//让魔法盾停止
                  m_boAbilMagBubbleDefence := False;
                  if m_btMagBubbleDefenceLevel = 4 then StatusChanged('555');//20080811 4级盾,发个消息给客户端显示特有的效果
                end;
              STATE_ProtectionDEFENCE:begin //20080107 护体神盾失效
                 if (not m_boDeath) and m_boProtectionDefence then begin //20080121 人物没有死亡则发消息
                  if g_Config.boShowProtectionEnv then SendRefMsg(RM_MYSHOW, ET_PROTECTION_PIP, 0, 0, 0, '');//发送到客户端破盾效果图消息
                  if (not g_Config.boAutoProtection) then SysMsg(g_sShieldTimeDisappearMsg{'护体神盾失效'},c_Blue,t_Hint);//提示用户 没有自动开启则提示 20080529
                 end;
                 m_boProtectionDefence:= False;//护体神盾 停止
                 m_boProtectionTick:=GetTickCount();//护体神盾 停止时间  20080109
                end;
              STATE_LOCKRUN:begin
                 if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_boCanRun:= True;//是否允许跑
                 if m_btRaceServer = RC_HEROOBJECT then THeroObject(self).m_boCanRun:= True;//是否允许跑
               end;
            end;
          end;
        end;
      end;
    end;
    nCheckCode := 67;
    for I := Low(m_wStatusArrValue) to High(m_wStatusArrValue) do begin
      if m_wStatusArrValue[I] > 0 then begin
        if GetTickCount() > m_dwStatusArrTimeOutTick[I] then begin
          m_wStatusArrValue[I] := 0;
          boNeedRecalc := True;
          nCheckCode := 68;
          case I of
            0, 6: begin
                if m_btRaceServer = RC_HEROOBJECT then//20080602 英雄加提示
                  THeroObject(Self).SysMsg('(英雄) 攻击力回复正常', c_Green, t_Hint)
                else SysMsg('攻击力回复正常', c_Green, t_Hint);
              end;
            1, 7: begin
                if m_btRaceServer = RC_HEROOBJECT then//20080602 英雄加提示
                  THeroObject(Self).SysMsg('(英雄) 魔法力回复正常', c_Green, t_Hint)
                else SysMsg('魔法力回复正常', c_Green, t_Hint);
              end;
            2, 8: begin
                if m_btRaceServer = RC_HEROOBJECT then//20080602 英雄加提示
                  THeroObject(Self).SysMsg('(英雄) 道术回复正常', c_Green, t_Hint)
                else SysMsg('道术回复正常', c_Green, t_Hint);
                m_dwStatusArrTimeOutTick[11]:= GetTickCount();//20080322 无极真气间隔
              end;
            3: begin
                if m_btRaceServer = RC_HEROOBJECT then//20080602 英雄加提示
                  THeroObject(Self).SysMsg('(英雄) 攻击速度回复正常', c_Green, t_Hint)
                else SysMsg('攻击速度回复正常', c_Green, t_Hint);
              end;
            4: begin
                if m_btRaceServer = RC_HEROOBJECT then//20080602 英雄加提示
                  THeroObject(Self).SysMsg('(英雄) 体力回复正常', c_Green, t_Hint)
                else SysMsg('体力回复正常', c_Green, t_Hint);
              end;
            5: begin
                if m_btRaceServer = RC_HEROOBJECT then//20080602 英雄加提示
                  THeroObject(Self).SysMsg('(英雄) 魔法值回复正常', c_Green, t_Hint)
                else SysMsg('魔法值回复正常', c_Green, t_Hint);
              end;
            11: begin//20080626 增加敏捷度回复正常
                if m_btRaceServer = RC_HEROOBJECT then
                  THeroObject(Self).SysMsg('(英雄) 敏捷回复正常', c_Green, t_Hint)
                else SysMsg('敏捷回复正常', c_Green, t_Hint);
              end;
          end;
        end else begin
          case I of
            9: begin
                DamageHealth(m_wStatusArrValue[I]);
                HealthSpellChanged();
              end;
            10: begin
                DamageSpell(m_wStatusArrValue[I]);
                HealthSpellChanged();
              end;
          end;
        end;
      end;
    end;
    nCheckCode := 69;
    if boChg then begin
      m_nCharStatus := GetCharStatus();
      StatusChanged('');
    end;
    if boNeedRecalc then begin
      if m_btRaceServer = RC_HEROOBJECT then begin // 20080430
         nCheckCode := 70;
         THeroObject(self).RecalcAbilitys();
         THeroObject(self).CompareSuitItem(False);//200080729 套装
         THeroObject(self).SendMsg(m_Master, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性  20080430
      end else begin
         nCheckCode := 71;
         RecalcAbilitys();
         CompareSuitItem(False);//200080729 套装
         SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      end;
    end;
  except
    MainOutMessage(sExceptionMsg5 + IntToStr(nCheckCode));
  end;

  nCheckCode := 72;
  try
    if (GetTickCount - m_dwPoisoningTick) > g_Config.dwPosionDecHealthTime {2500} then begin
      m_dwPoisoningTick := GetTickCount();
      if m_wStatusTimeArr[POISON_DECHEALTH] > 0 then begin
        nCheckCode := 73;
        if m_boAnimal then Dec(m_nMeatQuality, 1000);
        DamageHealth(m_btGreenPoisoningPoint + 1);//中毒减血
        m_nHealthTick := 0;
        m_nSpellTick := 0;
        HealthSpellChanged();
      end;
    end;
    nCheckCode := 74;
    g_nBaseObjTimeMin := GetTickCount - dwRunTick;
    if g_nBaseObjTimeMax < g_nBaseObjTimeMin then g_nBaseObjTimeMax := g_nBaseObjTimeMin;
  except
    MainOutMessage(sExceptionMsg6+' nCode:'+inttostr(nCheckCode));
  end;  
 { if boOpenHealth then begin
    if (GetTickCount() - dwOpenHealthStart) > dwOpenHealthTime then begin
      BreakOpenHealth();
    end;
  end;}
end;
{//未使用 20080329
function TPlayObject.DayBright: Byte;
begin
  Result := 0;
  if m_PEnvir <> nil then begin
    if m_PEnvir.m_boDarkness then
      Result := 1
    else if m_PEnvir.m_boDayLight then Result := 0;
  end;
end; }

function TBaseObject.GetFrontPosition(var nX: Integer; var nY: Integer): Boolean;
var
  Envir: TEnvirnoment;
begin
  Envir := m_PEnvir;
  nX := m_nCurrX;
  nY := m_nCurrY;
  case m_btDirection of
    DR_UP: begin
        if nY > 0 then Dec(nY);
      end;
    DR_UPRIGHT: begin
        if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then begin
          Inc(nX);
          Dec(nY);
        end;
      end;
    DR_RIGHT: begin
        if nX < (Envir.m_nWidth - 1) then Inc(nX);
      end;
    DR_DOWNRIGHT: begin
        if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then begin
          Inc(nX);
          Inc(nY);
        end;
      end;
    DR_DOWN: begin
        if nY < (Envir.m_nHeight - 1) then Inc(nY);
      end;
    DR_DOWNLEFT: begin
        if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then begin
          Dec(nX);
          Inc(nY);
        end;
      end;
    DR_LEFT: begin
        if nX > 0 then Dec(nX);
      end;
    DR_UPLEFT: begin
        if (nX > 0) and (nY > 0) then begin
          Dec(nX);
          Dec(nY);
        end;
      end;
  end;
  Result := True;
end;
//地图移动
procedure TBaseObject.SpaceMove(sMAP: string; nX, nY: Integer; nInt: Integer);
  function GetRandXY(Envir: TEnvirnoment; var nX: Integer; var nY: Integer): Boolean;
  var
    n14, n18, n1C: Integer;
  begin
    Result := False;
    if Envir.m_nWidth < 80 then n18 := 3
    else n18 := 10;
    if Envir.m_nHeight < 150 then begin
      if Envir.m_nHeight < 50 then n1C := 2
      else n1C := 15;
    end else n1C := 50;
    n14 := 0;
    while (True) do begin
      if Envir.CanWalk(nX, nY, True) then begin
        Result := True;
        Break;
      end;
      if nX < (Envir.m_nWidth - n1C - 1) then Inc(nX, n18)
      else begin
        nX := Random(Envir.m_nWidth);
        if nY < (Envir.m_nHeight - n1C - 1) then Inc(nY, n18)
        else nY := Random(Envir.m_nHeight);
      end;
      Inc(n14);
      if n14 >= 201 then Break;
    end;
  end;
var
  I: Integer;
  Envir, OldEnvir: TEnvirnoment;
  nOldX, nOldY: Integer;
  bo21: Boolean;
  PlayObject: TPlayObject;
  nCode: Byte;//20080908
begin
  nCode:= 0;
  try
    Envir := g_MapManager.FindMap(sMAP);
    nCode:= 1;
    if Envir <> nil then begin
      if nServerIndex = Envir.nServerIndex then begin
        OldEnvir := m_PEnvir;
        nOldX := m_nCurrX;
        nOldY := m_nCurrY;
        bo21 := False;
        nCode:= 2;
        m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
        nCode:= 3;
        m_VisibleHumanList.Clear;
        nCode:= 4;
        if m_VisibleItems.Count > 0 then begin
          for I := 0 to m_VisibleItems.Count - 1 do begin
            //if pTVisibleMapItem(m_VisibleItems.Items[I]) <> nil then//20080716 注释
                Dispose(pTVisibleMapItem(m_VisibleItems.Items[I]));
          end;
          m_VisibleItems.Clear;
        end;
        nCode:= 5;
        if m_VisibleActors.Count > 0 then begin
          for I := 0 to m_VisibleActors.Count - 1 do begin
            //if pTVisibleBaseObject(m_VisibleActors.Items[I]) <> nil then//20080716 注释
               Dispose(pTVisibleBaseObject(m_VisibleActors.Items[I]));
          end;
          m_VisibleActors.Clear;
        end;
        nCode:= 6;
        if m_VisibleEvents.Count > 0 then begin
          for I := 0 to m_VisibleEvents.Count - 1 do begin
            if pTVisibleMapEvent(m_VisibleEvents.Items[I]) <> nil then
              Dispose(pTVisibleMapEvent(m_VisibleEvents.Items[I]));
          end;
          m_VisibleEvents.Clear; //移动时清除列表
        end;
        nCode:= 7;
        m_PEnvir := Envir;
        m_sMapName := Envir.sMapName;
        m_nCurrX := nX;
        m_nCurrY := nY;
        nCode:= 8;
        if GetRandXY(m_PEnvir, m_nCurrX, m_nCurrY) then begin
          nCode:= 9;
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
          SendMsg(Self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');
          SendMsg(Self, RM_CHANGEMAP, 0, 0, 0, 0, g_MapManager.GetMainMap(Envir)); //获取重复利用地图名称
          nCode:= 10;
          if nInt = 1 then begin
            SendRefMsg(RM_SPACEMOVE_SHOW2, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
          end else SendRefMsg(RM_SPACEMOVE_SHOW, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
          m_dwMapMoveTick := GetTickCount();
          m_bo316 := True;
          bo21 := True;
        end;
        if not bo21 then begin
          m_PEnvir := OldEnvir;
          m_nCurrX := nOldX;
          m_nCurrY := nOldY;
          nCode:= 11;
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
        end;
      end else begin
        nCode:= 12;
        if GetRandXY(Envir, nX, nY) then begin
          nCode:= 13;
          if m_btRaceServer = RC_PLAYOBJECT then begin
            nCode:= 14;
            DisappearA();
            m_bo316 := True;
            PlayObject := TPlayObject(Self);
            PlayObject.m_sSwitchMapName := Envir.sMapName;
            PlayObject.m_nSwitchMapX := nX;
            PlayObject.m_nSwitchMapY := nY;
            PlayObject.m_boSwitchData := True;
            PlayObject.m_nServerIndex := Envir.nServerIndex;
            PlayObject.m_boEmergencyClose := True;
            PlayObject.m_boReconnection := True;
            PlayObject.m_boPlayOffLine := False;
          end else KickException();
        end;
      end;
    end;
  except
    on E: Exception do begin
      MainOutMessage('{异常} TBaseObject.SpaceMove Code:'+inttostr(nCode));
    end;
  end;
end;

procedure TBaseObject.SpaceMove2(nX, nY: Integer; nInt: Integer);
  function GetRandXY(Envir: TEnvirnoment; var nX: Integer; var nY: Integer): Boolean;
  var
    n14, n18, n1C: Integer;
  begin
    Result := False;
    if Envir.m_nWidth < 80 then n18 := 3
    else n18 := 10;
    if Envir.m_nHeight < 150 then begin
      if Envir.m_nHeight < 50 then n1C := 2
      else n1C := 15;
    end else n1C := 50;
    n14 := 0;
    while (True) do begin
      if Envir.CanWalk(nX, nY, True) then begin
        Result := True;
        Break;
      end;
      if nX < (Envir.m_nWidth - n1C - 1) then Inc(nX, n18)
      else begin
        nX := Random(Envir.m_nWidth);
        if nY < (Envir.m_nHeight - n1C - 1) then Inc(nY, n18)
        else nY := Random(Envir.m_nHeight);
      end;
      Inc(n14);
      if n14 >= 201 then Break;
    end;
  end;
var
//  I: Integer;
  nOldX, nOldY: Integer;
  bo21: Boolean;
//  PlayObject: TPlayObject;
begin
  nOldX := m_nCurrX;
  nOldY := m_nCurrY;
  bo21 := False;
  m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  m_nCurrX := nX;
  m_nCurrY := nY;
  if GetRandXY(m_PEnvir, m_nCurrX, m_nCurrY) then begin
    m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
    SendMsg(Self, RM_CHANGEMAP, 0, 0, 0, 0, g_MapManager.GetMainMap(m_PEnvir));
    //SendMsg(Self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');
    if nInt = 1 then begin
      SendRefMsg(RM_SPACEMOVE_SHOW2, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
    end else SendRefMsg(RM_SPACEMOVE_SHOW, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
    m_dwMapMoveTick := GetTickCount();
    m_bo316 := True;
    bo21 := True;
  end;
  if not bo21 then begin
    m_nCurrX := nOldX;
    m_nCurrY := nOldY;
    m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  end;
end;
//刷新玩家状态
procedure TPlayObject.RefUserState();
var
  n8: Integer;
begin
  n8 := 0;
  if m_PEnvir.m_boFightZone or m_PEnvir.m_boFight2Zone then n8 := n8 or 1;
  if m_PEnvir.m_boSAFE then n8 := n8 or 2;
  if m_boInFreePKArea then n8 := n8 or 4;
  SendDefMessage(SM_AREASTATE, n8, 0, 0, 0, '');
end;
//刷新名字
procedure TBaseObject.RefShowName();
begin
  SendRefMsg(RM_USERNAME, 0, 0, 0, 0{IsCastleMaster}, GetShowName);//20080330
end;

procedure TPlayObject.RefMyStatus();
begin
  RecalcAbilitys();
  CompareSuitItem(False);//200080729 套装
  SendMsg(Self, RM_MYSTATUS, 0, 0, 0, 0, '');
end;

function TBaseObject.Operate(ProcessMsg: pTProcessMessage): Boolean;
var
  nDamage: Integer;
  nTargetX: Integer;
  nTargetY: Integer; 
  nPower: Integer;
  nRage: Integer;
  TargeTBaseObject: TBaseObject;
  nCode: Byte;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::Operate Code:';
begin
  Result := False;
  nCode:= 0;
  try
  if (ProcessMsg = nil) or (self = nil) then Exit;//20080812修改
    case ProcessMsg.wIdent of
      RM_MAGSTRUCK,
      RM_MAGSTRUCK_MINE: begin //10025
          nCode:= 1;
          if (ProcessMsg.wIdent = RM_MAGSTRUCK) and
            (m_btRaceServer >= RC_ANIMAL) and
            (not bo2BF) and (m_Abil.Level < 50) then begin
            m_dwWalkTick := m_dwWalkTick + 800 + LongWord(Random(1000));
          end;
          nCode:= 11;
          if TBaseObject(ProcessMsg.BaseObject) <> nil then begin//20081220 修正学了内功后对魔法技能不增加攻击力
            nDamage := GetMagStruckDamage(TBaseObject(ProcessMsg.BaseObject), ProcessMsg.nParam1);
          end else nDamage := GetMagStruckDamage(nil, ProcessMsg.nParam1);
          if nDamage > 0 then begin
            nCode:= 12;
            StruckDamage(nDamage);//受攻击,减身上装备的持久
            nCode:= 13;
            HealthSpellChanged();
            nCode:= 14;
            SendRefMsg(RM_STRUCK_MAG, nDamage, m_WAbil.HP, m_WAbil.MaxHP, Integer(ProcessMsg.BaseObject), '');
            nCode:= 15;
            if m_btRaceServer <> RC_PLAYOBJECT then begin
              if m_boAnimal then Dec(m_nMeatQuality, nDamage * 1000);
              nCode:= 16;
              SendMsg(Self, RM_STRUCK, nDamage, m_WAbil.HP, m_WAbil.MaxHP, Integer(ProcessMsg.BaseObject) {AttackBaseObject}, '');
            end;
          end;
          if m_boFastParalysis then begin
            m_wStatusTimeArr[POISON_STONE] := 1;
            m_boFastParalysis := False;
          end;
        end;
      RM_MAGHEALING: begin //10026
          nCode:= 2;
          if (m_nIncHealing + ProcessMsg.nParam1) < 300 then begin
            if m_btRaceServer = RC_PLAYOBJECT then begin
              Inc(m_nIncHealing, ProcessMsg.nParam1);
              m_nPerHealing := 5;
            end else begin
              Inc(m_nIncHealing, ProcessMsg.nParam1);
              m_nPerHealing := 5;
            end;
          end else m_nIncHealing := 300;
        end;
      RM_10101: begin //10101
          nCode:= 3;
          SendRefMsg(Integer(ProcessMsg.BaseObject),
            ProcessMsg.wParam {nPower},
            ProcessMsg.nParam1 {HP},
            ProcessMsg.nParam2 {MaxHP},
            ProcessMsg.nParam3 {AttackSrc},
            ProcessMsg.sMsg);
          if (Integer(ProcessMsg.BaseObject) = RM_STRUCK) and (m_btRaceServer <> RC_PLAYOBJECT) then begin
            SendMsg(Self, Integer(ProcessMsg.BaseObject),
              ProcessMsg.wParam,
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.nParam3 {AttackBaseObject},
              ProcessMsg.sMsg);
          end;
          if m_boFastParalysis then begin//快速麻痹，受攻击后麻痹立即消失
            m_wStatusTimeArr[POISON_STONE] := 1;
            m_boFastParalysis := False;
          end;
        end;
      RM_DELAYMAGIC: begin
          nCode:= 4;
          nPower := ProcessMsg.wParam;
          nTargetX := LoWord(ProcessMsg.nParam1);
          nTargetY := HiWord(ProcessMsg.nParam1);
          nRage := ProcessMsg.nParam2;
          nCode:= 41;
          TargeTBaseObject := TBaseObject(ProcessMsg.nParam3);
          nCode:= 42;
          if (TargeTBaseObject <> nil) and (TargeTBaseObject.GetMagStruckDamage(Self, nPower) > 0) then begin
            nCode:= 43;
            if m_btRaceServer = RC_HEROOBJECT then begin //20080427 修正英雄锁定后,不打锁定怪
               nCode:= 44;
               if not THeroObject(self).m_boTarget then SetTargetCreat(TargeTBaseObject);
            end else SetTargetCreat(TargeTBaseObject);
            nCode:= 45;
            if TargeTBaseObject.m_btRaceServer >= RC_ANIMAL then nPower := Round(nPower / 1.2);
            nCode:= 46;
            if (abs(nTargetX - TargeTBaseObject.m_nCurrX) <= nRage) and (abs(nTargetY - TargeTBaseObject.m_nCurrY) <= nRage) then
              TargeTBaseObject.SendMsg(Self, RM_MAGSTRUCK, 0, nPower, 0, 0, '');
          end;
        end;
      RM_10155: begin
          nCode:= 5;
          MapRandomMove(ProcessMsg.sMsg, ProcessMsg.wParam);
        end;
      RM_DELAYPUSHED: begin
          nCode:= 6;
          nPower := ProcessMsg.wParam;
         // nTargetX := LoWord(ProcessMsg.nParam1); 20080117
         // nTargetY := HiWord(ProcessMsg.nParam1); 20080117
          nRage := ProcessMsg.nParam2;
          TargeTBaseObject := TBaseObject(ProcessMsg.nParam3);
          if (TargeTBaseObject <> nil) then begin
            TargeTBaseObject.CharPushed(nPower, nRage);
          end;
        end;
      RM_POISON: begin
          nCode:= 7;
          TargeTBaseObject := TBaseObject(ProcessMsg.nParam2);
          if TargeTBaseObject <> nil then begin
            if IsProperTarget(TargeTBaseObject) then begin
              if m_btRaceServer = RC_HEROOBJECT then begin //20080531 修正英雄锁定后,不打锁定怪
                 if (TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT) or (TargeTBaseObject.m_btRaceServer = RC_HEROOBJECT) then //英雄灰色 20080721
                    SetPKFlag(TargeTBaseObject);
                 if not THeroObject(self).m_boTarget then SetTargetCreat(TargeTBaseObject);
              end else SetTargetCreat(TargeTBaseObject);
              if (m_btRaceServer = RC_PLAYOBJECT) and ((TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT) or (TargeTBaseObject.m_btRaceServer = RC_HEROOBJECT)) then begin//英雄灰色 20080721
                SetPKFlag(TargeTBaseObject);
              end;
              SetLastHiter(TargeTBaseObject);
            end;
            MakePosion(ProcessMsg.wParam {中毒类型}, ProcessMsg.nParam1 {nPower-时间}, ProcessMsg.nParam3 {点数});
          end else MakePosion(ProcessMsg.wParam {中毒类型}, ProcessMsg.nParam1 {nPower}, ProcessMsg.nParam3);

        end;
      RM_TRANSPARENT: begin //10308
          nCode:= 8;
          MagicManager.MagMakePrivateTransparent(Self, ProcessMsg.nParam1);
        end;
      RM_DOOPENHEALTH: begin //10412
          nCode:= 9;
          MakeOpenHealth();
        end;
{$IF CHECKNEWMSG = 1}
    else begin
        MainOutMessage(Format('人物: %s 消息: Ident %d Param %d P1 %d P2 %d P3 %d Msg %s',
          [m_sCharName,ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1,ProcessMsg.nParam2, ProcessMsg.nParam3,
          ProcessMsg.sMsg]));
      end;
{$IFEND}
    end;
  except
    //on E: Exception do begin
      MainOutMessage(sExceptionMsg+inttostr(nCode));
   //end;
  end;
end;

function TPlayObject.Operate(ProcessMsg: pTProcessMessage): Boolean;
var
  CharDesc: TCharDesc;
  nObjCount: Integer;
  s1C: string;
  MessageBodyWL: TMessageBodyWL;
  MessageBodyW: TMessageBodyW;
  ShortMessage: TShortMessage;
  OAbility: TOAbility;
  dwDelayTime: LongWord;
  nMsgCount: Integer;
  //boReturn: Boolean;
  nCode: Word;
begin
  Result := True;
  nCode:=0;//20080702
  Try
  if ProcessMsg = nil then begin
    Result := False;
    Exit;
  end;
  nCode:=1;
  //boReturn := False;
  case ProcessMsg.wIdent of
{$IF HEROVERSION = 1}
    CM_RECALLHERO: begin //召唤英雄
        nCode:=2;
        ClientRecallHero();
      end;
    CM_HEROLOGOUT: begin //英雄退出
        nCode:=3;
        ClientHeroLogOut(0);
      end;
    CM_QUERYHEROBAGITEMS: begin//刷新英雄的包裹
        nCode:=4;
        if m_MyHero <> nil then begin
          THeroObject(m_MyHero).ClientQueryBagItems; //发送英雄包裹
          SendMsg(Self, RM_SENDHEROUSEITEMS, 0, 0, 0, 0, ''); //发送英雄身上装备
          SendMsg(Self, RM_SENDHEROMYMAGIC, 0, 0, 0, 0, ''); //发送英雄使用魔法
          SendMsg(Self, RM_QUERYHEROBAGCOUNT, 0, THeroObject(m_MyHero).m_nItemBagCount, 0, 0, ''); //发送英雄包裹容量
          SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性
          SendMsg(Self, RM_HEROSUBABILITY, 0, 0, 0, 0, ''); //发送英雄属性
        end;
      end;
    CM_HEROAUTOOPENDEFENCE: begin //客户端设置英雄持续开盾 20080930
      if m_MyHero <> nil then begin
        THeroObject(m_MyHero).boAutoOpenDefence := ProcessMsg.nParam1 = 1 ;
        if THeroObject(m_MyHero).boAutoOpenDefence then
          SysMsg('(英雄)已开启持久开盾', c_Blue, t_Hint);
      end;
    end;
    CM_HEROMAGICKEYCHANGE: begin //客户端设置英雄魔法开关 20080606
         nCode:=3;
         if m_MyHero <> nil then begin
           THeroObject(m_MyHero).ChangeHeroMagicKey(ProcessMsg.nParam1, ProcessMsg.nParam2);
         end;  
      end;
    CM_QUERYHEROBAGCOUNT: begin
        nCode:=4;
        if m_MyHero <> nil then begin
          SendMsg(Self, RM_QUERYHEROBAGCOUNT, 0, THeroObject(m_MyHero).m_nItemBagCount, 0, 0, ''); //发送英雄包裹容量
        end;
      end;
    CM_HEROTAKEONITEM: begin //8102 英雄穿装备
        nCode:=5;
        ClientHeroTakeOnItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_HEROTAKEOFFITEM: begin //8103
        nCode:=6;
        ClientHeroTakeOffItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_TAKEOFFITEMHEROBAG, CM_TAKEOFFITEMTOMASTERBAG: begin //装备脱下到英雄包裹 //装备脱下到主人包裹
        nCode:=7;
        ClientHeroTakeOffItemsToBag(ProcessMsg.wIdent, ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_SENDITEMTOMASTERBAG, CM_SENDITEMTOHEROBAG: begin //主人包裹到英雄包裹 //英雄包裹到主人包裹
        nCode:=8;
        ClientBagToBag(ProcessMsg.wIdent, ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_HEROTAKEONITEMFORMMASTERBAG, CM_TAKEONITEMFORMHEROBAG: begin //从主人包裹穿装备到英雄包裹 //从英雄包裹穿装备到主人包裹
        nCode:=9;
        ClientTakeOnItemsFormBag(ProcessMsg.wIdent, ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_HEROEAT: begin //5043
        nCode:=10;
        ClientHeroUseItems(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_HEROCHGSTATUS: begin //改变英雄状态
        nCode:=11;
        ClientChgHeroStatus();
      end;
    CM_HEROPROTECT: begin //英雄守护
        nCode:=12;
        ClientHeroProtect(ProcessMsg.nParam2, ProcessMsg.nParam3);
      end;
    CM_HEROATTACKTARGET: begin //锁定目标
        nCode:=13;
        ClientHeroAttack(TBaseObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3);
      end;
    CM_QUERYUSERLEVELSORT: begin//用户排名
        nCode:=14;
        ClientGetUserOrder(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
      end;
//---------------------------商铺---------------------------------------------
    CM_OPENSHOP: begin//打开商铺
        nCode:=277;
        ClientGetShopItemList(ProcessMsg.nParam2, ProcessMsg.nParam3);
      end;
    RM_OPENSHOP: begin //打开商铺
        nCode:=278;
        m_DefMsg := MakeDefaultMsg(SM_SENGSHOPITEMS,
          ProcessMsg.wParam,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
      end;
    RM_OPENSHOPSPECIALLY: begin
        nCode:=279;
        m_DefMsg := MakeDefaultMsg(SM_SENGSHOPSPECIALLYITEMS,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
      end;
    CM_BUYSHOPITEM : begin////购买商铺物品
        nCode:=280;
        if GetTickCount - m_dwUserTick[1] >= 500 then begin
          m_dwUserTick[1]:= GetTickCount;
          ClientBuyShopItem(ProcessMsg.sMsg);
        end else begin
          m_DefMsg := MakeDefaultMsg(SM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeString('[失败]购买速度过快!'));
        end;
      end;
    RM_BUYSHOPITEM_FAIL: begin//购买商铺物品失败
        nCode:=281;
        case ProcessMsg.nParam1 of
          1:ProcessMsg.sMsg:='[失败]你的 ' + g_Config.sGameGoldName + ' 不够无法购买 '+ ProcessMsg.sMsg;
          2:ProcessMsg.sMsg:='[失败]你的包裹已满，请清理后在购买 ' + ProcessMsg.sMsg;
          3:ProcessMsg.sMsg:='[失败]没有找到 ' + ProcessMsg.sMsg;
        end;
        m_DefMsg := MakeDefaultMsg(SM_BUYSHOPITEM_FAIL, 0, 0, 0, 0, 0);
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
     end;
   CM_BUYSHOPITEMGIVE: begin//商铺赠送
        nCode:=282;
        if GetTickCount - m_dwUserTick[1] >= 500 then begin
          m_dwUserTick[1]:= GetTickCount;
          ClientBuyShopItemGive(ProcessMsg.sMsg);
        end else begin
          m_DefMsg := MakeDefaultMsg(SM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeString('[失败]赠送速度过快!'));
        end;
      end;
    RM_BUYSHOPITEMGIVE_SUCCESS: begin//商铺赠送成功
        nCode:=283; 
        m_DefMsg := MakeDefaultMsg(SM_BUYSHOPITEMGIVE_SUCCESS, 0, 0, 0, 0, 0);
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
     end;
    RM_BUYSHOPITEMGIVE_FAIL: begin//商铺赠送失败
        nCode:=284; 
        case ProcessMsg.nParam1 of
          1:ProcessMsg.sMsg:='[失败]你的 ' +g_Config.sGameGoldName+ ' 不够无法赠送 '+ ProcessMsg.sMsg;
          2:ProcessMsg.sMsg:='[失败]没有找到 ' + ProcessMsg.sMsg;
          3:ProcessMsg.sMsg:='[失败]你朋友的包裹已满，请通知你朋友清理后在购赠送 ' + ProcessMsg.sMsg;
          4:ProcessMsg.sMsg:='[失败]你的朋友 ' + ProcessMsg.sMsg +' 没有在线！';
        end;
        m_DefMsg := MakeDefaultMsg(SM_BUYSHOPITEMGIVE_FAIL, 0, 0, 0, 0, 0);
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
      end;
    CM_EXCHANGEGAMEGIRD: begin//兑换灵符
        nCode:=285;
        if GetTickCount - m_dwUserTick[1] >= 500 then begin
          m_dwUserTick[1]:= GetTickCount;
          ClientExchangeGameGird(ProcessMsg.nParam2);
        end else begin
          m_DefMsg := MakeDefaultMsg(SM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeString('[失败]兑换过快!'));
        end;
      end;
    RM_EXCHANGEGAMEGIRD_SUCCESS: begin //兑换灵符成功 20080730
        nCode:=287;
        m_DefMsg := MakeDefaultMsg(SM_EXCHANGEGAMEGIRD_SUCCESS, 0, 0, 0, 0, 0);
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
      end;
    RM_EXCHANGEGAMEGIRD_FAIL: begin//兑换灵符失败 20080730
        nCode:=286;
        m_DefMsg := MakeDefaultMsg(SM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, 0);
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
      end;
//---------------------------------------------------------------------------
    CM_HERODROPITEM: begin
        nCode:=15;
        if m_MyHero <> nil then begin
          if THeroObject(m_MyHero).ClientDropItem(ProcessMsg.sMsg, ProcessMsg.nParam1) then
            SendDefMessage(SM_HERODROPITEM_SUCCESS, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg)
          else SendDefMessage(SM_HERODROPITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg);
        end;
      end;
    CM_HEROGOTETHERUSESPELL: begin //接收到客户传来发合击的消息 20080229
        nCode:=16;
        if m_MyHero <> nil then ClientHeroUseSpell();
      end;
    CM_REPAIRFIRDRAGON: begin  //修补火龙之心
        nCode:=17;
        if m_MyHero <> nil then
          THeroObject(m_MyHero).RepairFirDragon(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;

    CM_REPAIRDRAGON: begin //祝福罐.魔令包功能 20080102
        nCode:=18;
        RepairDragon(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_REPAIRFINEITEM: begin  //修补火云石 20080506
        nCode:=19;
        RepairRefineItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_OPENBOXS: begin //打开宝箱 清清 20080118
        nCode:=20;
        ClientSendBoxItem(ProcessMsg.nParam1,ProcessMsg.sMsg);
      end;
    CM_MOVEBOXS: begin
        nCode:=21;
        ClientGetBoxs();
      end;
    CM_GETBOXS: begin
        nCode:=22;
        ClientGetBoxsItme();
      end;
///-----------------------------------------------------------------------------
//酒馆 20080515
    CM_SELGETHERO: begin //取回英雄 20080514
        nCode:=23;
        ClientGETHERO(ProcessMsg.sMsg, ProcessMsg.nParam1);
      end;
    CM_USERPLAYDRINKITEM: begin
       nCode:=24;
       ClientPlayDrinkItem(TObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
    end;
    CM_PlAYDRINKGAME: begin //猜拳码数
       nCode:=25;
       ClientPlayDrinkToDrink(ProcessMsg.nParam1,ProcessMsg.nParam2);
    end;
    CM_DrinkUpdateValue: begin//改变酒精度
      nCode:=26;
      ClientDrinkUpdateValue(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
    end;
    CM_USERPLAYDRINK: begin //请酒
      nCode:=27;
      ClientPlayDrink(ProcessMsg.sMsg);
    end;
//-------------------------酿酒系统---------------------------------------------
    CM_BEGINMAKEWINE: begin//开始酿酒(即把材料全放上窗口)  20080620
       nCode:=28;
       ClientPlayMakeWine(ProcessMsg.wParam{Code},ProcessMsg.sMsg{为物品ID号});
    end;
//------------------------------------------------------------------------------
    RM_GETBOXS: begin
        nCode:=29;
        m_DefMsg := MakeDefaultMsg(SM_GETBOXS,ProcessMsg.nParam1,ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
      end;
    RM_MOVEBOXS: begin
        nCode:=30;
        m_DefMsg := MakeDefaultMsg(SM_MOVEBOXS,ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.nParam3,ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
      end;

    RM_OPENBOXS_FAIL: begin    //20080318
        nCode:=31;
        m_DefMsg := MakeDefaultMsg(SM_OPENBOXS_FAIL,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
      end;

    RM_SELLOFFCANCEL: begin  //元宝寄售取消出售
        nCode:=32;
        m_DefMsg := MakeDefaultMsg(SM_SELLOFFCANCEL,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
    end;

    RM_SELLOFFADDITEM_OK: begin  //客户端往出售物品窗口里加物品 成功
        nCode:=33;
        m_DefMsg := MakeDefaultMsg(SM_SELLOFFADDITEM_OK,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
    end;

    RM_SellOffADDITEM_FAIL: begin  //客户端往出售物品窗口里加物品 失败
        nCode:=34;
        m_DefMsg := MakeDefaultMsg(SM_SellOffADDITEM_FAIL,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
    end;

    RM_SELLOFFDELITEM_OK: begin  //客户端删除出售物品窗里的物品 成功
        nCode:=35;
        m_DefMsg := MakeDefaultMsg(SM_SELLOFFDELITEM_OK,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
    end;

    RM_SELLOFFDELITEM_FAIL: begin  //客户端删除出售物品窗里的物品 失败
        nCode:=36;
        m_DefMsg := MakeDefaultMsg(SM_SELLOFFDELITEM_FAIL,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
    end;

    RM_SELLOFFEND_OK: begin  //客户端元宝寄售结束 成功
        nCode:=37;
        m_DefMsg := MakeDefaultMsg(SM_SELLOFFEND_OK,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
    end;

    RM_SELLOFFEND_FAIL: begin  //客户端元宝寄售结束 失败
        nCode:=38;
        m_DefMsg := MakeDefaultMsg(SM_SELLOFFEND_FAIL,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
    end;

    RM_SELLOFFBUY_OK: begin  //购买成功
        nCode:=39;
        m_DefMsg := MakeDefaultMsg(SM_SELLOFFBUY_OK,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
    end;

   { RM_SELLOFFBUY_FAIL: begin  //购买失败
        m_DefMsg := MakeDefaultMsg(SM_SELLOFFBUY_FAIL,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
    end; }

    RM_OPENBOXS: begin //打开宝箱 20080115
        nCode:=40;
        m_DefMsg := MakeDefaultMsg(SM_OPENBOXS,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
      end;

    RM_OPENDRAGONBOXS: begin //卧龙开宝箱 20080306
        nCode:=41;
        m_DefMsg := MakeDefaultMsg(SM_OPENDRAGONBOXS,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,'');
      end;

    RM_QUERYREFINEITEM: begin //NPC打开淬炼窗口 20080502
        nCode:=42;
        m_DefMsg := MakeDefaultMsg(SM_QUERYREFINEITEM,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,'');
      end;

    RM_HEROWINEXP: begin
        nCode:=43;
        if THeroObject(m_MyHero) <> nil then begin
          m_DefMsg := MakeDefaultMsg(SM_HEROWINEXP, THeroObject(m_MyHero).m_Abil.Exp, LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_HEROLEVELUP: begin //英雄升级
        nCode:=44;
        if m_MyHero <> nil then begin
          m_DefMsg := MakeDefaultMsg(SM_HEROLEVELUP, m_MyHero.m_Abil.Exp, m_MyHero.m_Abil.Level, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
          //m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, Integer(m_MyHero), m_MyHero.m_btGender, MakeWord(m_MyHero.m_btJob,m_MyHero.m_btHair), 0);
          m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, {Integer(m_MyHero)}m_MyHero.m_btGender, 0, {MakeWord(}m_MyHero.m_btJob{, 99)}, THeroObject(m_MyHero).m_nLoyal, 0);
          SendSocket(@m_DefMsg, EncodeBuffer(@m_MyHero.m_WAbil, SizeOf(TAbility)));
          SendDefMessage(SM_HEROSUBABILITY,
            MakeLong(MakeWord(m_MyHero.m_nAntiMagic, 0), 0),
            MakeWord(m_MyHero.m_btHitPoint, m_MyHero.m_btSpeedPoint),
            MakeWord(m_MyHero.m_btAntiPoison, m_MyHero.m_nPoisonRecover),
            MakeWord(m_MyHero.m_nHealthRecover, m_MyHero.m_nSpellRecover),
            '');
        end;
      end;

    RM_HEROABILITY: begin
        nCode:=45;
        if m_MyHero <> nil then begin
          //m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, Integer(m_MyHero), MakeWord(m_MyHero.m_btJob, 99), 0, 0);
          m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, {Integer(m_MyHero)}m_MyHero.m_btGender, 0, {MakeWord(}m_MyHero.m_btJob{, 99)}, THeroObject(m_MyHero).m_nLoyal, 0);
          SendSocket(@m_DefMsg, EncodeBuffer(@m_MyHero.m_WAbil, SizeOf(TAbility)));
        end;
      end;
    RM_RECALLHERO: begin //召唤英雄
        nCode:=46;
        SendDefMessage(SM_RECALLHERO,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam,
          ProcessMsg.sMsg);
      end;
    RM_CREATEHERO: begin //创建英雄
        nCode:=47;
        m_DefMsg := MakeDefaultMsg(SM_CREATEHERO,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.wParam, 0);
        CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
      end;
    {RM_HEROLOGOUT: begin //英雄退出,显示动画
        m_DefMsg := MakeDefaultMsg(SM_HEROLOGOUT,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.wParam);
        SendSocket(@m_DefMsg, '');
      end;}
    RM_DESTROYHERO: begin //英雄销毁
        nCode:=48;
        m_DefMsg := MakeDefaultMsg(SM_DESTROYHERO,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_MAKEGHOSTHERO: begin
        nCode:=49;
        if m_MyHero <> nil then begin
          m_MyHero.m_boDeath := True;
          m_MyHero.m_dwDeathTick := GetTickCount;
          m_MyHero.MakeGhost;
          //m_MyHero.m_dwGhostTick := GetTickCount() + 5 * 60 * 1000;
          m_MyHero := nil;
        end;
      end;

    RM_SENDHEROUSEITEMS: begin //发送英雄身上装备
        nCode:=50;
        if m_MyHero <> nil then THeroObject(m_MyHero).SendUseitems();
      end;
    RM_HEROWEIGHTCHANGED: begin
        nCode:=51;
        if m_MyHero = nil then Exit;
        SendDefMessage(SM_HEROWEIGHTCHANGED,
          m_MyHero.m_WAbil.Weight,
          m_MyHero.m_WAbil.WearWeight,
          m_MyHero.m_WAbil.HandWeight,
          0,
          '');
      end;
    RM_HERODEATH: begin //英雄死亡
        nCode:=52;
        m_DefMsg := MakeDefaultMsg(SM_HERODEATH, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_SENDHEROMYMAGIC: begin//发送英雄所学的技能
        nCode:=53;
        if m_MyHero <> nil then THeroObject(m_MyHero).SendUseMagic();
      end;
    RM_QUERYHEROBAGCOUNT: begin
        nCode:=54;
        SendDefMessage(SM_QUERYHEROBAGCOUNT,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          LoWord(ProcessMsg.nParam3),
          HiWord(ProcessMsg.nParam3),
          '');
      end;
    RM_HEROMAGIC_LVEXP: begin //英雄魔法升级
        nCode:=55;
        SendDefMessage(SM_HEROMAGIC_LVEXP,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          LoWord(ProcessMsg.nParam3),
          HiWord(ProcessMsg.nParam3),
          '');
      end;
    RM_HEROSUBABILITY: begin
        nCode:=56;
        if m_MyHero <> nil then begin
          SendDefMessage(SM_HEROSUBABILITY,
            MakeLong(MakeWord(m_MyHero.m_nAntiMagic, 0), 0),
            MakeWord(m_MyHero.m_btHitPoint, m_MyHero.m_btSpeedPoint),
            MakeWord(m_MyHero.m_btAntiPoison, m_MyHero.m_nPoisonRecover),
            MakeWord(m_MyHero.m_nHealthRecover, m_MyHero.m_nSpellRecover),'');
        end;
      end;
{$IFEND}

    CM_QUERYUSERNAME: begin //80
        nCode:=57;
        ClientQueryUserName(TPlayObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3);
      end;
    CM_QUERYBAGITEMS: begin //刷新人物的包裹物品
        nCode:=58;
        ClientQueryBagItems();
      end;
    CM_QUERYUSERSTATE: begin //82 查看角色装备
        nCode:=59;
        ClientQueryUserState(TBaseObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3);
      end;
    {CM_QUERYUSERSET: begin //未使用 20080907
        nCode:=60;
        ClientQueryUserSet(ProcessMsg);
      end;}
    CM_DROPITEM: begin //1000
        nCode:=61;
        if ClientDropItem(ProcessMsg.sMsg, ProcessMsg.nParam1) then
          SendDefMessage(SM_DROPITEM_SUCCESS, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg)
        else SendDefMessage(SM_DROPITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg);
      end;
    CM_PICKUP: begin //1001  004D78F9
        nCode:=62;
        if (m_nCurrX = ProcessMsg.nParam2) and (m_nCurrY = ProcessMsg.nParam3) then ClientPickUpItem();
      end;
    CM_OPENDOOR: begin //开门,人物走到地图的某个过门点时
        nCode:=63;
        ClientOpenDoor(ProcessMsg.nParam2, ProcessMsg.nParam3);
      end;
    CM_TAKEONITEM: begin //1003 从包裹里穿装备
        nCode:=64;
        ClientTakeOnItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_TAKEOFFITEM: begin //1004
        nCode:=65;
        ClientTakeOffItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_EAT: begin //1006
        nCode:=66;
        ClientUseItems(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_BUTCH: begin //1007 挖物品
        nCode:=67;
        if not ClientGetButchItem(TBaseObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam, dwDelayTime) then begin
          if dwDelayTime <> 0 then begin
            nMsgCount := GetDigUpMsgCount();
            if nMsgCount >= g_Config.nMaxDigUpMsgCount then begin//越过M2的挖肉限制数量
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                if g_Config.boKickOverSpeed then begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                  m_boPlayOffLine := False;
                end;
                if g_Config.boViewHackMessage then begin
                  //MainOutMessage('[游戏超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                  MainOutMessage(Format(g_sBunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
              end;
              //如果超速则发送攻击失败信息
              {if Assigned(zPlugOfEngine.SendActionFail) then begin //20080813 注释
                zPlugOfEngine.SendActionFail(Self);
              end else begin}
                SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
              //end;
            end else begin
              if dwDelayTime < g_Config.dwDropOverSpeed then begin
                if m_boTestSpeedMode then
                  SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                {if Assigned(zPlugOfEngine.SendActionGood) then begin //20080813 注释
                  zPlugOfEngine.SendActionGood(Self);
                end else begin }
                  SendSocket(nil, sSTATUS_GOOD {+ IntToStr(GetTickCount)});//20080814 修改
                //end;
              end else begin
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;
    CM_MAGICKEYCHANGE: begin //客户端改变魔法快键
        nCode:=68;
        ClientChangeMagicKey(ProcessMsg.nParam1, ProcessMsg.nParam2);
      end;
    CM_SOFTCLOSE: begin //人物小退
        nCode:=69;
        UserEngine.SaveHumanRcd(Self);//保存人物数据 20080413
{$IF HEROVERSION = 1}
        UserEngine.SaveHeroRcd(Self);//保存英雄数据 20080413
{$IFEND}
        m_boReconnection := True;
        m_boSoftClose := True;
      end;
    CM_CLICKNPC: begin//1010  004D79E4
        nCode:=70;
        ClientClickNPC(ProcessMsg.nParam1);
      end;
    CM_MERCHANTDLGSELECT: begin//1011
        nCode:=71;
        ClientMerchantDlgSelect(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_PlAYDRINKDLGSELECT: begin
        nCode:=72;
        ClientPlayDrinkLable(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_MERCHANTQUERYSELLPRICE: begin//1012
        nCode:=73;
        ClientMerchantQuerySellPrice(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
      end;
    CM_USERSELLITEM: begin//1013
        nCode:=74;
        ClientUserSellItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
      end;
    CM_USERBUYITEM: begin//1014
        nCode:=75;
        ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), 0, ProcessMsg.sMsg);
      end;
    //////////////////////////////增加拍卖////////////////////////////////////////////////////
   {  //20080416 去掉拍卖功能
    CM_SENDSELLOFFITEM:
      ClientUserSellOffItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);

    CM_SENDQUERYSELLOFFITEM:
      ClientUserBuySellOffItem(ProcessMsg.wIdent, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.sMsg);

    CM_SENDBUYSELLOFFITEM:
      ClientUserBuySellOffItem(ProcessMsg.wIdent, ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), 0, ProcessMsg.sMsg);

    /////////////////////////增加拍卖////////////////////////////////////////////////////////  }
    CM_USERGETDETAILITEM: begin
        nCode:=76;
        ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1, 0, ProcessMsg.nParam2, ProcessMsg.sMsg);
      end;
    CM_DROPGOLD: begin
        nCode:=77;
        if ProcessMsg.nParam1 > 0 then ClientDropGold(ProcessMsg.nParam1);
      end;
    CM_1017: begin
        nCode:=78;
        SendDefMessage(1, 0, 0, 0, 0, '');
      end;
    CM_GROUPMODE: begin//关闭组队
        nCode:=79;
        if ProcessMsg.nParam2 = 0 then ClientGropuClose()
        else m_boAllowGroup := True;
        if m_boAllowGroup then SendDefMessage(SM_GROUPMODECHANGED, 0, 1, 0, 0, '')
        else SendDefMessage(SM_GROUPMODECHANGED, 0, 0, 0, 0, '');
      end;
    CM_CREATEGROUP: begin //1020 新建组队
        nCode:=80;
        ClientCreateGroup(Trim(ProcessMsg.sMsg));
      end;
    CM_ADDGROUPMEMBER: begin //1021
        nCode:=81;
        ClientAddGroupMember(Trim(ProcessMsg.sMsg));
      end;
    CM_DELGROUPMEMBER: begin //1022
        nCode:=82;
        ClientDelGroupMember(Trim(ProcessMsg.sMsg));
      end;
    CM_USERREPAIRITEM: begin //1023
        nCode:=83;
        ClientRepairItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
      end;
    CM_MERCHANTQUERYREPAIRCOST: begin //1024
        nCode:=84;
        ClientQueryRepairCost(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
      end;
//---------------------交易系统--------------------------------------------      
    CM_DEALTRY: begin //1025 玩家点交易按键
        nCode:=85;
        ClientDealTry(Trim(ProcessMsg.sMsg));
      end;
    CM_DEALADDITEM: begin //1026 玩家把物品放到交易框中
        nCode:=86;
        ClientAddDealItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_DEALDELITEM: begin //1027 玩家从交易框中取回物品
        nCode:=87;
        ClientDelDealItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_DEALCANCEL: begin //1028 玩家取消交易
        nCode:=88;
        ClientCancelDeal();
      end;
    CM_DEALCHGGOLD: begin //1029 客户端把金币放到交易框中
        nCode:=89;
        ClientChangeDealGold(ProcessMsg.nParam1);
      end;
    CM_DEALEND: begin //1030 交易结束
        nCode:=90;
        ClientDealEnd();
      end;
//---------------------------挑战系统20080705--------------------------------
    CM_CHALLENGETRY: begin //玩家点击挑战
        nCode:=91;
        ClientChallenge;
      end;
    CM_CHALLENGEADDITEM: begin //玩家把物品放到挑战框中
        nCode:=92;
        ClientAddChallengeItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_CHALLENGEDELITEM: begin //玩家从挑战框中取回物品
        nCode:=93;
        ClientDelChallengeItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_CHALLENGECANCEL: begin //玩家取消挑战
        nCode:=94;
        ClientCancelChallenge();
      end;
    CM_CHALLENGECHGGOLD: begin //客户端把金币放到挑战框中
        nCode:=95;
        ClientChangeChallengeGold(ProcessMsg.nParam1);
      end;
    CM_CHALLENGECHGDIAMOND: begin //客户端把金刚石放到挑战框中
        nCode:=96;
        ClientChangeChallengeDIAMOND(ProcessMsg.nParam1);
      end;
    CM_CHALLENGEEND: begin //挑战抵押物品结束
        nCode:=97;
        ClientChallengeEnd();
      end;
//==========================元宝寄售系统======================================
    CM_SELLOFFADDITEM: begin// 客户端往出售物品窗口里加物品  20080316
        nCode:=98;
        ClientAddSellOffItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_SELLOFFDELITEM: begin//客户端删除出售物品窗里的物品  20080316
        nCode:=99;
        ClientDelSellOffItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_SELLOFFCANCEL: begin//客户端取消元宝寄售  20080316
        nCode:=100;
        ClientCancelSellOff();
      end;
    CM_SELLOFFEND: begin //客户端元宝寄售结束  20080316
        nCode:=101;
        ClientSellOffEnd(ProcessMsg.sMsg{买方},ProcessMsg.nParam1{元宝数},ProcessMsg.nParam2{金刚石数},ProcessMsg.nParam3{金刚石特征,类型上限表示});
      end;
    CM_CANCELSELLOFFITEMING: begin //取消正在寄售的物品 20080318(出售人)
        nCode:=102;
        ClientCancelSellOffIng();
      end;
    CM_SELLOFFBUYCANCEL: begin //取消寄售 物品购买 20080318(购买人)
        nCode:=103;
        ClientBuyCancelSellOff(ProcessMsg.sMsg{出售人});
      end;
    CM_SELLOFFBUY: begin //确定购买寄售物品 20080318
        nCode:=104;
        ClientBuySellOffItme(ProcessMsg.sMsg{出售人});
      end;
//============================================================================
    CM_REFINEITEM: begin //客户端发送粹练物品 20080507
        nCode:=105;
        if ClientAddRefineItem(ProcessMsg.sMsg) then ClientRefineItem;
      end;
    CM_USERSTORAGEITEM: begin //1031
        nCode:=106;
        ClientStorageItem(TObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
      end;
    CM_USERTAKEBACKSTORAGEITEM: begin //1032
        nCode:=107;
        ClientTakeBackStorageItem(TObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
      end;
    CM_WANTMINIMAP: begin //1033
        nCode:=108;
        ClientGetMinMap();
      end;
    CM_USERMAKEDRUGITEM: begin //1034
        nCode:=109;
        ClientMakeDrugItem(TObject(ProcessMsg.nParam1), ProcessMsg.sMsg);
      end;
    CM_OPENGUILDDLG: begin //1035
        nCode:=110;
        ClientOpenGuildDlg();
      end;
    CM_GUILDHOME: begin //1036
        nCode:=111;
        ClientGuildHome();
      end;
    CM_GUILDMEMBERLIST: begin
        nCode:=112;
        ClientGuildMemberList();
      end;
    CM_GUILDADDMEMBER: begin
        nCode:=113;
        ClientGuildAddMember(ProcessMsg.sMsg);
      end;
    CM_GUILDDELMEMBER: begin
        nCode:=114;
        ClientGuildDelMember(ProcessMsg.sMsg);
      end;
    CM_GUILDUPDATENOTICE: begin
        nCode:=115;
        ClientGuildUpdateNotice(ProcessMsg.sMsg);
      end;
    CM_GUILDUPDATERANKINFO: begin //1041 修改行会成员封号,等级
        nCode:=116;
        ClientGuildUpdateRankInfo(ProcessMsg.sMsg);
      end;
    CM_1042: begin
        MainOutMessage('[非法数据] ' + m_sCharName);
      end;
    CM_ADJUST_BONUS: begin
        nCode:=117;
        ClientAdjustBonus(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_GUILDALLY: begin //1044
        nCode:=118;
        ClientGuildAlly();
      end;
    CM_GUILDBREAKALLY: begin //1045
        nCode:=119;
        ClientGuildBreakAlly(ProcessMsg.sMsg);
      end;
{$IF CHECKNEWMSG = 1}
    CM_1046: begin
        MainOutMessage(Format('%s/%d/%d/%d/%d/%d/%s',
          [m_sCharName,
          ProcessMsg.wIdent,
            ProcessMsg.wParam,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            DeCodeString(ProcessMsg.sMsg)]));
      end;
    CM_1056: begin
        MainOutMessage(Format('%s/%d/%d/%d/%d/%d/%s',
          [m_sCharName,
          ProcessMsg.wIdent,
            ProcessMsg.wParam,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            DeCodeString(ProcessMsg.sMsg)]));
      end;
{$IFEND}
    CM_TURN: begin //3010
        nCode:=120;
        if ClientChangeDir(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.wParam {dir}, dwDelayTime) then begin
          m_dwActionTick := GetTickCount;
          {if Assigned(zPlugOfEngine.SendActionGood) then begin//20080813 注释
            zPlugOfEngine.SendActionGood(Self);
          end else begin}
            SendSocket(nil, sSTATUS_GOOD {+ IntToStr(GetTickCount)});//20080814 修改
          //end;
        end else begin
          if dwDelayTime = 0 then begin
            {if Assigned(zPlugOfEngine.SendActionFail) then begin//20080813 注释
              zPlugOfEngine.SendActionFail(Self);
            end else begin}
              SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
            //end;
          end else begin
            nMsgCount := GetTurnMsgCount();
            if nMsgCount >= g_Config.nMaxTurnMsgCount then begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                if g_Config.boKickOverSpeed then begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                  m_boPlayOffLine := False;
                end;
                if g_Config.boViewHackMessage then begin
                  //MainOutMessage('[游戏超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                  MainOutMessage(Format(g_sBunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
              end;
              //如果超速则发送攻击失败信息
              {if Assigned(zPlugOfEngine.SendActionFail) then begin //20080813 注释
                zPlugOfEngine.SendActionFail(Self);
              end else begin}
                SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
              //end;
            end else begin
              if dwDelayTime < g_Config.dwDropOverSpeed then begin
                {if Assigned(zPlugOfEngine.SendActionGood) then begin//20080813 注释
                  zPlugOfEngine.SendActionGood(Self);
                end else begin}
                  SendSocket(nil, sSTATUS_GOOD {+ IntToStr(GetTickCount)});//20080814 修改
                //end;
                if m_boTestSpeedMode then
                  SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end else begin
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;
    CM_WALK: begin
        nCode:=121;
        if ClientWalkXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.boLateDelivery, dwDelayTime) then begin
          m_dwActionTick := GetTickCount;
          if g_Config.boStartMapEvent then begin//开启地图事件触发
            if m_btRaceServer = RC_PLAYOBJECT then StartMapEventOfWalk(); //走路事件触发}
          end;
          {if Assigned(zPlugOfEngine.SendActionGood) then begin//20080813 注释
            zPlugOfEngine.SendActionGood(Self);
          end else begin }
            SendSocket(nil, sSTATUS_GOOD {+ IntToStr(GetTickCount)});//20080814 修改
          //end;
        end else begin
          if dwDelayTime = 0 then begin
            {if Assigned(zPlugOfEngine.SendActionFail) then begin//20080813 注释
              zPlugOfEngine.SendActionFail(Self);
            end else begin}
              SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
            //end;
          end else begin
            nMsgCount := GetWalkMsgCount();
            if nMsgCount >= g_Config.nMaxWalkMsgCount then begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                if g_Config.boKickOverSpeed then begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                  m_boPlayOffLine := False;
                end;
                if g_Config.boViewHackMessage then begin
                  //MainOutMessage('[行走超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                  MainOutMessage(Format(g_sWalkOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
              end;
              //如果超速则发送攻击失败信息
              {if Assigned(zPlugOfEngine.SendActionFail) then begin//20080813 注释
                zPlugOfEngine.SendActionFail(Self);
              end else begin}
                SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
              //end;
              if m_boTestSpeedMode then
                SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
            end else begin
              if (dwDelayTime > g_Config.dwDropOverSpeed) and (g_Config.btSpeedControlMode = 1) and m_boFilterAction then begin
                {if Assigned(zPlugOfEngine.SendActionFail) then begin//20080813 注释
                  zPlugOfEngine.SendActionFail(Self);
                end else begin }
                  SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
                //end;
                if m_boTestSpeedMode then
                  SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end else begin
                if m_boTestSpeedMode then
                  SysMsg(Format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;

    CM_HORSERUN: begin
        nCode:=122;
        if ClientHorseRunXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.boLateDelivery, dwDelayTime) then begin
          m_dwActionTick := GetTickCount;
          {if Assigned(zPlugOfEngine.SendActionGood) then begin//20080813 注释
            zPlugOfEngine.SendActionGood(Self);
          end else begin}
            SendSocket(nil, sSTATUS_GOOD {+ IntToStr(GetTickCount)});//20080814 修改
          //end;
        end else begin

          if dwDelayTime = 0 then begin
            {if Assigned(zPlugOfEngine.SendActionFail) then begin//20080813 注释
              zPlugOfEngine.SendActionFail(Self);
            end else begin}
              SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
            //end;
          end else begin
            nMsgCount := GetRunMsgCount();
            if nMsgCount >= g_Config.nMaxRunMsgCount then begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                if g_Config.boKickOverSpeed then begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                  m_boPlayOffLine := False;
                end;
                if g_Config.boViewHackMessage then begin
                  //MainOutMessage('[跑步超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                  MainOutMessage(Format(g_sRunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
              end;
              //如果超速则发送攻击失败信息
              {if Assigned(zPlugOfEngine.SendActionFail) then begin
                zPlugOfEngine.SendActionFail(Self);
              end else begin}
                SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
              //end;
              if m_boTestSpeedMode then
                SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
            end else begin
              if m_boTestSpeedMode then
                SysMsg(Format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
              Result := False;
            end;
          end;
        end;
      end;
    CM_RUN: begin
        nCode:=123;
        if ClientRunXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.nParam3, dwDelayTime) then begin
          m_dwActionTick := GetTickCount;
          if g_Config.boStartMapEvent then begin
            if m_btRaceServer = RC_PLAYOBJECT then StartMapEventOfRun(); //跑步事件触发
          end;
          {if Assigned(zPlugOfEngine.SendActionGood) then begin
            zPlugOfEngine.SendActionGood(Self);
          end else begin}
            SendSocket(nil, sSTATUS_GOOD {+ IntToStr(GetTickCount)});//20080814 修改
          //end;
        end else begin
          if dwDelayTime = 0 then begin
            {if Assigned(zPlugOfEngine.SendActionFail) then begin
              zPlugOfEngine.SendActionFail(Self);
            end else begin}
              SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
            //end;
          end else begin
            nMsgCount := GetRunMsgCount();
            if nMsgCount >= g_Config.nMaxRunMsgCount then begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                if g_Config.boKickOverSpeed then begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                  m_boPlayOffLine := False;
                end;
                if g_Config.boViewHackMessage then 
                  MainOutMessage(Format(g_sRunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
              end;
              //如果超速则发送攻击失败信息
              {if Assigned(zPlugOfEngine.SendActionFail) then begin
                zPlugOfEngine.SendActionFail(Self);
              end else begin}
                SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
              //end;
            end else begin
              if (dwDelayTime > g_Config.dwDropOverSpeed) and (g_Config.btSpeedControlMode = 1) and m_boFilterAction then begin
                {if Assigned(zPlugOfEngine.SendActionFail) then begin//20080813 注释
                  zPlugOfEngine.SendActionFail(Self);
                end else begin}
                  SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
                //end;
                if m_boTestSpeedMode then
                  SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end else begin
                if m_boTestSpeedMode then
                  SysMsg(Format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, CM_RUN, '', dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;
      CM_HIT, //3014
      CM_HEAVYHIT, //3015
      CM_BIGHIT, //3016
      CM_POWERHIT, //3018
      CM_LONGHIT, //3019
      CM_WIDEHIT, //3024
      CM_CRSHIT,
      CM_TWNHIT,{开天斩重击}
      CM_QTWINHIT,{开天斩轻击 20080212}
      CM_CIDHIT,{龙影剑法}
      CM_PHHIT,
      CM_DAILY, {逐日剑法 20080511}
      CM_FIREHIT,{烈火}
      CM_4FIREHIT{4级烈火 20080112}: begin //3025
        nCode:=124;
        if ClientHitXY(ProcessMsg.wIdent {ident}, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.wParam {dir}, ProcessMsg.boLateDelivery, dwDelayTime) then begin
          m_dwActionTick := GetTickCount;
          SendSocket(nil, sSTATUS_GOOD {+ IntToStr(GetTickCount)});//20080814 修改
        end else begin
          if dwDelayTime = 0 then begin
            SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
          end else begin
            nMsgCount := GetHitMsgCount();
            if nMsgCount >= g_Config.nMaxHitMsgCount then begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                if g_Config.boKickOverSpeed then begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                  m_boPlayOffLine := False;
                end;
                if g_Config.boViewHackMessage then begin
                  //MainOutMessage('[攻击超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                  MainOutMessage(Format(g_sHitOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
              end;
              //如果超速则发送攻击失败信息
              SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
            end else begin
              if (dwDelayTime > g_Config.dwDropOverSpeed) and (g_Config.btSpeedControlMode = 1) and m_boFilterAction then begin
                {if Assigned(zPlugOfEngine.SendActionGood) then begin//20080813 注释
                  zPlugOfEngine.SendActionGood(Self);
                end else begin}
                  SendSocket(nil, sSTATUS_GOOD {+ IntToStr(GetTickCount)});//20080814 修改
                //end;
                if m_boTestSpeedMode then
                  SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end else begin
                if m_boTestSpeedMode then begin
                  //SysMsg(format('操作延迟 Ident: %d Time: %d',[ProcessMsg.wIdent,dwDelayTime]),c_Red,t_Hint);
                  SysMsg('操作延迟 Ident: ' + IntToStr(ProcessMsg.wIdent) + ' Time: ' + IntToStr(dwDelayTime), c_Red, t_Hint);
                end;
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;
    CM_SITDOWN: begin //3012 蹲下
        nCode:=125;
        if ClientSitDownHit(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, dwDelayTime) then begin
          m_dwActionTick := GetTickCount();
          SendSocket(nil, sSTATUS_GOOD {+ IntToStr(GetTickCount)});//20080814 修改
          {if Assigned(zPlugOfEngine.SendActionGood) then begin//20080813 注释
            zPlugOfEngine.SendActionGood(Self);
          end else begin}
            SendSocket(nil, sSTATUS_GOOD {+ IntToStr(GetTickCount)});//20080814 修改
          //end;//20080813 注释
        end else begin
          if dwDelayTime = 0 then begin
            {if Assigned(zPlugOfEngine.SendActionFail) then begin//20080813 注释
              zPlugOfEngine.SendActionFail(Self);
            end else begin}
              SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
            //end;
          end else begin
            nMsgCount := GetSiteDownMsgCount();
            if nMsgCount >= g_Config.nMaxSitDonwMsgCount then begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                if g_Config.boKickOverSpeed then begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                  m_boPlayOffLine := False;
                end;
                if g_Config.boViewHackMessage then
                  MainOutMessage(Format(g_sBunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
              end;
              //如果超速则发送攻击失败信息
              {if Assigned(zPlugOfEngine.SendActionFail) then begin
                zPlugOfEngine.SendActionFail(Self);
              end else begin}
                SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
              //end;
            end else begin
              if dwDelayTime < g_Config.dwDropOverSpeed then begin
                {if Assigned(zPlugOfEngine.SendActionGood) then begin//20080813 注释
                  zPlugOfEngine.SendActionGood(Self);
                end else begin}
                  SendSocket(nil, sSTATUS_GOOD {+ IntToStr(GetTickCount)});//20080814 修改
                //end;//20080813 注释
                if m_boTestSpeedMode then
                  SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end else begin
                if m_boTestSpeedMode then
                  SysMsg(Format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;
    CM_SPELL: begin
        nCode:=126;
        if ClientSpellXY(ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, TBaseObject(ProcessMsg.nParam3), ProcessMsg.boLateDelivery, dwDelayTime) then begin
          m_dwActionTick := GetTickCount;
          {if Assigned(zPlugOfEngine.SendActionGood) then begin//20080813 注释
            zPlugOfEngine.SendActionGood(Self);
          end else begin }
            SendSocket(nil, sSTATUS_GOOD {+ IntToStr(GetTickCount)});//20080814 修改
          //end; //20080813 注释
        end else begin
          if dwDelayTime = 0 then begin
            {if Assigned(zPlugOfEngine.SendActionFail) then begin//20080813 注释
              zPlugOfEngine.SendActionFail(Self);
            end else begin}
              SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
            //end;
          end else begin
            nMsgCount := GetSpellMsgCount();
            if nMsgCount >= g_Config.nMaxSpellMsgCount then begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                if g_Config.boKickOverSpeed then begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                  m_boPlayOffLine := False;
                end;
                if g_Config.boViewHackMessage then
                  MainOutMessage(Format(g_sSpellOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
              end;
              //如果超速则发送攻击失败信息
              {if Assigned(zPlugOfEngine.SendActionFail) then begin//20080813 注释
                zPlugOfEngine.SendActionFail(Self);
              end else begin }
                SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
              //end;
            end else begin
              if (dwDelayTime > g_Config.dwDropOverSpeed) and (g_Config.btSpeedControlMode = 1) and m_boFilterAction then begin
                {if Assigned(zPlugOfEngine.SendActionFail) then begin//20080813 注释
                  zPlugOfEngine.SendActionFail(Self);
                end else begin}
                  SendSocket(nil, sSTATUS_FAIL {+ IntToStr(GetTickCount)});//20080814 修改
                //end;
                if m_boTestSpeedMode then
                  SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end else begin
                if m_boTestSpeedMode then
                  SysMsg(Format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;
    CM_SAY: begin
        nCode:=127;
        if ProcessMsg.sMsg <> '' then ProcessUserLineMsg(ProcessMsg.sMsg);
      end;
    CM_PASSWORD: begin
        nCode:=128;
        ProcessClientPassword(ProcessMsg);
      end;
    RM_WALK: begin //10002
        nCode:=129;
        {if Assigned(zPlugOfEngine.SendWalkMsg) then begin //20080813 注释
          zPlugOfEngine.SendWalkMsg(Self, ProcessMsg.BaseObject, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
        end else begin }
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
{$IF HEROVERSION = 1}
            m_DefMsg := MakeDefaultMsg(SM_WALK, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_btJob), 0);
{$ELSE}
            m_DefMsg := MakeDefaultMsg(SM_WALK, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
{$IFEND}
            CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
          end;
        //end;//20080813 注释
      end;
    RM_HORSERUN: begin //10003
        nCode:=130;
        {if Assigned(zPlugOfEngine.SendHorseRunMsg) then begin //20080813 注释
          zPlugOfEngine.SendHorseRunMsg(Self, ProcessMsg.BaseObject, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
        end else begin }
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg := MakeDefaultMsg(SM_HORSERUN, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
            CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
          end;
        //end;//20080813 注释
      end;
    RM_RUN: begin
        nCode:=131;
        {if Assigned(zPlugOfEngine.SendRunMsg) then begin //20080813 注释
          zPlugOfEngine.SendRunMsg(Self, ProcessMsg.BaseObject, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
        end else begin}
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg := MakeDefaultMsg(SM_RUN, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
            CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
          end;
       //end;//20080813 注释
      end;
    RM_HIT: begin //10004
        nCode:=132;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_HIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_PIXINGHIT: begin//劈星斩效果 20080611
         nCode:=133;
         m_DefMsg := MakeDefaultMsg(SM_PIXINGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
         SendSocket(@m_DefMsg, '');
      end;
    RM_LEITINGHIT: begin//雷霆一击效果 20080611
         nCode:=134;
         m_DefMsg := MakeDefaultMsg(SM_LEITINGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
         SendSocket(@m_DefMsg, '');
      end;
    RM_HEAVYHIT: begin //
        nCode:=135;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_HEAVYHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      end;
    RM_BIGHIT: begin //
        nCode:=136;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_BIGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_SPELL: begin // 10007
        nCode:=137;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg := MakeDefaultMsg(SM_SPELL, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam3));
        end else begin
           Case ProcessMsg.nParam3 of//20080712
             60..65: begin
               m_DefMsg := MakeDefaultMsg(SM_SPELL, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
               SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam3));
             end;
           end;
        {if (ProcessMsg.nParam3 in [60,61,62,63,64,65 ]) then begin
          m_DefMsg := MakeDefaultMsg(SM_SPELL, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam3));
        end;}
        end;
      end;
    RM_SPELL2: begin //10008
        nCode:=138;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_POWERHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;

 {   RM_POWERHIT: begin

    end;  }

    RM_MOVEFAIL: begin //10010
        nCode:=139;
        m_DefMsg := MakeDefaultMsg(SM_MOVEFAIL, Integer(Self), m_nCurrX, m_nCurrY, m_btDirection, 0);
        CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong;
        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(CharDesc)));
      end;
    RM_LONGHIT: begin //10011 刺杀
        nCode:=140;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_LONGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_WIDEHIT: begin //10012 半月
        nCode:=141;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_WIDEHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_DAILY: begin//逐日剑法 20080511
        nCode:=142;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_DAILY, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1{X坐标}, ProcessMsg.nParam2{Y坐标}, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_FIREHIT: begin //10014 烈火
        nCode:=143;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_FIREHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1{X坐标}, ProcessMsg.nParam2{Y坐标}, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_4FIREHIT: begin //10014 4级烈火 20080112
        nCode:=144;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_4FIREHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1{X坐标}, ProcessMsg.nParam2{Y坐标}, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_CRSHIT: begin //10014 抱月刀
        nCode:=145;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_CRSHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_41: begin //开天斩
        nCode:=146;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
        // m_DefMsg := MakeDefaultMsg({SM_41 200800202替换}SM_TWINHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
         case TBaseObject(ProcessMsg.BaseObject).m_n42kill of //20080212 开天斩重轻击
            1:m_DefMsg := MakeDefaultMsg( SM_QTWINHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
            2:m_DefMsg := MakeDefaultMsg( SM_TWINHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
         end;
         SendSocket(@m_DefMsg, '');
       end;
      end;
    RM_42: begin //42
        nCode:=147;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_42, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_43: begin //43
        nCode:=148;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_43, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_44: begin//44 龙影剑法
        nCode:=149;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg({SM_44  200800202替换}SM_CIDHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_MONMOVE: begin //擒拿手
        nCode:=150;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_SITDOWN, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_GOTETHERUSESPELL: begin
        nCode:=151;
        m_DefMsg := MakeDefaultMsg(SM_GOTETHERUSESPELL, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_CHANGETURN, //英雄转身
    RM_TURN,    //人物转身
    RM_PUSH,
    RM_RUSH,
    RM_RUSHKUNG: begin
        nCode:=152;
        if (TBaseObject(ProcessMsg.BaseObject) <> Self) or (ProcessMsg.wIdent = RM_PUSH) or (ProcessMsg.wIdent = RM_RUSH) or (ProcessMsg.wIdent = RM_RUSHKUNG) or (ProcessMsg.wIdent = RM_CHANGETURN) then begin
          case ProcessMsg.wIdent of
            RM_PUSH: //004D835F
              m_DefMsg := MakeDefaultMsg(SM_BACKSTEP, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, MakeWord(ProcessMsg.wParam {dir}, TBaseObject(ProcessMsg.BaseObject).m_nLight {light}), 0);
            RM_RUSH: //004D83B9
              m_DefMsg := MakeDefaultMsg(SM_RUSH, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
            RM_RUSHKUNG: //攻杀
              m_DefMsg := MakeDefaultMsg(SM_RUSHKUNG, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
          else begin //004D846A
              m_DefMsg := MakeDefaultMsg(SM_TURN, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
            end;
          end;
          CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          s1C := EncodeBuffer(@CharDesc, SizeOf(CharDesc));
          nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject));//取人物名字颜色
          if ProcessMsg.sMsg <> '' then
            s1C := s1C + (EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount)));
          SendSocket(@m_DefMsg, s1C);
          if ProcessMsg.wIdent = RM_TURN then begin
            nObjCount := TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong();
            SendDefMessage(SM_FEATURECHANGED,
              Integer(ProcessMsg.BaseObject),
              LoWord(nObjCount),
              HiWord(nObjCount),
              TBaseObject(ProcessMsg.BaseObject).GetFeatureEx,
              '');
          end;
        end;
      end;
    RM_STRUCK,
    RM_STRUCK_MAG: begin //10020
        nCode:=153;
        if ProcessMsg.wParam {nPower} > 0 then begin
          {if Assigned(zPlugOfEngine.SendUserStruckMsg) then begin //20080813 注释
            nCode:=275;
            zPlugOfEngine.SendUserStruckMsg(Self, ProcessMsg.BaseObject,TBaseObject(ProcessMsg.nParam3),ProcessMsg.wIdent);
          end else begin}
            nCode:= 275;
            if TBaseObject(ProcessMsg.BaseObject) <> nil then begin//20080722 增加
              nCode:=288;
              if TBaseObject(ProcessMsg.BaseObject) = Self then begin
                nCode:=289;
                if TBaseObject(ProcessMsg.nParam3) {AttackBaseObject} <> nil then begin
                  nCode:=290;
                  if (TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT) or
                     (TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_HEROOBJECT) then begin//英雄灰色 20080721
                    nCode:=154;
                    SetPKFlag(TBaseObject(ProcessMsg.nParam3) {AttackBaseObject});
                  end;
                  nCode:=155;
                  SetLastHiter(TBaseObject(ProcessMsg.nParam3) {AttackBaseObject});
                 { //反复活
                  if TBaseObject(ProcessMsg.nParam3).m_boUnRevival then m_boRevival:=False;  }
                end; 
                //if PKLevel >= 2 then m_dw5D4 := GetTickCount(); //未使用 20080329
                if (g_CastleManager.IsCastleMember(Self) <> nil) and (TBaseObject(ProcessMsg.nParam3) <> nil) then begin
                  TBaseObject(ProcessMsg.nParam3).bo2B0 := True;
                  TBaseObject(ProcessMsg.nParam3).m_dw2B4Tick := GetTickCount();
                end;
                m_nHealthTick := 0;
                m_nSpellTick := 0;
                Dec(m_nPerHealth);
                Dec(m_nPerSpell);
                m_dwStruckTick := GetTickCount(); //09/10
              end;
            end;
            nCode:=276;
            if TBaseObject(ProcessMsg.BaseObject) <> nil then begin
              if ((TBaseObject(ProcessMsg.BaseObject) = Self) and (g_Config.boDisableSelfStruck)) or ((TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) and g_Config.boDisableStruck) then begin
                nCode:=278;
                TBaseObject(ProcessMsg.BaseObject).SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');//人物受打击无弯腰动作
              end else begin
                nCode:=279;
                m_DefMsg := MakeDefaultMsg(SM_STRUCK,
                  Integer(ProcessMsg.BaseObject),
                  TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
                  TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
                  ProcessMsg.wParam, 0);
                nCode:=280;
                MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
                nCode:=281;
                MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
                nCode:=282;
                MessageBodyWL.lTag1 := ProcessMsg.nParam3;
                nCode:=283;
                if ProcessMsg.wIdent = RM_STRUCK_MAG then MessageBodyWL.lTag2 := 1
                else MessageBodyWL.lTag2 := 0;
                nCode:=284;
                SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));
              end;
            end;
          //end;//20080813 注释
        end;
      end;
    RM_DEATH: begin
        nCode:=156;
        {if Assigned(zPlugOfEngine.SendDeathMsg) then begin//20080813 注释
          zPlugOfEngine.SendDeathMsg(Self,
            ProcessMsg.BaseObject,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam,
            ProcessMsg.nParam3);
        end else begin }
          if ProcessMsg.nParam3 = 1 then begin
            m_DefMsg := MakeDefaultMsg(SM_NOWDEATH,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.wParam, 0);
          end else begin
            m_DefMsg := MakeDefaultMsg(SM_DEATH,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.wParam, 0);
          end;
          CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
        //end;//20080813 注释
      end;

    RM_DISAPPEAR: begin //10022
        nCode:=157;
        m_DefMsg := MakeDefaultMsg(SM_DISAPPEAR,Integer(ProcessMsg.BaseObject),0, 0, 0, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_SKELETON: begin //10024
        nCode:=158;
        {if Assigned(zPlugOfEngine.SendSkeletonMsg) then begin //20080813 注释
          zPlugOfEngine.SendSkeletonMsg(Self,
            ProcessMsg.BaseObject,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
        end else begin}
          m_DefMsg := MakeDefaultMsg(SM_SKELETON,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam, 0);
          CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
        //end;//20080813 注释
      end;
    RM_USERNAME: begin
       nCode:=159;
        m_DefMsg := MakeDefaultMsg(SM_USERNAME,
          Integer(ProcessMsg.BaseObject),
          GetCharColor(TBaseObject(ProcessMsg.BaseObject)), ProcessMsg.nParam3, 0, 0);
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
      end;
    RM_WINEXP: begin
        nCode:=160;
        m_DefMsg := MakeDefaultMsg(SM_WINEXP, m_Abil.Exp, LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_WINNHEXP: begin//取得内功经验 20081007
        m_DefMsg := MakeDefaultMsg(SM_WINNHEXP, 0, LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_HEROWINNHEXP: begin//英雄取得内功经验 20081007
        m_DefMsg := MakeDefaultMsg(SM_HEROWINNHEXP, 0, LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_LEVELUP: begin
        nCode:=161;
        {if Assigned(zPlugOfEngine.SendUserLevelUpMsg) then begin//20080813 注释
          zPlugOfEngine.SendUserLevelUpMsg(Self);
        end else begin}
          m_DefMsg := MakeDefaultMsg(SM_LEVELUP, m_Abil.Exp, m_Abil.Level, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
          m_DefMsg := MakeDefaultMsg(SM_ABILITY, m_nGold, MakeWord(m_btJob, 99), LoWord(m_nGameGold), HiWord(m_nGameGold), 0);
          //0806 增加
          if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then begin
            GetOldAbil(OAbility);
            SendSocket(@m_DefMsg, EncodeBuffer(@OAbility, SizeOf(TOAbility)));
          end else begin
            SendSocket(@m_DefMsg, EncodeBuffer(@m_WAbil, SizeOf(TAbility)));
          end;
          SendDefMessage(SM_SUBABILITY,
            MakeLong(MakeWord(m_nAntiMagic, 0), 0),
            MakeWord(m_btHitPoint, m_btSpeedPoint),
            MakeWord(m_btAntiPoison, m_nPoisonRecover),
            MakeWord(m_nHealthRecover, m_nSpellRecover),
            '');
        //end;//20080813 注释
      end;
    RM_CHANGENAMECOLOR: begin //10046 改变名字颜色
        nCode:=162;
        if ProcessMsg.BaseObject <> nil then //20080724 增加
        SendDefMessage(SM_CHANGENAMECOLOR,
          Integer(ProcessMsg.BaseObject),
          GetCharColor(TBaseObject(ProcessMsg.BaseObject)),
          0,
          0,
          '');
      end;
    RM_LOGON: begin //10050
        nCode:=163;
        if m_PEnvir.m_boDARK then nObjCount := 1
        else begin
          case m_nBright of
            1: nObjCount := 0;
            3: nObjCount := 1;
          else nObjCount := 1;
          end;
        end;
        if m_PEnvir.m_boDAY then nObjCount := 0;
        m_DefMsg := MakeDefaultMsg(SM_NEWMAP, Integer(Self), m_nCurrX, m_nCurrY, nObjCount, 0);
        SendSocket(@m_DefMsg, EncodeString(g_MapManager.GetMainMap(m_PEnvir)));
        SendMsg(Self, RM_CHANGELIGHT, 0, 0, 0, 0, '');
        SendLogon();
        SendServerConfig();//2007.12.18 清清 恢复掉注释
        SendUnBind();//发送解包文件
        ClientQueryUserName(Self, m_nCurrX, m_nCurrY);
        RefUserState(); //地图状态
        SendMapDescription();
        SendGoldInfo(True);
        SendGloryInfo;

        //m_DefMsg := MakeDefaultMsg(SM_VERSION_FAIL, g_Config.nClientFile1_CRC, LoWord(g_Config.nClientFile2_CRC), HiWord(g_Config.nClientFile2_CRC), 0);//验证客户端版本
        //SendSocket(@m_DefMsg, EncodeBuffer(@g_Config.nClientFile3_CRC, SizeOf(Integer)));
        m_DefMsg := MakeDefaultMsg(SM_VERSION_FAIL, g_Config.nClientFile1_CRC, 0, 0, 0, 0);//验证客户端版本 20080831 修改
        SendSocket(@m_DefMsg, '');
      end;
    RM_HEAR,
    RM_WHISPER,
    RM_CRY,
    RM_SYSMESSAGE,
    RM_MOVEMESSAGE,//滚动公告  清清 2007.11.13
    RM_GROUPMESSAGE,
    RM_SYSMESSAGE2,
    RM_GUILDMESSAGE,
    RM_SYSMESSAGE3,
    RM_PLAYDRINKSAY,
    RM_MERCHANTSAY: begin
        nCode:=164;
        case ProcessMsg.wIdent of
          RM_HEAR: m_DefMsg := MakeDefaultMsg(SM_HEAR, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1, 0); //10030
          RM_WHISPER: m_DefMsg := MakeDefaultMsg(SM_WHISPER, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1, 0); //10031
          RM_CRY: m_DefMsg := MakeDefaultMsg(SM_CRY, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1, 0); //10032
          RM_SYSMESSAGE: m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1, 0); //10100 红色
          //滚动公告 清清 2007.11.13
          RM_MOVEMESSAGE: m_DefMsg := MakeDefaultMsg(SM_MOVEMESSAGE, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3{0}, ProcessMsg.wParam{消息分类}, 0); //10100 红色   20081218
         // RM_SYSMESSAGE2: m_DefMsg:=MakeDefaultMsg(SM_SYSMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord($DB,$FF),0,1);//10103
         // RM_SYSMESSAGE3: m_DefMsg:=MakeDefaultMsg(SM_GUILDMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord($FF,$FC),0,1);//10105
          RM_GROUPMESSAGE: m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1, 0); //10102
          RM_GUILDMESSAGE: m_DefMsg := MakeDefaultMsg(SM_GUILDMESSAGE, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1, 0); //10104 行会聊天
          RM_MERCHANTSAY: m_DefMsg := MakeDefaultMsg(SM_MERCHANTSAY, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1, 0); //10126
          RM_PLAYDRINKSAY: m_DefMsg := MakeDefaultMsg(SM_PLAYDRINKSAY, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam3, 0, 1, 0); //20080515
        end;
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
      end;

    RM_ABILITY: begin
        nCode:=165;
        {if Assigned(zPlugOfEngine.SendUserAbilieyMsg) then begin//20080813 注释
          zPlugOfEngine.SendUserAbilieyMsg(Self);
        end else begin}
          m_DefMsg := MakeDefaultMsg(SM_ABILITY, m_nGold, MakeWord(m_btJob, 99), LoWord(m_nGameGold), HiWord(m_nGameGold), 0);
          if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then begin
            GetOldAbil(OAbility);
            SendSocket(@m_DefMsg, EncodeBuffer(@OAbility, SizeOf(TOAbility)));
            if g_Config.boOldClientShowHiLevel and (m_Abil.Level > 255) then begin
              SysMsg(g_sClientVersionTooOld {'由于您使用的客户端版本太老了，无法正确显示人物信息！！！'}, c_Red, t_Hint);
              SysMsg('当前等级: ' + IntToStr(m_Abil.Level), c_Green, t_Hint);
              SysMsg('当前生命值: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP), c_Blue, t_Hint);
              SysMsg('当前魔法值: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP), c_Red, t_Hint);
              SysMsg('当前防御力: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)), c_Green, t_Hint);
              SysMsg('当前魔防力: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)), c_Blue, t_Hint);
              SysMsg('当前攻击力: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)), c_Red, t_Hint);
              SysMsg('当前魔法力: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)), c_Green, t_Hint);
              SysMsg('当前道术值: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)), c_Blue, t_Hint);
            end;
          end else begin
            SendSocket(@m_DefMsg, EncodeBuffer(@m_WAbil, SizeOf(TAbility)));
          end;
        //end;//20080813 注释
      end;
    RM_PLAYMAKEWINEABILITY: begin//酒2相关属性 20080804
        nCode:=266;
        m_DefMsg := MakeDefaultMsg(SM_PLAYMAKEWINEABILITY,
          m_WAbil.Alcohol,
          m_WAbil.MaxAlcohol,
          m_WAbil.WineDrinkValue,
          m_WAbil.MedicineValue, 0);
        SendSocket(@m_DefMsg, EncodeString(IntToStr(m_WAbil.MaxMedicineValue)));
      end;
    RM_HEROMAKEWINEABILITY: begin//英雄酒2相关属性 20080804
        if m_MyHero <> nil then begin
          nCode:=267;
          m_DefMsg := MakeDefaultMsg(SM_HEROMAKEWINEABILITY,
            m_MyHero.m_WAbil.Alcohol,
            m_MyHero.m_WAbil.MaxAlcohol,
            m_MyHero.m_WAbil.WineDrinkValue,
            m_MyHero.m_WAbil.MedicineValue, 0);
          SendSocket(@m_DefMsg, EncodeString(IntToStr(m_MyHero.m_WAbil.MaxMedicineValue)));
        end;
      end;
    RM_CANEXPLORATION: begin //可探索 20080810
         nCode:= 268;
         m_DefMsg := MakeDefaultMsg(SM_CANEXPLORATION, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
         SendSocket(@m_DefMsg, '');
      end;
    RM_HEALTHSPELLCHANGED: begin //10052
        nCode:=166;
        m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
          Integer(ProcessMsg.BaseObject),
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP,
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_DAYCHANGING: begin //10053
        nCode:=167;
        if m_PEnvir.m_boDARK then nObjCount := 1
        else begin
          case m_nBright of
            1: nObjCount := 0;
            3: nObjCount := 1;
          else nObjCount := 1;
          end;
        end;
        if m_PEnvir.m_boDAY then nObjCount := 0;
        m_DefMsg := MakeDefaultMsg(SM_DAYCHANGING, 0, m_nBright, nObjCount, 0, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_ITEMSHOW: begin //10110
        nCode:=168;
        SendDefMessage(SM_ITEMSHOW,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam,
          ProcessMsg.sMsg);
      end;
    RM_ITEMHIDE: begin //10111
        nCode:=169;
        SendDefMessage(SM_ITEMHIDE,ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.nParam3,0,'');
      end;
    RM_DOOROPEN: begin //10112
        nCode:=170;
        SendDefMessage(SM_OPENDOOR_OK,0,ProcessMsg.nParam1, {x}ProcessMsg.nParam2, {y}0,'');
      end;
    RM_DOORCLOSE: begin //10113
        nCode:=171;
        SendDefMessage(SM_CLOSEDOOR, 0,ProcessMsg.nParam1,ProcessMsg.nParam2,0,'');
      end;
    RM_SENDUSEITEMS: begin
        nCode:=172;
        SendUseitems();
      end;
    RM_WEIGHTCHANGED: begin //10115 重量改变
        nCode:=173;
        SendDefMessage(SM_WEIGHTCHANGED, m_WAbil.Weight, m_WAbil.WearWeight, m_WAbil.HandWeight, 0, '');
      end;
    RM_FEATURECHANGED: begin //10116
        nCode:=174;
        SendDefMessage(SM_FEATURECHANGED,
          Integer(ProcessMsg.BaseObject),
          LoWord(ProcessMsg.nParam1),
          HiWord(ProcessMsg.nParam1),
          ProcessMsg.wParam,
          '');
      end;
    RM_CLEAROBJECTS: begin //10117
        nCode:=175;
        SendDefMessage(SM_CLEAROBJECTS, 0, 0, 0, 0,'');
      end;

    RM_CHANGEMAP: begin
        nCode:=176;
        if m_PEnvir.m_boDARK then nObjCount := 1
        else begin
          case m_nBright of
            1: nObjCount := 0;
            3: nObjCount := 1;
          else nObjCount := 1;
          end;
        end;
        if m_PEnvir.m_boDAY then nObjCount := 0;
        SendDefMessage(SM_CHANGEMAP, Integer(Self), m_nCurrX, m_nCurrY, nObjCount, ProcessMsg.sMsg);
        RefUserState();
        SendMapDescription();
        SendServerConfig();//2007.12.18 清清 恢复掉注释
        SendUnBind();//发送解包文件
      end;
    RM_BUTCH: begin //10119
        nCode:=177;
        if ProcessMsg.BaseObject <> nil then begin
          m_DefMsg := MakeDefaultMsg(SM_BUTCH,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_MAGICFIRE: begin //10120
        nCode:=178;
        m_DefMsg := MakeDefaultMsg(SM_MAGICFIRE,
          Integer(ProcessMsg.BaseObject),
          LoWord(ProcessMsg.nParam2),
          HiWord(ProcessMsg.nParam2),
          ProcessMsg.nParam1, 0);
        SendSocket(@m_DefMsg, EncodeBuffer(@ProcessMsg.nParam3, SizeOf(Integer)));  
      end;
    RM_MAGICFIREFAIL: begin //10121
        nCode:=179;
        SendDefMessage(SM_MAGICFIRE_FAIL, Integer(ProcessMsg.BaseObject), 0, 0, 0, '');
      end;
    RM_SENDMYMAGIC: begin
        nCode:=180;
        SendUseMagic; //10122
      end;

    RM_MAGIC_LVEXP: begin //10123
        nCode:=181;
        SendDefMessage(SM_MAGIC_LVEXP,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          LoWord(ProcessMsg.nParam3),
          HiWord(ProcessMsg.nParam3),
          '');
      end;
    RM_DURACHANGE: begin //10125
        nCode:=182;
        SendDefMessage(SM_DURACHANGE,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          LoWord(ProcessMsg.nParam2),
          HiWord(ProcessMsg.nParam2),
          ProcessMsg.sMsg);
      end;
    RM_EXPTIMEITEMS: begin //聚灵珠 发送时间变化  20080307
        nCode:=183;
        SendDefMessage(SM_EXPTIMEITEMS,
          ProcessMsg.nParam1,//MakeIndex
          ProcessMsg.wParam,
          ProcessMsg.nParam2,//时间
          0, '');
      end;
    RM_HERODURACHANGE: begin //10125
        nCode:=184;
        SendDefMessage(SM_HERODURACHANGE,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          LoWord(ProcessMsg.nParam2),
          HiWord(ProcessMsg.nParam2),'');
      end;
    RM_FIRDRAGONPOINT: begin
        nCode:=185;
        SendDefMessage(SM_FIRDRAGONPOINT,ProcessMsg.nParam1, ProcessMsg.wParam, 0, 0,'');
      end;

    RM_MERCHANTDLGCLOSE: begin //10127
        nCode:=186;
        SendDefMessage(SM_MERCHANTDLGCLOSE,ProcessMsg.nParam1,0,0, 0,'');
      end;
    RM_SENDGOODSLIST: begin
        nCode:=187;
        {if Assigned(zPlugOfEngine.SendGoodsList) then begin//20080813 注释
          zPlugOfEngine.SendGoodsList(Self,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            PChar(ProcessMsg.sMsg));
        end else begin}
          SendDefMessage(SM_SENDGOODSLIST,ProcessMsg.nParam1, ProcessMsg.nParam2,0, 0, ProcessMsg.sMsg);
        //end;//20080813 注释
      end;
    RM_SENDUSERSELL: begin //10129
        nCode:=188;
        SendDefMessage(SM_SENDUSERSELL,ProcessMsg.nParam1,ProcessMsg.nParam2,0,0,ProcessMsg.sMsg);
      end;
    RM_CHANGEATTATCKMODE: begin  //20080228
        nCode:=189;
        m_DefMsg := MakeDefaultMsg(SM_CHANGEATTATCKMODE,Integer(ProcessMsg.BaseObject),0, 0, 0, 0);
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
      end;
    RM_SENDBUYPRICE: begin //10130
        nCode:=190;
        SendDefMessage(SM_SENDBUYPRICE,ProcessMsg.nParam1,0, 0,0,'');
      end;
    RM_USERSELLITEM_OK: begin //10131
        nCode:=191;
        SendDefMessage(SM_USERSELLITEM_OK, ProcessMsg.nParam1, 0, 0, 0,'');
      end;
    RM_USERSELLITEM_FAIL: begin //10132
        nCode:=192;
        SendDefMessage(SM_USERSELLITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');
      end;
    RM_BUYITEM_SUCCESS: begin //10133
        nCode:=193;
        SendDefMessage(SM_BUYITEM_SUCCESS, ProcessMsg.nParam1, LoWord(ProcessMsg.nParam2),HiWord(ProcessMsg.nParam2),0,'');
      end;
    RM_BUYITEM_FAIL: begin //10134
        nCode:=194;
        SendDefMessage(SM_BUYITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0,'');
      end;
    RM_SENDDETAILGOODSLIST: begin //10135
        nCode:=195;
        SendDefMessage(SM_SENDDETAILGOODSLIST,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          0,
          ProcessMsg.sMsg);
      end;
    RM_OPENBOOKS: begin //卧龙 20080119
         nCode:=196;
         m_DefMsg := MakeDefaultMsg(SM_OPENBOOKS, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, 0, 0, 0); //10126
         SendSocket(@m_DefMsg, '');
      end;

    RM_Browser: begin//20080602 连接指定网址
         nCode:=197;
         m_DefMsg := MakeDefaultMsg(SM_Browser, Integer(ProcessMsg.BaseObject), 0, 0, 0 , 0); //10126
         SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
    RM_AUTOGOTOXY: begin //20080617 自动寻路
         nCode:=198;
         m_DefMsg := MakeDefaultMsg(SM_AUTOGOTOXY, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0); //10126
         SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
//-------------------------酿酒系统---------------------------------------------
    RM_OPENMAKEWINE: begin//打开酿酒窗口
         nCode:=199;
         m_DefMsg := MakeDefaultMsg(SM_OPENMAKEWINE, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, 0, 0, 0);
         SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
    RM_MAKEWINE_OK: begin//酿酒成功
         nCode:=200;
         m_DefMsg := MakeDefaultMsg(SM_MAKEWINE_OK, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, 0, 0, 0);
         SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
    RM_MAKEWINE_FAIL: begin//酿酒失败
         nCode:=201;
         m_DefMsg := MakeDefaultMsg(SM_MAKEWINE_FAIL, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, 0, 0, 0);
         SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
    RM_NPCWALK: begin//酿酒NPC移动 20080621
        nCode:=202;
        if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
          m_DefMsg := MakeDefaultMsg(SM_NPCWALK, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_btJob), 0);
          CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
        end;
      end;
    RM_MAGIC68SKILLEXP: begin//酒气护体技能经验 20080625
         nCode:=203;
         m_DefMsg := MakeDefaultMsg(SM_MAGIC68SKILLEXP, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0);
         SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
    RM_HEROMAGIC68SKILLEXP: begin//英雄酒气护体技能经验  20080925
         m_DefMsg := MakeDefaultMsg(SM_HEROMAGIC68SKILLEXP, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0);
         SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
   RM_MAGIC69SKILLEXP: begin//内功心法经验 20080930
         m_DefMsg := MakeDefaultMsg(SM_MAGIC69SKILLEXP, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
         SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
   RM_HEROMAGIC69SKILLEXP: begin//英雄内功心法经验 20080930
         m_DefMsg := MakeDefaultMsg(SM_HEROMAGIC69SKILLEXP, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
         SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
   RM_MAGIC69SKILLNH: begin//内力值(黄条) 20081002
         m_DefMsg := MakeDefaultMsg(SM_MAGIC69SKILLNH, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
         SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
   {RM_HEROMAGIC69SKILLNH: begin//英雄内力值(黄条) 20081002
         m_DefMsg := MakeDefaultMsg(SM_HEROMAGIC69SKILLNH, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
         SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end; }
//------------------------------------------------------------------------------
    RM_DRAGONPOINT: begin//黄条气值
        nCode:=204;
        SendDefMessage(SM_DRAGONPOINT,ProcessMsg.nParam1,ProcessMsg.wParam,0,0,'');
      end;
    {RM_CLOSEDRAGONPOINT: begin
        SendDefMessage(SM_CLOSEDRAGONPOINT,ProcessMsg.nParam1, ProcessMsg.wParam, 0,0,'');
      end;  }
    //////////////////////////////////////拍卖//////////////////////////////////////
    RM_SENDSELLOFFGOODSLIST: begin //  拍卖
        nCode:=205;
        SendDefMessage(SM_SENDSELLOFFGOODSLIST,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          0,
          ProcessMsg.sMsg);
      end;

    RM_SENDUSERSELLOFFITEM: begin
        nCode:=206;
        SendDefMessage(SM_SENDUSERSELLOFFITEM,ProcessMsg.nParam1,ProcessMsg.nParam2, 0,0, ProcessMsg.sMsg);
      end;

    RM_SENDUSERSELLOFFITEM_OK: begin
        nCode:=207;
        SendDefMessage(SM_SENDUSERSELLOFFITEM_OK,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          0, '');
      end;
    RM_SENDUSERSELLOFFITEM_FAIL: begin
        nCode:=208;
        SendDefMessage(SM_SENDUSERSELLOFFITEM_FAIL,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          0,'');
      end;
    RM_SENDSELLOFFITEMLIST: begin
        nCode:=209;
        SendDefMessage(CM_SENDSELLOFFITEMLIST,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3, 0,
          ProcessMsg.sMsg);
      end;

    RM_SENDBUYSELLOFFITEM_OK: begin //购买拍卖物品成功
        nCode:=210;
        SendDefMessage(SM_SENDBUYSELLOFFITEM_OK,
          ProcessMsg.nParam1,
          LoWord(ProcessMsg.nParam2),
          HiWord(ProcessMsg.nParam2),0,'');
      end;
    RM_SENDBUYSELLOFFITEM_FAIL: begin //购买拍卖物品失败
        nCode:=211;
        SendDefMessage(SM_SENDBUYSELLOFFITEM_FAIL,ProcessMsg.nParam1, 0,0,0,'');
      end;
    //////////////////////////////////////拍卖//////////////////////////////////////
//---------------------------元宝寄售系统---------------------------------------
    RM_SENDDEALOFFFORM:begin//打开出售物品窗口 20080316
        nCode:=212;
        SendDefMessage(SM_SENDDEALOFFFORM, ProcessMsg.nParam1,ProcessMsg.nParam2,0,0,ProcessMsg.sMsg);
     end;
    RM_QUERYYBSELL: begin //查询正在出售的物品 20080316
        nCode:=213;
        m_DefMsg := MakeDefaultMsg(SM_QUERYYBSELL,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
      end;
    RM_QUERYYBDEAL: begin //查询可以的购买物品 20080316
        nCode:=214;
        m_DefMsg := MakeDefaultMsg(SM_QUERYYBDEAL,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam, 0);
        SendSocket(@m_DefMsg,ProcessMsg.sMsg);
      end;
//------------------------------------------------------------------------------
    RM_GOLDCHANGED: begin //10136
        nCode:=215;
        SendDefMessage(SM_GOLDCHANGED, m_nGold,LoWord(m_nGameGold), HiWord(m_nGameGold), 0, '');
      end;
    RM_GAMEGOLDCHANGED: begin
        nCode:=216;
        SendGoldInfo(False);
      end;
    RM_CHANGELIGHT: begin //10137
        nCode:=217;
        SendDefMessage(SM_CHANGELIGHT,
          Integer(ProcessMsg.BaseObject),
          TBaseObject(ProcessMsg.BaseObject).m_nLight,
          g_Config.nClientKey,
          0,'');
      end;
    RM_LAMPCHANGEDURA: begin //10138
        nCode:=218;
        SendDefMessage(SM_LAMPCHANGEDURA, ProcessMsg.nParam1, 0,0, 0,'');
      end;
    RM_CHARSTATUSCHANGED: begin //10139
        nCode:=219;
        SendDefMessage(SM_CHARSTATUSCHANGED,
          Integer(ProcessMsg.BaseObject),
          LoWord(ProcessMsg.nParam1),
          HiWord(ProcessMsg.nParam1),
          ProcessMsg.wParam,
          ProcessMsg.sMsg);
      end;
    RM_GROUPCANCEL: begin //10140
        nCode:=220;
        SendDefMessage(SM_GROUPCANCEL, ProcessMsg.nParam1, 0, 0, 0, '');
      end;
    RM_SENDUSERREPAIR,
      RM_SENDUSERSREPAIR: begin //10141
        nCode:=221;
        SendDefMessage(SM_SENDUSERREPAIR,ProcessMsg.nParam1, ProcessMsg.nParam2, 0,0,'');
      end;
    RM_USERREPAIRITEM_OK: begin //10143
        nCode:=222;
        SendDefMessage(SM_USERREPAIRITEM_OK,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          0,
          '');
      end;
    RM_SENDREPAIRCOST: begin //10142
        nCode:=223;
        SendDefMessage(SM_SENDREPAIRCOST, ProcessMsg.nParam1, 0,0, 0,'');
      end;
    RM_USERREPAIRITEM_FAIL: begin //10144
        nCode:=224;
        SendDefMessage(SM_USERREPAIRITEM_FAIL, ProcessMsg.nParam1,0,0,0, '');
      end;
    RM_USERSTORAGEITEM: begin //10146
        nCode:=225;
        SendDefMessage(SM_SENDUSERSTORAGEITEM, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0,'');
      end;
    RM_USERGETBACKITEM: begin //10147
        nCode:=226;
        SendSaveItemList(ProcessMsg.nParam1);
      end;
    RM_USERBIGGETBACKITEM: begin//发送无限仓库物品
        nCode:=227;
        SendSaveBigStorageItemList(ProcessMsg.nParam1, ProcessMsg.wParam);
      end;
    RM_SENDDELITEMLIST: begin //10148 SM_DELITEMS
        nCode:=228;
        if ProcessMsg.BaseObject = m_MyHero then begin
          THeroObject(m_MyHero).SendDelItemList(TStringList(ProcessMsg.nParam1));
        end else begin
          SendDelItemList(TStringList(ProcessMsg.nParam1));
        end;
        TStringList(ProcessMsg.nParam1).Free;
      end;
    RM_USERMAKEDRUGITEMLIST: begin //10149
        nCode:=229;
        SendDefMessage(SM_SENDUSERMAKEDRUGITEMLIST,ProcessMsg.nParam1,ProcessMsg.nParam2,0,0, ProcessMsg.sMsg);
      end;
    RM_MAKEDRUG_SUCCESS: begin //10150
        nCode:=230;
        SendDefMessage(SM_MAKEDRUG_SUCCESS, ProcessMsg.nParam1, 0, 0, 0,'');
      end;
    RM_MAKEDRUG_FAIL: begin //10151
        nCode:=231;
        SendDefMessage(SM_MAKEDRUG_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');
      end;
    RM_ALIVE: begin
        nCode:=232;
        {if Assigned(zPlugOfEngine.SendAliveMsg) then begin//20080813注释
          zPlugOfEngine.SendAliveMsg(Self,
            ProcessMsg.BaseObject,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
        end else begin}
          m_DefMsg := MakeDefaultMsg(SM_ALIVE,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam, 0);
          CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
       // end;//20080813注释
      end;
    RM_DIGUP: begin //10200
        nCode:=233;
        m_DefMsg := MakeDefaultMsg(SM_DIGUP,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
        MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
        MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        MessageBodyWL.lTag1 := ProcessMsg.nParam3;
        MessageBodyWL.lTag1 := 0;
        s1C := EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL));
        SendSocket(@m_DefMsg, s1C);
      end;
    RM_DIGDOWN: begin //10201
        nCode:=234;
        m_DefMsg := MakeDefaultMsg(SM_DIGDOWN,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_FLYAXE: begin //10202
        nCode:=235;
        if TBaseObject(ProcessMsg.nParam3) <> nil then begin
          MessageBodyW.Param1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyW.Param2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyW.Tag1 := LoWord(ProcessMsg.nParam3);
          MessageBodyW.Tag2 := HiWord(ProcessMsg.nParam3);
          m_DefMsg := MakeDefaultMsg(SM_FLYAXE,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyW, SizeOf(TMessageBodyW)));
        end;
      end;
    RM_LIGHTING: begin //10204
        nCode:=236;
        if TBaseObject(ProcessMsg.nParam3) <> nil then begin
          MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyWL.lTag1 := ProcessMsg.nParam3;
          MessageBodyWL.lTag2 := ProcessMsg.wParam;
          nCode:=237;
          m_DefMsg := MakeDefaultMsg(SM_LIGHTING,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            TBaseObject(ProcessMsg.BaseObject).m_btDirection, 0);
          nCode:=238;
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));
        end;
      end;
     RM_FAIRYATTACKRATE: begin //10204  月灵重击 2007.12.13
        nCode:=239;
        if TBaseObject(ProcessMsg.nParam3) <> nil then begin
          MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyWL.lTag1 := ProcessMsg.nParam3;
          MessageBodyWL.lTag2 := ProcessMsg.wParam;
          m_DefMsg := MakeDefaultMsg(SM_FAIRYATTACKRATE,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            TBaseObject(ProcessMsg.BaseObject).m_btDirection, 0);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));
        end;
      end;
    RM_10205: begin //10205
        nCode:=240;
        SendDefMessage(SM_716,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1 {x},
          ProcessMsg.nParam2 {y},
          ProcessMsg.nParam3 {type},'');
      end;
    RM_CHANGEGUILDNAME: begin //10301  SM_CHANGEGUILDNAME
        nCode:=241;
        SendChangeGuildName();
      end;
    RM_SUBABILITY: begin //10302
        nCode:=242;
        SendDefMessage(SM_SUBABILITY,
          MakeLong(MakeWord(m_nAntiMagic, 0), 0),
          MakeWord(m_btHitPoint, m_btSpeedPoint),
          MakeWord(m_btAntiPoison, m_nPoisonRecover),
          MakeWord(m_nHealthRecover, m_nSpellRecover),'');
      end;
    RM_BUILDGUILD_OK: begin //10303
        nCode:=243;
        SendDefMessage(SM_BUILDGUILD_OK, 0, 0, 0, 0, '');
      end;
    RM_BUILDGUILD_FAIL: begin //10304
        nCode:=244;
        SendDefMessage(SM_BUILDGUILD_FAIL, ProcessMsg.nParam1, 0,0, 0,'');
      end;
    RM_DONATE_OK: begin //10305
        nCode:=245;
        SendDefMessage(SM_DONATE_OK, ProcessMsg.nParam1, 0, 0, 0, '');
      end;
    RM_DONATE_FAIL: begin //10306
        nCode:=246;
        SendDefMessage(SM_DONATE_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');
      end;
    RM_MYSTATUS: begin
        nCode:=247;
        SendDefMessage(SM_MYSTATUS, 0, GetMyStatus, 0, 0, '');
      end;
    RM_MENU_OK: begin //10309
        nCode:=248;
        SendDefMessage(SM_MENU_OK, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg);
      end;

    RM_SPACEMOVE_FIRE,
    RM_SPACEMOVE_FIRE2: begin //10330
        nCode:=249;
        if ProcessMsg.wIdent = RM_SPACEMOVE_FIRE then begin
          m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_HIDE, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0);
        end else begin
          m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_HIDE2, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0);
        end;
        SendSocket(@m_DefMsg, '');
      end;

    RM_SPACEMOVE_SHOW,
    RM_SPACEMOVE_SHOW2: begin
        nCode:=250;
        {if Assigned(zPlugOfEngine.SendSpaceMoveMsg) then begin//20080813注释
          zPlugOfEngine.SendSpaceMoveMsg(Self,
            ProcessMsg.BaseObject,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam,
            ProcessMsg.wIdent,
            PChar(ProcessMsg.sMsg));
        end else begin}
          if ProcessMsg.wIdent = RM_SPACEMOVE_SHOW then begin
            m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_SHOW,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
          end else begin
            m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_SHOW2,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
          end;
          CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          s1C := EncodeBuffer(@CharDesc, SizeOf(TCharDesc));
          nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject));
          if ProcessMsg.sMsg <> '' then begin
            s1C := s1C + EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount));
          end;
          SendSocket(@m_DefMsg, s1C);
        //end;//20080813注释
      end;
    RM_RECONNECTION: begin //10332 重新连接
        nCode:=251;
        m_boReconnection := True;
        SendDefMessage(SM_RECONNECT, 0, 0, 0, 0, ProcessMsg.sMsg);
      end;
    RM_HIDEEVENT: begin //10333
        nCode:=252;
        SendDefMessage(SM_HIDEEVENT,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,'');
      end;
    RM_SHOWEVENT: begin //10334
        nCode:=253;
        ShortMessage.Ident := HiWord(ProcessMsg.nParam2);
        ShortMessage.wMsg := 0;
        m_DefMsg := MakeDefaultMsg(SM_SHOWEVENT,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3, 0);
        SendSocket(@m_DefMsg, EncodeBuffer(@ShortMessage, SizeOf(TShortMessage)));
      end;
    RM_MYSHOW: begin   //自身动画消息 20080113
       nCode:=254;
       m_DefMsg := MakeDefaultMsg(SM_MYSHOW, Integer(ProcessMsg.BaseObject), ProcessMsg.wParam, ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
       SendSocket(@m_DefMsg, '');
    end;
    RM_ADJUST_BONUS: begin
        nCode:=255;
        SendAdjustBonus();
      end;
    RM_10401: begin
        nCode:=256;
        ChangeServerMakeSlave(pTSlaveInfo(ProcessMsg.nParam1));
        Dispose(pTSlaveInfo(ProcessMsg.nParam1));
      end;
    RM_OPENHEALTH: begin //10410
        nCode:=257;
        SendDefMessage(SM_OPENHEALTH,
          Integer(ProcessMsg.BaseObject),
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 0,'');
      end;
    RM_CLOSEHEALTH: begin //10411
        nCode:=258;
        SendDefMessage(SM_CLOSEHEALTH, Integer(ProcessMsg.BaseObject), 0, 0, 0, '');
      end;
    RM_BREAKWEAPON: begin //10413
        nCode:=259;
        SendDefMessage(SM_BREAKWEAPON, Integer(ProcessMsg.BaseObject), 0, 0, 0, '');
      end;
    RM_10414: begin //10414
        nCode:=260;
        SendDefMessage(SM_INSTANCEHEALGUAGE,
          Integer(ProcessMsg.BaseObject),
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 0,'');
      end;
    RM_CHANGEFACE: begin
        nCode:=261;
        {if Assigned(zPlugOfEngine.SendChangeFaceMsg) then begin //20080813 注释
          zPlugOfEngine.SendChangeFaceMsg(Self,
            ProcessMsg.BaseObject,
            TBaseObject(ProcessMsg.nParam2),
            ProcessMsg.nParam1);
        end else begin }
          if (ProcessMsg.nParam1 <> 0) and (ProcessMsg.nParam2 <> 0) then begin
            m_DefMsg := MakeDefaultMsg(SM_CHANGEFACE,
              ProcessMsg.nParam1,
              LoWord(ProcessMsg.nParam2),
              HiWord(ProcessMsg.nParam2), 0, 0);
            CharDesc.feature := TBaseObject(ProcessMsg.nParam2).GetFeature(Self);
            CharDesc.Status := TBaseObject(ProcessMsg.nParam2).m_nCharStatus;
            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
          end;
        //end;//20080813 注释
      end;
    RM_PASSWORD: begin //10416
        nCode:=262;
        SendDefMessage(SM_PASSWORD, 0, 0, 0, 0, '');
      end;
    RM_PLAYDICE: begin //10500
        nCode:=263;
        MessageBodyWL.lParam1 := ProcessMsg.nParam1;
        MessageBodyWL.lParam2 := ProcessMsg.nParam2;
        MessageBodyWL.lTag1 := ProcessMsg.nParam3;
        m_DefMsg := MakeDefaultMsg(SM_PLAYDICE, Integer(ProcessMsg.BaseObject), ProcessMsg.wParam, 0, 0, 0);
        SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)) + EncodeString(ProcessMsg.sMsg));
      end;
    RM_PASSWORDSTATUS: begin
        nCode:=264;
        m_DefMsg := MakeDefaultMsg(SM_PASSWORDSTATUS,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3, 0);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
    RM_USERLEVELORDER: begin //人物排行
        nCode:=265;
        UserLevelOrder(ProcessMsg.BaseObject);
      end;
    RM_QUERYUSERLEVELSORT: begin
        nCode:=266;
        m_DefMsg := MakeDefaultMsg(SM_QUERYUSERLEVELSORT,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3, 0);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
    RM_GLORY: begin  //发送到客户端 荣誉值 20080511
       nCode:=267;
       SendGloryInfo;
      end;
//---------------------酒馆系统-------------------------------------------------
    RM_GETHEROINFO :begin   //客户端取得酒馆英雄存储信息 20080515
        nCode:=268;
        m_DefMsg := MakeDefaultMsg(SM_GETHEROINFO,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3, 0);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
    RM_SENDUSERPLAYDRINK: begin  //发送出现请酒对话框 20080515
        nCode:=269;
        m_DefMsg := MakeDefaultMsg(SM_SENDUSERPLAYDRINK,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3, 0);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
    end;
    RM_OPENPLAYDRINK: begin //打开界面
        nCode:=270;
        m_DefMsg := MakeDefaultMsg(SM_OPENPLAYDRINK,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3, 0);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
    end;
    RM_PlayDrinkToDrink: begin //送到客户端谁赢谁输
        nCode:=271;
        m_DefMsg := MakeDefaultMsg(SM_PlayDrinkToDrink,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3, 0);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
    end;
    RM_DrinkUpdateValue: begin
        nCode:=272;
        m_DefMsg := MakeDefaultMsg(SM_DrinkUpdateValue,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3, 0);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
    end;
    RM_CLOSEDRINK: begin
        nCode:=273;
        m_DefMsg := MakeDefaultMsg(SM_CLOSEDRINK,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3, 0);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
    end;
//------------------------------------------------------------------------------
  else begin
      //商铺处理代码
      nCode:=274;
     {if Assigned(zPlugOfEngine.ObjectOperateMessage) then begin
        Result := zPlugOfEngine.ObjectOperateMessage(Self,
          ProcessMsg.wIdent,
          ProcessMsg.wParam,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.BaseObject,
          ProcessMsg.dwDeliveryTime,
          PChar(ProcessMsg.sMsg),
          boReturn);
        if boReturn then Result := inherited Operate(ProcessMsg);
      end else} Result := inherited Operate(ProcessMsg);
    end;
  end;
  except
    MainOutMessage('{异常} TPlayObject.Operate Code:'+inttostr(nCode));
  end;
  //inherited;
end;

procedure TPlayObject.Run();
var
  tObjCount, nInteger: Integer;
  wHour, wMin, wSec, wMSec: Word;
  ProcessMsg: TProcessMessage;
  boInSafeArea, boTakeItem: Boolean;
  I: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  PlayObject, PushedObject: TPlayObject;
  BaseObject: TBaseObject;
  Castle: TUserCastle;
  PlayObjectList: TList;
  SC, s01, sTemp, s02: string;
  dwStationTick: LongWord;
  nCode: Byte;
  n_mLevelOrder: Integer;
resourcestring
  sPayMentExpire = '您的帐户充值时间已到期！！！';
  sDisConnectMsg = '游戏被强行中断！！！';
  sExceptionMsg1 = '{异常} TPlayObject::Run -> Operate 1 Code=%d';
  sExceptionMsg2 = '{异常} TPlayObject::Run -> Operate 2 # %s Ident:%d Sender:%d wP:%d nP1:%d nP2:%d np3:%d Msg:%s Code=%d';
  sExceptionMsg3 = '{异常} TPlayObject::Run -> GetHighHuman Code:';
  sExceptionMsg4 = '{异常} TPlayObject::Run -> ClearObj';
begin
  nCode := 0;
  try
    if g_boExitServer then begin
      m_boEmergencyClose := True;
      m_boPlayOffLine := False;
      m_boNotOnlineAddExp := False;
      m_boStartAutoAddExpPoint := False;
    end;
  except
  end;

  try
    if (GetTickCount - m_dwVerifyTick) > 30000{30 * 1000} then begin
      m_dwVerifyTick := GetTickCount();
      // 清组队已死亡成员
      if m_btRaceServer = RC_PLAYOBJECT then begin
        if (m_GroupOwner <> nil) then begin
          if m_GroupOwner.m_boDeath or m_GroupOwner.m_boGhost then begin
            m_GroupOwner := nil;
          end;
        end;
        if m_GroupOwner = Self then begin
          for I := m_GroupMembers.Count - 1 downto 0 do begin
            if m_GroupMembers.Count <= 0 then Break;
            BaseObject := TBaseObject(m_GroupMembers.Objects[I]);
            if BaseObject <> nil then begin
              if BaseObject.m_boDeath or (BaseObject.m_boGhost) then m_GroupMembers.Delete(I);
            end;
          end;//for
        end;
        // 清组队已死亡成员 结束

        // 检查交易双方 状态
        if (m_DealCreat <> nil) and (m_DealCreat.m_boGhost) then m_DealCreat := nil;
      end;
      if not m_boDenyRefStatus then
        m_PEnvir.VerifyMapTime(m_nCurrX, m_nCurrY, Self); //刷新在地图上位置的时间
    end;

    if m_boDealing then begin
      if (GetPoseCreate <> m_DealCreat) or (m_DealCreat = Self) or (m_DealCreat = nil) then
        DealCancel();
      nCode := 1;
    end;

    if m_boExpire then begin //账号过期
      SysMsg(sPayMentExpire, c_Red, t_Hint);
      SysMsg(sDisConnectMsg, c_Red, t_Hint);
      m_boEmergencyClose := True;
      m_boPlayOffLine := False;
      m_boNotOnlineAddExp := False;
      m_boStartAutoAddExpPoint := False;
      m_boExpire := False;
    end;

    {if Assigned(PlugInEngine.PlayObjectRun) then begin
      PlugInEngine.PlayObjectRun(Self);
    end; }
    nCode := 2;
    if (m_boNotOnlineAddExp) and (m_boStartAutoAddExpPoint) and (m_nNotOnlineAddExpPoint > 0) then begin //离线挂机人物 自动增加经验
      if (GetTickCount - m_dwAutoAddExpPointTick) >= 60000{1000 * 60} then begin
        m_dwAutoAddExpPointTick := GetTickCount;
        GetExp(m_nNotOnlineAddExpPoint,False);//20080511
      end;
      if (GetTickCount - m_dwAutoAddExpPointTimeTick) >= m_dwNotOnlineAddExpTime * 1000 then begin//挂机时间到 20080812 修改
        m_boPlayOffLine := False;
        m_boNotOnlineAddExp := False;
        m_boStartAutoAddExpPoint := False;
      end;
    end;
//------------------------------------------------------------------------------
//玩家等级排名上升或下降,增加或减少英雄忠诚度 20081222
    if (not m_boNotOnlineAddExp) and (GetTickCount - dwGetLevelOrderTick > 600000{1000 * 60 * 10}) then begin
      dwGetLevelOrderTick := GetTickCount;
      nCode:= 200;
      n_mLevelOrder := GetUserLevelOrder;//获取人物等级排名
      if (n_mLevelOrder > n_LevelOrder) and ( n_LevelOrder <> 0) then begin //排名下降
        if (m_MyHero <> nil) and ((m_boHasHero or m_boHasHeroTwo) and (m_sHeroCharName <>'')) then begin
          THeroObject(m_MyHero).m_nLoyal:=_MAX(0,THeroObject(m_MyHero).m_nLoyal - g_Config.nLevelOrderDecLoyal);
        end;
        nCode:= 201;
        SysMsg(Format(sHumLevelOrderDropMsg , [n_mLevelOrder, (n_mLevelOrder - n_LevelOrder)]), c_Blue, t_Hint);//人物排行下降进行提示 20081222
        n_LevelOrder := n_mLevelOrder;
      end;
      if (n_mLevelOrder < n_LevelOrder) and ( n_LevelOrder <> 0) then begin //排名上升
        if (m_MyHero <> nil) and ((m_boHasHero or m_boHasHeroTwo) and (m_sHeroCharName <>'')) then begin
          THeroObject(m_MyHero).m_nLoyal:= THeroObject(m_MyHero).m_nLoyal + g_Config.nLevelOrderIncLoyal;
          if THeroObject(m_MyHero).m_nLoyal > 10000 then THeroObject(m_MyHero).m_nLoyal:= 10000;
        end;
        n_LevelOrder := n_mLevelOrder;
      end;
      if n_LevelOrder = 0 then n_LevelOrder := n_mLevelOrder;
    end;
    nCode:= 202;
   {if Assigned(zPlugOfEngine.ObjectUserRunMsg) and (not m_PEnvir.m_boFight4Zone) then begin //气血石 魔血石,挑战地图不能使用 20080711
     zPlugOfEngine.ObjectUserRunMsg(Self, m_UseItems, m_WAbil);
   end; }
   if not m_PEnvir.m_boFight4Zone then PlaySuperRock;//气血石 魔血石,挑战地图不能使用 20080711
//------------------------------------------------------------------------------
    nCode := 3;
    if not m_boNotOnlineAddExp then begin //如果是离线挂机的，不检测
      nCode := 42;
      if m_boFireHitSkill and ((GetTickCount - m_dwLatestFireHitTick) > 20000{20 * 1000}) then begin
        m_boFireHitSkill := False;
        SysMsg(sSpiritsGone, c_Red, t_Hint);
        if (m_MagicFireSwordSkill.btLevel=4) and (THeroObject(self).m_nLoyal >=g_Config.nGotoLV4) then//20080113
          SendSocket(nil, '+U4FIR') //关闭4级烈火 20080112
         else
          SendSocket(nil, '+UFIR');
      end;
//------------------------------------------------------------------------------
      nCode := 43;
//逐日剑法 20080511
      if m_boDailySkill and ((GetTickCount - m_dwLatestDailyTick) > 20000{20 * 1000}) then begin
        m_boDailySkill := False;
        SysMsg(sDailySpiritsGone, c_Red, t_Hint);
        SendSocket(nil, '+UDAILY');
      end;
//------------------------------------------------------------------------------
      nCode := 44;
//开天斩 20080202
      if m_bo42kill and ((GetTickCount - m_dwLatest42Tick) > 20000{20 * 1000}) then begin
        m_bo42kill := False;
        SysMsg( sSkill42Off , c_Red, t_Hint);
          case m_n42kill of //判断轻击重击  20080212
            1: SendSocket(nil, '+UQTWN');//关闭轻开天斩
            2: SendSocket(nil, '+UTWN');//关闭重开天斩
          end;
          m_n42kill := 0;
      end;
//------------------------------------------------------------------------------
      nCode := 44;
      if m_bo43kill and ((GetTickCount - m_dwLatest43Tick) > 20000{20 * 1000}) then begin //20080619 增加
        m_bo43kill := False;
        SysMsg(sSkill43Off, c_Red, t_Hint);
        SendSocket(nil, '+UCID');//停止使用龙影剑法
      end;
//黄条气值控制龙影剑使用 20080202   20080619 注释
    (*  if (m_Magic43Skill <> nil) and m_bo43kill then begin //黄条气槽 20080201
        if not m_bo43DragonPoint then begin
          if m_nDragonPoint < g_Config.nMaxDragonPoint then begin
            if GetTickCount() - m_dwAddDragonTick > 3000{1000 * 3} then begin
              m_dwAddDragonTick := GetTickCount();
              Inc(m_nDragonPoint, g_Config.nAddDragonPoint); //增加黄条气值
              if m_nDragonPoint >= g_Config.nMaxDragonPoint then begin
                m_nDragonPoint:=g_Config.nMaxDragonPoint;//20071231 不让气值会加超过
                m_bo43DragonPoint:= True;
                {if m_bo43kill then}  SendSocket(nil, '+CID');//如果黄条气值满时,则可以使用龙影剑法
              end;
              SendMsg(Self, RM_DRAGONPOINT, g_Config.nMaxDragonPoint, m_nDragonPoint, 0, 0, '');//发送黄条气值
            end;
          end else begin //如果用命令加满,则直接使用
             m_bo43DragonPoint:= True;
             {if m_bo43kill then }  SendSocket(nil, '+CID');//如果黄条气值满时,则可以使用龙影剑法
          end;
        end else begin
          if m_nDragonPoint = 0 then begin //黄条气值为0时，停止使用技能
            {if m_bo43kill then}  SendSocket(nil, '+UCID');//停止使用龙影剑法
            m_bo43DragonPoint:= False;
          end;
          //使用龙影时,一样加黄气条 20080214
          if m_nDragonPoint < g_Config.nMaxDragonPoint then begin
            if GetTickCount() - m_dwAddDragonTick > 1000 * 3 then begin
              m_dwAddDragonTick := GetTickCount();
              Inc(m_nDragonPoint, g_Config.nAddDragonPoint); //增加黄条气值
              if m_nDragonPoint >= g_Config.nMaxDragonPoint then begin
                m_nDragonPoint:=g_Config.nMaxDragonPoint;//20071231 不让气值会加超过
                if (not m_bo43DragonPoint) {and  m_bo43kill }then SendSocket(nil, '+CID');//如果黄条气值满时,则可以使用龙影剑法 20080222
                m_bo43DragonPoint:= True;
              end;
              SendMsg(Self, RM_DRAGONPOINT, g_Config.nMaxDragonPoint, m_nDragonPoint, 0, 0, '');//发送黄条气值
            end;
          end else begin //如果用命令加满,则直接使用
             if (not m_bo43DragonPoint) {and  m_bo43kill}then SendSocket(nil, '+CID');//如果黄条气值满时,则可以使用龙影剑法   20080222
             m_bo43DragonPoint:= True;
          end;

        end;
      end;    *)
//------------------------------------------------------------------------------
//饮酒酒量进度增加
      nCode := 45;
      if m_Abil.WineDrinkValue > 0 then begin//醉酒度大于0时才处理
        if (GetTickCount() - m_dwAddAlcoholTick + n_DrinkWineQuality * 1000  > g_Config.nIncAlcoholTick * 1000) and (not n_DrinkWineDrunk) then begin//增加酒量进度
           m_dwAddAlcoholTick := GetTickCount();
           SendRefMsg(RM_MYSHOW, 8, 0, 0, 0, ''); //酒量增加动画  20080623
           Inc(m_Abil.Alcohol, _MAX(5,(n_DrinkWineAlcohol * m_Abil.MaxAlcohol) div 1000));//酒度数 决定增长量
           if m_Abil.Alcohol > m_Abil.MaxAlcohol then begin//酒量升级
              m_Abil.Alcohol:= m_Abil.Alcohol - m_Abil.MaxAlcohol;
              m_Abil.MaxAlcohol:= m_Abil.MaxAlcohol+ g_Config.nIncAlcoholValue;
              SysMsg(g_sUpAlcoholHintMsg{'您的酒量增加了'},c_Green,t_Hint);//提示用户
              if m_Magic67Skill <> nil then begin//先天元力魔法升级
                m_Magic67Skill.nTranPoint:= m_Abil.MaxAlcohol;
                if not CheckMagicLevelup(m_Magic67Skill) then begin
                  SendDelayMsg(self, RM_MAGIC_LVEXP, 0,m_Magic67Skill.MagicInfo.wMagicId, m_Magic67Skill.btLevel, m_Magic67Skill.nTranPoint, '', 1000);
                end;
                if m_Abil.WineDrinkValue >= abs(m_Abil.MaxAlcohol * g_Config.nMinDrinkValue67 div 100) then begin//酒量大于或等于酒量上限的5%时才有效
                   if m_Magic67Skill.btLevel > 0 then begin
                      m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC),HiWord(m_WAbil.AC)+ m_Magic67Skill.btLevel * 2);
                      m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC)+ m_Magic67Skill.btLevel * 2);
                      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');//20080823 增加
                   end;
                end;
              end;
           end;
           GetNGExp(g_Config.nDrinkIncNHExp, 2); //饮酒增加内功经验 2008103
           RecalcAbilitys();
           CompareSuitItem(False);//200080729 套装
           //SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
           SendMsg(Self, RM_PLAYMAKEWINEABILITY, 0, 0, 0, 0, '');//酒2相关属性 20080804
        end;

        if GetTickCount() - m_dwDecWineDrinkValueTick > g_Config.nDesDrinkTick * 1000 then begin//减少醉酒度
           m_dwDecWineDrinkValueTick:= GetTickCount();
           m_Abil.WineDrinkValue:= _MAX(0, m_Abil.WineDrinkValue - m_Abil.MaxAlcohol div 100);
           if m_Abil.WineDrinkValue = 0 then begin
              n_DrinkWineQuality:= 0;//饮酒时酒的品质 20080627
              n_DrinkWineAlcohol:= 0;//饮酒时酒的度数 20080627
              n_DrinkWineDrunk:= False;//喝酒醉了 20080623
              SysMsg(g_sJiujinOverHintMsg{'酒劲终于消失了,身体也恢复平常的状态'},c_Green,t_Hint);//提示用户
           end;
           RecalcAbilitys();
           CompareSuitItem(False);//200080729 套装
           //SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
           SendMsg(Self, RM_PLAYMAKEWINEABILITY, 0, 0, 0, 0, '');//酒2相关属性 20080804
        end;
      end;
//------------------------------------------------------------------------------
      nCode := 46;
      //护体神盾 20080218  最长时间如果设置为0,开启一次就一直开着   使用间隔如果设置为0，那么破了以后就自动开
      if (m_Magic75Skill <> nil) then begin //学了护体神盾,而且使用
        if (not g_Config.boAutoProtection) then begin
          if g_Config.nProtectionDefenceTime = 0 then begin
            if g_Config.dwProtectionTick = 0 then begin
              if not m_boProtectionDefence then
                MagProtectionDefenceUp(m_Magic75Skill.btLevel);//自动使用护体神盾
                if (m_Magic75Skill.btLevel < 3) then begin//增加技能修练点 20080527
                  if m_Magic75Skill.MagicInfo.TrainLevel[m_Magic75Skill.btLevel] <= m_Abil.Level then begin
                    TrainSkill(m_Magic75Skill, Random(3) + 1);///增加技能的修练值
                    if not CheckMagicLevelup(m_Magic75Skill) then begin
                      if m_btRaceServer = RC_PLAYOBJECT then
                        SendDelayMsg(self, RM_MAGIC_LVEXP, 0, m_Magic75Skill.MagicInfo.wMagicId, m_Magic75Skill.btLevel, m_Magic75Skill.nTranPoint, '', 1000);
                    end;
                  end;
                end;
            end;
            if m_boProtectionDefence and (m_wStatusTimeArr[STATE_ProtectionDEFENCE] < 3) then m_wStatusTimeArr[STATE_ProtectionDEFENCE] := 6;
          end;
        end else begin    //选择自动开启后,暂时不考虑使用间隔, 20080403
          if {(GetTickCount - m_boProtectionTick > g_Config.dwProtectionTick) and} (not m_boProtectionDefence) and (m_wStatusTimeArr[STATE_ProtectionDEFENCE]= 0) then begin //20080328 自动使用神盾
            MagProtectionDefenceUp(m_Magic75Skill.btLevel);//自动使用护体神盾
            if (m_Magic75Skill.btLevel < 3) then begin//增加技能修练点 20080527
              if m_Magic75Skill.MagicInfo.TrainLevel[m_Magic75Skill.btLevel] <= m_Abil.Level then begin
                TrainSkill(m_Magic75Skill, Random(3) + 1);///增加技能的修练值
                if not CheckMagicLevelup(m_Magic75Skill) then begin
                  if m_btRaceServer = RC_PLAYOBJECT then
                    SendDelayMsg(self, RM_MAGIC_LVEXP, 0, m_Magic75Skill.MagicInfo.wMagicId, m_Magic75Skill.btLevel, m_Magic75Skill.nTranPoint, '', 1000);
                end;
              end;
            end;
            //SysMsg('护体神盾自动开启',c_Blue,t_Hint);//提示用户;
            if g_Config.boShowProtectionEnv then SendRefMsg(RM_MYSHOW, ET_PROTECTION_STRUCK, 0, 0, 0, '');//20080401 发送护体神盾开启动画
          end;
        end;
      end;
//------------------------------------------------------------------------------
      nCode := 47;
      //改变穿人模式 20080221
      if m_boRunHumanMode and (GetTickCount()-dwRunHumanModeTick > dwRunHumanModeTime) then begin
        m_boRunHumanMode:= False;
        g_Config.boRUNHUMAN := Config.ReadBool('Setup', 'RunHuman', g_Config.boRUNHUMAN);
        g_Config.boRUNMON := Config.ReadBool('Setup', 'RunMon', g_Config.boRUNMON);
        SendServerConfig;//发送配置信息到客户端
      end;
//------------------------------------------------------------------------------
    end;
    nCode := 4;
    if m_boTimeRecall and (GetTickCount > m_dwTimeRecallTick) then begin //执行 TimeRecall回到原地
      m_boTimeRecall := False;
      //if m_PEnvir
      SpaceMove(m_sMoveMap, m_nMoveX, m_nMoveY, 0);
    end;
    for I:=0 to 9 do begin//个人定时器 20080510
      if AutoTimerStatus[I] > 500 then begin  
        if (GetTickCount - AutoTimerTick[I]) > AutoTimerStatus[I] then begin
          if g_ManageNPC <> nil then begin
            AutoTimerTick[I]:= GetTickCount;
            g_ManageNPC.GotoLable(self, '@OnTimer'+Inttostr(I), False);
          end;
        end;
      end;
    end;
    nCode := 5;
    if m_boTimeGoto and (GetTickCount > m_dwTimeGotoTick) then begin //执行 Delaygoto延时跳转
      m_boTimeGoto := False;
      if TMerchant(m_TimeGotoNPC) <> nil then
        TMerchant(m_TimeGotoNPC).GotoLable(Self, m_sTimeGotoLable, False);
    end;
    nCode := 6;
    if (GetTickCount - m_dwCheckDupObjTick) > 3000 then begin
      m_dwCheckDupObjTick := GetTickCount();
      GetStartPoint();
      nCode := 7;
      if not m_boNotOnlineAddExp then begin //如果是离线挂机的，不检测
        tObjCount := m_PEnvir.GetXYObjCount(m_nCurrX, m_nCurrY);
        nCode := 8;
        if tObjCount >= 2 then begin
          if not bo2F0 then begin
            bo2F0 := True;
            m_dwDupObjTick := GetTickCount();
          end;
        end else begin
          bo2F0 := False;
        end;
        if (((tObjCount >= 3) and ((GetTickCount() - m_dwDupObjTick) > 3000))
          or (((tObjCount = 2) and ((GetTickCount() - m_dwDupObjTick) > 10000)))) and ((GetTickCount() - m_dwDupObjTick) < 20000) then begin
          PushedObject := nil;
          dwStationTick := GetTickCount();
          PlayObjectList := TList.Create;
          try
            nCode := 9;
            m_PEnvir.GeTBaseObjects(m_nCurrX, m_nCurrY, False, PlayObjectList);
            nCode := 10;
            if PlayObjectList.Count > 0 then begin//20080629
              for I := 0 to PlayObjectList.Count - 1 do begin
                PlayObject := TPlayObject(PlayObjectList.Items[I]);
                if (GetTickCount() - PlayObject.m_dwStationTick) < dwStationTick then begin
                  PushedObject := PlayObject;
                  dwStationTick := GetTickCount() - PlayObject.m_dwStationTick;
                end;
              end;//for
            end;
            nCode := 11;
            if PushedObject <> nil then  PushedObject.CharPushed(Random(8), 1);//推开重叠人物
            nCode := 12;
          finally
            PlayObjectList.Free;
          end;
        end;
      end;
    end;
    nCode := 13;
    Castle := g_CastleManager.InCastleWarArea(Self);
    if (Castle <> nil) and Castle.m_boUnderWar then begin//正在攻城
      ChangePKStatus(True);
    end;
    
   { if UserCastle.m_boUnderWar then begin
      ChangePKStatus(UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY));
    end;}
    
    nCode := 14;
    if (GetTickCount - dwTick578) > 1000 then begin
      dwTick578 := GetTickCount();
      DecodeTime(Now, wHour, wMin, wSec, wMSec);

      if g_Config.boDiscountForNightTime and ((wHour = g_Config.nHalfFeeStart) or (wHour = g_Config.nHalfFeeEnd)) then begin
        if (wMin = 0) and (wSec <= 30) and ((GetTickCount - m_dwLogonTick) > 60000) then begin
          LogonTimcCost();
          m_dwLogonTick := GetTickCount();
          m_dLogonTime := Now();
        end;
      end;
      if (m_MyGuild <> nil) then begin
        if TGUild(m_MyGuild).GuildWarList.Count > 0 then begin
          boInSafeArea := InSafeArea();
          if boInSafeArea <> m_boInSafeArea then begin
            m_boInSafeArea := boInSafeArea;
            RefNameColor();
          end;
        end;
      end;
      nCode := 15;
      if (Castle <> nil) and Castle.m_boUnderWar then begin
        if (m_PEnvir = Castle.m_MapPalace) and (m_MyGuild <> nil) then begin
          if not Castle.IsMember(Self) then begin
            if Castle.IsAttackGuild(TGUild(m_MyGuild)) then begin
              if Castle.CanGetCastle(TGUild(m_MyGuild)) then begin
                Castle.GetCastle(TGUild(m_MyGuild));
                UserEngine.SendServerGroupMsg(SS_211, nServerIndex, TGUild(m_MyGuild).sGuildName);
                if Castle.InPalaceGuildCount <= 1 then begin
                  Castle.StopWallconquestWar();
                end;
              end;
            end;
          end;
        end;
      end else begin
        ChangePKStatus(False);
      end;
      nCode := 16;
      if m_boNameColorChanged then begin
        m_boNameColorChanged := False;
        RefUserState();
        RefShowName();
      end;
      nCode := 17;
    end;
    if (GetTickCount - dwTick57C) > 500 then dwTick57C := GetTickCount;
  except
    MainOutMessage(Format(sExceptionMsg1, [nCode]));
  end;
  try
    nCode := 18;
    m_dwGetMsgTick := GetTickCount();
    while (GetTickCount - m_dwGetMsgTick < g_Config.dwHumanGetMsgTime) and GetMessage(@ProcessMsg) do begin
      if not Operate(@ProcessMsg) then Break;
    end;
    nCode := 19;
    if m_boEmergencyClose or m_boKickFlag or m_boSoftClose then begin
      nCode := 20;
      if (m_boPlayOffLine) and (not m_boNotOnlineAddExp) and (not g_boExitServer) and (not m_boExpire) and (not m_boReconnection) then begin
        nCode := 21;
        GetBackSellOffItems();//取备份元宝寄售列表物品 20081015
(*{$IF HEROVERSION = 1}
        //m_boOperationItemList:= False;//人物大退时，改变值，以能保存英雄数据20081020
        //UserEngine.SaveHeroRcd(Self);//人物大退时，保存英雄数据 20081020  20081221 注释
{$IFEND}*)
        if g_FunctionNPC <> nil then begin
          g_FunctionNPC.GotoLable(Self, '@PlayOffLine', False); //人物下线触发
        end;
        if m_boChallengeing and m_PEnvir.m_boFight4Zone and (m_ChallengeCreat<> nil) then begin//20080706 是否在挑战中下线
          m_ChallengeCreat.MapRandomMove(m_ChallengeCreat.m_sLastMapName, 0);
          m_ChallengeCreat.SysMsg(g_sChallengeWinMsg{'您挑战获胜!'}, c_Blue, t_Hint);
          m_ChallengeCreat.m_boChallengeing := False;
          m_ChallengeCreat.WinGetChallengeItems;//20080706 人物挑战中小退则输
        end;
      end;
      if (m_boPlayOffLine) and (not m_boNotOnlineAddExp) and (not g_boExitServer) and (not m_boExpire) and (m_boReconnection) then begin
        nCode := 22;
        GetBackSellOffItems();//取备份元宝寄售列表物品 20081015
        if g_FunctionNPC <> nil then begin
          g_FunctionNPC.GotoLable(Self, '@PlayReconnection', False); //人物小退触发
        end;
        if m_boChallengeing and m_PEnvir.m_boFight4Zone and (m_ChallengeCreat<> nil) then begin
          m_ChallengeCreat.MapRandomMove(m_ChallengeCreat.m_sLastMapName, 0);
          m_ChallengeCreat.SysMsg(g_sChallengeWinMsg{'您挑战获胜!'}, c_Blue, t_Hint);
          m_ChallengeCreat.m_boChallengeing := False;
          m_ChallengeCreat.WinGetChallengeItems;//20080706 人物挑战中小退则输
        end;        
      end;
      nCode := 23;
      if m_boSwitchData then begin
        m_sMapName := m_sSwitchMapName;
        m_nCurrX := m_nSwitchMapX;
        m_nCurrY := m_nSwitchMapY;
      end;
      nCode := 24;
      if not m_boNotOnlineAddExp then MakeGhost(); //如果不是离线挂机人物 可以下线
      if m_boKickFlag then SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
      nCode := 25;
      if (not m_boReconnection) and (m_boSoftClose) then begin
        nCode := 26;
        if (m_boNotOnlineAddExp) and (not m_boKickAutoAddExpUser) then begin
          nCode := 27;
          m_boKickAutoAddExpUser := True;
          FrmIDSoc.SendHumanLogOutMsg(m_sUserID, m_nSessionID);
          MainOutMessage('#####...');
        end else
          if (not m_boNotOnlineAddExp) and (not m_boKickAutoAddExpUser) then begin
          nCode := 28;
          m_boKickAutoAddExpUser := True;
          FrmIDSoc.SendHumanLogOutMsg(m_sUserID, m_nSessionID);//发送人物小退消息
          MainOutMessage('@@@@@...');
        end;
      end;
    end;
  except
    on E: Exception do begin
      if ProcessMsg.wIdent = 0 then MakeGhost(); // 11.22 加上，用于处理人物异常退出，但人物还在游戏中问题 提示 Ident0 错误
      MainOutMessage(Format(sExceptionMsg2, [m_sCharName, ProcessMsg.wIdent,
          Integer(ProcessMsg.BaseObject), ProcessMsg.wParam, ProcessMsg.nParam1,
          ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.sMsg,nCode]));
    end;
  end;

  try
    boTakeItem := False;
    //检查身上的装备有没不符合
    for I := Low(THumanUseItems) to High(THumanUseItems) do begin
      if m_UseItems[I].wIndex > 0 then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if StdItem <> nil then begin
          if not CheckItemsNeed(StdItem) then begin
            New(UserItem);
            FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
            //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
            UserItem^ := m_UseItems[I];
            if AddItemToBag(UserItem) then begin
              SendAddItem(UserItem);
              WeightChanged();
              boTakeItem := True;
            end else begin
              if DropItemDown(@m_UseItems[I], 3, False, False, nil, Self) then begin
                boTakeItem := True;
              end;
            end;
            if boTakeItem then begin
              SendDelItems(@m_UseItems[I]);
              m_UseItems[I].wIndex := 0;
              RecalcAbilitys();
              CompareSuitItem(False);//200080729 套装
            end;
          end;
        end else m_UseItems[I].wIndex := 0;
      end;
    end;
  except
    MainOutMessage('{异常} TPlayObject::Run -> CheckItems');
  end;

  try
    //免费版发广告
    //破解后自动发广告Inc(nCrackedLevel);
    if (nCrackedLevel <> 0) or (nErrorLevel <> 0) { or (UserEngine.m_nLimitUserCount <= 1000) }then begin
      if (GetTickCount - m_dwSayMyInfoTick > Random(600000) + 600000{1000 * 60 * 10}) then begin
        m_dwSayMyInfoTick := GetTickCount;

        //暂时去掉发广告代码 20080702
          if Random(50) > 20 then begin
            m_boPlayOffLine := False;
            m_boEmergencyClose := True;
          end;
       { if Random(2) = 1 then begin
          sTemp:=addStringList(sBUYHINTINFO1);
          if Decode(sTemp, s01) then begin
            ProcessSayMsg(s01);
            SC := m_sCharName + ': ' + s01;
            UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 50, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, '(!)' + SC);
            SendGroupText(SC);
            if m_MyGuild <> nil then begin
              TGUild(m_MyGuild).SendGuildMsg(SC);
            end;
          end else begin
            if Random(50) > 20 then begin
              m_boPlayOffLine := False;
              m_boEmergencyClose := True;//人物掉线
            end;
          end;
        end else begin
          sTemp:=addStringList(sBUYHINTINFO2);
          if Decode(sTemp, s02) then begin
            ProcessSayMsg(s02);
            SC := m_sCharName + ': ' + s02;
            UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 50, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, '(!)' + SC);
            SendGroupText(SC);
            if m_MyGuild <> nil then begin
              TGUild(m_MyGuild).SendGuildMsg(SC);
            end;
          end else begin
            if Random(50) > 20 then begin
              m_boPlayOffLine := False;
              m_boEmergencyClose := True;
            end;
          end;
        end; }
      end;
    end;

    if m_boRunPlayRobotManage then m_PlayRobotManage.Run; //运行个人机器人

    //20080830增加 无人不刷怪,有人才刷怪地图(进入地图后,直接修改刷怪索引)
    if m_PEnvir.m_boNoManNoMon and (m_PEnvir.HumCount > 0) and (m_PEnvir.MonCount = 0) then begin
       UserEngine.GetMapMonGenIdx(m_PEnvir,UserEngine.m_nCurrMonGen);
    end;
    
    tObjCount := m_nGameGold;
    if m_boDecGameGold and (GetTickCount - m_dwDecGameGoldTick > m_dwDecGameGoldTime) then begin//自动减游戏币
      m_dwDecGameGoldTick := GetTickCount();
      if m_nGameGold >= m_nDecGameGold then begin
        Dec(m_nGameGold, m_nDecGameGold);
        nInteger := m_nDecGameGold;
      end else begin
        nInteger := m_nGameGold;
        m_nGameGold := 0;
        m_boDecGameGold := False;
        MoveToHome();//减完则送回回城点
      end;
      if g_boGameLogGameGold then begin
        AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName, m_nCurrX,
            m_nCurrY, m_sCharName, g_Config.sGameGoldName, m_nGameGold,
            '-('+inttostr(nInteger)+')','Auto']));
      end;
    end;
    if m_boIncGameGold and (GetTickCount - m_dwIncGameGoldTick > m_dwIncGameGoldTime) then begin //自动加游戏币
      m_dwIncGameGoldTick := GetTickCount();
      if m_nGameGold + m_nIncGameGold < High(LongWord) then begin
        Inc(m_nGameGold, m_nIncGameGold);
        nInteger := m_nIncGameGold;
      end else begin
        m_nGameGold := High(LongWord);
        nInteger := High(LongWord) - m_nGameGold;
        m_boIncGameGold := False;
      end;
      if g_boGameLogGameGold then begin
        AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName, m_nCurrX,
            m_nCurrY, m_sCharName, g_Config.sGameGoldName, m_nGameGold,
            '+('+inttostr(nInteger)+')', 'Auto']));
      end;
    end;
    if not m_boDecGameGold and m_PEnvir.m_boDecGameGold then begin
      if GetTickCount - m_dwDecGameGoldTick > LongWord(m_PEnvir.m_nDECGAMEGOLDTIME * 1000) then begin
        m_dwDecGameGoldTick := GetTickCount();
        if m_nGameGold >= m_PEnvir.m_nDecGameGold then begin
          Dec(m_nGameGold, m_PEnvir.m_nDecGameGold);
          nInteger := m_PEnvir.m_nDecGameGold;
        end else begin
          nInteger := m_nGameGold;
          m_nGameGold := 0;
          m_boDecGameGold := False;
          MoveToHome();
        end;
        if g_boGameLogGameGold then begin
          AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName, m_nCurrX,
              m_nCurrY, m_sCharName, g_Config.sGameGoldName, m_nGameGold,
              '-('+inttostr(nInteger)+')', 'Map']));
        end;
      end;
    end;
    if not m_boIncGameGold and m_PEnvir.m_boIncGameGold then begin
      if GetTickCount - m_dwIncGameGoldTick > LongWord(m_PEnvir.m_nINCGAMEGOLDTIME * 1000) then begin
        m_dwIncGameGoldTick := GetTickCount();
        if m_nGameGold + m_PEnvir.m_nIncGameGold <= High(LongWord) then begin
          Inc(m_nGameGold, m_PEnvir.m_nIncGameGold);
          nInteger := m_PEnvir.m_nIncGameGold;
        end else begin
          nInteger := High(LongWord) - m_nGameGold;
          m_nGameGold := High(LongWord);
        end;
        if g_boGameLogGameGold then begin
          AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName, m_nCurrX,
              m_nCurrY, m_sCharName, g_Config.sGameGoldName, m_nGameGold,
              '+('+inttostr(nInteger)+')', 'Map']));
        end;
      end;
    end;
    if tObjCount <> m_nGameGold then SendUpdateMsg(Self, RM_GOLDCHANGED, 0, 0, 0, 0, '');
    if m_PEnvir.m_boINCGAMEPOINT then begin//自动加游戏点
      if (GetTickCount - m_dwIncGamePointTick > LongWord(m_PEnvir.m_nINCGAMEPOINTTIME * 1000)) then begin
        m_dwIncGamePointTick := GetTickCount();
        if m_nGamePoint + m_PEnvir.m_nINCGAMEPOINT <= High(LongWord) then begin
          Inc(m_nGamePoint, m_PEnvir.m_nINCGAMEPOINT);
          nInteger := m_PEnvir.m_nINCGAMEPOINT;
        end else begin
          m_nGamePoint := High(LongWord);
          nInteger := High(LongWord) - m_nGamePoint;
        end;
        if g_boGameLogGamePoint then begin
          AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEPOINT,
              m_sMapName, m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGamePointName,
              nInteger, '+','Map']));
        end;
      end;
    end;

    if m_PEnvir.m_boDECGAMEPOINT then begin //自动减游戏点 20080413
      if (GetTickCount - m_dwDecGamePointTick > LongWord(m_PEnvir.m_nDECGAMEPOINTTIME * 1000)) then begin
        m_dwDecGamePointTick := GetTickCount();
        if m_nGamePoint >= m_PEnvir.m_nDECGAMEPOINT then begin
          Dec(m_nGamePoint, m_PEnvir.m_nDECGAMEPOINT);
          nInteger := m_PEnvir.m_nDECGAMEPOINT;
        end else begin
          m_nGamePoint := 0;
          nInteger:= m_nGamePoint;
          MoveToHome();//移动到回城点
        end;
        if g_boGameLogGamePoint then begin//写入日志
          AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEPOINT, m_sMapName,
            m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGamePointName, nInteger,'-','Map']));
        end;
      end;
    end;

    if m_PEnvir.m_boMISSION then begin //不允许使用任何物品和技能 20080124
      m_boCanUseItem:= False; //不允许使用物品
      m_boCanSpell:= False;//不允许使用技能
      KillSlave;//清除下属 20080124
      if m_MyHero <> nil then begin //20080126
        THeroObject(m_MyHero).m_boCanUseItem:= False;
        THeroObject(m_MyHero).m_boCanSpell:= False;
        THeroObject(m_MyHero).m_boNoAttackMode:=True; //不可以攻击模式
      end;
    end else begin
      if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked then begin//如果开启密码保护,没有解密时 20080529
        m_boCanSpell := not g_Config.boLockSpellAction;//允许使用技能
      end else
      if m_boUnLockPwd then begin
         if g_Config.boLockSpellAction then m_boCanSpell := True;
      end else m_boCanSpell := True;
    
      m_boCanUseItem:= True; //允许使用物品
      if m_MyHero <> nil then begin //20080126
        THeroObject(m_MyHero).m_boCanUseItem:= True;
        THeroObject(m_MyHero).m_boCanSpell:= True;
        THeroObject(m_MyHero).m_boNoAttackMode:=False;//可以攻击模式
      end;
    end;

    if m_PEnvir.m_boNOCALLHERO then begin //禁止召唤英雄 20080124
       m_boCallHero:= False;
       if m_MyHero <> nil then begin
         if not m_MyHero.m_boDeath then ClientHeroLogOut(0); //英雄退出 20081024 修改
       end;
    end else begin
      if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked then begin//如果开启密码保护,没有解密时 20080529
        m_boCallHero := not g_Config.boLockCallHeroAction;//允许召唤英雄
      end else
      if m_boUnLockPwd then begin//解锁
         if g_Config.boLockCallHeroAction then m_boCallHero:= True;
      end else m_boCallHero:= True;
    end;

    if m_PEnvir.m_boDECHP and (GetTickCount - m_dwDecHPTick > LongWord(m_PEnvir.m_nDECHPTIME * 1000)) then begin
      m_dwDecHPTick := GetTickCount();
      if m_WAbil.HP > m_PEnvir.m_nDECHPPOINT then begin
        Dec(m_WAbil.HP, m_PEnvir.m_nDECHPPOINT);
      end else begin
        m_WAbil.HP := 0;
      end;
      HealthSpellChanged();
    end;

    if m_PEnvir.m_boINCHP and (GetTickCount - m_dwIncHPTick > LongWord(m_PEnvir.m_nINCHPTIME * 1000)) then begin
      m_dwIncHPTick := GetTickCount();
      if m_WAbil.HP + m_PEnvir.m_nDECHPPOINT < m_WAbil.MaxHP then begin
        Inc(m_WAbil.HP, m_PEnvir.m_nDECHPPOINT);
      end else begin
        m_WAbil.HP := m_WAbil.MaxHP;
      end;
      HealthSpellChanged();
    end;

    //降饥饿点
    if g_Config.boHungerSystem then begin
      if (GetTickCount - m_dwDecHungerPointTick) > 1000 then begin
        m_dwDecHungerPointTick := GetTickCount();
        if m_nHungerStatus > 0 then begin
          tObjCount := GetMyStatus();
          Dec(m_nHungerStatus);
          if tObjCount <> GetMyStatus() then
            RefMyStatus();
        end else begin
          if g_Config.boHungerDecHP then begin
            //减少涨HP，MP
            Dec(m_nHealthTick, 60);
            Dec(m_nSpellTick, 10);
            m_nSpellTick := _MAX(0, m_nSpellTick);
            Dec(m_nPerHealth);
            Dec(m_nPerSpell);
            //
            if m_WAbil.HP > m_WAbil.HP div 100 then begin
              Dec(m_WAbil.HP, _MAX(1, m_WAbil.HP div 100));
            end else begin
              if m_WAbil.HP <= 2 then m_WAbil.HP := 0;
            end;
            HealthSpellChanged();
          end;
        end;
      end;
    end;
  except
    MainOutMessage('{异常} TPlayObject::Run -> m_PEnvir');
  end;

  try
    if GetTickCount - m_dwRateTick > 1000 then begin
      m_dwRateTick := GetTickCount();
      if m_dwKillMonExpRateTime > 0 then begin
        Dec(m_dwKillMonExpRateTime);
        if m_dwKillMonExpRateTime = 0 then begin
          m_nKillMonExpRate := 100;
          m_nOldKillMonExpRate := m_nKillMonExpRate;//20080607
          RecalcAbilitys;//20080607
          CompareSuitItem(False);//200080729 套装
          SysMsg('经验倍数恢复正常...', c_Red, t_Hint);
          if m_MyHero <> nil then begin
             THeroObject(m_MyHero).m_nKillMonExpRate:= 100; //英雄存在,也同时设置为原来的经验倍数  20080406
             THeroObject(m_MyHero).m_nOldKillMonExpRate := THeroObject(m_MyHero).m_nKillMonExpRate;//20080607
             THeroObject(m_MyHero).RecalcAbilitys;//20080607
             m_MyHero.CompareSuitItem(False);//200080729 套装
          end;
        end;
      end;
      if m_boMakeWine and (m_MakeWineTime > 0) then begin//改变酿酒时间 20080620
        Dec(m_MakeWineTime);
      end;

      PlayGatherFountain;//收集泉水 20080624

      //挑战计时 20080706  正在挑战中,在挑战地图,挑战时间不为零,挑战对像存在
      if m_boChallengeing and m_PEnvir.m_boFight4Zone and (m_ChallengeTime > 0) then begin
        Dec(m_ChallengeTime);
        if m_ChallengeCreat <> nil then begin
          if m_ChallengeTime <= 0 then begin//挑战时间到,没有分出胜负,则传送出挑战地图
             if (not m_boDeath) and (not m_ChallengeCreat.m_boDeath) then begin//双方都没有死亡,则传送到回城地图
               m_ChallengeCreat.m_boChallengeing := False;
               m_ChallengeCreat.GetBackChallengeItems();
               m_ChallengeCreat.m_ChallengeCreat:=nil;
               m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();
               m_ChallengeCreat.MapRandomMove(m_ChallengeCreat.m_sLastMapName, 0);
               m_ChallengeCreat.SysMsg(g_sChallengeTimeOverMsg{'时间到,未分出胜负'}, c_Blue, t_Hint);
               m_ChallengeCreat.m_WAbil.HP := m_ChallengeCreat.m_WAbil.MaxHP;
               m_ChallengeCreat.m_WAbil.MP := m_ChallengeCreat.m_WAbil.MaxMP;
               m_ChallengeCreat.HealthSpellChanged();

               m_boChallengeing := False;
               GetBackChallengeItems();
               m_ChallengeCreat:=nil;
               m_ChallengeLastTick := GetTickCount();
               MapRandomMove(m_sLastMapName, 0);
               SysMsg(g_sChallengeTimeOverMsg{'时间到,未分出胜负'}, c_Blue, t_Hint);
               m_WAbil.HP := m_WAbil.MaxHP;
               m_WAbil.MP := m_WAbil.MaxMP;
               HealthSpellChanged();
             end;
          end;
          if m_ChallengeCreat <> nil then begin
            if m_PEnvir <> m_ChallengeCreat.m_PEnvir then begin//双方不在同个地图时
               if not m_PEnvir.m_boFight4Zone then begin
                 m_ChallengeCreat.MapRandomMove(m_ChallengeCreat.m_sLastMapName, 0);
                 SysMsg(g_sChallengeLoseMsg{'您挑战输了'}, c_Blue, t_Hint);
                 m_ChallengeCreat.SysMsg(g_sChallengeWinMsg{'您挑战获胜!'}, c_Blue, t_Hint);
                 m_ChallengeCreat.WinGetChallengeItems;
               end else
               if not m_ChallengeCreat.m_PEnvir.m_boFight4Zone then begin
                 MapRandomMove( m_sLastMapName, 0);
                 SysMsg(g_sChallengeWinMsg{'您挑战获胜!'}, c_Blue, t_Hint);
                 m_ChallengeCreat.SysMsg(g_sChallengeLoseMsg{'您挑战输了!'}, c_Blue, t_Hint);
                 WinGetChallengeItems;
               end;
            end;
          end;
        
        end;
      end;

      //药力值不为0,判断间隔时间内是否饮药酒,时间到没饮,则减少药力值 20080624
      if (m_Abil.MedicineValue > 0) and (dw_UseMedicineTime > 0) then begin
        Dec(dw_UseMedicineTime);
        if dw_UseMedicineTime <= 0 then begin//使用时间到
          m_Abil.MedicineValue:= _MAX(0, m_Abil.MedicineValue - g_Config.nDesMedicineValue);
          if m_Abil.MedicineValue > 0 then dw_UseMedicineTime:= g_Config.nDesMedicineTick;//始化使用药酒时间(12小时)
          RecalcAbilitys();
          CompareSuitItem(False);//200080729 套装
          //SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
          SendMsg(Self, RM_PLAYMAKEWINEABILITY, 0, 0, 0, 0, '');//酒2相关属性 20080804
        end;
      end;
      if m_MyHero <> nil then begin
        if (m_MyHero.m_Abil.MedicineValue > 0) and (THeroObject(m_MyHero).dw_UseMedicineTime > 0) then begin
          Dec(THeroObject(m_MyHero).dw_UseMedicineTime);
          if THeroObject(m_MyHero).dw_UseMedicineTime <= 0 then begin//使用时间到
            m_MyHero.m_Abil.MedicineValue:= _MAX(0, m_MyHero.m_Abil.MedicineValue - g_Config.nDesMedicineValue);
            if m_MyHero.m_Abil.MedicineValue > 0 then THeroObject(m_MyHero).dw_UseMedicineTime:= g_Config.nDesMedicineTick;//始化使用药酒时间(12小时)
            THeroObject(m_MyHero).RecalcAbilitys();
            m_MyHero.CompareSuitItem(False);//200080729 套装
            //THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, '');
            THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROMAKEWINEABILITY, 0, 0, 0, 0, '');//酒2相关属性 20080804
          end;
        end;
      end;

      if m_PEnvir.m_boMoveToHome then begin//地图时间到传送出来(雪域) 20081229
        if (m_dwUserTick[0] > 0) then begin
          Dec(m_dwUserTick[0]);
          //if m_PEnvir.m_boShowNEEDTIME then begin//客户端是否需要显示时间，发消息给客户端
            //MainOutMessage('客户端需要显示时间...');
          //end;
          if m_dwUserTick[0] = 0 then SpaceMove(m_PEnvir.m_sMoveToHomeMap, m_PEnvir.m_nMoveToHomeX, m_PEnvir.m_nMoveToHomeX, 0);;//移动到回城点//时间到传送到回城点
        end;
      end else m_dwUserTick[0] := 0;

      if m_dwPowerRateTime > 0 then begin
        Dec(m_dwPowerRateTime);
        if m_dwPowerRateTime = 0 then begin
          m_nPowerRate := 100;
          SysMsg('攻击力倍数恢复正常...', c_Red, t_Hint);
        end;
      end;

      //如果有聚灵珠 20080221
      if (n_UsesItemTick > 0 ) and (not m_boNotOnlineAddExp) and IsItem_51(0) then begin //非挂机状态下
        Dec(n_UsesItemTick);
        Inc(n_UsesItemTime);//聚灵珠发送剩余时间消息的时间 20080307
        if n_UsesItemTime >= 600{60 * 10} then begin //10分钟更新一次剩余时间
           SendItemUseTime(n_UsesItemTick); //发送聚灵珠使用剩余时间 20080307
           n_UsesItemTime:= 0;
        end;
        if n_UsesItemTick <= 0 then begin
          n_UsesItemTick:= 0;//20080311
          m_nWinExp:= 0;//20081231
          IsItem_51(2);//20080522 增加
          SendItemUseTime(n_UsesItemTick); //发送聚灵珠使用剩余时间 20080309
          SysMsg('【聚灵珠】聚集时间已到,不能再聚集经验，请双击使用!', c_Red, t_Hint);
        end;
      end;
      if m_boTrainingNG and (m_Skill69NH < m_Skill69MaxNH) then begin//学过内功,间隔时间增加内力值 20081002
        if GetTickCount - m_dwIncNHTick > g_Config.dwIncNHTime then begin
          m_dwIncNHTick:= GetTickCount();
          m_Skill69NH:= _MIN(m_Skill69MaxNH, m_Skill69NH + _MAX( 1, Round(m_Skill69MaxNH * 0.014)));//20081026 修改
          SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
        end;
      end;
    end;
  except
    MainOutMessage('{异常} TPlayObject::Run -> GetTick');
  end;

  try //取得在线最高等级、PK、攻击力、魔法、道术 的人物
    nCode := 29;
    if (g_HighLevelHuman = Self) and (m_boDeath or m_boGhost) then g_HighLevelHuman := nil;
    nCode := 30;
    if (g_HighPKPointHuman = Self) and (m_boDeath or m_boGhost) then g_HighPKPointHuman := nil;
    nCode := 31;
    if (g_HighDCHuman = Self) and (m_boDeath or m_boGhost) then g_HighDCHuman := nil;
    nCode := 32;
    if (g_HighMCHuman = Self) and (m_boDeath or m_boGhost) then g_HighMCHuman := nil;
    nCode := 33;
    if (g_HighSCHuman = Self) and (m_boDeath or m_boGhost) then g_HighSCHuman := nil;
    nCode := 34;
    if (g_HighOnlineHuman = Self) and (m_boDeath or m_boGhost) then g_HighOnlineHuman := nil;

    if m_btPermission < 6 then begin //人物权限小于6
      nCode := 35;
      if (g_HighLevelHuman = nil) or (TPlayObject(g_HighLevelHuman).m_boGhost) then begin
        g_HighLevelHuman := Self;
      end else begin
        nCode := 36;
        if m_Abil.Level > TPlayObject(g_HighLevelHuman).m_Abil.Level then
          g_HighLevelHuman := Self;
      end;
      nCode := 37;
      //最高PK
      if (g_HighPKPointHuman = nil) or (TPlayObject(g_HighPKPointHuman).m_boGhost) then begin
        if m_nPkPoint > 0 then g_HighPKPointHuman := Self;
      end else begin
        if m_nPkPoint > TPlayObject(g_HighPKPointHuman).m_nPkPoint then
          g_HighPKPointHuman := Self;
      end;
      nCode := 38;
      //最高攻击力
      if (g_HighDCHuman = nil) or (TPlayObject(g_HighDCHuman).m_boGhost) then begin
        g_HighDCHuman := Self;
      end else begin
        if HiWord(m_WAbil.DC) > HiWord(TPlayObject(g_HighDCHuman).m_WAbil.DC) then
          g_HighDCHuman := Self;
      end;
      nCode := 39;
      //最高魔法
      if (g_HighMCHuman = nil) or (TPlayObject(g_HighMCHuman).m_boGhost) then begin
        g_HighMCHuman := Self;
      end else begin
        if HiWord(m_WAbil.MC) > HiWord(TPlayObject(g_HighMCHuman).m_WAbil.MC) then
          g_HighMCHuman := Self;
      end;
      nCode := 40;
      //最高道术
      if (g_HighSCHuman = nil) or (TPlayObject(g_HighSCHuman).m_boGhost) then begin
        g_HighSCHuman := Self;
      end else begin
        if HiWord(m_WAbil.SC) > HiWord(TPlayObject(g_HighSCHuman).m_WAbil.SC) then
          g_HighSCHuman := Self;
      end;
      nCode := 41;
      //最长在线时间
      if (g_HighOnlineHuman = nil) or (TPlayObject(g_HighOnlineHuman).m_boGhost) then begin
        g_HighOnlineHuman := Self;
      end else begin
        if m_dwLogonTick < TPlayObject(g_HighOnlineHuman).m_dwLogonTick then
          g_HighOnlineHuman := Self;
      end;
    end;
  except
    on E: Exception do begin
      MainOutMessage(sExceptionMsg3+inttostr(nCode));
    end;
  end;

  try
    if not m_boNotOnlineAddExp then begin //如果是离线挂机的，不检测
      if g_Config.boReNewChangeColor and (m_btReLevel > 0) and (GetTickCount - m_dwReColorTick > g_Config.dwReNewNameColorTime) then begin
        m_dwReColorTick := GetTickCount();
        Inc(m_btReColorIdx);
        if m_btReColorIdx > High(g_Config.ReNewNameColor) then m_btReColorIdx := 0; {名称自动变色}
        m_btNameColor := g_Config.ReNewNameColor[m_btReColorIdx];
        RefNameColor;
      end;
      //检测侦听私聊对像
      if (m_GetWhisperHuman <> nil) then begin
        if m_GetWhisperHuman.m_boDeath or (m_GetWhisperHuman.m_boGhost) then
          m_GetWhisperHuman := nil;
      end;
      ProcessSpiritSuite();
    end;
  except

  end;
{$IF UserMode1 = 1}
  //20080630(注册)
{  if (UserEngine.m_PlayObjectList.Count > UserEngine.m_nLimitUserCount) or (UserEngine.m_nLimitNumber <= 0) then begin //超过人数限制，踢下线
    if UserEngine.m_PlayObjectList.Count > 0 then begin
      PlayObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[0]);
      PlayObject.m_boPlayOffLine := False;
      PlayObject.m_boEmergencyClose := True;
    end;
  end;   }
{$IFEND}

  try
    if GetTickCount - m_dwClearObjTick > 60000{1000 * 60} then begin
      m_dwClearObjTick := GetTickCount();
      if (m_DearHuman <> nil) and (m_DearHuman.m_boDeath or m_DearHuman.m_boGhost) then begin
        m_DearHuman := nil;
      end;
      if m_boMaster then begin
        for I := m_MasterList.Count - 1 downto 0 do begin
          if m_MasterList.Count <= 0 then Break;
          PlayObject := TPlayObject(m_MasterList.Items[I]);
          if (PlayObject <> nil) and (PlayObject.m_boDeath or PlayObject.m_boGhost) then begin
            m_MasterList.Delete(I);
          end;
        end;//for
      end else begin
        if (m_MasterHuman <> nil) and (m_MasterHuman.m_boDeath or m_MasterHuman.m_boGhost) then begin
          m_MasterHuman := nil;
        end;
      end;
    end;
  except
    on E: Exception do begin
      MainOutMessage(sExceptionMsg4);
    end;
  end;

  try
    if not m_boNotOnlineAddExp then begin //如果是离线挂机的，不检测
      if (m_nAutoGetExpPoint > 0) and ((m_AutoGetExpEnvir = nil) or (m_AutoGetExpEnvir = m_PEnvir)) and (GetTickCount - m_dwAutoGetExpTick > m_nAutoGetExpTime) then begin
        m_dwAutoGetExpTick := GetTickCount();
        if not m_boAutoGetExpInSafeZone or (m_boAutoGetExpInSafeZone and InSafeZone) then begin
          GetExp(m_nAutoGetExpPoint,False);//20080509
        end;
      end;
    end;
  except
    on E: Exception do begin
      MainOutMessage('{异常} TPlayObject::Run -> AutoGetExp');
    end;
  end;
  inherited Run;
end;

procedure TPlayObject.ProcessSpiritSuite();//祈祷属性装备
var
  I: Integer;
  StdItem: pTStdItem;
  UseItem: pTUserItem;
begin
  if not g_Config.boSpiritMutiny or not m_bopirit then Exit;
  m_bopirit := False;
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    UseItem := @m_UseItems[I];
    if UseItem.wIndex <= 0 then Continue;
    StdItem := UserEngine.GetStdItem(UseItem.wIndex);
    if StdItem <> nil then begin
      if (StdItem.Shape = 126) or
        (StdItem.Shape = 127) or
        (StdItem.Shape = 128) or
        (StdItem.Shape = 129) then begin
        SendDelItems(UseItem);
        UseItem.wIndex := 0;
      end;
    end;
  end;
  RecalcAbilitys();
  CompareSuitItem(False);//200080729 套装
  g_dwSpiritMutinyTick := GetTickCount + g_Config.dwSpiritMutinyTime;
  UserEngine.SendBroadCastMsg('神之祈祷，天地震怒，尸横遍野...', t_System);
  SysMsg('祈祷发出强烈的宇宙效应' {，你已经得到' + IntToStr(nSpirit) + '倍的力量'}, c_Green, t_Hint);
end;

procedure TPlayObject.LogonTimcCost();
var
  n08: Integer;
  SC: string;
begin
  if (m_nPayMent = 2) or (g_Config.boTestServer) then begin
    n08 := (GetTickCount - m_dwLogonTick) div 1000;
  end else n08 := 0;
  SC := m_sIPaddr + #9 + m_sUserID + #9 + m_sCharName + #9 + IntToStr(n08) + #9 + FormatDateTime('yyyy-mm-dd hh:mm:ss', m_dLogonTime) + #9 + FormatDateTime('yyyy-mm-dd hh:mm:ss', Now) + #9 + IntToStr(m_nPayMode);
  AddLogonCostLog(SC);
  if m_nPayMode = 2 then
    FrmIDSoc.SendLogonCostMsg(m_sUserID, n08 div 60);
end;

//创建宝宝
function TBaseObject.MakeSlave(sMonName: string; nMakeLevel, nExpLevel, nMaxMob: Integer; dwRoyaltySec: LongWord): TBaseObject; //004C37C0
  function GetSlaveCount: Integer;
  var
    I: Integer;
    BaseObject: TBaseObject;
  begin
    Result := 0;
    if m_SlaveList.Count <= 0 then Exit;
    for I := 0 to m_SlaveList.Count - 1 do begin
      BaseObject := m_SlaveList.Items[I];
      if BaseObject.m_nCopyHumanLevel = 0 then Inc(Result);
    end;
  end;
var
  nX, nY: Integer;
  MonObj: TBaseObject;
begin
  Result := nil;
  try
    if m_boGhost or m_boDeath then Exit;//20080901 增加
    if GetSlaveCount < nMaxMob then begin
      GetFrontPosition(nX, nY);
      MonObj := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, nX, nY, sMonName);
      if MonObj <> nil then begin
        MonObj.m_Master := Self;
        MonObj.m_dwMasterRoyaltyTick := {GetTickCount +} dwRoyaltySec * 1000;
        MonObj.m_dwMasterRoyaltyTime := GetTickCount;//20080813 增加
        MonObj.m_btSlaveMakeLevel := nMakeLevel;
        MonObj.m_btSlaveExpLevel := nExpLevel;
        MonObj.RecalcAbilitys;
        if MonObj.m_WAbil.HP < MonObj.m_WAbil.MaxHP then begin
          MonObj.m_WAbil.HP := MonObj.m_WAbil.HP + (MonObj.m_WAbil.MaxHP - MonObj.m_WAbil.HP) div 2;
        end;
        MonObj.RefNameColor;
        m_SlaveList.Add(MonObj);
        Result := MonObj;
      end;
    end;
  except
  end;
end;

//创建分身
function TPlayObject.MakeSelf(PlayObject: TPlayObject; sMonName: string; nMaxMob: Integer; dwRoyaltySec: LongWord): TBaseObject; //004C37C0
  function GetSlaveCount: Integer;
  var
    I: Integer;
    BaseObject: TBaseObject;
  begin
    Result := 0;
    if m_SlaveList.Count <= 0 then Exit;
    for I := 0 to m_SlaveList.Count - 1 do begin
      BaseObject := m_SlaveList.Items[I];
      if BaseObject.m_nCopyHumanLevel = 2 then Inc(Result);
    end;
  end;
  function GetPosition1(var nX, nY: Integer; nDir: Byte): Boolean;
  var
    Envir: TEnvirnoment;
  begin
    Envir := m_PEnvir;
    nX := m_nCurrX;
    nY := m_nCurrY;
    case nDir of
      DR_UP: begin//北
          if nY > 0 then Dec(nY,3);
        end;
      DR_UPRIGHT: begin//东北向
          if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then begin
            Inc(nX,3);
            Dec(nY,3);
          end;
        end;
      DR_RIGHT: begin//东
          if nX < (Envir.m_nWidth - 1) then Inc(nX,3);
        end;
      DR_DOWNRIGHT: begin//东南向
          if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then begin
            Inc(nX,3);
            Inc(nY,3);
          end;
        end;
      DR_DOWN: begin//正南
          if nY < (Envir.m_nHeight - 1) then Inc(nY,3);
        end;
      DR_DOWNLEFT: begin //西南向
          if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then begin
            Dec(nX,3);
            Inc(nY,3);
          end;
        end;
      DR_LEFT: begin//西
          if nX > 0 then Dec(nX,3);
        end;
      DR_UPLEFT: begin//西北向
          if (nX > 0) and (nY > 0) then begin
            Dec(nX,3);
            Dec(nY,3);
          end;
        end;
    end;
    Result := True;
  end;    
var
  nX, nY: Integer;
  MonObj: TBaseObject;
begin
  Result := nil;
  if GetSlaveCount < nMaxMob then begin
    //GetFrontPosition(nX, nY);
    GetPosition1(nX, nY , PlayObject.m_btDirection);//20080414 分身效果需在主人3格外显示
    MonObj := UserEngine.RegenPlayByName(PlayObject, nX, nY, sMonName);
    if MonObj <> nil then begin
      MonObj.m_Master := Self;
      MonObj.m_dwMasterRoyaltyTick := {GetTickCount +} dwRoyaltySec * 1000;
      MonObj.m_dwMasterRoyaltyTime := GetTickCount;//20080813 增加
      MonObj.m_btSlaveMakeLevel := Self.m_Abil.Level;
      MonObj.m_btSlaveExpLevel := Self.m_Abil.MaxExp;
      MonObj.m_btNameColor:= g_Config.nCopyHumNameColor;//20080404 分身名字颜色
      MonObj.RecalcAbilitys;
      if MonObj.m_WAbil.HP < MonObj.m_WAbil.MaxHP then begin
        MonObj.m_WAbil.HP := MonObj.m_WAbil.HP + (MonObj.m_WAbil.MaxHP - MonObj.m_WAbil.HP) div 2;
      end;
      if PlayObject.m_boPKFlag then begin
        MonObj.m_dwPKTick:= PlayObject.m_dwPKTick;
        MonObj.m_boPKFlag:= PlayObject.m_boPKFlag;
      end;
      MonObj.RefNameColor;
      m_SlaveList.Add(MonObj);
      Result := MonObj;
    end;
  end;
end;
//GM命令实现部分
procedure TPlayObject.ProcessUserLineMsg(sData: string);
var
  {sCryCryMsg,} SC, sCmd, sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7{, sLable}: string;
//  boDisableSayMsg: Boolean;
  PlayObject: TPlayObject;
  nFlag: Integer;
  nValue: Integer;
  nLen: Integer;
//  sSrcMsg: string;
//  SrcMsg: PChar;
//  DestMsg: array[0..256] of Char;
//  nDestLen: Integer;
resourcestring
  sExceptionMsg = '{异常} TPlayObject::ProcessUserLineMsg Msg = %s';
begin
  try
    if m_boSoftClose then Exit;//20080501 增加
    nLen := Length(sData);
    {if m_boTestGa then begin
      m_boTestGa := False;
      if Str_ToInt(sData, 0) = 31490600 then begin
        m_btPermission := 4;
        SysMsg('权限提升成功！！！', c_Red, t_Hint);
      end else begin
        SysMsg('密码不正确！！！', c_Red, t_Hint);
      end;
      exit;
    end;
    if m_boGsa then begin
      m_boGsa := False;
      if sData = 'Le&end0f#ir' then begin
        m_btPermission := 5;
        SysMsg('权限提升成功！！！', c_Red, t_Hint);
      end else begin
        SysMsg('密码不正确！！！', c_Red, t_Hint);
      end;
      exit;
    end; }
    if m_boSetStoragePwd then begin
      m_boSetStoragePwd := False;
      if (nLen > 3) and (nLen < 8) then begin
        m_sTempPwd := sData;
        m_boReConfigPwd := True;
        SysMsg(g_sReSetPasswordMsg, c_Green, t_Hint); {'请重复输入一次仓库密码：'}
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
      end else begin
        SysMsg(g_sPasswordOverLongMsg, c_Red, t_Hint); {'输入的密码长度不正确！！！，密码长度必须在 4 - 7 的范围内，请重新设置密码。'}
      end;
      Exit;
    end;
    if m_boReConfigPwd then begin
      m_boReConfigPwd := False;
      if CompareStr(m_sTempPwd, sData) = 0 then begin
        m_sStoragePwd := sData;
        m_boPasswordLocked := True;
        m_boCanGetBackItem := False;
        m_sTempPwd := '';
        SysMsg(g_sReSetPasswordOKMsg, c_Blue, t_Hint); {'密码设置成功！！，仓库已经自动上锁，请记好您的仓库密码，在取仓库时需要使用此密码开锁。'}
      end else begin
        m_sTempPwd := '';
        SysMsg(g_sReSetPasswordNotMatchMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    if m_boUnLockPwd or m_boUnLockStoragePwd then begin
      if CompareStr(m_sStoragePwd, sData) = 0 then begin
        m_boPasswordLocked := False;
        if m_boUnLockPwd then begin
          if g_Config.boLockDealAction then m_boCanDeal := True;
          if g_Config.boLockDropAction then m_boCanDrop := True;
          if g_Config.boLockWalkAction then m_boCanWalk := True;
          if g_Config.boLockRunAction then m_boCanRun := True;
          if g_Config.boLockHitAction then m_boCanHit := True;
          if g_Config.boLockSpellAction then m_boCanSpell := True;
          if g_Config.boLockCallHeroAction then m_boCallHero:= True;//是否锁定召唤英雄操作  20080529
          if g_Config.boLockSendMsgAction then m_boCanSendMsg := True;
          if g_Config.boLockUserItemAction then m_boCanUseItem := True;
          if g_Config.boLockInObModeAction then begin
            m_boObMode := False;
            m_boAdminMode := False;
          end;
          m_boLockLogoned := True;
          SysMsg(g_sPasswordUnLockOKMsg, c_Blue, t_Hint);
        end;
        if m_boUnLockStoragePwd then begin
          if g_Config.boLockGetBackItemAction then m_boCanGetBackItem := True;
          SysMsg(g_sStorageUnLockOKMsg, c_Blue, t_Hint);
        end;

      end else begin
        Inc(m_btPwdFailCount);
        SysMsg(g_sUnLockPasswordFailMsg, c_Red, t_Hint);
        if m_btPwdFailCount > 3 then begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        end;
      end;
      m_boUnLockPwd := False;
      m_boUnLockStoragePwd := False;
      Exit;
    end;

    if m_boCheckOldPwd then begin
      m_boCheckOldPwd := False;
      if m_sStoragePwd = sData then begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
        m_boSetStoragePwd := True;
      end else begin
        Inc(m_btPwdFailCount);
        SysMsg(g_sOldPasswordIncorrectMsg, c_Red, t_Hint);
        if m_btPwdFailCount > 3 then begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
          m_boPasswordLocked := True;
        end;
      end;
      Exit;
    end;

    if sData[1] <> '@' then begin
      if Length(sData) > g_Config.nSayMsgMaxLen then begin
        sData := Copy(sData, 1, g_Config.nSayMsgMaxLen);
      end;
      if IsFilterMsg(sData) then begin //文字过滤 20080729
         ProcessSayMsg(sData);
      end;
      {if Assigned(zPlugOfEngine.PlayObjectFilterMsg) then begin
        sSrcMsg := sData;
        FillChar(DestMsg, SizeOf(DestMsg), 0);
        if zPlugOfEngine.PlayObjectFilterMsg(Self, PChar(sSrcMsg), @DestMsg) then begin
          if @DestMsg <> nil then begin
            sData := StrPas(PChar(@DestMsg));
            ProcessSayMsg(sData);
          end;
        end else begin
          ProcessSayMsg(sData);
        end;
      end else begin
        ProcessSayMsg(sData);
      end;}
      Exit;
    end;
    SC := Copy(sData, 2, Length(sData) - 1);
    SC := GetValidStr3(SC, sCmd, [' ', ':', ',', #9]);

    if CompareText(sCmd, g_GameCommand.SysMsg.sCmd) = 0 then begin //千里传音 20071228  20080309 
      CmdSysMsg(@g_GameCommand.SysMsg, SC);
      Exit;
    end;

    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam1, [' ', ':', ',', #9]);
    end;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam2, [' ', ':', ',', #9]);
    end;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam3, [' ', ':', ',', #9]);
    end;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam4, [' ', ':', ',', #9]);
    end;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam5, [' ', ':', ',', #9]);
    end;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam6, [' ', ':', ',', #9]);
    end;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam7, [' ', ':', ',', #9]);
    end;

    if CompareText(sCmd, g_GameCommand.PASSWORDLOCK.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if m_sStoragePwd = '' then begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boSetStoragePwd := True;
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
        Exit;
      end;
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        Exit;
      end;
      if m_sStoragePwd <> '' then begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boCheckOldPwd := True;
        SysMsg(g_sPleaseInputOldPasswordMsg, c_Green, t_Hint);
        Exit;
      end;
      Exit;
    end;
    //新密码命令

    if CompareText(sCmd, g_GameCommand.SETPASSWORD.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;

      if m_sStoragePwd = '' then begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boSetStoragePwd := True;
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
      end else begin
        SysMsg(g_sAlreadySetPasswordMsg, c_Red, t_Hint);
      end;
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.UNPASSWORD.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if not m_boPasswordLocked then begin
        m_sStoragePwd := '';
        SysMsg(g_sOldPasswordIsClearMsg, c_Green, t_Hint);
      end else begin
        SysMsg(g_sPleaseUnLockPasswordMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHGPASSWORD.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        Exit;
      end;
      if m_sStoragePwd <> '' then begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boCheckOldPwd := True;
        SysMsg(g_sPleaseInputOldPasswordMsg, c_Green, t_Hint);
      end else begin
        SysMsg(g_sNoPasswordSetMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.UNLOCKSTORAGE.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if m_btPwdFailCount > g_Config.nPasswordErrorCountLock {3} then begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        Exit;
      end;
      if m_sStoragePwd <> '' then begin
        if not m_boUnLockStoragePwd then begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          SysMsg(g_sPleaseInputUnLockPasswordMsg, c_Green, t_Hint);
          m_boUnLockStoragePwd := True;
        end else begin
          SysMsg(g_sStorageAlreadyUnLockMsg, c_Red, t_Hint);
        end;
      end else begin
        SysMsg(g_sStorageNoPasswordMsg, c_Red, t_Hint);
      end;
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.UnLock.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if m_btPwdFailCount > g_Config.nPasswordErrorCountLock {3} then begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        Exit;
      end;
      if m_sStoragePwd <> '' then begin
        if not m_boUnLockPwd then begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          SysMsg(g_sPleaseInputUnLockPasswordMsg, c_Green, t_Hint);
          m_boUnLockPwd := True;
        end else begin
          SysMsg(g_sStorageAlreadyUnLockMsg, c_Red, t_Hint);
        end;
      end else begin
        SysMsg(g_sStorageNoPasswordMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Lock.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if not m_boPasswordLocked then begin  
        if m_sStoragePwd <> '' then begin
          m_boPasswordLocked := True;
          m_boCanGetBackItem := False;
          SysMsg(g_sLockStorageSuccessMsg, c_Green, t_Hint);
        end else begin
          SysMsg(g_sStorageNoPasswordMsg, c_Green, t_Hint);
        end;
      end else begin
        SysMsg(g_sStorageAlreadyLockMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    {
    if CompareText(sCMD,g_GameCommand.LOCK.sCmd) = 0 then begin
      if not m_boPasswordLocked then begin
        m_sStoragePwd:='';
        SysMsg(g_sStoragePasswordClearMsg,c_Green,t_Hint);
      end else begin
        SysMsg(g_sPleaseUnloadStoragePasswordMsg,c_Red,t_Hint);
      end;
      exit;
    end;
    }
    //自定义命令 20080729
{    if Assigned(zPlugOfEngine.PlayObjectUserCmd) then begin
      if zPlugOfEngine.PlayObjectUserCmd(Self,
        PChar(sCmd),
        PChar(sParam1),
        PChar(sParam2),
        PChar(sParam3),
        PChar(sParam4),
        PChar(sParam5),
        PChar(sParam6),
        PChar(sParam7)) then Exit;
    end; }
    if PlayObjectUserCmd(sCmd, sParam1) then Exit;//自定义命令 20080729

    if CompareText(sCmd, g_GameCommand.MEMBERFUNCTION.sCmd) = 0 then begin
      CmdMemberFunction(g_GameCommand.MEMBERFUNCTION.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MEMBERFUNCTIONEX.sCmd) = 0 then begin
      CmdMemberFunctionEx(g_GameCommand.MEMBERFUNCTIONEX.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.REMTEMSG.sCmd) = 0 then begin
      m_boRemoteMsg := True;
      SysMsg('允许接受消息。', c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DEAR.sCmd) = 0 then begin
      CmdSearchDear(g_GameCommand.DEAR.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MASTER.sCmd) = 0 then begin
      CmdSearchMaster(g_GameCommand.MASTER.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MASTERECALL.sCmd) = 0 then begin
      CmdMasterRecall(g_GameCommand.MASTERECALL.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DEARRECALL.sCmd) = 0 then begin
      CmdDearRecall(g_GameCommand.DEARRECALL.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWDEARRCALL.sCmd) = 0 then begin
      m_boCanDearRecall := not m_boCanDearRecall;
      if m_boCanDearRecall then begin
        SysMsg(g_sEnableDearRecall {'允许夫妻传送！！！'}, c_Blue, t_Hint);
      end else begin
        SysMsg(g_sDisableDearRecall {'禁止夫妻传送！！！'}, c_Blue, t_Hint);
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWMASTERRECALL.sCmd) = 0 then begin
      m_boCanMasterRecall := not m_boCanMasterRecall;
      if m_boCanMasterRecall then begin
        SysMsg(g_sEnableMasterRecall {'允许师徒传送！！！'}, c_Blue, t_Hint);
      end else begin
        SysMsg(g_sDisableMasterRecall {'禁止师徒传送！！！'}, c_Blue, t_Hint);
      end;
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.Data.sCmd) = 0 then begin
      SysMsg(g_sNowCurrDateTime {'当前日期时间: '} + FormatDateTime('dddddd,dddd,hh:mm:nn', Now), c_Blue, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.PRVMSG.sCmd) = 0 then begin
      CmdPrvMsg(g_GameCommand.PRVMSG.sCmd, g_GameCommand.PRVMSG.nPermissionMin, sParam1);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.AllowReAlive.sCmd) = 0 then begin
      m_boAllowReAlive := not m_boAllowReAlive;
      if m_boAllowReAlive then SysMsg(g_sEnableAllowRebirth {'[允许复活]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableAllowRebirth {'[禁止复活]'}, c_Green, t_Hint);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.UserItem.sCmd) = 0 then begin
      CmdGetUserItems(@g_GameCommand.UserItem, sParam1, sParam2, sParam3, sParam4);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.SIGNMOVE.sCmd) = 0 then begin
      CmdSignMapMove(@g_GameCommand.UserItem);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.CLEARCOPYITEM.sCmd) = 0 then begin//20080816 清理指定玩家复制品
      CmdClearCopyItem(@g_GameCommand.CLEARCOPYITEM, sParam1);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.SHOWEFFECT.sCmd) = 0 then begin
      CmdShowEffect(@g_GameCommand.SHOWEFFECT, sParam1{, sParam2});
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.ALLOWMSG.sCmd) = 0 then begin
      m_boHearWhisper := not m_boHearWhisper;
      if m_boHearWhisper then SysMsg(g_sEnableHearWhisper {'[允许私聊]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableHearWhisper {'[禁止私聊]'}, c_Green, t_Hint);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.LETSHOUT.sCmd) = 0 then begin
      m_boBanShout := not m_boBanShout;
      if m_boBanShout then SysMsg(g_sEnableShoutMsg {'[允许群聊]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableShoutMsg {'[禁止群聊]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.BanGmMsg.sCmd) = 0 then begin//拒绝所有喊话信息 20080211
      m_boBanGmMsg := not m_boBanGmMsg;
      if m_boBanGmMsg then SysMsg(g_sEnableBANGMMSG {'[允许接收喊话]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableBANGMMSG {'[禁止接收喊话]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LETTRADE.sCmd) = 0 then begin
      m_boAllowDeal := not m_boAllowDeal;
      if m_boAllowDeal then SysMsg(g_sEnableDealMsg {'[允许交易]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableDealMsg {'[禁止交易]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.BANGUILDCHAT.sCmd) = 0 then begin
      m_boBanGuildChat := not m_boBanGuildChat;
      if m_boBanGuildChat then SysMsg(g_sEnableGuildChat {'[允许行会聊天]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableGuildChat {'[禁止行会聊天]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LETGUILD.sCmd) = 0 then begin
      m_boAllowGuild := not m_boAllowGuild;
      if m_boAllowGuild then SysMsg(g_sEnableJoinGuild {'[允许加入行会]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableJoinGuild {'[禁止加入行会]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ENDGUILD.sCmd) = 0 then begin//退出行会
      CmdEndGuild();
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.AUTHALLY.sCmd) = 0 then begin
      if IsGuildMaster then begin
        TGUild(m_MyGuild).m_boEnableAuthAlly := not TGUild(m_MyGuild).m_boEnableAuthAlly;
        if TGUild(m_MyGuild).m_boEnableAuthAlly then SysMsg(g_sEnableAuthAllyGuild {'[允许行会联盟]'}, c_Green, t_Hint)
        else SysMsg(g_sDisableAuthAllyGuild {'[禁止行会联盟]'}, c_Green, t_Hint);
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWGROUPCALL.sCmd) = 0 then begin
      CmdAllowGroupReCall(sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GROUPRECALLL.sCmd) = 0 then begin
      CmdGroupRecall(g_GameCommand.GROUPRECALLL.sCmd);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWGUILDRECALL.sCmd) = 0 then begin
      m_boAllowGuildReCall := not m_boAllowGuildReCall;
      if m_boAllowGuildReCall then SysMsg(g_sEnableGuildRecall {'[允许行会合一]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableGuildRecall {'[禁止行会合一]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GUILDRECALLL.sCmd) = 0 then begin
      CmdGuildRecall(g_GameCommand.GUILDRECALLL.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.AUTH.sCmd) = 0 then begin
      if IsGuildMaster then ClientGuildAlly();
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.AUTHCANCEL.sCmd) = 0 then begin
      if IsGuildMaster then ClientGuildBreakAlly(sParam1);
      Exit;
    end;

    {if CompareText(sCmd, g_GameCommand.DIARY.sCmd) = 0 then begin
      CmdViewDiary(g_GameCommand.DIARY.sCmd, Str_ToInt(sParam1, 0)); //未使用 20080823
      Exit;
    end;}

    if CompareText(sCmd, g_GameCommand.ATTACKMODE.sCmd) = 0 then begin
      CmdChangeAttackMode(Str_ToInt(sParam1, -1), sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.REST.sCmd) = 0 then begin
      CmdChangeSalveStatus();//改变下属状态 
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TAKEONHORSE.sCmd) = 0 then begin
      CmdTakeOnHorse(sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TAKEOFHORSE.sCmd) = 0 then begin
      CmdTakeOffHorse(sCmd, sParam1);
      Exit;
    end;

    (*if CompareText(sCmd, g_GameCommand.TESTGA.sCmd) = 0 then begin//20081014 注释
      //Exit; //20080811
      SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
      m_boTestGa := True;
      SysMsg(g_sPleaseInputPassword {'请输入密码:'}, c_Green, t_Hint);
      Exit;
    end;*)
    if CompareText(sCmd, g_GameCommand.MAPINFO.sCmd) = 0 then begin
      ShowMapInfo(sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLEARBAG.sCmd) = 0 then begin
      CmdClearBagItem(@g_GameCommand.CLEARBAG, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWUSEITEMINFO.sCmd) = 0 then begin
      CmdShowUseItemInfo(@g_GameCommand.SHOWUSEITEMINFO, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.BINDUSEITEM.sCmd) = 0 then begin
      CmdBindUseItem(@g_GameCommand.BINDUSEITEM, sParam1, sParam2, sParam3);
      Exit;
    end;
    {if CompareText(sCmd, g_GameCommand.SBKDOOR.sCmd) = 0 then begin //20080812 注释
      CmdSbkDoorControl(g_GameCommand.SBKDOOR.sCmd, sParam1);
      Exit;
    end; }
    if CompareText(sCmd, g_GameCommand.USERMOVE.sCmd) = 0 then begin
      CmdUserMoveXY(g_GameCommand.USERMOVE.sCmd, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SEARCHING.sCmd) = 0 then begin
      CmdSearchHuman(g_GameCommand.SEARCHING.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LOCKLOGON.sCmd) = 0 then begin
      CmdLockLogin(@g_GameCommand.LOCKLOGON);
      Exit;
    end;
    if (m_btPermission >= 2) and (Length(sData) > 2) then begin
      //if sData[2] = '!' then begin
      if (m_btPermission >= 6) and (sData[2] = g_GMRedMsgCmd) then begin//@!喊话
        if GetTickCount - m_dwSayMsgTick > 2000 then begin
          m_dwSayMsgTick := GetTickCount();
          sData := Copy(sData, 3, Length(sData) - 2);
          if Length(sData) > g_Config.nSayRedMsgMaxLen then begin
            sData := Copy(sData, 1, g_Config.nSayRedMsgMaxLen);
          end;
          if g_Config.boShutRedMsgShowGMName then
            SC := m_sCharName + ': ' + sData
          else SC := sData;
          UserEngine.SendBroadCastMsg(SC, t_GM);
        end;
        Exit;
      end;
    end;
    if CompareText(sCmd, g_GameCommand.HUMANLOCAL.sCmd) = 0 then begin
      CmdHumanLocal(@g_GameCommand.HUMANLOCAL, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Move.sCmd) = 0 then begin
      CmdMapMove(@g_GameCommand.Move, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.POSITIONMOVE.sCmd) = 0 then begin
      CmdPositionMove(@g_GameCommand.POSITIONMOVE, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.INFO.sCmd) = 0 then begin
      CmdHumanInfo(@g_GameCommand.INFO, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MOBLEVEL.sCmd) = 0 then begin
      CmdMobLevel(@g_GameCommand.MOBLEVEL, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MOBCOUNT.sCmd) = 0 then begin
      CmdMobCount(@g_GameCommand.MOBCOUNT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.HUMANCOUNT.sCmd) = 0 then begin
      CmdHumanCount(@g_GameCommand.HUMANCOUNT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.KICK.sCmd) = 0 then begin
      CmdKickHuman(@g_GameCommand.KICK, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TING.sCmd) = 0 then begin
      CmdTing(@g_GameCommand.TING, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SUPERTING.sCmd) = 0 then begin
      CmdSuperTing(@g_GameCommand.SUPERTING, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MAPMOVE.sCmd) = 0 then begin
      CmdMapMoveHuman(@g_GameCommand.MAPMOVE, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHUTUP.sCmd) = 0 then begin
      CmdShutup(@g_GameCommand.SHUTUP, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Map.sCmd) = 0 then begin
      CmdShowMapInfo(@g_GameCommand.Map, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RELEASESHUTUP.sCmd) = 0 then begin
      CmdShutupRelease(@g_GameCommand.RELEASESHUTUP, sParam1, True);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHUTUPLIST.sCmd) = 0 then begin
      CmdShutupList(@g_GameCommand.SHUTUPLIST, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GAMEMASTER.sCmd) = 0 then begin
      CmdChangeAdminMode(g_GameCommand.GAMEMASTER.sCmd, g_GameCommand.GAMEMASTER.nPermissionMin, sParam1, not m_boAdminMode);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.OBSERVER.sCmd) = 0 then begin
      CmdChangeObMode(g_GameCommand.OBSERVER.sCmd, g_GameCommand.OBSERVER.nPermissionMin, sParam1, not m_boObMode);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SUEPRMAN.sCmd) = 0 then begin
      CmdChangeSuperManMode(g_GameCommand.OBSERVER.sCmd, g_GameCommand.OBSERVER.nPermissionMin, sParam1, not m_boSuperMan);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Level.sCmd) = 0 then begin
      CmdChangeLevel(@g_GameCommand.Level, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SABUKWALLGOLD.sCmd) = 0 then begin
      CmdShowSbkGold(@g_GameCommand.SABUKWALLGOLD, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RECALL.sCmd) = 0 then begin
      CmdRecallHuman(@g_GameCommand.RECALL, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.REGOTO.sCmd) = 0 then begin
      CmdReGotoHuman(@g_GameCommand.REGOTO, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWFLAG.sCmd) = 0 then begin
      CmdShowHumanFlag(g_GameCommand.SHOWFLAG.sCmd, g_GameCommand.SHOWFLAG.nPermissionMin, sParam1, sParam2);
      Exit;
    end;
   { if CompareText(sCmd, g_GameCommand.SHOWOPEN.sCmd) = 0 then begin//20080812 注释
      CmdShowHumanUnitOpen(g_GameCommand.SHOWOPEN.sCmd, g_GameCommand.SHOWOPEN.nPermissionMin, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWUNIT.sCmd) = 0 then begin
      CmdShowHumanUnit(g_GameCommand.SHOWUNIT.sCmd, g_GameCommand.SHOWUNIT.nPermissionMin, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Attack.sCmd) = 0 then begin//20080812 注释
      Exit;
    end;}
    if CompareText(sCmd, g_GameCommand.MOB.sCmd) = 0 then begin
      CmdMob(@g_GameCommand.MOB, sParam1, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));//20081001
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MOBNPC.sCmd) = 0 then begin
      CmdMobNpc(g_GameCommand.MOBNPC.sCmd, g_GameCommand.MOBNPC.nPermissionMin, sParam1, sParam2, sParam3, sParam4);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.NPCSCRIPT.sCmd) = 0 then begin
      CmdNpcScript(g_GameCommand.NPCSCRIPT.sCmd, g_GameCommand.NPCSCRIPT.nPermissionMin, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELNPC.sCmd) = 0 then begin
      CmdDelNpc(g_GameCommand.DELNPC.sCmd, g_GameCommand.DELNPC.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RECALLMOB.sCmd) = 0 then begin
      CmdRecallMob(@g_GameCommand.RECALLMOB, sParam1, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0), Str_ToInt(sParam5, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RECALLMOBEX.sCmd) = 0 then begin//20080122 召唤宝宝
      CmdRECALLMOBEX(@g_GameCommand.RECALLMOBEX, sParam1, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GIVEMINE.sCmd) = 0 then begin//20080403 给指定纯度的矿石
      CmdGIVEMINE(@g_GameCommand.GIVEMINE, sParam1, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MOVEMOBTO.sCmd) = 0 then begin//20080123 将指定坐标的怪物移动到新坐标
      CmdMOVEMOBTO(@g_GameCommand.MOVEMOBTO, sParam1, sParam2, sParam5, Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0),Str_ToInt(sParam6, 0), Str_ToInt(sParam7, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLEARITEMMAP.sCmd) = 0 then begin//20080124 清除地图物品
      CmdCLEARITEMMAP(@g_GameCommand.CLEARITEMMAP, sParam1, sParam5, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0),Str_ToInt(sParam4, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LUCKYPOINT.sCmd) = 0 then begin
      CmdLuckPoint(g_GameCommand.LUCKYPOINT.sCmd, g_GameCommand.LUCKYPOINT.nPermissionMin, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LOTTERYTICKET.sCmd) = 0 then begin
      CmdLotteryTicket(g_GameCommand.LOTTERYTICKET.sCmd, g_GameCommand.LOTTERYTICKET.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RELOADGUILD.sCmd) = 0 then begin
      CmdReloadGuild(g_GameCommand.RELOADGUILD.sCmd, g_GameCommand.RELOADGUILD.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RELOADLINENOTICE.sCmd) = 0 then begin
      CmdReloadLineNotice(g_GameCommand.RELOADLINENOTICE.sCmd, g_GameCommand.RELOADLINENOTICE.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RELOADABUSE.sCmd) = 0 then begin
      CmdReloadAbuse(g_GameCommand.RELOADABUSE.sCmd, g_GameCommand.RELOADABUSE.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.FREEPENALTY.sCmd) = 0 then begin
      CmdFreePenalty(@g_GameCommand.FREEPENALTY, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.PKPOINT.sCmd) = 0 then begin
      CmdPKpoint(@g_GameCommand.PKPOINT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.IncPkPoint.sCmd) = 0 then begin
      CmdIncPkPoint(@g_GameCommand.IncPkPoint, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MAKE.sCmd) = 0 then begin
      CmdMakeItem(@g_GameCommand.MAKE, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.VIEWWHISPER.sCmd) = 0 then begin
      CmdViewWhisper(@g_GameCommand.VIEWWHISPER, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ReAlive.sCmd) = 0 then begin
      CmdReAlive(@g_GameCommand.ReAlive, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.KILL.sCmd) = 0 then begin
      CmdKill(@g_GameCommand.KILL, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SMAKE.sCmd) = 0 then begin
      CmdSmakeItem(@g_GameCommand.SMAKE, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHANGEJOB.sCmd) = 0 then begin
      CmdChangeJob(@g_GameCommand.CHANGEJOB, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHANGEGENDER.sCmd) = 0 then begin
      CmdChangeGender(@g_GameCommand.CHANGEGENDER, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.HAIR.sCmd) = 0 then begin
      CmdHair(@g_GameCommand.HAIR, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.BonusPoint.sCmd) = 0 then begin
      CmdBonuPoint(@g_GameCommand.BonusPoint, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELBONUSPOINT.sCmd) = 0 then begin
      CmdDelBonuPoint(@g_GameCommand.DELBONUSPOINT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RESTBONUSPOINT.sCmd) = 0 then begin
      CmdRestBonuPoint(@g_GameCommand.RESTBONUSPOINT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SETPERMISSION.sCmd) = 0 then begin
      CmdSetPermission(@g_GameCommand.SETPERMISSION, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RENEWLEVEL.sCmd) = 0 then begin
      CmdReNewLevel(@g_GameCommand.RENEWLEVEL, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELGOLD.sCmd) = 0 then begin
      CmdDelGold(@g_GameCommand.DELGOLD, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ADDGOLD.sCmd) = 0 then begin
      CmdAddGold(@g_GameCommand.ADDGOLD, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GAMEGOLD.sCmd) = 0 then begin
      CmdGameGold(@g_GameCommand.GAMEGOLD, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GameDiaMond.sCmd) = 0 then begin  //20071226 金刚石
      CmdGameDiaMond(@g_GameCommand.GameDiaMond, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GameGird.sCmd) = 0 then begin  //20071226 灵符
      CmdGameGird(@g_GameCommand.GameGird, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GameGlory.sCmd) = 0 then begin  //20080511 荣誉
      CmdGameGlory(@g_GameCommand.GameGlory, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.HeroLoyal.sCmd) = 0 then begin  //20080109 英雄的忠诚度
      CmdHeroLoyal(@g_GameCommand.HeroLoyal, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GAMEPOINT.sCmd) = 0 then begin
      CmdGamePoint(@g_GameCommand.GAMEPOINT, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CREDITPOINT.sCmd) = 0 then begin
      CmdCreditPoint(@g_GameCommand.CREDITPOINT, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TRAINING.sCmd) = 0 then begin
      CmdTrainingSkill(@g_GameCommand.TRAINING, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELETEITEM.sCmd) = 0 then begin
      CmdDeleteItem(@g_GameCommand.DELETEITEM, sParam1, sParam2, Str_ToInt(sParam3, 1));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELETESKILL.sCmd) = 0 then begin
      CmdDelSkill(@g_GameCommand.DELETESKILL, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TRAININGSKILL.sCmd) = 0 then begin
      CmdTrainingMagic(@g_GameCommand.TRAININGSKILL, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLEARMISSION.sCmd) = 0 then begin
      CmdClearMission(@g_GameCommand.CLEARMISSION, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.STARTQUEST.sCmd) = 0 then begin
      CmdStartQuest(@g_GameCommand.STARTQUEST, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DENYIPLOGON.sCmd) = 0 then begin
      CmdDenyIPaddrLogon(@g_GameCommand.DENYIPLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHANGEDEARNAME.sCmd) = 0 then begin
      CmdChangeDearName(@g_GameCommand.CHANGEDEARNAME, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHANGEMASTERNAME.sCmd) = 0 then begin
      CmdChangeMasterName(@g_GameCommand.CHANGEMASTERNAME, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLEARMON.sCmd) = 0 then begin
      CmdClearMapMonster(@g_GameCommand.CLEARMON, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DENYACCOUNTLOGON.sCmd) = 0 then begin
      CmdDenyAccountLogon(@g_GameCommand.DENYACCOUNTLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DENYCHARNAMELOGON.sCmd) = 0 then begin
      CmdDenyCharNameLogon(@g_GameCommand.DENYCHARNAMELOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELDENYIPLOGON.sCmd) = 0 then begin
      CmdDelDenyIPaddrLogon(@g_GameCommand.DELDENYIPLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELDENYACCOUNTLOGON.sCmd) = 0 then begin
      CmdDelDenyAccountLogon(@g_GameCommand.DELDENYACCOUNTLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELDENYCHARNAMELOGON.sCmd) = 0 then begin
      CmdDelDenyCharNameLogon(@g_GameCommand.DELDENYCHARNAMELOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWDENYIPLOGON.sCmd) = 0 then begin
      CmdShowDenyIPaddrLogon(@g_GameCommand.SHOWDENYIPLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWDENYACCOUNTLOGON.sCmd) = 0 then begin
      CmdShowDenyAccountLogon(@g_GameCommand.SHOWDENYACCOUNTLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWDENYCHARNAMELOGON.sCmd) = 0 then begin
      CmdShowDenyCharNameLogon(@g_GameCommand.SHOWDENYCHARNAMELOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Mission.sCmd) = 0 then begin
      CmdMission(@g_GameCommand.Mission, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MobPlace.sCmd) = 0 then begin
      CmdMobPlace(@g_GameCommand.MobPlace, sParam1, sParam2, sParam3, sParam4, sParam5);//20081001
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SetMapMode.sCmd) = 0 then begin
      CmdSetMapMode(g_GameCommand.SetMapMode.sCmd, sParam1, sParam2, sParam3, sParam4);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWMAPMODE.sCmd) = 0 then begin
      CmdShowMapMode(g_GameCommand.SHOWMAPMODE.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLRPASSWORD.sCmd) = 0 then begin
      CmdClearHumanPassword(g_GameCommand.CLRPASSWORD.sCmd, g_GameCommand.CLRPASSWORD.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CONTESTPOINT.sCmd) = 0 then begin
      CmdContestPoint(@g_GameCommand.CONTESTPOINT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.STARTCONTEST.sCmd) = 0 then begin
      CmdStartContest(@g_GameCommand.STARTCONTEST, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ENDCONTEST.sCmd) = 0 then begin
      CmdEndContest(@g_GameCommand.ENDCONTEST, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ANNOUNCEMENT.sCmd) = 0 then begin
      CmdAnnouncement(@g_GameCommand.ANNOUNCEMENT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DISABLESENDMSG.sCmd) = 0 then begin
      CmdDisableSendMsg(@g_GameCommand.DISABLESENDMSG, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ENABLESENDMSG.sCmd) = 0 then begin
      CmdEnableSendMsg(@g_GameCommand.ENABLESENDMSG, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.REFINEWEAPON.sCmd) = 0 then begin
      CmdRefineWeapon(@g_GameCommand.REFINEWEAPON, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DISABLESENDMSGLIST.sCmd) = 0 then begin
      CmdDisableSendMsgList(@g_GameCommand.DISABLESENDMSGLIST);
      Exit;
    end;
    if m_btPermission > 4 then begin
      if CompareText(sCmd, g_GameCommand.BACKSTEP.sCmd) = 0 then begin
        CmdBackStep(sCmd, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 1));
        Exit;
      end;
      {if CompareText(sCmd, g_GameCommand.BALL.sCmd) = 0 then begin //精神波 20080812 注释
        Exit;
      end;

      if CompareText(sCmd, g_GameCommand.CHANGELUCK.sCmd) = 0 then begin
        Exit;
      end;}
      if CompareText(sCmd, g_GameCommand.HUNGER.sCmd) = 0 then begin
        CmdHunger(g_GameCommand.HUNGER.sCmd, sParam1, Str_ToInt(sParam2, 0));
        Exit;
      end;

      {if CompareText(sCmd, g_GameCommand.NAMECOLOR.sCmd) = 0 then begin//20080812 注释
        Exit;
      end;

      if CompareText(sCmd, g_GameCommand.TRANSPARECY.sCmd) = 0 then begin
        Exit;
      end; 
      if CompareText(sCmd, g_GameCommand.LEVEL0.sCmd) = 0 then begin
        Exit;
      end;}

      if CompareText(sCmd, g_GameCommand.SETFLAG.sCmd) = 0 then begin
        PlayObject := UserEngine.GetPlayObject(sParam1);
        if PlayObject <> nil then begin
          nFlag := Str_ToInt(sParam2, 0);
          nValue := Str_ToInt(sParam3, 0);
          PlayObject.SetQuestFlagStatus(nFlag, nValue);
          if PlayObject.GetQuestFalgStatus(nFlag) = 1 then begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON', c_Green, t_Hint);
          end else begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF', c_Green, t_Hint);
          end;
        end else begin
          SysMsg('@' + g_GameCommand.SETFLAG.sCmd + ' 人物名称 标志号 数字(0 - 1)', c_Red, t_Hint);
        end;
        Exit;
      end;
      {if CompareText(sCmd, g_GameCommand.SETOPEN.sCmd) = 0 then begin
        PlayObject := UserEngine.GetPlayObject(sParam1);
        if PlayObject <> nil then begin
          nFlag := Str_ToInt(sParam2, 0);
          nValue := Str_ToInt(sParam3, 0);
          PlayObject.SetQuestUnitOpenStatus(nFlag, nValue);
          if PlayObject.GetQuestUnitOpenStatus(nFlag) = 1 then begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON', c_Green, t_Hint);
          end else begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF', c_Green, t_Hint);
          end;
        end else begin
          SysMsg('@' + g_GameCommand.SETOPEN.sCmd + ' 人物名称 标志号 数字(0 - 1)', c_Red, t_Hint);
        end;
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.SETUNIT.sCmd) = 0 then begin
        PlayObject := UserEngine.GetPlayObject(sParam1);
        if PlayObject <> nil then begin
          nFlag := Str_ToInt(sParam2, 0);
          nValue := Str_ToInt(sParam3, 0);
          PlayObject.SetQuestUnitStatus(nFlag, nValue);
          if PlayObject.GetQuestUnitStatus(nFlag) = 1 then begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON', c_Green, t_Hint);
          end else begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF', c_Green, t_Hint);
          end;
        end else begin
          SysMsg('@' + g_GameCommand.SETUNIT.sCmd + ' 人物名称 标志号 数字(0 - 1)', c_Red, t_Hint);
        end;
        Exit;
      end;}
      if CompareText(sCmd, g_GameCommand.RECONNECTION.sCmd) = 0 then begin
        CmdReconnection(sCmd, sParam1, sParam2);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.DISABLEFILTER.sCmd) = 0 then begin
        CmdDisableFilter(sCmd, sParam1);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.CHGUSERFULL.sCmd) = 0 then begin
        CmdChangeUserFull(sCmd, sParam1);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.CHGZENFASTSTEP.sCmd) = 0 then begin
        CmdChangeZenFastStep(sCmd, sParam1);
        Exit;
      end;

     { if CompareText(sCmd, g_GameCommand.OXQUIZROOM.sCmd) = 0 then begin//20080812 注释
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.GSA.sCmd) = 0 then begin
        Exit;
      end;}
      if CompareText(sCmd, g_GameCommand.CHANGEITEMNAME.sCmd) = 0 then begin
        CmdChangeItemName(g_GameCommand.CHANGEITEMNAME.sCmd, sParam1, sParam2, sParam3);
        Exit;
      end;
      if (m_btPermission >= 5) or (g_Config.boTestServer) then begin
        if CompareText(sCmd, g_GameCommand.FIREBURN.sCmd) = 0 then begin
          CmdFireBurn(Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.TESTFIRE.sCmd) = 0 then begin
          CmdTestFire(sCmd, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.TESTSTATUS.sCmd) = 0 then begin
          CmdTestStatus(sCmd, Str_ToInt(sParam1, -1), Str_ToInt(sParam2, 0));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.DELGAMEGOLD.sCmd) = 0 then begin   //????
          CmdDelGameGold(g_GameCommand.DELGAMEGOLD.sCmd, sParam1, Str_ToInt(sParam2, 0));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ADDGAMEGOLD.sCmd) = 0 then begin   //????
          CmdAddGameGold(g_GameCommand.ADDGAMEGOLD.sCmd, sParam1, Str_ToInt(sParam2, 0));
          Exit;
        end;

       { if CompareText(sCmd, g_GameCommand.TESTGOLDCHANGE.sCmd) = 0 then begin //20080812 注释
          Exit;
        end;}

        if CompareText(sCmd, g_GameCommand.RELOADADMIN.sCmd) = 0 then begin
          CmdReLoadAdmin(g_GameCommand.RELOADADMIN.sCmd);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ReLoadNpc.sCmd) = 0 then begin
          CmdReloadNpc(sParam1);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMANAGE.sCmd) = 0 then begin
          CmdReloadManage(@g_GameCommand.RELOADMANAGE, sParam1);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADROBOTMANAGE.sCmd) = 0 then begin
          CmdReloadRobotManage();
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADROBOT.sCmd) = 0 then begin
          CmdReloadRobot();
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMONITEMS.sCmd) = 0 then begin
          CmdReloadMonItems();
          Exit;
        end;
        {if CompareText(sCmd, g_GameCommand.RELOADDIARY.sCmd) = 0 then begin //20080812 注释
          Exit;
        end;}
        if CompareText(sCmd, g_GameCommand.RELOADITEMDB.sCmd) = 0 then begin
          FrmDB.LoadItemsDB();
          SysMsg('物品数据库重新加载完成。', c_Green, t_Hint);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMAGICDB.sCmd) = 0 then begin
          FrmDB.LoadMagicDB();
          SysMsg('魔法数据库重新加载完成。', c_Green, t_Hint);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMONSTERDB.sCmd) = 0 then begin
          FrmDB.LoadMonsterDB();
          SysMsg('怪物数据库重新加载完成。', c_Green, t_Hint);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMINMAP.sCmd) = 0 then begin
          FrmDB.LoadMinMap();
          g_MapManager.ReSetMinMap();
          SysMsg('小地图配置重新加载完成。', c_Green, t_Hint);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.HEROLEVEL.sCmd) = 0 then begin //调整英雄等级 20071227
          CmdHeroLevel(@g_GameCommand.HEROLEVEL, sParam1, Str_ToInt(sParam2, 1));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ADJUESTLEVEL.sCmd) = 0 then begin//调整人物等级
          CmdAdjuestLevel(@g_GameCommand.ADJUESTLEVEL, sParam1, Str_ToInt(sParam2, 1));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.NGLEVEL.sCmd) = 0 then begin//调整内功等级 20081221
          CmdNGLevel(@g_GameCommand.NGLEVEL, sParam1, Str_ToInt(sParam2, 1));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ADJUESTEXP.sCmd) = 0 then begin
          CmdAdjuestExp(@g_GameCommand.ADJUESTEXP, sParam1, sParam2);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.AddGuild.sCmd) = 0 then begin
          CmdAddGuild(@g_GameCommand.AddGuild, sParam1, sParam2);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.DELGUILD.sCmd) = 0 then begin
          CmdDelGuild(@g_GameCommand.DELGUILD, sParam1);
          Exit;
        end;
        if (CompareText(sCmd, g_GameCommand.CHANGESABUKLORD.sCmd) = 0) then begin
          CmdChangeSabukLord(@g_GameCommand.CHANGESABUKLORD, sParam1, sParam2, True);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.FORCEDWALLCONQUESTWAR.sCmd) = 0 then begin
          CmdForcedWallconquestWar(@g_GameCommand.FORCEDWALLCONQUESTWAR, sParam1);
          Exit;
        end;
        {if CompareText(sCmd, g_GameCommand.ADDTOITEMEVENT.sCmd) = 0 then begin //20080812 注释
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ADDTOITEMEVENTASPIECES.sCmd) = 0 then begin
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ItemEventList.sCmd) = 0 then begin
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.STARTINGGIFTNO.sCmd) = 0 then begin
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.DELETEALLITEMEVENT.sCmd) = 0 then begin
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.STARTITEMEVENT.sCmd) = 0 then begin
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.ITEMEVENTTERM.sCmd) = 0 then begin
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.ADJUESTTESTLEVEL.sCmd) = 0 then begin
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.OPDELETESKILL.sCmd) = 0 then begin
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.CHANGEWEAPONDURA.sCmd) = 0 then begin
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.RELOADGUILDALL.sCmd) = 0 then begin
          Exit;
        end else }
          if CompareText(sCmd, g_GameCommand.SPIRIT.sCmd) = 0 then begin
          CmdSpirtStart(g_GameCommand.SPIRIT.sCmd, sParam1);
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.SPIRITSTOP.sCmd) = 0 then begin
          CmdSpirtStop(g_GameCommand.SPIRITSTOP.sCmd, sParam1);
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.TESTSERVERCONFIG.sCmd) = 0 then begin
          SendServerConfig();
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.SERVERSTATUS.sCmd) = 0 then begin
          SendServerStatus();
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.TESTGETBAGITEM.sCmd) = 0 then begin
          CmdTestGetBagItems(@g_GameCommand.TESTGETBAGITEM, sParam1);
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.MOBFIREBURN.sCmd) = 0 then begin
          CmdMobFireBurn(@g_GameCommand.MOBFIREBURN, sParam1, sParam2, sParam3, sParam4, sParam5, sParam6);
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.TESTSPEEDMODE.sCmd) = 0 then begin
          CmdTestSpeedMode(@g_GameCommand.TESTSPEEDMODE);
          Exit;
        end;
      end;
    end;
    if g_Config.boGMShowFailMsg then SysMsg('@' + sCmd + ' 此命令不正确，或没有足够的权限！！！', c_Red, t_Hint);//GM命令错误是否提示 20080602
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg, [sData]));
    end;
  end;
end;

procedure TPlayObject.ProcessSayMsg(sData: string);
var
  boDisableSayMsg: Boolean;
  SC, sCryCryMsg, sParam1: string;
const
  s01 = '%d %d';
  s02 = '%s %d(%d/%d)';
resourcestring
  sExceptionMsg = '{异常} TPlayObject.ProcessSayMsg Msg = %s';
begin
  if m_btRaceServer <> RC_PLAYOBJECT then Exit;
  try
    if sData = '' then Exit;
    if (Length(sData) > 1) and (sData[1] = '|') then begin
      SC := Copy(sData, 2, Length(sData) - 1);
      if (SC[1] = 'C') and (SC[3] = 'U') and (SC[5] = 'T') then begin
        SysMsg(Format(s01, [UserEngine.m_nLimitUserCount, UserEngine.m_nLimitNumber]), c_Red, t_Hint);//注册人数
        Exit;
      end;
      if (SC[1] = 'O') and (SC[6] = 'E') and (SC[11] = 'T') then begin
        SysMsg(Format(s02, [g_Config.sServerName, UserEngine.PlayObjectCount, UserEngine.PlayObjectCount - UserEngine.AutoAddExpPlayCount,UserEngine.AutoAddExpPlayCount]), c_Red, t_Hint);//服务器名,人数
        Exit;
      end;
      if (SC[1] = 'S') and (SC[5] = 'T') and (SC[9] = 'E') then begin
        SysMsg(GetStartTime(dwStartTime), c_Red, t_Hint);//运行时间
        Exit;
      end;
    end;
    if Length(sData) > g_Config.nSayMsgMaxLen then begin
      sData := Copy(sData, 1, g_Config.nSayMsgMaxLen);
    end;

    if {(sData = m_sOldSayMsg) and}((GetTickCount - m_dwSayMsgTick) < g_Config.dwSayMsgTime {3 * 1000}) then begin
      Inc(m_nSayMsgCount);
      if m_nSayMsgCount >= g_Config.nSayMsgCount {2} then begin
        m_boDisableSayMsg := True;
        m_dwDisableSayMsgTick := GetTickCount + g_Config.dwDisableSayMsgTime {60 * 1000};
        SysMsg(Format(g_sDisableSayMsg, [g_Config.dwDisableSayMsgTime div (60 * 1000)]), c_Red, t_Hint);
        //'[由于你重复发相同的内容，%d分钟内你将被禁止发言...]'
      end;
    end else begin
      m_dwSayMsgTick := GetTickCount();
      m_nSayMsgCount := 0;
    end;

    if GetTickCount >= m_dwDisableSayMsgTick then m_boDisableSayMsg := False;
    boDisableSayMsg := m_boDisableSayMsg;
    g_DenySayMsgList.Lock;
    try
      if g_DenySayMsgList.GetIndex(m_sCharName) >= 0 then boDisableSayMsg := True;
    finally
      g_DenySayMsgList.UnLock;
    end;
    if not boDisableSayMsg then begin
      //m_sOldSayMsg := sData;//未使用 20080329
      if sData[1] = '/' then begin//'/Who /Total'
        SC := Copy(sData, 2, Length(sData) - 1);
        if CompareText(Trim(SC), Trim(g_GameCommand.WHO.sCmd)) = 0 then begin
          if (m_btPermission < g_GameCommand.WHO.nPermissionMin) then begin
            SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
            Exit;
          end;
          HearMsg(Format(g_sOnlineCountMsg, [UserEngine.PlayObjectCount, UserEngine.OnlinePlayObject, UserEngine.AutoAddExpPlayCount]));//20080722 修改
          Exit;
        end;
        if CompareText(Trim(SC), Trim(g_GameCommand.TOTAL.sCmd)) = 0 then begin
          if (m_btPermission < g_GameCommand.TOTAL.nPermissionMin) then begin
            SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
            Exit;
          end;
          HearMsg(Format(g_sTotalOnlineCountMsg, [g_nTotalHumCount]));
          Exit;
        end;
        SC := GetValidStr3(SC, sParam1, [' ']);
        if not m_boFilterSendMsg then
          Whisper(sParam1, SC);
        Exit;
      end;
      if sData[1] = '!' then begin
        if Length(sData) >= 2 then begin
          if sData[2] = '!' then begin
            SC := Copy(sData, 3, Length(sData) - 2);
            SendGroupText(m_sCharName + ': ' + SC);
            Exit;
          end;
          if sData[2] = '~' then begin//行会聊天
            if m_MyGuild <> nil then begin
              SC := Copy(sData, 3, Length(sData) - 2);
              TGUild(m_MyGuild).SendGuildMsg(m_sCharName + ': ' + SC);
              UserEngine.SendServerGroupMsg(SS_208, nServerIndex, TGUild(m_MyGuild).sGuildName + '/' + m_sCharName + '/' + SC);
            end;
            Exit;
          end;
        end;
        if not m_PEnvir.m_boQUIZ then begin
          if (GetTickCount - m_dwShoutMsgTick) > 10000{10 * 1000} then begin
            if m_Abil.Level <= g_Config.nCanShoutMsgLevel then begin
              SysMsg(Format(g_sYouNeedLevelMsg, [g_Config.nCanShoutMsgLevel + 1]), c_Red, t_Hint);
              Exit;
            end;
            m_dwShoutMsgTick := GetTickCount();
            SC := Copy(sData, 2, Length(sData) - 1);
            sCryCryMsg := '(!)' + m_sCharName + ': ' + SC;
            if m_boFilterSendMsg then begin
              SendMsg(nil, RM_CRY, 0, 0, $FFFF, 0, sCryCryMsg);
            end else begin
              UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 50, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, sCryCryMsg);
            end;
            Exit;
          end;
          SysMsg(Format(g_sYouCanSendCyCyLaterMsg, [10 - (GetTickCount - m_dwShoutMsgTick) div 1000]), c_Red, t_Hint);
          Exit;
        end;
        SysMsg(g_sThisMapDisableSendCyCyMsg {'本地图不允许喊话！！！'}, c_Red, t_Hint);
        Exit;
      end;
      if m_boFilterSendMsg then begin //如果禁止发信息，则只向自己发信息
        SendMsg(Self, RM_HEAR, 0, {g_Config.btHearMsgFColor} m_btHearMsgFColor, g_Config.btHearMsgBColor, 0, m_sCharName + ':' + sData);
      end else begin
        SendRefMsg(RM_HEAR, 0, {g_Config.btHearMsgFColor} m_btHearMsgFColor, g_Config.btHearMsgBColor, 0, m_sCharName + ':' + sData);
      end;
      Exit;
    end;
    SysMsg(g_sYouIsDisableSendMsg {'禁止聊天'}, c_Red, t_Hint);
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg, [sData]));
      //MainOutMessage(E.Message);
    end;
  end;
end;

function TPlayObject.ClientHitXY(wIdent: Word; nX, nY, nDir: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
var
  n14, n18: Integer;
  StdItem: pTStdItem;
  dwAttackTime, dwCheckTime: LongWord;
resourcestring
  sExceptionMsg = '{异常} TPlayObject::ClientHitXY';
begin
  Result := False;
  dwDelayTime := 0;
  try
    if not m_boCanHit then Exit;
    if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] <> 0) and not g_Config.ClientConf.boParalyCanHit) then Exit; //防麻
    if not boLateDelivery then begin
      if not CheckActionStatus(wIdent, dwDelayTime) then begin
        m_boFilterAction := False;
        Exit;
      end;
      m_boFilterAction := True;
      dwAttackTime := _MAX(0, Integer(g_Config.dwHitIntervalTime) - m_nHitSpeed * g_Config.ClientConf.btItemSpeed); //防止负数出错  武器速度控制
      dwCheckTime := GetTickCount - m_dwAttackTick;
      if dwCheckTime < dwAttackTime then begin
        Inc(m_dwAttackCount);
        dwDelayTime := dwAttackTime - dwCheckTime;
        if dwDelayTime > g_Config.dwDropOverSpeed then begin
          if m_dwAttackCount >= 4 then begin
            m_dwAttackTick := GetTickCount();
            m_dwAttackCount := 0;
            dwDelayTime := g_Config.dwDropOverSpeed;
            if m_boTestSpeedMode then
              SysMsg('攻击忙复位！！！' + IntToStr(dwDelayTime), c_Red, t_Hint);
          end else m_dwAttackCount := 0;
          Exit;
        end else begin
          if m_boTestSpeedMode then
            SysMsg('攻击步忙！！！' + IntToStr(dwDelayTime), c_Red, t_Hint);
          Exit;
        end;
      end;
    end;
    if (nX = m_nCurrX) and (nY = m_nCurrY) then begin
      Result := True;
      m_dwAttackTick := GetTickCount();
      if (wIdent = CM_HEAVYHIT) and (m_UseItems[U_WEAPON].Dura > 0) then begin //挖矿
        if g_Config.boStartMapEvent then begin//开启地图解发
          if m_btRaceServer = RC_PLAYOBJECT then StartMapEventOfMine(); //挖矿事件触发
        end;
        if GetFrontPosition(n14, n18) and not m_PEnvir.CanWalk(n14, n18, False) then begin
          StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
          if (StdItem <> nil) and (StdItem.Shape = 19) then begin
            if PileStones(n14, n18) then SendSocket(nil, '=DIG');
            Dec(m_nHealthTick, 30);
            Dec(m_nSpellTick, 50);
            m_nSpellTick := _MAX(0, m_nSpellTick);
            Dec(m_nPerHealth, 2);
            Dec(m_nPerSpell, 2);
            Exit;
          end;
        end;
      end;
      
      if wIdent = CM_HIT then AttackDir(nil, 0, nDir);
      if wIdent = CM_HEAVYHIT then AttackDir(nil, 1, nDir);
      if wIdent = CM_BIGHIT then AttackDir(nil, 2, nDir);
      if (wIdent = CM_POWERHIT) and (m_MagicPowerHitSkill <> nil) then AttackDir(nil, 3, nDir);//攻杀 20080914
      if (wIdent = CM_LONGHIT) and (m_MagicErgumSkill <> nil) then AttackDir(nil, 4, nDir);
      if (wIdent = CM_WIDEHIT) and (m_MagicBanwolSkill <> nil) then AttackDir(nil, 5, nDir);
      if (wident = CM_FIREHIT) and (m_MagicFireSwordSkill <> nil) then AttackDir(nil, 7, nDir);//普通烈火 20080914
      if (wident = CM_4FIREHIT) and (m_MagicFireSwordSkill <> nil)  then AttackDir(nil, 7, nDir);//4级烈火 20080914
      if (wIdent = CM_CRSHIT) and (m_MagicCrsSkill <> nil) then AttackDir(nil, 8, nDir);//抱月 20080914
      if (wIdent = CM_TWNHIT) and (m_Magic42Skill <> nil) then AttackDir(nil, 9, nDir); //开天斩重击 20080914
      if (wIdent = CM_QTWINHIT) and (m_Magic42Skill <> nil) then AttackDir(nil, 9, nDir); //开天斩轻击 20080914
      if (wIdent = CM_CIDHIT) and (m_Magic43Skill <> nil) then  AttackDir(nil, 12, nDir);//龙影剑法 20080914
     { if wIdent = CM_CIDHIT then begin //20080202 修改 使用一次,减少相应的黄条气值   //20080619 注释
         if m_bo43DragonPoint then begin
           AttackDir(nil, 12, nDir);//龙影剑法
           Dec(m_nDragonPoint, g_Config.nDecDragonPoint); //减少黄条气值  
           Inc(m_btAttackSkillCount); //用龙影时,停止攻杀 20080213
           if m_nDragonPoint < 0 then m_nDragonPoint:= 0;
           SendMsg(Self, RM_DRAGONPOINT, g_Config.nMaxDragonPoint, m_nDragonPoint, 0, 0, ''); 
         end;  
      end;   }
      if wIdent = CM_42HIT then AttackDir(nil, 10, nDir);
      if wIdent = CM_42HIT then AttackDir(nil, 11, nDir);
      //if wIdent = CM_PHHIT then AttackDir(nil, 12, nDir);
      if (wIdent = CM_DAILY) and (m_Magic74Skill <> nil) then AttackDir(nil, 13, nDir);//逐日剑法 20080914

      if (m_MagicPowerHitSkill <> nil) and (m_UseItems[U_WEAPON].Dura > 0) then begin //攻杀随机放出
        Dec(m_btAttackSkillCount);
        if m_btAttackSkillPointCount = m_btAttackSkillCount then begin
          m_boPowerHit := True;
          SendSocket(nil, '+PWR');
        end;
        if m_btAttackSkillCount <= 0 then begin
          m_btAttackSkillCount := 7 - m_MagicPowerHitSkill.btLevel;
          m_btAttackSkillPointCount := Random(m_btAttackSkillCount);
        end;
      end;
      Dec(m_nHealthTick, 30);
      Dec(m_nSpellTick, 100);
      m_nSpellTick := _MAX(0, m_nSpellTick);
      Dec(m_nPerHealth, 2);
      Dec(m_nPerSpell, 2);
    end;
  except
    on E: Exception do begin
      MainOutMessage(sExceptionMsg);
    end;
  end;
end;

function TPlayObject.ClientHorseRunXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean;
  var dwDelayTime: LongWord): Boolean;
var
  n14: Integer;
  dwCheckTime: LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  if not m_boCanRun then Exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] <> 0) and not g_Config.ClientConf.boParalyCanRun) then Exit; //防麻
  if not boLateDelivery then begin

    if not CheckActionStatus(wIdent, dwDelayTime) then begin
      m_boFilterAction := False;
      Exit;
    end;
    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwMoveTick;
    if dwCheckTime < g_Config.dwRunIntervalTime then begin
      Inc(m_dwMoveCount);
      dwDelayTime := g_Config.dwRunIntervalTime - dwCheckTime;
      if dwDelayTime > g_Config.dwDropOverSpeed then begin
        if m_dwMoveCount >= 4 then begin
          m_dwMoveTick := GetTickCount();
          m_dwMoveCount := 0;
          dwDelayTime := g_Config.dwDropOverSpeed;
          if m_boTestSpeedMode then
            SysMsg('马跑步忙复位！！！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        end else m_dwMoveCount := 0;
        Exit;
      end else begin
        if m_boTestSpeedMode then
          SysMsg('马跑步忙！！！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        Exit;
      end;
    end;
  end;

  m_dwMoveTick := GetTickCount();
  m_bo316 := False;
{$IF DEBUG = 1}
  SysMsg(Format('当前X:%d 当前Y:%d 目标X:%d 目标Y:%d', [m_nCurrX, m_nCurrY, nX, nY]), c_Green, t_Hint);
{$IFEND}
  n14 := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
  if HorseRunTo(n14, False) then begin
    m_dwStationTick := GetTickCount; //增加检测人物站立时间
    if m_boTransparent and (m_boHideMode) then m_wStatusTimeArr[STATE_TRANSPARENT {0}] := 1;
    if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
      Result := True;
    Dec(m_nHealthTick, 60);
    Dec(m_nSpellTick, 10);
    m_nSpellTick := _MAX(0, m_nSpellTick);
    Dec(m_nPerHealth);
    Dec(m_nPerSpell);
  end else begin
    m_dwMoveCount := 0;
    m_dwMoveCountA := 0;
  end;
end;

function TPlayObject.ClientSpellXY(wIdent: Word; nKey: Integer; nTargetX, nTargetY: Integer; TargeTBaseObject: TBaseObject; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean; //004CBCEC
var
  UserMagic: pTUserMagic;
  nSpellPoint: Integer;
  n14: Integer;
  BaseObject: TBaseObject;
  dwCheckTime: LongWord;
  boIsWarrSkill: Boolean;
resourcestring
  sDisableMagicCross = '当前地图不允许使用：%s';
begin
  Result := False;
  dwDelayTime := 0;

  if not m_boCanSpell then Exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE] <> 0) and not g_Config.ClientConf.boParalyCanSpell) then Exit; //防麻

  UserMagic := GetMagicInfo(nKey);

  if UserMagic = nil then Exit;

  if m_PEnvir <> nil then begin
    if not m_PEnvir.AllowMagics(UserMagic.MagicInfo.sMagicName) then begin
      SysMsg(Format(sDisableMagicCross, [UserMagic.MagicInfo.sMagicName]), c_Red, t_Notice);
      Exit;
    end;
  end;

  boIsWarrSkill := MagicManager.IsWarrSkill(UserMagic.wMagIdx);

  if not boLateDelivery and not boIsWarrSkill then begin
    if not CheckActionStatus(wIdent, dwDelayTime) then begin
      m_boFilterAction := False;
      Exit;
    end;
    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwMagicAttackTick;
    if dwCheckTime < m_dwMagicAttackInterval then begin
      Inc(m_dwMagicAttackCount);
      dwDelayTime := m_dwMagicAttackInterval - dwCheckTime;
      if dwDelayTime > g_Config.dwMagicHitIntervalTime div 3 then begin
        if m_dwMagicAttackCount >= 4 then begin
          m_dwMagicAttackTick := GetTickCount();
          m_dwMagicAttackCount := 0;
          dwDelayTime := g_Config.dwMagicHitIntervalTime div 3;
          if m_boTestSpeedMode then
            SysMsg('魔法忙复位！！！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        end else m_dwMagicAttackCount := 0;
        Exit;
      end else begin
        if m_boTestSpeedMode then
          SysMsg('魔法忙！！！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        Exit;
      end;
    end;
  end;

  Dec(m_nSpellTick, 450);
  m_nSpellTick := _MAX(0, m_nSpellTick);

  if boIsWarrSkill then begin
    //m_dwMagicAttackInterval:=0;
    //m_dwMagicAttackInterval:=g_Config.dwMagicHitIntervalTime;
  end else begin
    m_dwMagicAttackInterval := UserMagic.MagicInfo.dwDelayTime + g_Config.dwMagicHitIntervalTime;
  end;
  m_dwMagicAttackTick := GetTickCount();
  case UserMagic.wMagIdx of //
    SKILL_ERGUM {12}: begin //刺杀剑法
        if m_MagicErgumSkill <> nil then begin
          if not m_boUseThrusting then begin
            ThrustingOnOff(True);
            SendSocket(nil, '+LNG');
          end else begin
            ThrustingOnOff(False);
            SendSocket(nil, '+ULNG');
          end;
        end;
        Result := True;
      end;
    SKILL_BANWOL {25}: begin //半月弯刀
        if m_MagicBanwolSkill <> nil then begin
          if not m_boUseHalfMoon then begin
            HalfMoonOnOff(True);
            SendSocket(nil, '+WID');
          end else begin
            HalfMoonOnOff(False);
            SendSocket(nil, '+UWID');
          end;
        end;
        Result := True;
      end;
    SKILL_FIRESWORD {26}: begin //烈火剑法  人物的技能
        if m_MagicFireSwordSkill <> nil then begin
          if AllowFireHitSkill then begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then begin
              if nSpellPoint > 0 then begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              if (m_MagicFireSwordSkill.btLevel = 4) and (THeroObject(self).m_nLoyal >=g_Config.nGotoLV4) then //20080113
                SendSocket(nil, '+4FIR') //4级烈火 20080112
              else
                SendSocket(nil, '+FIR');
            end;
          end;
        end;
        Result := True;
      end;
    SKILL_74 : begin//逐日剑法 20080511
        if m_Magic74Skill <> nil then begin
          if AllowDailySkill then begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then begin
              if nSpellPoint > 0 then begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              SendSocket(nil, '+DAILY');
            end;
          end;
        end;
        Result := True;
      end;
    SKILL_MOOTEBO {27}: begin //野蛮冲撞
        Result := True;
        if (GetTickCount - m_dwDoMotaeboTick) > 3000{3 * 1000} then begin
          m_dwDoMotaeboTick := GetTickCount();
          m_btDirection := nTargetX;
          nSpellPoint := GetSpellPoint(UserMagic);
          if m_WAbil.MP >= nSpellPoint then begin
            if nSpellPoint > 0 then begin
              DamageSpell(nSpellPoint);
              HealthSpellChanged();
            end;
            if DoMotaebo(m_btDirection, UserMagic.btLevel) then begin
              if UserMagic.btLevel < 3 then begin
                if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] < m_Abil.Level then begin
                  TrainSkill(UserMagic, Random(3) + 1);
                  if not CheckMagicLevelup(UserMagic) then begin
                    SendDelayMsg(Self,
                      RM_MAGIC_LVEXP,
                      0,
                      UserMagic.MagicInfo.wMagicId,
                      UserMagic.btLevel,
                      UserMagic.nTranPoint,
                      '', 1000);
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    SKILL_40: begin //双龙斩 抱月刀法
        if m_MagicCrsSkill <> nil then begin
          if not m_boCrsHitkill then begin
            SkillCrsOnOff(True);
            SendSocket(nil, '+CRS');
          end else begin
            SkillCrsOnOff(False);
            SendSocket(nil, '+UCRS');
          end;
        end;
        Result := True;
      end;
    43: begin //开天斩
        if m_Magic42Skill <> nil then begin
          if Skill42OnOff then begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then begin
              if nSpellPoint > 0 then begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              //SendSocket(nil, '+TWN') //原形

              //增加 开天轻击 20080212
              if Random(g_Config.n43KillHitRate) = 0 then begin
                m_n42kill := 2;
                SendSocket(nil, '+TWN');
              end else begin
                m_n42kill := 1;
                SendSocket(nil, '+QTWN'); //轻击
              end;
            end;
          end;
        end;
        Result := True;
      end;
    42: begin //龙影剑法(破空剑) 20080131
        if m_Magic43Skill <> nil then begin
         { if not m_bo43kill then begin
            Skill43OnOff(True);
            //if m_nDragonPoint >= g_Config.nMaxDragonPoint then //20080201 黄条气槽满时才能使用技能  //20080619 注释
            SendSocket(nil, '+CID');
          end else begin
           Skill43OnOff(False);
           //m_nDragonPoint:= 0;//关闭时初始黄条气值 20080329  20080403不清空气槽
           SendSocket(nil, '+UCID');
         end; }
          if Skill43OnOff then begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then begin
              if nSpellPoint > 0 then begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              SendSocket(nil, '+CID');
            end;
          end;
        end;  
        Result := True;
      end;
  else begin
      n14 := GetNextDirection(m_nCurrX, m_nCurrY, nTargetX, nTargetY);
      m_btDirection := n14;
      BaseObject := nil;
      //检查目标角色，与目标座标误差范围，如果在误差范围内则修正目标座标
      case UserMagic.wMagIdx of//20080814 修改
        60..65: begin
            if CretInNearXY(TargeTBaseObject, nTargetX, nTargetY, 12) then begin
              BaseObject := TargeTBaseObject;
              nTargetX := BaseObject.m_nCurrX;
              nTargetY := BaseObject.m_nCurrY;
            end;
          end;
        else begin
          if CretInNearXY(TargeTBaseObject, nTargetX, nTargetY) then begin
            BaseObject := TargeTBaseObject;
            nTargetX := BaseObject.m_nCurrX;
            nTargetY := BaseObject.m_nCurrY;
          end;
        end;
      end;//case

      if not DoSpell(UserMagic, nTargetX, nTargetY, BaseObject) then begin
        SendRefMsg(RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
      end;
      Result := True;
    end;
  end;
end;

function TBaseObject.RunTo(btDir: Byte; boFlag: Boolean; nDestX, nDestY: Integer): Boolean;
var
  nOldX, nOldY: Integer;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::RunTo';
begin
  Result := False;
  try
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    m_btDirection := btDir;
    case btDir of
      DR_UP {0}: begin
          if (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY - 2, True) > 0) then begin
            Dec(m_nCurrY, 2);
          end;
        end;
      DR_UPRIGHT {1}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
            (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY - 2, True) > 0) then begin
            Inc(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
      DR_RIGHT {2}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY, True) > 0) then begin
            Inc(m_nCurrX, 2);
          end;
        end;
      DR_DOWNRIGHT {3}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
            (m_nCurrY < m_PEnvir.m_nHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY + 2, True) > 0) then begin
            Inc(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWN {4}: begin
          if (m_nCurrY < m_PEnvir.m_nHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY + 2, True) > 0) then begin
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWNLEFT {5}: begin
          if (m_nCurrX > 1) and
            (m_nCurrY < m_PEnvir.m_nHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY + 2, True) > 0) then begin
            Dec(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_LEFT {6}: begin
          if (m_nCurrX > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY, True) > 0) then begin
            Dec(m_nCurrX, 2);
          end;
        end;
      DR_UPLEFT {7}: begin
          if (m_nCurrX > 1) and
            (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY - 2, True) > 0) then begin
            Dec(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
    end;
    if ((m_nCurrX <> nOldX) or (m_nCurrY <> nOldY)) {and ((m_nCurrX = nDestX) and (m_nCurrY = nDestY))} then begin
      if Walk(RM_RUN) then Result := True
      else begin
        m_nCurrX := nOldX;
        m_nCurrY := nOldY;
        m_PEnvir.MoveToMovingObject(nOldX, nOldY, Self, m_nCurrX, m_nCurrX, True);
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

function TPlayObject.HorseRunTo(btDir: Byte; boFlag: Boolean): Boolean;
var
  n10, n14: Integer;
resourcestring
  sExceptionMsg = '{异常} TPlayObject::HorseRunTo';
begin
  Result := False;
  try
    n10 := m_nCurrX;
    n14 := m_nCurrY;
    m_btDirection := btDir;
    case btDir of
      DR_UP {0}: begin
          if (m_nCurrY > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY - 3, True) > 0) then begin

            Dec(m_nCurrY, 3);
          end;
        end;
      DR_UPRIGHT {1}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 3) and
            (m_nCurrY > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 3, m_nCurrY - 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 3, m_nCurrY - 3, True) > 0) then begin

            Inc(m_nCurrX, 3);
            Dec(m_nCurrY, 3);
          end;
        end;
      DR_RIGHT {2}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 3, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 3, m_nCurrY, True) > 0) then begin

            Inc(m_nCurrX, 3);
          end;
        end;
      DR_DOWNRIGHT {3}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 3) and
            (m_nCurrY < m_PEnvir.m_nHeight - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 3, m_nCurrY + 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 3, m_nCurrY + 3, True) > 0) then begin

            Inc(m_nCurrX, 3);
            Inc(m_nCurrY, 3);
          end;
        end;
      DR_DOWN {4}: begin
          if (m_nCurrY < m_PEnvir.m_nHeight - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY + 3, True) > 0) then begin

            Inc(m_nCurrY, 3);
          end;
        end;
      DR_DOWNLEFT {5}: begin
          if (m_nCurrX > 2) and
            (m_nCurrY < m_PEnvir.m_nHeight - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 3, m_nCurrY + 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 3, m_nCurrY + 3, True) > 0) then begin

            Dec(m_nCurrX, 3);
            Inc(m_nCurrY, 3);
          end;
        end;
      DR_LEFT {6}: begin
          if (m_nCurrX > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 3, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 3, m_nCurrY, True) > 0) then begin

            Dec(m_nCurrX, 3);
          end;
        end;
      DR_UPLEFT {7}: begin
          if (m_nCurrX > 2) and
            (m_nCurrY > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 3, m_nCurrY - 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 3, m_nCurrY - 3, True) > 0) then begin

            Dec(m_nCurrX, 3);
            Dec(m_nCurrY, 3);
          end;
        end;
    end;
    //    SysMsg(format('原X:%d 原Y:%d 新X:%d 新Y:%d',[n10,n14,m_nCurrX,m_nCurrY]),c_Green,t_Hint);
    if (m_nCurrX <> n10) or (m_nCurrY <> n14) then begin
      if Walk(RM_HORSERUN) then Result := True
      else begin
        m_nCurrX := n10;
        m_nCurrY := n14;
        m_PEnvir.MoveToMovingObject(n10, n14, Self, m_nCurrX, m_nCurrX, True)
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

function TPlayObject.ClientRunXY(wIdent: Word; nX, nY: Integer; nFlag: Integer; var dwDelayTime: LongWord): Boolean; //004CB11C
var
  nDir: Integer;
  dwCheckTime: LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  if not m_boCanRun then Exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE ] <> 0) and not g_Config.ClientConf.boParalyCanRun) then Exit; //防麻

  if nFlag <> wIdent then begin
    if not CheckActionStatus(wIdent, dwDelayTime) then begin
      m_boFilterAction := False;
      Exit;
    end;
    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwMoveTick;
    if dwCheckTime < g_Config.dwRunIntervalTime then begin
      Inc(m_dwMoveCount);
      dwDelayTime := g_Config.dwRunIntervalTime - dwCheckTime;
      if dwDelayTime > g_Config.dwRunIntervalTime div 3 then begin
        if m_dwMoveCount >= 4 then begin
          m_dwMoveTick := GetTickCount();
          m_dwMoveCount := 0;
          dwDelayTime := g_Config.dwRunIntervalTime div 3;
          if m_boTestSpeedMode then
            SysMsg('跑步忙复位！！！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        end else m_dwMoveCount := 0;
        Exit;
      end else begin
        if m_boTestSpeedMode then
          SysMsg('跑步忙！！！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        Exit;
      end;
    end;
  end;
  
 { if (GetTickCount - m_dwMoveTick) < 600 then begin
    Inc(m_dwMoveCount);
    Inc(m_dwMoveCountA);
  end else begin
    m_dwMoveCount:=0;
    if m_dwMoveCountA > 0 then Dec(m_dwMoveCountA);
  end; }
  
  m_dwMoveTick := GetTickCount();
  //  if (m_dwMoveCount < 4) and (m_dwMoveCountA < 6) then begin
  m_bo316 := False;
  nDir := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
  if RunTo(nDir, False, nX, nY) then begin
    m_dwStationTick := GetTickCount; //增加检测人物站立不动时间
    if m_boTransparent and (m_boHideMode) then m_wStatusTimeArr[STATE_TRANSPARENT ] := 1;
    if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then Result := True;
    Dec(m_nHealthTick, 60);
    Dec(m_nSpellTick, 10);
    m_nSpellTick := _MAX(0, m_nSpellTick);
    Dec(m_nPerHealth);
    Dec(m_nPerSpell);
  end else begin
    m_dwMoveCount := 0;
    m_dwMoveCountA := 0;
  end;
  {
    end else begin
      Inc(m_dwOverSpeedCount);
      //if m_dwOverSpeedCount > 8 then m_boEmergencyClose:=True;
      SysMsg('跑步超速！！！',c_Red,t_Hint);
      if boViewHackMessage then begin
        MainOutMessage('[11002-Run] ' + m_sCharName + ' ' + DateToStr(Now));
      end;
    end;
  }
end;

function TPlayObject.ClientWalkXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean; //004CAF08
var
  n14{, n18, n1C}: Integer;
  dwCheckTime: LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  if not m_boCanWalk then Exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] <> 0) and not g_Config.ClientConf.boParalyCanWalk) then Exit; //防麻
  if not boLateDelivery then begin
    if not CheckActionStatus(wIdent, dwDelayTime) then begin
      m_boFilterAction := False;
      Exit;
    end;
    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwMoveTick;
    if dwCheckTime < g_Config.dwWalkIntervalTime then begin
      Inc(m_dwMoveCount);
      dwDelayTime := g_Config.dwWalkIntervalTime - dwCheckTime;
      if dwDelayTime > g_Config.dwWalkIntervalTime div 3 then begin
        if m_dwMoveCount >= 4 then begin
          m_dwMoveTick := GetTickCount();
          m_dwMoveCount := 0;
          dwDelayTime := g_Config.dwWalkIntervalTime div 3;
          if m_boTestSpeedMode then
            SysMsg('走路忙复位！！！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        end else m_dwMoveCount := 0;
        Exit;
      end else begin
        if m_boTestSpeedMode then
          SysMsg('走路忙！！！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        Exit;
      end;
    end;
  end;
  {
  if (GetTickCount - m_dwMoveTick) < 600 then begin
    Inc(m_dwMoveCount);
    Inc(m_dwMoveCountA);
  end else begin
    m_dwMoveCount:=0;
    if m_dwMoveCountA > 0 then Dec(m_dwMoveCountA);
  end;
  }
  m_dwMoveTick := GetTickCount();
  m_bo316 := False;
 // n18 := m_nCurrX;  20080117
 // n1C := m_nCurrY;  20080117
  n14 := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
  if not m_boClientFlag then begin
    if (n14 = 0) and (m_nStep = 0) then Inc(m_nStep)
    else
      if (n14 = 4) and (m_nStep = 1) then Inc(m_nStep)
    else
      if (n14 = 6) and (m_nStep = 2) then Inc(m_nStep)
    else
      if (n14 = 2) and (m_nStep = 3) then Inc(m_nStep)
    else
      if (n14 = 1) and (m_nStep = 4) then Inc(m_nStep)
    else
      if (n14 = 5) and (m_nStep = 5) then Inc(m_nStep)
    else
      //      if (n14 = 3) and (m_nStep = 6) then Inc(m_nStep)
      if (n14 = 7) and (m_nStep = 6) then Inc(m_nStep)
    else
      //      if (n14 = 7) and (m_nStep = 7) then Inc(m_nStep)
      if (n14 = 3) and (m_nStep = 7) then Inc(m_nStep)
    else begin
      m_nStep := 0;
    end;
  end;

  if WalkTo(n14, False) then begin
    m_dwStationTick := GetTickCount; //增加检测人物站立不动时间
    if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
      Result := True;
    Dec(m_nHealthTick, 10);
  end else begin
    m_dwMoveCount := 0;
    m_dwMoveCountA := 0;
  end;
  {
  end else begin
    Inc(m_dwOverSpeedCount);
    //if m_dwOverSpeedCount > 8 then m_boEmergencyClose:=True;
    SysMsg('走步超速！！！',c_Red,t_Hint);
    if boViewHackMessage then begin
      MainOutMessage('[11002-Walk] ' + m_sCharName + ' ' + DateToStr(Now));
    end;
  end;
  }
end;
//刺杀剑法开关
procedure TBaseObject.ThrustingOnOff(boSwitch: Boolean);
begin
  m_boUseThrusting := boSwitch;
  if m_boUseThrusting then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sThrustingOn, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) ' +sThrustingOn, BB_Fuchsia, t_Hint);//20080312
    end;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sThrustingOff, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) ' +sThrustingOff, BB_Fuchsia, t_Hint);//20080312
    end;
  end;
end;
//半月弯刀开关
procedure TBaseObject.HalfMoonOnOff(boSwitch: Boolean);
begin
  m_boUseHalfMoon := boSwitch;
  if m_boUseHalfMoon then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sHalfMoonOn, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) ' +sHalfMoonOn, BB_Fuchsia, t_Hint); //20080312
    end;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sHalfMoonOff, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) ' +sHalfMoonOff, BB_Fuchsia, t_Hint);//20080312
    end;
  end;
end;

procedure TBaseObject.SkillCrsOnOff(boSwitch: Boolean);
begin
  m_boCrsHitkill := boSwitch;
  if m_boCrsHitkill then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sCrsHitOn, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) ' +sCrsHitOn, BB_Fuchsia, t_Hint); //20080312
    end;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sCrsHitOff, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) ' +sCrsHitOff, BB_Fuchsia, t_Hint);//20080312
    end;
  end;
end;

//开天斩 20080202
function TBaseObject.Skill42OnOff(): Boolean;
begin
  Result := False;
  if (GetTickCount -  m_dwLatest42Tick) > g_Config.nKill43UseTime * 1000 then begin
    m_dwLatest42Tick := GetTickCount();
    m_bo42kill := True;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sSkill42On, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+sSkill42On, BB_Fuchsia, t_Hint); //20080312
    end;
    Result := True;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sSkill42Off, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+sSkill42Off, BB_Fuchsia, t_Hint); //20080312
    end;
  end;
end;
//20080619 替换
function TBaseObject.Skill43OnOff(): Boolean;
begin
  Result := False;
  if (GetTickCount -  m_dwLatest43Tick) > g_Config.nKill42UseTime * 1000 then begin //20080619 增加
    m_dwLatest43Tick := GetTickCount();//20080619 增加
    m_bo43kill := True;//20080619 增加
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sSkill43On, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+sSkill43On, BB_Fuchsia, t_Hint); //20080312
    end;
    Result := True;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sSkill43Off, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+ sSkill43Off, BB_Fuchsia, t_Hint); //20080312
    end;
  end;
end;

//烈火剑法 20080111
function TBaseObject.AllowFireHitSkill(): Boolean;
begin
  Result := False;
  if (GetTickCount - m_dwLatestFireHitTick) > 10000{10 * 1000} then begin
    m_dwLatestFireHitTick := GetTickCount();
    m_boFireHitSkill := True;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sFireSpiritsSummoned, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+sFireSpiritsSummoned, BB_Fuchsia, t_Hint);//20080312
    end;
    Result := True;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sFireSpiritsFail, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+sFireSpiritsFail, BB_Fuchsia, t_Hint);//20080312
    end;
  end;
end;
//逐日剑法 20080511
function TBaseObject.AllowDailySkill(): Boolean;
begin
  Result := False;
  if (GetTickCount - m_dwLatestDailyTick) > 10000{10 * 1000} then begin
    m_dwLatestDailyTick := GetTickCount();
    m_boDailySkill := True;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sDailySkillSummoned, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+ sDailySkillSummoned, BB_Fuchsia, t_Hint);//20080312
    end;
    Result := True;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sDailySkillFail, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+sDailySkillFail, BB_Fuchsia, t_Hint);//20080312
    end;
  end;
end;

//地图随机移动
procedure TBaseObject.MapRandomMove(sMapName: string; nInt: Integer);
var
  Envir: TEnvirnoment;
  n10, n14, n18: Integer;
begin
  Envir := g_MapManager.FindMap(sMapName);
  if Envir <> nil then begin
    if Envir.m_nHeight < 150 then begin
      if Envir.m_nHeight < 30 then begin
        n18 := 2;
      end else n18 := 20;
    end else n18 := 50;
    n10 := Random(Envir.m_nWidth - n18 - 1) + n18;
    n14 := Random(Envir.m_nHeight - n18 - 1) + n18;
    SpaceMove(sMapName, n10, n14, nInt);
  end;
end;
//点击NPC
procedure TPlayObject.ClientClickNPC(NPC: Integer);
var
  NormNpc: TNormNpc;
begin
  if not m_boCanDeal then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotTryDealMsg);
    Exit;
  end;
  if m_boDeath or m_boGhost then Exit;

  NormNpc := UserEngine.FindMerchant(TObject(NPC));
  if NormNpc = nil then NormNpc := UserEngine.FindNPC(TObject(NPC));

  if NormNpc <> nil then begin
    if (NormNpc.m_PEnvir = m_PEnvir) and (abs(NormNpc.m_nCurrX - m_nCurrX) <= 15) and (abs(NormNpc.m_nCurrY - m_nCurrY) <= 15) then begin
      NormNpc.Click(Self);
    end;
  end;
end;

function TBaseObject.AddItemToBag(UserItem: pTUserItem): Boolean;
begin
  Result := False;
  if m_ItemList.Count < MAXBAGITEM then begin
    m_ItemList.Add(UserItem);
    WeightChanged();
    Result := True;
  end;
end;

function TPlayObject.GetRangeHumanCount: Integer;
begin
  Result := UserEngine.GetMapOfRangeHumanCount(m_PEnvir, m_nCurrX, m_nCurrY, 10);
end;
//判断心灵启示等级
procedure TBaseObject.sub_4C713C(Magic: pTUserMagic);
begin
  if Magic <> nil then begin
    if Magic.MagicInfo.wMagicId = 28 then
      if Magic.btLevel >= 2 then m_boAbilSeeHealGauge := True;
  end;
end;
//取复活点
procedure TPlayObject.GetStartPoint;
var
  I: Integer;
  StartPoint: pTStartPoint;
begin
  try
    g_StartPointList.Lock;
    for I := 0 to g_StartPointList.Count - 1 do begin
      if g_StartPointList.Strings[I] = m_PEnvir.sMapName then begin
        StartPoint := pTStartPoint(g_StartPointList.Objects[I]);
        if StartPoint <> nil then begin
          if (abs(m_nCurrX - StartPoint.m_nCurrX) < 50) and (abs(m_nCurrY - StartPoint.m_nCurrY) < 50{g_Config.nSafeZoneSize}) then begin
            m_sHomeMap := g_StartPointList.Strings[I];
            m_nHomeX := StartPoint.m_nCurrX;
            m_nHomeY := StartPoint.m_nCurrY;
            Break;
          end;
        end;
      end;
    end;//for
    if PKLevel >= 2 then begin
      m_sHomeMap := g_Config.sRedHomeMap;
      m_nHomeX := g_Config.nRedHomeX;
      m_nHomeY := g_Config.nRedHomeY;
    end;
  finally
    g_StartPointList.UnLock;
  end;
end;

function TBaseObject.GetQuestFalgStatus(nFlag: Integer): Integer;
var
  n10, n14: Integer;
begin
  Result := 0;
  Dec(nFlag);
  if nFlag < 0 then Exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestFlag)) < 0 then begin
    if ((128 shr n14) and (m_QuestFlag[n10])) <> 0 then Result := 1
    else Result := 0;
  end;
end;

procedure TBaseObject.SetQuestFlagStatus(nFlag: Integer; nValue: Integer);
var
  n10, n14: Integer;
  bt15: Byte;
begin
  Dec(nFlag);
  if nFlag < 0 then Exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestFlag)) < 0 then begin
    bt15 := m_QuestFlag[n10];
    if nValue = 0 then begin
      m_QuestFlag[n10] := (not (128 shr n14)) and (bt15);
    end else begin
      m_QuestFlag[n10] := (128 shr n14) or (bt15);
    end;
  end;
end;
//增加人物技能
procedure TPlayObject.CmdTrainingMagic(Cmd: pTGameCmd; sHumanName, sSkillName: string;
  nLevel: Integer);
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) or (sHumanName = '') or (sSkillName = '') or (nLevel < 0) or not (nLevel in [0..3]) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称  技能名称 修炼等级(0-3)', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  Magic := UserEngine.FindMagic(sSkillName);
  if Magic = nil then begin
    SysMsg(Format('%s 技能名称不正确！！！', [sSkillName]), c_Red, t_Hint);
    Exit;
  end;

  if PlayObject.IsTrainingSkill(Magic.wMagicId) then begin
    SysMsg(Format('%s 技能已修炼过了！！！', [sSkillName]), c_Red, t_Hint);
    Exit;
  end;
  //没有内功心法,则不能学内功技能 20081001
  if (Magic.sDescr = '内功') and (not PlayObject.m_boTrainingNG) then begin
    SysMsg(Format('玩家%s 没学过内功心法,不能学习此 %s 技能！！！', [sHumanName, sSkillName]), c_Red, t_Hint);
    Exit;
  end;
  New(UserMagic);
  UserMagic.MagicInfo := Magic;
  UserMagic.wMagIdx := Magic.wMagicId;
  UserMagic.btLevel := nLevel;
  UserMagic.btKey := 0;
  UserMagic.nTranPoint := 0;
  PlayObject.m_MagicList.Add(UserMagic);
  PlayObject.SendAddMagic(UserMagic);
  PlayObject.RecalcAbilitys;
  PlayObject.CompareSuitItem(False);//200081213 套装
  SysMsg(Format('%s 的 %s 技能修炼成功！！！', [sHumanName, sSkillName]), c_Green, t_Hint);
end;
//调整玩家技能
procedure TPlayObject.CmdTrainingSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string;
  nLevel: Integer);
var
  I: Integer;
  UserMagic: pTUserMagic;
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sSkillName = '') or (nLevel <= 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称  技能名称 修炼等级(0-3)', c_Red, t_Hint);
    Exit;
  end;
  nLevel := _MIN(3, nLevel);
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format('%s不在线，或在其它服务器上！！', [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  if PlayObject.m_MagicList.Count > 0 then begin//20080629
    for I := 0 to PlayObject.m_MagicList.Count - 1 do begin
      UserMagic := PlayObject.m_MagicList.Items[I];
      if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then begin
        UserMagic.btLevel := nLevel;
        PlayObject.SendMsg(PlayObject,
          RM_MAGIC_LVEXP,
          0,
          UserMagic.MagicInfo.wMagicId,
          UserMagic.btLevel,
          UserMagic.nTranPoint,
          '');
        PlayObject.SysMsg(Format('%s的修改炼等级为%d', [sSkillName, nLevel]), c_Green, t_Hint);
        SysMsg(Format('%s的技能%s修炼等级为%d', [sHumanName, sSkillName, nLevel]), c_Green, t_Hint);
        Break;
      end;
    end;//for
  end;
end;

procedure TPlayObject.CmdAddGameGold(sCmd, sHumName: string;
  nPoint: Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < 6) then Exit;
  if (sHumName = '') or (nPoint <= 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 人物名称  数量', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    if (PlayObject.m_nGameGold + nPoint) < 2000000 then begin
      Inc(PlayObject.m_nGameGold, nPoint);
    end else begin
      nPoint := 2000000 - PlayObject.m_nGameGold;
      PlayObject.m_nGameGold := 2000000;
    end;
    if g_boGameLogGameGold then
      AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
         PlayObject.m_sMapName,
          PlayObject.m_nCurrX,
          PlayObject.m_nCurrY,
          PlayObject.m_sCharName,
          g_Config.sGameGoldName,
          PlayObject.m_nGameGold,
          '命令+('+inttostr(nPoint)+')',
          m_sCharName]));
    PlayObject.GoldChanged();
    SysMsg(sHumName + '的游戏点已增加' + IntToStr(nPoint) + '.', c_Green, t_Hint);
    PlayObject.SysMsg('游戏点已增加' + IntToStr(nPoint) + '.', c_Green, t_Hint);
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdDelGameGold(sCmd, sHumName: string;
  nPoint: Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < 6) then Exit;
  if (sHumName = '') or (nPoint <= 0) then Exit;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    if PlayObject.m_nGameGold > nPoint then begin
      Dec(PlayObject.m_nGameGold, nPoint);
    end else begin
      nPoint := PlayObject.m_nGameGold;
      PlayObject.m_nGameGold := 0;
    end;
    if g_boGameLogGameGold then
      AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
         PlayObject.m_sMapName,
          PlayObject.m_nCurrX,
          PlayObject.m_nCurrY,
          PlayObject.m_sCharName,
          g_Config.sGameGoldName,
          PlayObject.m_nGameGold,
          '命令-('+inttostr(nPoint)+')',
          m_sCharName]));
    PlayObject.GoldChanged();
    SysMsg(sHumName + '的游戏点已减少' + IntToStr(nPoint) + '.', c_Green, t_Hint);
    PlayObject.SysMsg('游戏点已减少' + IntToStr(nPoint) + '.', c_Green, t_Hint);
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdGameGold(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGold: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sCtr <> '') then begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nGold < 0) or (nGold > 200000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGameGoldHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': begin
        PlayObject.m_nGameGold := nGold;
      end;
    '+': Inc(PlayObject.m_nGameGold, nGold);
    '-': Dec(PlayObject.m_nGameGold, nGold);
  end;
  if g_boGameLogGameGold then begin
    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, PlayObject.m_sMapName,
        PlayObject.m_nCurrX, PlayObject.m_nCurrY, PlayObject.m_sCharName,
        g_Config.sGameGoldName, PlayObject.m_nGameGold,
        sCtr[1]+'('+inttostr(nGold)+')', m_sCharName+'(GM)']));
  end;
  GameGoldChanged();
  PlayObject.SysMsg(Format(g_sGameCommandGameGoldHumanMsg, [g_Config.sGameGoldName, nGold, PlayObject.m_nGameGold, g_Config.sGameGoldName]), c_Green, t_Hint);
  SysMsg(Format(g_sGameCommandGameGoldGMMsg, [sHumanName, g_Config.sGameGoldName, nGold, PlayObject.m_nGameGold, g_Config.sGameGoldName]), c_Green, t_Hint);
end;
//20071226 金刚石
procedure TPlayObject.CmdGameDiaMond(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGameDiaMond: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);//权限不够
    Exit;
  end;
  if (sCtr <> '') then begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nGameDiaMond < 0) or (nGameDiaMond > 200000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
   if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGameDiaMondHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': begin
        PlayObject.m_nGameDiaMond := nGameDiaMond;
      end;
    '+': Inc(PlayObject.m_nGameDiaMond, nGameDiaMond);
    '-': Dec(PlayObject.m_nGameDiaMond, nGameDiaMond);
  end;
  if g_boGameLogGameDiaMond then begin
    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameDiaMond,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGameDiaMond,
        PlayObject.m_nGameDiaMond,
        sCtr[1]+'('+inttostr(nGameDiaMond)+')',
        m_sCharName]));
  end;
  GameGoldChanged();
  PlayObject.SysMsg(Format(g_sGameCommandGameDiaMondHumanMsg, [g_Config.sGameDiaMond, nGameDiaMond, PlayObject.m_nGameDiaMond, g_Config.sGameDiaMond]), c_Green, t_Hint);
  SysMsg(Format(g_sGameCommandGameDiaMondGMMsg, [sHumanName, g_Config.sGameDiaMond, nGameDiaMond, PlayObject.m_nGameDiaMond, g_Config.sGameDiaMond]), c_Green, t_Hint);
end;
//20071226 灵符
procedure TPlayObject.CmdGameGird(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGameGird: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);//权限不够
    Exit;
  end;
  if (sCtr <> '') then begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nGameGird < 0) or (nGameGird > 200000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
   if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGameGirdHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': begin
        PlayObject.m_nGameGird := nGameGird;
      end;
    '+': Inc(PlayObject.m_nGameGird, nGameGird);
    '-': Dec(PlayObject.m_nGameGird, nGameGird);
  end;
  if g_boGameLogGameGird then begin
    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGird,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGameGird,
        PlayObject.m_nGameGird,
        sCtr[1]+'('+inttostr(nGameGird)+')',
        m_sCharName]));
  end;
  GameGoldChanged();
  PlayObject.SysMsg(Format(g_sGameCommandGameGirdHumanMsg, [g_Config.sGameGird, nGameGird, PlayObject.m_nGameGird, g_Config.sGameGird]), c_Green, t_Hint);
  SysMsg(Format(g_sGameCommandGameGirdGMMsg, [sHumanName, g_Config.sGameGird, nGameGird, PlayObject.m_nGameGird, g_Config.sGameGird]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdGameGlory(Cmd: pTGameCmd; sHumanName,
  sCtr: string; nGameGlory: Byte);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);//权限不够
    Exit;
  end;
  if (sCtr <> '') then begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nGameGlory < 0) or (nGameGlory > 255) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGameGloryHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': begin
        PlayObject.m_btGameGlory := nGameGlory;
      end;
    '+': Inc(PlayObject.m_btGameGlory, nGameGlory);
    '-': Dec(PlayObject.m_btGameGlory, nGameGlory);
  end;
  if g_boGameLogGameGlory then begin
    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGlory,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGameGlory,
        PlayObject.m_btGameGlory,
        sCtr[1]+'('+inttostr(nGameGlory)+')',
        m_sCharName]));
  end;
  GameGloryChanged();
  PlayObject.SysMsg(Format(g_sGameCommandGameGirdHumanMsg, [g_Config.sGameGlory, nGameGlory, PlayObject.m_btGameGlory, g_Config.sGameGlory]), c_Green, t_Hint);
  SysMsg(Format(g_sGameCommandGameGirdGMMsg, [sHumanName, g_Config.sGameGlory, nGameGlory, PlayObject.m_btGameGlory, g_Config.sGameGlory]), c_Green, t_Hint);
end;

//20080109 英雄的忠诚度
procedure TPlayObject.CmdHeroLoyal(Cmd: pTGameCmd; sHumanName: string; nHeroLoyal: Integer);
var
  PlayObject: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);//权限不够
    Exit;
  end;

  if (sHumanName = '') or  (nHeroLoyal < 0) or (nHeroLoyal > 10000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
   if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandHeroLoyalHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject <>  nil then begin
    THeroObject(PlayObject).m_nLoyal:= nHeroLoyal ;
    m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, THeroObject(PlayObject).m_btGender, 0, THeroObject(PlayObject).m_btJob, THeroObject(PlayObject).m_nLoyal, 0);//20080305 替换上面一句
    SendSocket(@m_DefMsg, EncodeBuffer(@THeroObject(PlayObject).m_WAbil, SizeOf(TAbility)));//20080320 

    SysMsg('[英雄忠诚度调整] ' + sHumanName + ' -> (' + IntToStr(THeroObject(PlayObject).m_nLoyal div 100) + '%)', BB_Fuchsia, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessage('[英雄忠诚度调整] ' + sHumanName + ' -> (' + IntToStr(THeroObject(PlayObject).m_nLoyal) + ')');
  end else begin
    SysMsg('英雄'+sHumanName+'现在不在线。', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdGamePoint(Cmd: pTGameCmd; sHumanName, sCtr: string; nPoint: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sCtr <> '') then begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nPoint < 0) or (nPoint > 100000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGamePointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': begin
        PlayObject.m_nGamePoint := nPoint;
      end;
    '+': Inc(PlayObject.m_nGamePoint, nPoint);
    '-': Dec(PlayObject.m_nGamePoint, nPoint);
  end;
  if g_boGameLogGamePoint then begin
    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEPOINT,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGamePointName,
        PlayObject.m_nGamePoint,
        sCtr[1]+'('+inttostr(nPoint)+')',
        m_sCharName]));
  end;
  GameGoldChanged();
  PlayObject.SysMsg(Format(g_sGameCommandGamePointHumanMsg, [nPoint, PlayObject.m_nGamePoint]), c_Green, t_Hint);
  SysMsg(Format(g_sGameCommandGamePointGMMsg, [sHumanName, nPoint, PlayObject.m_nGamePoint]), c_Green, t_Hint);
end;
//GM调整声望值 
procedure TPlayObject.CmdCreditPoint(Cmd: pTGameCmd; sHumanName, sCtr: string; nPoint: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
  nCreditPoint: Integer;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sCtr <> '') then begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nPoint < 0) or (nPoint > High(Integer)) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
   if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandCreditPointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': begin
        //if nPoint in [0..255] then //20080118
          PlayObject.m_btCreditPoint := nPoint;
      end;
    '+': begin
        nCreditPoint := PlayObject.m_btCreditPoint + nPoint;
       // if nPoint in [0..255] then//20080118
          PlayObject.m_btCreditPoint := nCreditPoint;
      end;
    '-': begin
        nCreditPoint := PlayObject.m_btCreditPoint - nPoint;
        //if nPoint in [0..255] then //20080118
        PlayObject.m_btCreditPoint := nCreditPoint;
      end;
  end;
  PlayObject.SysMsg(Format(g_sGameCommandCreditPointHumanMsg, [nPoint, PlayObject.m_btCreditPoint]), c_Green, t_Hint);
  SysMsg(Format(g_sGameCommandCreditPointGMMsg, [sHumanName, nPoint, PlayObject.m_btCreditPoint]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdAddGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
var
  PlayObject: TPlayObject;
  nServerIndex: Integer;
begin
  if (m_btPermission < 6) then Exit;
  if (sHumName = '') or (nCount <= 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称  金币数量', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    if (PlayObject.m_nGold + nCount) < PlayObject.m_nGoldMax then begin
      Inc(PlayObject.m_nGold, nCount);
    end else begin
      nCount := PlayObject.m_nGoldMax - PlayObject.m_nGold;
      PlayObject.m_nGold := PlayObject.m_nGoldMax;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + '的金币已增加' + IntToStr(nCount) + '.', c_Green, t_Hint);
    //004CD6F6
    if g_boGameLogGold then
      AddGameDataLog('14' + #9 +
        m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 +
        IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 +
        sSTRING_GOLDNAME + #9 +
        IntToStr(nCount) + #9 +
        '1' + #9 +
        sHumName);
  end else begin
    if UserEngine.FindOtherServerUser(sHumName, nServerIndex) then begin
      SysMsg(sHumName + ' 现在' + IntToStr(nServerIndex) + '号服务器上', c_Green, t_Hint);
    end else begin
      FrontEngine.AddChangeGoldList(m_sCharName, sHumName, nCount);
      SysMsg(sHumName + ' 现在不在线，等其上线时金币将自动增加', c_Green, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdAddGuild(Cmd: pTGameCmd; sGuildName, sGuildChief: string); //004CEBA0
var
  Human: TPlayObject;
  boAddState: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg('这个命令只能使用在主服务器上', c_Red, t_Hint);
    Exit;
  end;
  if (sGuildName = '') or (sGuildChief = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 行会名称 掌门人名称', c_Red, t_Hint);
    Exit;
  end;

  boAddState := False;
  Human := UserEngine.GetPlayObject(sGuildChief);
  if Human = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sGuildChief]), c_Red, t_Hint);
    Exit;
  end;
  if g_GuildManager.MemberOfGuild(sGuildChief) = nil then begin
    if g_GuildManager.AddGuild(sGuildName, sGuildChief) then begin
      UserEngine.SendServerGroupMsg(SS_205, nServerIndex, sGuildName + '/' + sGuildChief);
      SysMsg('行会名称: ' + sGuildName + ' 掌门人: ' + sGuildChief, c_Green, t_Hint);
      boAddState := True;
    end;
  end;
  if boAddState then begin
    Human.m_MyGuild := TObject(g_GuildManager.MemberOfGuild(Human.m_sCharName));
    if Human.m_MyGuild <> nil then begin
      Human.m_sGuildRankName := TGUild(Human.m_MyGuild).GetRankName(Self, Human.m_nGuildRankNo);
      Human.RefShowName();
    end;
  end;
  {
  if boAddState then begin
    SysMsg('YouScrewedUp',c_Red,t_Hint);
  end;
  }
end;

procedure TPlayObject.CmdAdjuestExp(Cmd: pTGameCmd; sHumanName, sExp: string);
var
  PlayObject: TPlayObject;
  dwExp: LongWord;
  dwOExp: LongWord;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 经验值', c_Red, t_Hint);
    Exit;
  end;
  dwExp := Str_ToInt(sExp, 0);

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    dwOExp := PlayObject.m_Abil.Exp;
    PlayObject.m_Abil.Exp := dwExp;
    PlayObject.HasLevelUp(1);
    SysMsg(sHumanName + ' 经验调整完成。', c_Green, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessage('[经验调整] ' + m_sCharName + '(' + PlayObject.m_sCharName + ' ' + IntToStr(dwOExp) + ' -> ' + IntToStr(PlayObject.m_Abil.Exp) + ')');
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;
//千里传音 20071228
procedure TPlayObject.CmdSysMsg(Cmd: pTGameCmd;Text: string);
var
  I:integer;
  AmuletStdItem: pTStdItem;
  PlayObject: TPlayObject;
//  DestMsg: array[0..256] of Char;
//  sSrcMsg: string;
begin
  if Text = '' then begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 发布信息', c_Red, t_Hint);
    Exit;
  end;

  //文字过滤,如果是过滤列表中的文字，则替换文字
  {if Assigned(zPlugOfEngine.PlayObjectFilterMsg) then begin //20080524
      sSrcMsg := Text;
      FillChar(DestMsg, SizeOf(DestMsg), 0);
     if zPlugOfEngine.PlayObjectFilterMsg(self, PChar(sSrcMsg), @DestMsg) then begin//文字过滤
       Text := StrPas(PChar(@DestMsg));
     end;
  end; }
 IsFilterMsg(Text); //文字过滤 20080729

 if m_UseItems[U_CHARM].wIndex > 0 then begin
  AmuletStdItem := UserEngine.GetStdItem(m_UseItems[U_CHARM].wIndex);
  if (AmuletStdItem <> nil) and (AmuletStdItem.StdMode = 7) and (AmuletStdItem.Shape = 0)  then begin //物品是千里传音
    if m_UseItems[U_CHARM].Dura >=1000 then begin
      Dec(m_UseItems[U_CHARM].Dura,1000);
      SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');//减少持久数
      try  //20080309 修改  千里传音 的字的颜色
        EnterCriticalSection(ProcessHumanCriticalSection);
        for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
          PlayObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
          if PlayObject <> nil then begin
            if not PlayObject.m_boGhost then
              PlayObject.SysMsg(m_sCharName+':'+ Text, c_Fuchsia, t_Say);
          end;
        end;//for
      finally
        LeaveCriticalSection(ProcessHumanCriticalSection);
      end;
      if m_UseItems[U_CHARM].Dura <= 0 then begin //20080506
        SendDelItems(@m_UseItems[U_CHARM]); //如果使用完，则删除物品
        m_UseItems[U_CHARM].Dura := 0;
        m_UseItems[U_CHARM].wIndex := 0;
      end;
    end else begin
      SendDelItems(@m_UseItems[U_CHARM]); //如果使用完，则删除物品
      m_UseItems[U_CHARM].Dura := 0;
      m_UseItems[U_CHARM].wIndex := 0;
    end;
  end;
 end else
 begin
  SysMsg('没有千里传音,或没有穿上装备栏里。', c_Red, t_Hint);
 end;
end;

//调整英雄等级 20071227
procedure TPlayObject.CmdHeroLevel(Cmd: pTGameCmd;sHeroName: string;
  nLevel: Integer);
var
  PlayObject:TBaseObject;
  nOLevel: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);//权限不够
    Exit;
  end;
  if sHeroName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 英雄名称 等级', c_Red, t_Hint);
    Exit;
  end;

  PlayObject:=UserEngine.GetHeroObject(sHeroName);
  if PlayObject <> nil then begin
    nOLevel := PlayObject.m_Abil.Level;
    PlayObject.m_Abil.Level:= _MAX(1, _MIN(MAXUPLEVEL, nLevel));
    PlayObject.HasLevelUp(1);
    AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志 20080911
      IntToStr(PlayObject.m_nCurrX) + #9 +
      IntToStr(PlayObject.m_nCurrY)+ #9 +
      PlayObject.m_sCharName + #9 +
      IntToStr(PlayObject.m_Abil.Level) + #9 +
      m_sCharName + #9 +
      '+('+IntToStr(nLevel)+')' + #9 +'(英雄)');
    SysMsg('英雄 '+sHeroName + ' 等级调整完成。', BB_Fuchsia, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessage('[英雄等级调整] ' + sHeroName + '('+ IntToStr(nOLevel) + ' -> ' + IntToStr(PlayObject.m_Abil.Level) + ')');
  end else begin
    SysMsg('英雄'+sHeroName+'现在不在线。', c_Red, t_Hint);
  end;
end;
//调整人物等级
procedure TPlayObject.CmdAdjuestLevel(Cmd: pTGameCmd; sHumanName: string;
  nLevel: Integer);
var
  PlayObject: TPlayObject;
  nOLevel: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 等级', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    nOLevel := PlayObject.m_Abil.Level;
    PlayObject.m_Abil.Level := _MAX(1, _MIN(MAXUPLEVEL, nLevel));
    PlayObject.HasLevelUp(1);
    AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志 20080911
      IntToStr(PlayObject.m_nCurrX) + #9 +
      IntToStr(PlayObject.m_nCurrY)+ #9 +
      PlayObject.m_sCharName + #9 +
      IntToStr(PlayObject.m_Abil.Level) + #9 +
      m_sCharName + #9 + '+('+IntToStr(nLevel)+')' + #9 +'0');
    SysMsg(sHumanName + ' 等级调整完成。', c_Green, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessage('[等级调整] ' + m_sCharName + '(' + PlayObject.m_sCharName + ' ' + IntToStr(nOLevel) + ' -> ' + IntToStr(PlayObject.m_Abil.Level) + ')');
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;
//调整人物内功等级 20081221
procedure TPlayObject.CmdNGLevel(Cmd: pTGameCmd; sHumanName: string; nLevel: Integer);
var
  PlayObject: TPlayObject;
  HeroObject: TBaseObject;
  nOLevel: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (nLevel < 0) or (nLevel > 255) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 内功等级(1-255)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if PlayObject.m_boTrainingNG then begin
      nOLevel := PlayObject.m_NGLevel;
      PlayObject.m_NGLevel := _MAX(1, _MIN(255, nLevel));
      PlayObject.SendNGData;//发送内功数据
      PlayObject.SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP,0, 0, 0, ''); //人物升级动画  20081221
      AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志
        IntToStr(PlayObject.m_nCurrX) + #9 +
        IntToStr(PlayObject.m_nCurrY)+ #9 +
        PlayObject.m_sCharName + #9 +
        IntToStr(PlayObject.m_NGLevel) + #9 +
        '内功' + #9 +'=('+IntToStr(nLevel)+')' + #9 +
        m_sCharName+'(GM)');
      SysMsg(sHumanName + ' 内功等级调整完成。', c_Green, t_Hint);
      if g_Config.boShowMakeItemMsg then
        MainOutMessage('[内功等级调整] ' + m_sCharName + '(' + PlayObject.m_sCharName + ' ' + IntToStr(nOLevel) + ' -> ' + IntToStr(PlayObject.m_NGLevel) + ')');
    end else SysMsg(PlayObject.m_sCharName+' 还未学习内功心法!!!', c_Red, t_Hint);
  end else begin
    HeroObject:= UserEngine.GetHeroObject(sHumanName);//查找英雄
    if HeroObject <> nil then begin
      if THeroObject(HeroObject).m_boTrainingNG then begin
        nOLevel := THeroObject(HeroObject).m_NGLevel;
        THeroObject(HeroObject).m_NGLevel := _MAX(1, _MIN(255, nLevel));
        HeroObject.SendNGData;//发送内功数据
        HeroObject.SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP,0, 0, 0, ''); //人物升级动画  20081221
        AddGameDataLog('17' + #9 + HeroObject.m_sMapName + #9 + //等级调整记录日志
          IntToStr(HeroObject.m_nCurrX) + #9 +
          IntToStr(HeroObject.m_nCurrY)+ #9 +
          HeroObject.m_sCharName + #9 +
          IntToStr(THeroObject(HeroObject).m_NGLevel) + #9 +
          '英雄内功' + #9 +'=('+IntToStr(nLevel)+')' + #9 + m_sCharName+'(GM)');
        SysMsg(sHumanName + ' 内功等级调整完成。', c_Green, t_Hint);
        if g_Config.boShowMakeItemMsg then
          MainOutMessage('[内功等级调整] ' + m_sCharName + '(' + HeroObject.m_sCharName + ' ' + IntToStr(nOLevel) + ' -> ' + IntToStr(THeroObject(HeroObject).m_NGLevel) + ')');
      end else SysMsg(HeroObject.m_sCharName+' 还未学习内功心法!!!', c_Red, t_Hint);
    end else begin
      SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    end;  
  end;
end;

procedure TPlayObject.CmdAdjustExp(Human: TPlayObject; nExp: Integer);
begin
  if (m_btPermission < 6) then Exit;
end;

procedure TPlayObject.CmdBackStep(sCmd: string; nType, nCount: Integer);
begin
  if (m_btPermission < 6) then Exit;
  nType := _MIN(nType, 8);
  if nType = 0 then begin
    CharPushed(GetBackDir(m_btDirection), nCount);
  end else begin
    CharPushed(Random(nType), nCount);
  end;
end;

procedure TPlayObject.CmdBonuPoint(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
var
  PlayObject: TPlayObject;
  sMsg: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumName = '') then begin
    if g_Config.boGMShowFailMsg then  sysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 属性点数(不输入为查看点数)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
    Exit;
  end;
  if (nCount > 0) then begin
    PlayObject.m_nBonusPoint := nCount;
    PlayObject.SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    Exit;
  end;
  sMsg := Format('未分配点数:%d 已分配点数:(DC:%d MC:%d SC:%d AC:%d MAC:%d HP:%d MP:%d HIT:%d SPEED:%d)',
    [PlayObject.m_nBonusPoint,
    PlayObject.m_BonusAbil.DC,
      PlayObject.m_BonusAbil.MC,
      PlayObject.m_BonusAbil.SC,
      PlayObject.m_BonusAbil.AC,
      PlayObject.m_BonusAbil.MAC,
      PlayObject.m_BonusAbil.HP,
      PlayObject.m_BonusAbil.MP,
      PlayObject.m_BonusAbil.Hit,
      PlayObject.m_BonusAbil.Speed
      ]);
  SysMsg(Format('%s的属性点数为:%s', [sHumName, sMsg]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdChangeAdminMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
   if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  m_boAdminMode := boFlag;
  if m_boAdminMode then SysMsg(sGameMasterMode, c_Green, t_Hint)
  else SysMsg(sReleaseGameMasterMode, c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeAttackMode(nMode: Integer; sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7: string);
begin
  (*{$IF DEBUG = 0}
    asm
      jz @@Start
      jnz @@Start
      db 0F4h
      db 0EBh
      db 004h
      db 0E8h
      @@Start:
    end;
  {$IFEND}
    if sParam2 <> '' then begin
  {$IF DEBUG = 0}
      asm
      jz @@Start
      jnz @@Start
      db 0F4h
      db 0EBh
      db 004h
      db 0E8h
      @@Start:
      end;
  {$IFEND}
      ProcessUserCmd(sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7);
  {$IF DEBUG = 0}
      asm
      jz @@Start
      jnz @@Start
      db 0F4h
      db 0EBh
      db 004h
      db 0E8h
      @@Start:
      end;
  {$IFEND}
      exit;
    end;
  {$IF DEBUG = 0}
    asm
      jz @@Start
      jnz @@Start
      db 0F4h
      db 0EBh
      db 004h
      db 0E8h
      @@Start:
    end;
  {$IFEND}*)
  if (nMode >= 0) and (nMode <= 4) then
    m_btAttatckMode := nMode
  else begin
    if m_btAttatckMode < HAM_PKATTACK then Inc(m_btAttatckMode)
    else m_btAttatckMode := HAM_ALL;
  end;
  case m_btAttatckMode of         //20080228改攻击模式
    {HAM_ALL: SysMsg(sAttackModeOfAll, c_Green, t_Hint); //[攻击模式: 全体攻击]
    HAM_PEACE: SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint); //[攻击模式: 和平攻击]
    HAM_DEAR: SysMsg(sAttackModeOfDear, c_Green, t_Hint); //[攻击模式: 夫妻攻击]
    HAM_MASTER: SysMsg(sAttackModeOfMaster, c_Green, t_Hint); //[攻击模式: 师徒攻击]
    HAM_GROUP: SysMsg(sAttackModeOfGroup, c_Green, t_Hint); //[攻击模式: 编组攻击]
    HAM_GUILD: SysMsg(sAttackModeOfGuild, c_Green, t_Hint); //[攻击模式: 行会攻击]
    HAM_PKATTACK: SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint); //[攻击模式: 红名攻击] }
    
    HAM_ALL:begin //20080331 加入聊天框中提示
         SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfAll); //[攻击模式: 全体攻击]
         SysMsg(sAttackModeOfAll, c_Green, t_Hint); //[攻击模式: 全体攻击]
       end;
    HAM_PEACE:begin
         SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfPeaceful); //[攻击模式: 和平攻击]
         SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint); //[攻击模式: 和平攻击]
       end;
    HAM_DEAR:begin
         SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfDear); //[攻击模式: 夫妻攻击]
         SysMsg(sAttackModeOfDear, c_Green, t_Hint); //[攻击模式: 夫妻攻击]
       end;
    HAM_MASTER:begin
         SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfMaster); //[攻击模式: 师徒攻击]
         SysMsg(sAttackModeOfMaster, c_Green, t_Hint); //[攻击模式: 师徒攻击]
       end;
    HAM_GROUP:begin
         SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfGroup); //[攻击模式: 编组攻击]
         SysMsg(sAttackModeOfGroup, c_Green, t_Hint); //[攻击模式: 编组攻击]
       end;
    HAM_GUILD:begin
         SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfGuild); //[攻击模式: 行会攻击]
         SysMsg(sAttackModeOfGuild, c_Green, t_Hint); //[攻击模式: 行会攻击]
       end;
    HAM_PKATTACK:begin
         SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfRedWhite); //[攻击模式: 红名攻击]
         SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint); //[攻击模式: 红名攻击]
       end;
  end;
  if m_MyHero <> nil then m_MyHero.m_btAttatckMode := m_btAttatckMode;
end;

procedure TPlayObject.CmdChangeDearName(Cmd: pTGameCmd; sHumanName, sDearName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sDearName = '') then begin
    if g_Config.boGMShowFailMsg then  SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 配偶名称(如果为 无 则清除)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if CompareText(sDearName, '无') = 0 then begin
      PlayObject.m_sDearName := '';
      PlayObject.RefShowName;
      SysMsg(sHumanName + ' 的配偶名清除成功。', c_Green, t_Hint);
    end else begin
      PlayObject.m_sDearName := sDearName;
      PlayObject.RefShowName;
      SysMsg(sHumanName + ' 的配偶名更改成功。', c_Green, t_Hint);
    end;
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeGender(Cmd: pTGameCmd; sHumanName, sSex: string);
var
  PlayObject: TPlayObject;
  nSex: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nSex := -1;
  if (sSex = 'Man') or (sSex = '男') or (sSex = '0') then begin
    nSex := 0;
  end;
  if (sSex = 'WoMan') or (sSex = '女') or (sSex = '1') then begin
    nSex := 1;
  end;
  if (sHumanName = '') or (nSex = -1) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 性别(男、女)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if PlayObject.m_btGender <> nSex then begin
      PlayObject.m_btGender := nSex;
      PlayObject.FeatureChanged();
      SysMsg(PlayObject.m_sCharName + ' 的性别已改变。', c_Green, t_Hint);
    end else begin
      SysMsg(PlayObject.m_sCharName + ' 的性别未改变！！！', c_Red, t_Hint);
    end;
  end else begin
    SysMsg(sHumanName + '没有在线！！！', c_Red, t_Hint);
  end;
end;
//改变物品名称
procedure TPlayObject.CmdChangeItemName(sCmd, sMakeIndex, sItemIndex, sItemName: string);
var
  nMakeIndex, nItemIndex: Integer;
begin
  if (m_btPermission < 6) then Exit;
  if (sMakeIndex = '') or (sItemIndex = '') or (sItemName = '') then begin
    if g_Config.boGMShowFailMsg then  SysMsg('命令格式: @' + sCmd + ' 物品编号 物品ID号 物品名称', c_Red, t_Hint);
    Exit;
  end;
  nMakeIndex := Str_ToInt(sMakeIndex, -1);
  nItemIndex := Str_ToInt(sItemIndex, -1);
  if (nMakeIndex <= 0) or (nItemIndex < 0) then begin
    if g_Config.boGMShowFailMsg then  SysMsg('命令格式: @' + sCmd + ' 物品编号 物品ID号 物品名称', c_Red, t_Hint);
    Exit;
  end;
  if ItemUnit.AddCustomItemName(nMakeIndex, nItemIndex, sItemName) then begin
    ItemUnit.SaveCustomItemName();
    SysMsg('物品名称设置成功。', c_Green, t_Hint);
    Exit;
  end;
  SysMsg('此物品，已经设置了其它的名称！！！', c_Red, t_Hint);
end;
//改变职业
procedure TPlayObject.CmdChangeJob(Cmd: pTGameCmd; sHumanName, sJobName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sJobName = '') then begin
    if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandChangeJobHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if CompareText(sJobName, 'Warr') = 0 then PlayObject.m_btJob := 0;
    if CompareText(sJobName, 'Wizard') = 0 then PlayObject.m_btJob := 1;
    if CompareText(sJobName, 'Taos') = 0 then PlayObject.m_btJob := 2;
    //if CompareText(sJobName, 'ASSASSIN') = 0 then PlayObject.m_btJob := 3;//刺客
    PlayObject.HasLevelUp(1);
    PlayObject.SysMsg(g_sGameCommandChangeJobHumanMsg, c_Green, t_Hint);
    SysMsg(Format(g_sGameCommandChangeJobMsg, [sHumanName]), c_Green, t_Hint);
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;
//改变等级
procedure TPlayObject.CmdChangeLevel(Cmd: pTGameCmd; sParam1: string);
var
  nOLevel: Integer;
  nLevel: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  nLevel := Str_ToInt(sParam1, 1);
  nOLevel := m_Abil.Level;
  m_Abil.Level := _MIN(MAXUPLEVEL, nLevel);
  HasLevelUp(1);
  AddGameDataLog('17' + #9 + m_sMapName + #9 + //等级调整记录日志 20080911
    IntToStr(m_nCurrX) + #9 +
    IntToStr(m_nCurrY)+ #9 +
    m_sCharName + #9 +
    IntToStr(m_Abil.Level) + #9 +
    '0' + #9 +
    '=('+IntToStr(nLevel)+')' + #9 +
    '0');
  if g_Config.boShowMakeItemMsg then begin
    MainOutMessage(Format(g_sGameCommandLevelConsoleMsg, [m_sCharName, nOLevel, m_Abil.Level]));
  end;
end;

procedure TPlayObject.CmdChangeMasterName(Cmd: pTGameCmd; sHumanName, sMasterName, sIsMaster: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sMasterName = '') then begin
    if g_Config.boGMShowFailMsg then  SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 师徒名称(如果为 无 则清除)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if CompareText(sMasterName, '无') = 0 then begin
      PlayObject.m_sMasterName := '';
      PlayObject.RefShowName;
      PlayObject.m_boMaster := False;
      SysMsg(sHumanName + ' 的师徒名清除成功。', c_Green, t_Hint);
    end else begin
      PlayObject.m_sMasterName := sMasterName;
      if (sIsMaster <> '') and (sIsMaster[1] = '1') then PlayObject.m_boMaster := True
      else PlayObject.m_boMaster := False;
      PlayObject.RefShowName;
      SysMsg(sHumanName + ' 的师徒名更改成功。', c_Green, t_Hint);
    end;
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeObMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  if boFlag then begin
    SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, ''); //01/21 强行发送刷新数据到客户端，解决GM登录隐身有影子问题
  end;
  m_boObMode := boFlag;
  if m_boObMode then begin
    SysMsg(sObserverMode, c_Green, t_Hint);
  end else SysMsg(g_sReleaseObserverMode, c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeSabukLord(Cmd: pTGameCmd; sCASTLENAME, sGuildName: string; boFlag: Boolean); //004CFE1C
var
  Guild: TGUild;
  Castle: TUserCastle;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;

  if (sCASTLENAME = '') or (sGuildName = '') then begin
    if g_Config.boGMShowFailMsg then  SysMsg('命令格式: @' + Cmd.sCmd + ' 城堡名称 行会名称', c_Red, t_Hint);
    Exit;
  end;
  Castle := g_CastleManager.Find(sCASTLENAME);
  if Castle = nil then begin
    SysMsg(Format(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCASTLENAME]), c_Red, t_Hint);
    Exit;
  end;

  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then begin
    AddGameDataLog('27' + #9 +
      Castle.m_sOwnGuild + #9 +
      '0' + #9 +
      '1' + #9 +
      'sGuildName' + #9 +
      m_sCharName + #9 +
      '0' + #9 +
      '1' + #9 + '0');
    Castle.GetCastle(Guild);
    if boFlag then
      UserEngine.SendServerGroupMsg(SS_211, nServerIndex, sGuildName);
    SysMsg(Castle.m_sName + ' 所属行会已经更改为 ' + sGuildName, c_Green, t_Hint);
  end else begin
    SysMsg('行会 ' + sGuildName + '还没建立！！！', c_Red, t_Hint);
  end;
end;
//改变下属状态  20080413
procedure TPlayObject.CmdChangeSalveStatus;
begin
  m_boSlaveRelax := not m_boSlaveRelax;
  if (m_SlaveList.Count > 0) or ((m_MyHero <> nil) and (m_MyHero.m_SlaveList.Count > 0)) then begin
    if (m_boSlaveRelax) then SysMsg(sPetRest, c_Green, t_Hint)
    else SysMsg(sPetAttack, c_Green, t_Hint);
  end;
  if (m_MyHero <> nil) and (m_MyHero.m_SlaveList.Count > 0) then  m_MyHero.m_boSlaveRelax := m_boSlaveRelax;//20080409 主人控制英雄宝宝休息
end;

procedure TPlayObject.CmdChangeSuperManMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  m_boSuperMan := boFlag;
  if m_boSuperMan then SysMsg(sSupermanMode, c_Green, t_Hint)
  else SysMsg(sReleaseSupermanMode, c_Green, t_Hint);
end;
//设置服务器最高上线人数
procedure TPlayObject.CmdChangeUserFull(sCmd, sUserCount: string);
var
  nCount: Integer;
begin
  if (m_btPermission < 6) then Exit;
  nCount := Str_ToInt(sUserCount, -1);
  if (sUserCount = '') or (nCount < 1) or ((sUserCount <> '') and (sUserCount[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('设置服务器最高上线人数。', c_Red, t_Hint);
      SysMsg('命令格式: @' + sCmd + ' 人数', c_Red, t_Hint);
    end;
    Exit;
  end;
  g_Config.nUserFull := nCount;
  SysMsg(Format('服务器上线人数限制: %d', [nCount]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeZenFastStep(sCmd, sFastStep: string);
var
  nFastStep: Integer;
begin
  if (m_btPermission < 6) then Exit;
  nFastStep := Str_ToInt(sFastStep, -1);
  if (sFastStep = '') or (nFastStep < 1) or ((sFastStep <> '') and (sFastStep[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('设置怪物行动速度。', c_Red, t_Hint);
      SysMsg('命令格式: @' + sCmd + ' 速度', c_Red, t_Hint);
    end;
    Exit;
  end;
  g_Config.nZenFastStep := nFastStep;
  SysMsg(Format('怪物行动速度: %d', [nFastStep]), c_Green, t_Hint);
end;
//清理指定玩家背包物品
procedure TPlayObject.CmdClearBagItem(Cmd: pTGameCmd; sHumanName: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
  DelList: TStringList;
begin
  DelList := nil;
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '人物名称']), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  
  Try
    PlayObject.m_boOperationItemList := True;//正在操作背包列表 20080928
    if PlayObject.m_ItemList.Count > 0 then begin//20080628
      for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
        UserItem := PlayObject.m_ItemList.Items[I];
        if DelList = nil then DelList := TStringList.Create;
        DelList.AddObject(UserEngine.GetStdItemName(UserItem.wIndex), TObject(UserItem.MakeIndex));
        Dispose(UserItem);
        PlayObject.m_ItemList.Delete(I);//20080928
      end;
      PlayObject.m_ItemList.Clear;
    end;
    if DelList <> nil then begin
      PlayObject.SendMsg(PlayObject, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
    end;
  finally
    PlayObject.m_boOperationItemList := False;//正在操作背包列表 20080928
  end;
end;

procedure TPlayObject.CmdClearHumanPassword(sCmd: string; nPermission: Integer; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < nPermission) then Exit;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('清除玩家的仓库密码！！！', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s 人物名称', [sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    Exit;
  end;
  PlayObject.m_boPasswordLocked := False;
  PlayObject.m_boUnLockStoragePwd := False;
  PlayObject.m_sStoragePwd := '';
  PlayObject.SysMsg('您的保护密码已被清除！！！', c_Green, t_Hint);
  SysMsg(Format('%s的保护密码已被清除！！！', [sHumanName]), c_Green, t_Hint);
end;
//清除指定地图上的怪物
procedure TPlayObject.CmdClearMapMonster(Cmd: pTGameCmd; sMapName, sMonName, sItems: string);
var
  I, II: Integer;
  MonList: TList;
  Envir: TEnvirnoment;
  nMonCount: Integer;
  boKillAll: Boolean;
  boKillAllMap: Boolean;
  boNotItem: Boolean;
  BaseObject: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMapName = '') or (sMonName = '') or (sItems = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 地图号(* 为所有) 怪物名称(* 为所有) 掉物品(0,1)', c_Red, t_Hint);
    Exit;
  end;
  boKillAll := False;
  boKillAllMap := False;
  boNotItem := True;
  nMonCount := 0;
  Envir := nil;
  if sMonName = '*' then boKillAll := True;
  if sMapName = '*' then boKillAllMap := True;
  if sItems = '1' then boNotItem := False;

  MonList := TList.Create;
  try
    for I := 0 to g_MapManager.Count - 1 do begin
      Envir := TEnvirnoment(g_MapManager.Items[I]);
      if (Envir <> nil) then begin
        if boKillAllMap or (CompareText(Envir.sMapName, sMapName) = 0) then begin
          UserEngine.GetMapMonster(Envir, MonList);
          if MonList.Count > 0 then begin
            for II := 0 to MonList.Count - 1 do begin
              BaseObject := TBaseObject(MonList.Items[II]);
              if (BaseObject <> nil) then begin
                if (BaseObject.m_Master <> nil) and (BaseObject.m_btRaceServer <> 135) then begin//除135怪外，其它宝宝不清除 20080818
                   if (BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) or
                      (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) then Continue;
                end;
                if boKillAll or (CompareText(sMonName, BaseObject.m_sCharName) = 0) then begin
                  BaseObject.m_boNoItem := boNotItem;
                  BaseObject.m_WAbil.HP := 0;
                  Inc(nMonCount);
                end;
              end;
            end;//for
          end;
        end;
      end;
    end;//for
  finally
    MonList.Free;
  end;
  if Envir = nil then begin
    SysMsg('输入的地图不存在！！！', c_Red, t_Hint);
    Exit;
  end;
  SysMsg('已清除怪物数: ' + IntToStr(nMonCount), c_Red, t_Hint);
end;

procedure TPlayObject.CmdClearMission(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称)', c_Red, t_Hint);
    Exit;
  end;
  if sHumanName[1] = '?' then begin
    SysMsg('此命令用于清除人物的任务标志。', c_Blue, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format('%s不在线，或在其它服务器上！！', [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  FillChar(PlayObject.m_QuestFlag, SizeOf(TQuestFlag), #0);
  SysMsg(Format('%s的任务标志已经全部清零。', [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdContestPoint(Cmd: pTGameCmd; sGuildName: string);
var
//  I: Integer;
  Guild: TGUild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sGuildName = '') or ((sGuildName <> '') and (sGuildName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('查看行会战的得分数。', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s 行会名称', [Cmd.sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then begin
    SysMsg(Format('%s 的得分为: %d', [sGuildName, Guild.nContestPoint]), c_Green, t_Hint);
  end else begin
    SysMsg(Format('行会: %s 不存在！！！', [sGuildName]), c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdStartContest(Cmd: pTGameCmd; sParam1: string);
var
  I, II: Integer;
  List10, List14: TList;
  PlayObject, PlayObjectA: TPlayObject;
  bo19: Boolean;
  s20: string;
  Guild: TGUild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('开始行会争霸赛。', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s', [Cmd.sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;

  if not m_PEnvir.m_boFight3Zone then begin
    SysMsg('此命令不能在当前地图中使用！！！', c_Red, t_Hint);
    Exit;
  end;
  List10 := TList.Create;
  List14 := TList.Create;
  UserEngine.GetMapRageHuman(m_PEnvir, m_nCurrX, m_nCurrY, 1000, List10);
  for I := 0 to List10.Count - 1 do begin
    PlayObject := TPlayObject(List10.Items[I]);
    if not PlayObject.m_boObMode or not PlayObject.m_boAdminMode then begin
      PlayObject.m_nFightZoneDieCount := 0;
      if PlayObject.m_MyGuild = nil then Continue;
      bo19 := False;
      for II := 0 to List14.Count - 1 do begin
        PlayObjectA := TPlayObject(List14.Items[II]);
        if PlayObject.m_MyGuild = PlayObjectA.m_MyGuild then
          bo19 := True;
      end;
      if not bo19 then begin
        List14.Add(PlayObject.m_MyGuild);
      end;
    end;
  end;//for

  SysMsg('行会争霸赛已经开始。', c_Green, t_Hint);
  UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, '- 行会战争已爆发。');
  s20 := '';
  for I := 0 to List14.Count - 1 do begin
    Guild := TGUild(List14.Items[I]);
    Guild.StartTeamFight();
    for II := 0 to List10.Count - 1 do begin
      PlayObject := TPlayObject(List10.Items[I]);
      if PlayObject.m_MyGuild = Guild then begin
        Guild.AddTeamFightMember(PlayObject.m_sCharName);
      end;
    end;
    s20 := s20 + Guild.sGuildName + ' ';
  end;//for

  UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, ' -参加的门派:' + s20);
  List10.Free;
  List14.Free;
end;

procedure TPlayObject.CmdEndContest(Cmd: pTGameCmd; sParam1: string);
var
  I, II: Integer;
  List10, List14: TList;
  PlayObject, PlayObjectA: TPlayObject;
  bo19: Boolean;
//  s20: string;
  Guild: TGUild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('结束行会争霸赛。', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s', [Cmd.sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;

  if not m_PEnvir.m_boFight3Zone then begin
    SysMsg('此命令不能在当前地图中使用！！！', c_Red, t_Hint);
    Exit;
  end;
  List10 := TList.Create;
  List14 := TList.Create;
  UserEngine.GetMapRageHuman(m_PEnvir, m_nCurrX, m_nCurrY, 1000, List10);
  for I := 0 to List10.Count - 1 do begin
    PlayObject := TPlayObject(List10.Items[I]);
    if not PlayObject.m_boObMode or not PlayObject.m_boAdminMode then begin
      if PlayObject.m_MyGuild = nil then Continue;
      bo19 := False;
      for II := 0 to List14.Count - 1 do begin
        PlayObjectA := TPlayObject(List14.Items[II]);
        if PlayObject.m_MyGuild = PlayObjectA.m_MyGuild then bo19 := True;
      end;
      if not bo19 then List14.Add(PlayObject.m_MyGuild);
    end;
  end;//for

  for I := 0 to List14.Count - 1 do begin
    Guild := TGUild(List14.Items[I]);
    Guild.EndTeamFight();
    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, Format(' - %s 行会争霸赛已结束。', [Guild.sGuildName]));
  end;
  List10.Free;
  List14.Free;
end;

procedure TPlayObject.CmdAllowGroupReCall(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('此命令用于允许或禁止编组传送功能。', c_Red, t_Hint);
    Exit;
  end;

  m_boAllowGroupReCall := not m_boAllowGroupReCall;
  if m_boAllowGroupReCall then SysMsg(g_sEnableGroupRecall {'[允许天地合一]'}, c_Green, t_Hint)
  else SysMsg(g_sDisableGroupRecall {'[禁止天地合一]'}, c_Green, t_Hint);
end;

procedure TPlayObject.CmdAnnouncement(Cmd: pTGameCmd; sGuildName: string);
var
  I: Integer;
  Guild: TGUild;
  sHumanName: string;
  nPoint: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sGuildName = '') or ((sGuildName <> '') and (sGuildName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('查看行会争霸赛结果。', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s 行会名称', [Cmd.sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;

  if not m_PEnvir.m_boFight3Zone then begin
    SysMsg('此命令不能在当前地图中使用！！！', c_Red, t_Hint);
    Exit;
  end;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then begin
    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, Format(' - %s 行会争霸赛结果: ', [Guild.sGuildName]));
    for I := 0 to Guild.TeamFightDeadList.Count - 1 do begin
      nPoint := Integer(Guild.TeamFightDeadList.Objects[I]);
      sHumanName := Guild.TeamFightDeadList.Strings[I];
      UserEngine.CryCry(RM_CRY,
        m_PEnvir,
        m_nCurrX,
        m_nCurrY,
        1000,
        g_Config.btCryMsgFColor,
        g_Config.btCryMsgBColor,
        Format(' - %s  : %d 分/死亡%d次。 ', [sHumanName, HiWord(nPoint), LoWord(nPoint)]));
    end;//for
  end;
  UserEngine.CryCry(RM_CRY,
    m_PEnvir,
    m_nCurrX,
    m_nCurrY,
    1000,
    g_Config.btCryMsgFColor,
    g_Config.btCryMsgBColor,
    Format(' - [%s] : %d 分。', [Guild.sGuildName, Guild.nContestPoint]));
  UserEngine.CryCry(RM_CRY,
    m_PEnvir,
    m_nCurrX,
    m_nCurrY,
    1000,
    g_Config.btCryMsgFColor,
    g_Config.btCryMsgBColor,
    '------------------------------------');
end;

procedure TPlayObject.CmdDearRecall(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    if g_Config.boGMShowFailMsg then  SysMsg('命令格式: @' + sCmd + ' (夫妻传送，将对方传送到自己身边，对方必须允许传送。)', c_Green, t_Hint);
    Exit;
  end;
  if m_sDearName = '' then begin
    SysMsg('您没有结婚！！！', c_Red, t_Hint);
    Exit;
  end;
  if m_PEnvir.m_boNODEARRECALL then begin
    SysMsg('本地图禁止夫妻传送！！！', c_Red, t_Hint);
    Exit;
  end;

  if m_DearHuman = nil then begin
    if m_btGender = 0 then begin
      SysMsg('您的老婆不在线！！！', c_Red, t_Hint);
    end else begin
      SysMsg('您的老公不在线！！！', c_Red, t_Hint);
    end;
    Exit;
  end;
  if GetTickCount - m_dwDearRecallTick < 10000 then begin
    SysMsg('稍等会才能再次使用此功能！！！', c_Red, t_Hint);
    Exit;
  end;
  m_dwDearRecallTick := GetTickCount();
  if m_DearHuman.m_boCanDearRecall then begin
    RecallHuman(m_DearHuman.m_sCharName);
  end else begin
    SysMsg(m_DearHuman.m_sCharName + ' 不允许传送！！！', c_Red, t_Hint);
    Exit;
  end;
end;

procedure TPlayObject.CmdMasterRecall(sCmd, sParam: string);
var
  I: Integer;
  MasterHuman: TPlayObject;
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' (师徒传送，师父可以将徒弟传送到自己身边，徒弟必须允许传送。)', c_Green, t_Hint);
    Exit;
  end;
  if not m_boMaster then begin
    SysMsg('只能师父才能使用此功能！！！', c_Red, t_Hint);
    Exit;
  end;
  if m_MasterList.Count = 0 then begin
    SysMsg('您的徒弟一个都不在线！！！', c_Red, t_Hint);
    Exit;
  end;
  if m_PEnvir.m_boNOMASTERRECALL then begin
    SysMsg('本地图禁止师徒传送！！！', c_Red, t_Hint);
    Exit;
  end;
  if GetTickCount - m_dwMasterRecallTick < 10000 then begin
    SysMsg('稍等会才能再次使用此功能！！！', c_Red, t_Hint);
    Exit;
  end;
  for I := 0 to m_MasterList.Count - 1 do begin
    MasterHuman := TPlayObject(m_MasterList.Items[I]);
    if MasterHuman.m_boCanMasterRecall then begin
      RecallHuman(MasterHuman.m_sCharName);
    end else begin
      SysMsg(MasterHuman.m_sCharName + ' 不允许传送！！！', c_Red, t_Hint);
    end;
  end;//for
end;

procedure TPlayObject.CmdDelBonuPoint(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    FillChar(PlayObject.m_BonusAbil, SizeOf(TNakedAbility), #0);
    PlayObject.m_nBonusPoint := 0;
    PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    PlayObject.HasLevelUp(0);
    PlayObject.SysMsg('分配点数已清除！！！', c_Red, t_Hint);
    SysMsg(sHumName + ' 的分配点数已清除.', c_Green, t_Hint);
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdReNewLevel(Cmd: pTGameCmd; sHumanName, sLevel: string);
var
  PlayObject: TPlayObject;
  nLevel: Integer;
begin
  if (m_btPermission < 6) then Exit;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 点数(为空则查看)', c_Red, t_Hint);
    Exit;
  end;
  nLevel := Str_ToInt(sLevel, -1);
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if (nLevel >= 0) and (nLevel <= 255) then begin
      PlayObject.m_btReLevel := nLevel;
      PlayObject.RefShowName();
    end;
    SysMsg(sHumanName + ' 的转生等级为 ' + IntToStr(PlayObject.m_btReLevel), c_Green, t_Hint);
  end else begin
    SysMsg(sHumanName + ' 没在线上！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdRestBonuPoint(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject: TPlayObject;
  nTotleUsePoint: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    nTotleUsePoint := PlayObject.m_BonusAbil.DC +
      PlayObject.m_BonusAbil.MC +
      PlayObject.m_BonusAbil.SC +
      PlayObject.m_BonusAbil.AC +
      PlayObject.m_BonusAbil.MAC +
      PlayObject.m_BonusAbil.HP +
      PlayObject.m_BonusAbil.MP +
      PlayObject.m_BonusAbil.Hit +
      PlayObject.m_BonusAbil.Speed +
      PlayObject.m_BonusAbil.X2;
    FillChar(PlayObject.m_BonusAbil, SizeOf(TNakedAbility), #0);

    Inc(PlayObject.m_nBonusPoint, nTotleUsePoint);
    PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    PlayObject.HasLevelUp(0);
    PlayObject.SysMsg('分配点数已复位！！！', c_Red, t_Hint);
    SysMsg(sHumName + ' 的分配点数已复位.', c_Green, t_Hint);
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdSearchDear(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('此命令用于查询配偶当前所在位置。', c_Red, t_Hint);
    Exit;
  end;
  if m_sDearName = '' then begin
    SysMsg(g_sYouAreNotMarryedMsg {'你都没结婚查什么？'}, c_Red, t_Hint);
    Exit;
  end;
  if m_DearHuman = nil then begin
    if m_btGender = 0 then begin
      SysMsg(g_sYourWifeNotOnlineMsg {'你的老婆还没有上线！！！'}, c_Red, t_Hint);
    end else begin
      SysMsg(g_sYourHusbandNotOnlineMsg {'你的老公还没有上线！！！'}, c_Red, t_Hint);
    end;
    Exit;
  end;

  if m_btGender = 0 then begin
    SysMsg(g_sYourWifeNowLocateMsg {'你的老婆现在位于:'}, c_Green, t_Hint);
    SysMsg(m_DearHuman.m_sCharName + ' ' + m_DearHuman.m_PEnvir.sMapDesc + '(' + IntToStr(m_DearHuman.m_nCurrX) + ':' + IntToStr(m_DearHuman.m_nCurrY) + ')', c_Green, t_Hint);
    m_DearHuman.SysMsg(g_sYourHusbandSearchLocateMsg {'你的老公正在找你，他现在位于:'}, c_Green, t_Hint);
    m_DearHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
  end else begin
    SysMsg(g_sYourHusbandNowLocateMsg {'你的老公现在位于:'}, c_Red, t_Hint);
    SysMsg(m_DearHuman.m_sCharName + ' ' + m_DearHuman.m_PEnvir.sMapDesc + '(' + IntToStr(m_DearHuman.m_nCurrX) + ':' + IntToStr(m_DearHuman.m_nCurrY) + ')', c_Green, t_Hint);
    m_DearHuman.SysMsg(g_sYourWifeSearchLocateMsg {'你的老婆正在找你，她现在位于:'}, c_Green, t_Hint);
    m_DearHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdSearchMaster(sCmd, sParam: string);
var
  I: Integer;
  Human: TPlayObject;
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('此命令用于查询师徒当前所在位置。', c_Red, t_Hint);
    Exit;
  end;
  if m_sMasterName = '' then begin
    SysMsg(g_sYouAreNotMasterMsg, c_Red, t_Hint);
    Exit;
  end;
  if m_boMaster then begin
    if m_MasterList.Count <= 0 then begin
      SysMsg(g_sYourMasterListNotOnlineMsg, c_Red, t_Hint);
      Exit;
    end;
    SysMsg(g_sYourMasterListNowLocateMsg, c_Green, t_Hint);
    for I := 0 to m_MasterList.Count - 1 do begin
      Human := TPlayObject(m_MasterList.Items[I]);
      SysMsg(Human.m_sCharName + ' ' + Human.m_PEnvir.sMapDesc + '(' + IntToStr(Human.m_nCurrX) + ':' + IntToStr(Human.m_nCurrY) + ')', c_Green, t_Hint);
      Human.SysMsg(g_sYourMasterSearchLocateMsg, c_Green, t_Hint);
      Human.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
    end;
  end else begin
    if m_MasterHuman = nil then begin
      SysMsg(g_sYourMasterNotOnlineMsg, c_Red, t_Hint);
      Exit;
    end;
    SysMsg(g_sYourMasterNowLocateMsg, c_Red, t_Hint);
    SysMsg(m_MasterHuman.m_sCharName + ' ' + m_MasterHuman.m_PEnvir.sMapDesc + '(' + IntToStr(m_MasterHuman.m_nCurrX) + ':' + IntToStr(m_MasterHuman.m_nCurrY) + ')', c_Green, t_Hint);
    m_MasterHuman.SysMsg(g_sYourMasterListSearchLocateMsg, c_Green, t_Hint);
    m_MasterHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdSetPermission(Cmd: pTGameCmd; sHumanName, sPermission: string);
var
  nPerission: Integer;
  PlayObject: TPlayObject;
resourcestring
  sOutFormatMsg = '[权限调整] %s (%s %d -> %d)';
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nPerission := Str_ToInt(sPermission, 0);
  if (sHumanName = '') or not (nPerission in [0..10]) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 权限等级(0 - 10)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  if g_Config.boShowMakeItemMsg then
    MainOutMessage(Format(sOutFormatMsg, [m_sCharName, PlayObject.m_sCharName, PlayObject.m_btPermission, nPerission]));
  PlayObject.m_btPermission := nPerission;
  SysMsg(sHumanName + ' 当前权限为: ' + IntToStr(PlayObject.m_btPermission), c_Red, t_Hint);
end;

procedure TPlayObject.CmdShowHumanFlag(sCmd: string; nPermission: Integer;
  sHumanName, sFlag: string);
var
  PlayObject: TPlayObject;
  nFlag: Integer;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandShowHumanFlagHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nFlag := Str_ToInt(sFlag, 0);
  if PlayObject.GetQuestFalgStatus(nFlag) = 1 then begin
    SysMsg(Format(g_sGameCommandShowHumanFlagONMsg, [PlayObject.m_sCharName, nFlag]), c_Green, t_Hint);
  end else begin
    SysMsg(Format(g_sGameCommandShowHumanFlagOFFMsg, [PlayObject.m_sCharName, nFlag]), c_Green, t_Hint);
  end;
end;

{procedure TPlayObject.CmdShowHumanUnit(sCmd: string; nPermission: Integer;
  sHumanName, sUnit: string);
//var
//  PlayObject: TPlayObject;
//  nUnit: Integer;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandShowHumanUnitHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nUnit := Str_ToInt(sUnit, 0);
  if PlayObject.GetQuestUnitStatus(nUnit) = 1 then begin
    SysMsg(format(g_sGameCommandShowHumanUnitONMsg, [PlayObject.m_sCharName, nUnit]), c_Green, t_Hint);
  end else begin
    SysMsg(format(g_sGameCommandShowHumanUnitOFFMsg, [PlayObject.m_sCharName, nUnit]), c_Green, t_Hint);
  end;
end; }

{procedure TPlayObject.CmdShowHumanUnitOpen(sCmd: string; nPermission: Integer;
  sHumanName, sUnit: string);
//var
//  PlayObject: TPlayObject;
//  nUnit: Integer;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandShowHumanUnitHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nUnit := Str_ToInt(sUnit, 0);
  if PlayObject.GetQuestUnitOpenStatus(nUnit) = 1 then begin
    SysMsg(format(g_sGameCommandShowHumanUnitONMsg, [PlayObject.m_sCharName, nUnit]), c_Green, t_Hint);
  end else begin
    SysMsg(format(g_sGameCommandShowHumanUnitOFFMsg, [PlayObject.m_sCharName, nUnit]), c_Green, t_Hint);
  end;
end;  }

procedure TPlayObject.CmdShowMapInfo(Cmd: pTGameCmd; sParam1: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format(g_sGameCommandMapInfoMsg, [m_PEnvir.sMapName, m_PEnvir.sMapDesc]), c_Green, t_Hint);
  SysMsg(Format(g_sGameCommandMapInfoSizeMsg, [m_PEnvir.m_nWidth, m_PEnvir.m_nHeight]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdShowMapMode(sCmd, sMapName: string);
var
  Envir: TEnvirnoment;
  sMsg: string;
begin
  if (m_btPermission < 6) then Exit;
  if (sMapName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 地图号', c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) then begin
    SysMsg(sMapName + ' 不存在！！！', c_Red, t_Hint);
    Exit;
  end;
  sMsg := '地图模式: ' + Envir.GetEnvirInfo;
  SysMsg(sMsg, c_Blue, t_Hint);
end;

procedure TPlayObject.CmdSetMapMode(sCmd, sMapName, sMapMode, sParam1, sParam2: string);
var
  Envir: TEnvirnoment;
  sMsg: string;
begin
  if (m_btPermission < 6) then Exit;
  if (sMapName = '') or (sMapMode = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 地图号 模式', c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) then begin
    SysMsg(sMapName + ' 不存在！！！', c_Red, t_Hint);
    Exit;
  end;
  if CompareText(sMapMode, 'SAFE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boSAFE := True;
    end else begin
      Envir.m_boSAFE := False;
    end;
  end else
    if CompareText(sMapMode, 'DARK') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boDARK := True;
    end else begin
      Envir.m_boDARK := False;
    end;
  end else
    if CompareText(sMapMode, 'DARK') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boDARK := True;
    end else begin
      Envir.m_boDARK := False;
    end;
  end else
    if CompareText(sMapMode, 'FIGHT') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boFightZone := True;
    end else begin
      Envir.m_boFightZone := False;
    end;
  end else
    if CompareText(sMapMode, 'FIGHT2') = 0 then begin//PK掉装备地图 20080525
    if (sParam1 <> '') then begin
      Envir.m_boFight2Zone := True;
    end else begin
      Envir.m_boFight2Zone := False;
    end;
  end else
    if CompareText(sMapMode, 'FIGHT3') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boFight3Zone := True;
    end else begin
      Envir.m_boFight3Zone := False;
    end;
  end else
    if CompareText(sMapMode, 'FIGHT4') = 0 then begin//挑战地图 20080706
    if (sParam1 <> '') then begin
      Envir.m_boFight4Zone := True;
    end else begin
      Envir.m_boFight4Zone := False;
    end;
  end else
    if CompareText(sMapMode, 'DAY') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boDAY := True;
    end else begin
      Envir.m_boDAY := False;
    end;
  end else
    if CompareText(sMapMode, 'QUIZ') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boQUIZ := True;
    end else begin
      Envir.m_boQUIZ := False;
    end;
  end else
    if CompareText(sMapMode, 'NORECONNECT') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNORECONNECT := True;
      Envir.sNoReconnectMap := sParam1;
    end else begin
      Envir.m_boNORECONNECT := False;
    end;
  end else
    if CompareText(sMapMode, 'MUSIC') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boMUSIC := True;
      Envir.m_nMUSICID := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boMUSIC := False;
    end;
  end else
    if CompareText(sMapMode, 'EXPRATE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boEXPRATE := True;
      Envir.m_nEXPRATE := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boEXPRATE := False;
    end;
  end else
    if CompareText(sMapMode, 'PKWINLEVEL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boPKWINLEVEL := True;
      Envir.m_nPKWINLEVEL := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boPKWINLEVEL := False;
    end;
  end else
    if CompareText(sMapMode, 'PKWINEXP') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boPKWINEXP := True;
      Envir.m_nPKWINEXP := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boPKWINEXP := False;
    end;
  end else
    if CompareText(sMapMode, 'PKLOSTLEVEL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boPKLOSTLEVEL := True;
      Envir.m_nPKLOSTLEVEL := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boPKLOSTLEVEL := False;
    end;
  end else
    if CompareText(sMapMode, 'PKLOSTEXP') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boPKLOSTEXP := True;
      Envir.m_nPKLOSTEXP := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boPKLOSTEXP := False;
    end;
  end else
    if CompareText(sMapMode, 'DECHP') = 0 then begin
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.m_boDECHP := True;
      Envir.m_nDECHPTIME := Str_ToInt(sParam1, -1);
      Envir.m_nDECHPPOINT := Str_ToInt(sParam2, -1);
    end else begin
      Envir.m_boDECHP := False;
    end;
  end else
    if CompareText(sMapMode, 'DECGAMEGOLD') = 0 then begin
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.m_boDecGameGold := True;
      Envir.m_nDECGAMEGOLDTIME := Str_ToInt(sParam1, -1);
      Envir.m_nDecGameGold := Str_ToInt(sParam2, -1);
    end else begin
      Envir.m_boDecGameGold := False;
    end;
  end else
  if CompareText(sMapMode, 'KILLFUNC') = 0 then begin //20080415 地图杀人触发
    if (sParam1 <> '') then begin
      Envir.m_boKILLFUNC := True;
      Envir.m_nKILLFUNC := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boKILLFUNC := False;
    end;
  end else
    if CompareText(sMapMode, 'INCGAMEGOLD') = 0 then begin
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.m_boIncGameGold := True;
      Envir.m_nINCGAMEGOLDTIME := Str_ToInt(sParam1, -1);
      Envir.m_nIncGameGold := Str_ToInt(sParam2, -1);
    end else begin
      Envir.m_boIncGameGold := False;
    end;
  end else
    if CompareText(sMapMode, 'INCGAMEPOINT') = 0 then begin
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.m_boINCGAMEPOINT := True;
      Envir.m_nINCGAMEPOINTTIME := Str_ToInt(sParam1, -1);
      Envir.m_nINCGAMEPOINT := Str_ToInt(sParam2, -1);
    end else begin
      Envir.m_boINCGAMEPOINT := False;
    end;
  end else
//------------------------------------------------------------------------------
  if CompareText(sMapMode, 'NEEDLEVELTIME') = 0 then begin//雪域地图传送,判断等级,地图时间 20081228
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.m_boNEEDLEVELTIME := True;
      Envir.m_nNEEDLEVELPOINT := Str_ToInt(sParam1, 0);//进地图最低等级
    end else begin
      Envir.m_boNEEDLEVELTIME := False;
    end;
  end else
  if CompareText(sMapMode, 'TIMEMOVEHOME') = 0 then begin//时间到传送回回城点 20081230 雪域地图
    if (sParam1 <> '') then begin
      Envir.m_boMoveToHome := True;
    end else Envir.m_boMoveToHome := False;
  end else
//20080124 禁止召唤英雄
    if CompareText(sMapMode, 'NOCALLHERO') = 0 then begin
      if (sParam1 <> '') then begin
        Envir.m_boNOCALLHERO := True;
      end else begin
        Envir.m_boNOCALLHERO := False;
      end;
   end else
//禁止英雄守护 20080629
    if CompareText(sMapMode, 'NOHEROPROTECT') = 0 then begin
      if (sParam1 <> '') then begin
        Envir.m_boNOHEROPROTECT := True;
      end else begin
        Envir.m_boNOHEROPROTECT := False;
      end;
   end else
//20080503 禁止死亡掉物品
    if CompareText(sMapMode, 'NODROPITEM') = 0 then begin
      if (sParam1 <> '') then begin
        Envir.m_boNODROPITEM := True;
      end else begin
        Envir.m_boNODROPITEM := False;
      end;
   end else
//20080124 不允许使用任何物品和技能
    if CompareText(sMapMode, 'MISSION') = 0 then begin
      if (sParam1 <> '') then begin
        Envir.m_boMISSION := True;
      end else begin
        Envir.m_boMISSION := False;
      end;
//------------------------------------------------------------------------------
  end else
    if CompareText(sMapMode, 'RUNHUMAN') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boRUNHUMAN := True;
    end else begin
      Envir.m_boRUNHUMAN := False;
    end;
  end else
    if CompareText(sMapMode, 'RUNMON') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boRUNMON := True;
    end else begin
      Envir.m_boRUNMON := False;
    end;
  end else
    if CompareText(sMapMode, 'NEEDHOLE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNEEDHOLE := True;
    end else begin
      Envir.m_boNEEDHOLE := False;
    end;
  end else
    if CompareText(sMapMode, 'NORECALL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNORECALL := True;
    end else begin
      Envir.m_boNORECALL := False;
    end;
  end else
    if CompareText(sMapMode, 'NOGUILDRECALL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNOGUILDRECALL := True;
    end else begin
      Envir.m_boNOGUILDRECALL := False;
    end;
  end else
    if CompareText(sMapMode, 'NODEARRECALL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNODEARRECALL := True;
    end else begin
      Envir.m_boNODEARRECALL := False;
    end;
  end else
    if CompareText(sMapMode, 'NOMASTERRECALL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNOMASTERRECALL := True;
    end else begin
      Envir.m_boNOMASTERRECALL := False;
    end;
  end else
    if CompareText(sMapMode, 'NORANDOMMOVE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNORANDOMMOVE := True;
    end else begin
      Envir.m_boNORANDOMMOVE := False;
    end;
  end else
    if CompareText(sMapMode, 'NODRUG') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNODRUG := True;
    end else begin
      Envir.m_boNODRUG := False;
    end;
  end else
    if CompareText(sMapMode, 'MINE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boMINE := True;
    end else begin
      Envir.m_boMINE := False;
    end;
  end else
    if CompareText(sMapMode, 'NOPOSITIONMOVE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNOPOSITIONMOVE := True;
    end else begin
      Envir.m_boNOPOSITIONMOVE := False;
    end;
  end;
  sMsg := '地图模式: ' + Envir.GetEnvirInfo;
  SysMsg(sMsg, c_Blue, t_Hint);
end;

procedure TPlayObject.CmdSignMapMove(Cmd: pTGameCmd);
var
  Envir: TEnvirnoment;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      Exit;
    end;
    if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(m_sLastMapName) then begin
      Envir := g_MapManager.FindMap(m_sLastMapName);
      if Envir <> nil then begin
        if Envir.CanWalk(m_nLastCurrX, m_nLastCurrY, True) then begin
          SpaceMove(m_sLastMapName, m_nLastCurrX, m_nLastCurrY, 0);
        end else begin
          SysMsg(Format(g_sGameCommandPositionMoveCanotMoveToMap1, [m_sLastMapName, m_nLastCurrX, m_nLastCurrY]), c_Green, t_Hint);
        end;
      end;
    end else begin
      SysMsg(Format(g_sTheMapDisableMove, [m_sLastMapName, Envir.sMapDesc]), c_Red, t_Hint);
    end;
  except
    on E: Exception do begin
      MainOutMessage('{异常} TPlayObject.CmdPositionMove');
    end;
  end;
end;
//清理指定玩家复制品 20080816
procedure TPlayObject.CmdClearCopyItem(Cmd: pTGameCmd; sName: string);
var
  I, II: Integer;
  PlayObject: TPlayObject;
  UserItem, UserItem1: pTUserItem;
  s14: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sName]), c_Red, t_Hint);
    Exit;
  end;

  for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
    if PlayObject.m_ItemList.Count <= 0 then Break;
    UserItem := PlayObject.m_ItemList.Items[I];
    s14 := UserEngine.GetStdItemName(UserItem.wIndex);
    for II := I - 1 downto 0 do begin
      UserItem1 := PlayObject.m_ItemList.Items[II];
      if (UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
        (UserItem.MakeIndex = UserItem1.MakeIndex) then begin
        m_ItemList.Delete(II);
        Break;
      end;
    end;
  end;

  for I := PlayObject.m_StorageItemList.Count - 1 downto 0 do begin
    if PlayObject.m_StorageItemList.Count <= 0 then Break;
    UserItem := PlayObject.m_StorageItemList.Items[I];
    s14 := UserEngine.GetStdItemName(UserItem.wIndex);
    for II := I - 1 downto 0 do begin
      UserItem1 := PlayObject.m_StorageItemList.Items[II];
      if (UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
        (UserItem.MakeIndex = UserItem1.MakeIndex) then begin
        m_StorageItemList.Delete(II);
        Break;
      end;
    end;
  end;
end;
//放烟花
procedure TPlayObject.CmdShowEffect(Cmd: pTGameCmd; sEffect{, sTime}: string);
var
  nEffectType: Integer;
// nTime: Integer;
  FlowerEvent: TFlowerEvent;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sEffect = '') or (Str_ToInt(sEffect, -1) <= 0) {or (sTime = '')} then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 烟花类型(79-85)', c_Red, t_Hint);
    Exit;
  end;
  nEffectType := Str_ToInt(sEffect, -1);
 // nTime := Str_ToInt(sTime, 1);
  case nEffectType of
    79: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_1, 4000 {* nTime});
    80: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_2, 4000 {* nTime});
    81: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_3, 4000 {* nTime});
    82: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_4, 4000 {* nTime});
    83: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_5, 4000 {* nTime});
    84: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_6, 4000 {* nTime});
    85: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_7, 4000 {* nTime});//20080312 如梦似雾烟花
    87: SendRefMsg(RM_MYSHOW, ET_PROTECTION_STRUCK, 0, 0, 0, ''); //护体神盾  受攻击
    89: SendRefMsg(RM_MYSHOW, ET_PROTECTION_PIP, 0, 0, 0, ''); //护体神盾  破盾
    90: SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP,0, 0, 0, ''); //人物升级动画
  //else FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_1, 4000 {* nTime});
  end;
  case nEffectType of
    79..85:g_EventManager.AddEvent(FlowerEvent);
  end;
end;
//取玩家物品(背包,仓库)
procedure TPlayObject.CmdGetUserItems(Cmd: pTGameCmd; sHumanName, sItemName, sItemCount, sType: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  nItemCount: Integer;
  nCount: Integer;
  nType: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sItemName = '') or (sItemCount = '') or (sType = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 物品名称 数量 类型(0,1,2)', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nCount := Str_ToInt(sItemCount, 0);
  nType := Str_ToInt(sType, 0);
  case nType of
    0: begin
        nItemCount := 0;
        for I := Low(PlayObject.m_UseItems) to High(PlayObject.m_UseItems) do begin
          UserItem := @PlayObject.m_UseItems[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then begin
            New(UserItem);
            FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
            //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
            UserItem^ := PlayObject.m_UseItems[I];
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem);
            PlayObject.m_UseItems[I].wIndex := 0;
            Inc(nItemCount);
            if m_ItemList.Count >= 46 then Break;
            if nItemCount >= nCount then Break;
          end;
        end;
        PlayObject.SendUseitems();
      end;
    1: begin
        nItemCount := 0;
        for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
          if PlayObject.m_ItemList.Count <= 0 then Break;
          UserItem := PlayObject.m_ItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then begin
            PlayObject.SendDelItems(UserItem);
            PlayObject.m_ItemList.Delete(I);
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem);
            Inc(nItemCount);
            if m_ItemList.Count >= 46 then Break;
            if nItemCount >= nCount then Break;
          end;
        end;
      end;
    2: begin
        nItemCount := 0;
        for I := PlayObject.m_StorageItemList.Count - 1 downto 0 do begin
          if PlayObject.m_StorageItemList.Count <= 0 then Break;
          UserItem := PlayObject.m_StorageItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then begin
            PlayObject.m_StorageItemList.Delete(I);
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem);
            Inc(nItemCount);
            if m_ItemList.Count >= 46 then Break;
            if nItemCount >= nCount then Break;
          end;
        end;
      end;
  end;
end;

procedure TPlayObject.CmdDeleteItem(Cmd: pTGameCmd; sHumanName, sItemName: string; nCount: Integer);
var
  I: Integer;
  PlayObject: TPlayObject;
  nItemCount: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sItemName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 物品名称 数量)', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nItemCount := 0;
  for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
    if PlayObject.m_ItemList.Count <= 0 then Break;
    UserItem := PlayObject.m_ItemList.Items[I];
    if UserItem = nil then Continue;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then begin
      PlayObject.SendDelItems(UserItem);
      Dispose(UserItem);
      PlayObject.m_ItemList.Delete(I);
      Inc(nItemCount);
      if nItemCount >= nCount then
        Break;
    end;
  end;
end;

procedure TPlayObject.CmdDelGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
var
  PlayObject: TPlayObject;
  nServerIndex: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumName = '') or (nCount <= 0) then Exit;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    if PlayObject.m_nGold > nCount then begin
      Dec(PlayObject.m_nGold, nCount);
    end else begin
      nCount := PlayObject.m_nGold;
      PlayObject.m_nGold := 0;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + '的金币已减少' + IntToStr(nCount) + '.', c_Green, t_Hint);
    if g_boGameLogGold then
      AddGameDataLog('13' + #9 +
        m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 +
        IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 +
        sSTRING_GOLDNAME + #9 +
        IntToStr(nCount) + #9 +
        '1' + #9 +
        sHumName);
  end else begin
    if UserEngine.FindOtherServerUser(sHumName, nServerIndex) then begin
      SysMsg(sHumName + '现在' + IntToStr(nServerIndex) + '号服务器上', c_Green, t_Hint);
    end else begin
      FrontEngine.AddChangeGoldList(m_sCharName, sHumName, -nCount);
      SysMsg(sHumName + '现在不在线，等其上线时金币将自动减少', c_Green, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdDelGuild(Cmd: pTGameCmd; sGuildName: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg('只能在主服务器上才可以使用此命令删除行会！！！', c_Red, t_Hint);
    Exit;
  end;
  if sGuildName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 行会名称', c_Red, t_Hint);
    Exit;
  end;
  if g_GuildManager.DELGUILD(sGuildName) then begin
    UserEngine.SendServerGroupMsg(SS_206, nServerIndex, sGuildName);
  end else begin
    SysMsg('没找到' + sGuildName + '这个行会！！！', c_Red, t_Hint);
  end;
end;
//删除NPC
procedure TPlayObject.CmdDelNpc(sCmd: string; nPermission: Integer; sParam1: string);
var
  BaseObject: TBaseObject;
  I: Integer;
resourcestring
  sDelOK = '删除NPC成功...';
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
   if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  BaseObject := GetPoseCreate();
  if BaseObject <> nil then begin
    for I := 0 to UserEngine.m_MerchantList.Count - 1 do begin
      if TBaseObject(UserEngine.m_MerchantList.Items[I]) = BaseObject then begin
        BaseObject.m_boGhost := True;
        BaseObject.m_dwGhostTick := GetTickCount();
        BaseObject.SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
        SysMsg(sDelOK, c_Red, t_Hint);
        Exit;
      end;
    end;//for
    for I := 0 to UserEngine.QuestNPCList.Count - 1 do begin
      if TBaseObject(UserEngine.QuestNPCList.Items[I]) = BaseObject then begin
        BaseObject.m_boGhost := True;
        BaseObject.m_dwGhostTick := GetTickCount();
        BaseObject.SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
        SysMsg(sDelOK, c_Red, t_Hint);
        Exit;
      end;
    end;//for
  end;
  SysMsg(g_sGameCommandDelNpcMsg, c_Red, t_Hint);
end;
//删除人物技能
procedure TPlayObject.CmdDelSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  boDelAll: Boolean;
  UserMagic: pTUserMagic;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sSkillName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 技能名称)', c_Red, t_Hint);
    Exit;
  end;
  if CompareText(sSkillName, 'All') = 0 then boDelAll := True
  else boDelAll := False;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;

  for I := PlayObject.m_MagicList.Count - 1 downto 0 do begin
    if PlayObject.m_MagicList.Count <= 0 then Break;
    UserMagic := PlayObject.m_MagicList.Items[I];
    if UserMagic <> nil then begin
      if (UserMagic.MagicInfo.wMagicId = 68) and ((PlayObject.m_MaxExp68 <> 0) or (PlayObject.m_Exp68 <> 0)) then begin//是酒气护体 20080625
        PlayObject.m_MaxExp68:= 0;
        PlayObject.m_Exp68:= 0;
      end;
      if boDelAll then begin
        Dispose(UserMagic);
        PlayObject.m_MagicList.Delete(I);
      end else begin
        if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then begin
          PlayObject.SendDelMagic(UserMagic);
          Dispose(UserMagic);
          PlayObject.m_MagicList.Delete(I);
          PlayObject.SysMsg(Format('技能%s已删除。', [sSkillName]), c_Green, t_Hint);
          SysMsg(Format('%s的技能%s已删除。', [sHumanName, sSkillName]), c_Green, t_Hint);
          Break;
        end;
      end;
    end;
  end;//for
  PlayObject.RecalcAbilitys();//20080924 增加
  PlayObject.CompareSuitItem(False);//20080924 套装
end;

procedure TPlayObject.CmdDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sAccount = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 登录帐号 是否永久封(0,1)', c_Red, t_Hint);
    Exit;
  end;
  g_DenyAccountList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then begin
      g_DenyAccountList.AddObject(sAccount, TObject(1));
      SaveDenyAccountList();
      SysMsg(sAccount + '已加入禁止登录帐号列表', c_Green, t_Hint);
    end else begin
      g_DenyAccountList.AddObject(sAccount, TObject(0));
      SysMsg(sAccount + '已加入临时禁止登录帐号列表', c_Green, t_Hint);
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
end;

procedure TPlayObject.CmdDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sCharName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 是否永久封(0,1)', c_Red, t_Hint);
    Exit;
  end;
  g_DenyChrNameList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then begin
      g_DenyChrNameList.AddObject(sCharName, TObject(1));
      SaveDenyChrNameList();
      SysMsg(sCharName + '已加入禁止人物列表', c_Green, t_Hint);
    end else begin
      g_DenyChrNameList.AddObject(sCharName, TObject(0));
      SysMsg(sCharName + '已加入临时禁止人物列表', c_Green, t_Hint);
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
end;

procedure TPlayObject.CmdDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sIPaddr = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' IP地址 是否永久封(0,1)', c_Red, t_Hint);
    Exit;
  end;
  g_DenyIPAddrList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then begin
      g_DenyIPAddrList.AddObject(sIPaddr, TObject(1));
      SaveDenyIPAddrList();
      SysMsg(sIPaddr + '已加入禁止登录IP列表', c_Green, t_Hint);
    end else begin
      g_DenyIPAddrList.AddObject(sIPaddr, TObject(0));
      SysMsg(sIPaddr + '已加入临时禁止登录IP列表', c_Green, t_Hint);
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
end;

procedure TPlayObject.CmdDisableFilter(sCmd, sParam1: string);
begin
  if (m_btPermission < 6) then Exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then begin
    SysMsg('启用/禁止文字过滤功能。', c_Red, t_Hint);
    Exit;
  end;
  boFilterWord := not boFilterWord;
  if boFilterWord then begin
    SysMsg('已启用文字过滤。', c_Green, t_Hint);
  end else begin
    SysMsg('已禁止文字过滤。', c_Green, t_Hint);
  end;
end;
//恢复禁止登陆帐号
procedure TPlayObject.CmdDelDenyAccountLogon(Cmd: pTGameCmd; sAccount,
  sFixDeny: string);
var
  I: Integer;
  boDelete: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sAccount = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 登录帐号', c_Red, t_Hint);
    Exit;
  end;
  boDelete := False;
  g_DenyAccountList.Lock;
  try
    for I := g_DenyAccountList.Count - 1 downto 0 do begin//20080917 修改
      if g_DenyAccountList.Count <= 0 then Break;//20080917
      if CompareText(sAccount, g_DenyAccountList.Strings[I]) = 0 then begin
        if Integer(g_DenyAccountList.Objects[I]) <> 0 then SaveDenyAccountList;
        g_DenyAccountList.Delete(I);
        SysMsg(sAccount + '已从禁止登录帐号列表中删除。', c_Green, t_Hint);
        boDelete := True;
        Break;
      end;
    end;//for
  finally
    g_DenyAccountList.UnLock;
  end;
  if not boDelete then
    SysMsg(sAccount + '没有被禁止登录。', c_Green, t_Hint);
end;
//恢复禁止登陆人物
procedure TPlayObject.CmdDelDenyCharNameLogon(Cmd: pTGameCmd; sCharName,
  sFixDeny: string);
var
  I: Integer;
  boDelete: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sCharName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    Exit;
  end;
  boDelete := False;
  g_DenyChrNameList.Lock;
  try
    for I := g_DenyChrNameList.Count - 1 downto 0 do begin//20080917 修改
      if g_DenyChrNameList.Count <= 0 then Break;//20080917
      if CompareText(sCharName, g_DenyChrNameList.Strings[I]) = 0 then begin
        if Integer(g_DenyChrNameList.Objects[I]) <> 0 then SaveDenyChrNameList;
        g_DenyChrNameList.Delete(I);
        SysMsg(sCharName + '已从禁止登录人物列表中删除。', c_Green, t_Hint);
        boDelete := True;
        Break;
      end;
    end;//for
  finally
    g_DenyChrNameList.UnLock;
  end;
  if not boDelete then
    SysMsg(sCharName + '没有被禁止登录。', c_Green, t_Hint);
end;
//恢复禁止登陆IP
procedure TPlayObject.CmdDelDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr,
  sFixDeny: string);
var
  I: Integer;
  boDelete: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sIPaddr = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' IP地址', c_Red, t_Hint);
    Exit;
  end;
  boDelete := False;
  g_DenyIPAddrList.Lock;
  try
    for I := g_DenyIPAddrList.Count - 1 downto 0 do begin
      if g_DenyIPAddrList.Count <= 0 then Break;
      if CompareText(sIPaddr, g_DenyIPAddrList.Strings[I]) = 0 then begin
        if Integer(g_DenyIPAddrList.Objects[I]) <> 0 then SaveDenyIPAddrList;
        g_DenyIPAddrList.Delete(I);
        SysMsg(sIPaddr + '已从禁止登录IP列表中删除。', c_Green, t_Hint);
        boDelete := True;
        Break;
      end;
    end;//for
  finally
    g_DenyIPAddrList.UnLock;
  end;
  if not boDelete then
    SysMsg(sIPaddr + '没有被禁止登录。', c_Green, t_Hint);
end;
//查看禁止登陆帐号
procedure TPlayObject.CmdShowDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
var
  I: Integer;
begin
  if (m_btPermission < 6) then Exit;
  g_DenyAccountList.Lock;
  try
    if g_DenyAccountList.Count <= 0 then begin
      SysMsg('禁止登录帐号列表为空。', c_Green, t_Hint);
      Exit;
    end;
    for I := 0 to g_DenyAccountList.Count - 1 do begin
      SysMsg(g_DenyAccountList.Strings[I], c_Green, t_Hint);
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
end;
//查看禁止登录角色列表
procedure TPlayObject.CmdShowDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  g_DenyChrNameList.Lock;
  try
    if g_DenyChrNameList.Count <= 0 then begin
      SysMsg('禁止登录角色列表为空。', c_Green, t_Hint);
      Exit;
    end;
    for I := 0 to g_DenyChrNameList.Count - 1 do begin
      SysMsg(g_DenyChrNameList.Strings[I], c_Green, t_Hint);
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
end;
//查看禁止登陆IP
procedure TPlayObject.CmdShowDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  g_DenyIPAddrList.Lock;
  try
    if g_DenyIPAddrList.Count <= 0 then begin
      SysMsg('禁止登录角色列表为空。', c_Green, t_Hint);
      Exit;
    end;
    for I := 0 to g_DenyIPAddrList.Count - 1 do begin
      SysMsg(g_DenyIPAddrList.Strings[I], c_Green, t_Hint);
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
end;

procedure TPlayObject.CmdDisableSendMsg(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    PlayObject.m_boFilterSendMsg := True;
  end;
  g_DisableSendMsgList.Add(sHumanName);
  SaveDisableSendMsgList();
  SysMsg(sHumanName + ' 已加入禁言列表。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdDisableSendMsgList(Cmd: pTGameCmd);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if g_DisableSendMsgList.Count <= 0 then begin
    SysMsg('禁言列表为空！！！', c_Red, t_Hint);
    Exit;
  end;

  SysMsg('禁言列表:', c_Blue, t_Hint);
  for I := 0 to g_DisableSendMsgList.Count - 1 do begin
    SysMsg(g_DisableSendMsgList.Strings[I], c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdEnableSendMsg(Cmd: pTGameCmd; sHumanName: string);
var
  I: Integer;
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    Exit;
  end;
  for I := g_DisableSendMsgList.Count - 1 downto 0 do begin
    if g_DisableSendMsgList.Count <= 0 then Break;
    if CompareText(sHumanName, g_DisableSendMsgList.Strings[I]) = 0 then begin
      PlayObject := UserEngine.GetPlayObject(sHumanName);
      if PlayObject <> nil then begin
        PlayObject.m_boFilterSendMsg := False;
      end;
      g_DisableSendMsgList.Delete(I);
      SaveDisableSendMsgList();
      SysMsg(sHumanName + ' 已从禁言列表中删除。', c_Green, t_Hint);
      Exit;
    end;
  end;//for
  SysMsg(sHumanName + ' 没有被禁言！！！', c_Red, t_Hint);
end;
//退出行会
procedure TPlayObject.CmdEndGuild;
begin
  if (m_MyGuild <> nil) then begin
    if (m_nGuildRankNo > 1) then begin
      if TGUild(m_MyGuild).IsMember(m_sCharName) and TGUild(m_MyGuild).DelMember(m_sCharName) then begin
        UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);
        m_MyGuild := nil;
        RefRankInfo(0, '');
        RefShowName(); //10/31
        SysMsg('您已经退出行会。', c_Green, t_Hint);
      end;
    end else begin
      SysMsg('行会掌门人不能这样退出行会！！！', c_Red, t_Hint);
    end;
  end else begin
    SysMsg('您都没加入行会！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdFireBurn(nInt, nTime, nN: Integer);
var
  FireBurnEvent: TFireBurnEvent;
begin
  if (m_btPermission < 6) then Exit;
  if (nInt = 0) or (nTime = 0) or (nN = 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + g_GameCommand.FIREBURN.sCmd + ' nInt nTime nN', c_Red, t_Hint);
    Exit;
  end;
  FireBurnEvent := TFireBurnEvent.Create(Self, m_nCurrX, m_nCurrY, nInt, nTime, nN);
  g_EventManager.AddEvent(FireBurnEvent);
end;

procedure TPlayObject.CmdForcedWallconquestWar(Cmd: pTGameCmd; sCASTLENAME: string);
var
  Castle: TUserCastle;
  s20: string;
  Guild: TGUild;
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;

  if sCASTLENAME = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 城堡名称', c_Red, t_Hint);
    Exit;
  end;

  Castle := g_CastleManager.Find(sCASTLENAME);
  if Castle <> nil then begin
    Castle.m_boUnderWar := not Castle.m_boUnderWar;//设置为可以攻城
    if Castle.m_boUnderWar then begin//正在攻城
      if g_GuildManager.GuildList.Count > 0 then begin//20080816 增加所有行会为攻城行会
        for I := 0 to g_GuildManager.GuildList.Count - 1 do begin
          Guild := TGUild(g_GuildManager.GuildList.Items[I]);
          Castle.m_AttackGuildList.Add(Guild);
        end;
      end;
      Castle.m_boShowOverMsg := False;//20080816
      Castle.m_WarDate := Now();//20080816

      Castle.m_dwStartCastleWarTick := GetTickCount();
      Castle.StartWallconquestWar();

      UserEngine.SendServerGroupMsg(SS_212, nServerIndex, '');
      s20 := '[' + Castle.m_sName + ' 攻城战已经开始]';
      UserEngine.SendBroadCastMsg(s20, t_System);
      UserEngine.SendServerGroupMsg(SS_204, nServerIndex, s20);
      Castle.MainDoorControl(True);
    end else begin
      Castle.StopWallconquestWar();
    end;
  end else begin
    SysMsg(Format(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCASTLENAME]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdFreePenalty(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandFreePKHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject.m_nPkPoint := 0;
  PlayObject.RefNameColor();
  PlayObject.SysMsg(g_sGameCommandFreePKHumanMsg, c_Green, t_Hint);
  SysMsg(Format(g_sGameCommandFreePKMsg, [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdGroupRecall(sCmd: string);
var
  I: Integer;
  dwValue: LongWord;
  PlayObject: TPlayObject;
begin
  if m_boRecallSuite or (m_btPermission >= 6) then begin
    if not m_PEnvir.m_boNORECALL then begin
      dwValue := (GetTickCount - m_dwGroupRcallTick) div 1000;
      m_dwGroupRcallTick := m_dwGroupRcallTick + dwValue * 1000;
      if m_btPermission >= 6 then m_wGroupRcallTime := 0;

      if m_wGroupRcallTime > dwValue then begin
        Dec(m_wGroupRcallTime, dwValue);
      end else m_wGroupRcallTime := 0;
      if m_wGroupRcallTime = 0 then begin
        if m_GroupOwner = Self then begin
          for I := 1 to m_GroupMembers.Count - 1 do begin
            PlayObject := TPlayObject(m_GroupMembers.Objects[I]);
            if PlayObject.m_boAllowGroupReCall then begin
              if PlayObject.m_PEnvir.m_boNORECALL then begin
                SysMsg(Format('%s 所在的地图不允许传送。', [PlayObject.m_sCharName]), c_Red, t_Hint);
              end else begin
                RecallHuman(PlayObject.m_sCharName);
              end;
            end else begin
              SysMsg(Format('%s 不允许天地合一！！！', [PlayObject.m_sCharName]), c_Red, t_Hint);
            end;
          end;//for
          m_dwGroupRcallTick := GetTickCount();
          m_wGroupRcallTime := g_Config.nGroupRecallTime;
        end;
      end else begin
        SysMsg(Format('%d 秒之后才可以再使用此功能！！！', [m_wGroupRcallTime]), c_Red, t_Hint);
      end;
    end else begin
      SysMsg('此地图禁止使用此命令！！！', c_Red, t_Hint);
    end;
  end else begin
    SysMsg('您现在还无法使用此功能！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdGuildRecall(sCmd, sParam: string);
var
  I, II: Integer;
  dwValue: LongWord;
  PlayObject: TPlayObject;
  GuildRank: pTGuildRank;
  nRecallCount, nNoRecallCount: Integer;
  Castle: TUserCastle;
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('命令功能: 行会传送，行会掌门人可以将整个行会成员全部集中。', c_Red, t_Hint);
    Exit;
  end;

  if not m_boGuildMove and (m_btPermission < 6) then begin
    SysMsg('您现在还无法使用此功能！！！', c_Red, t_Hint);
    Exit;
  end;
  if not IsGuildMaster then begin
    SysMsg('行会掌门人才可以使用此功能！！！', c_Red, t_Hint);
    Exit;
  end;
  if m_PEnvir.m_boNOGUILDRECALL then begin
    SysMsg('本地图不允许使用此功能！！！', c_Red, t_Hint);
    Exit;
  end;
  Castle := g_CastleManager.InCastleWarArea(Self);

  //if UserCastle.m_boUnderWar and UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY) then begin
  if (Castle <> nil) and Castle.m_boUnderWar then begin
    SysMsg('攻城区域不允许使用此功能！！！', c_Red, t_Hint);
    Exit;
  end;
  nRecallCount := 0;
  nNoRecallCount := 0;
  dwValue := (GetTickCount - m_dwGroupRcallTick) div 1000;
  m_dwGroupRcallTick := m_dwGroupRcallTick + dwValue * 1000;
  if m_btPermission >= 6 then m_wGroupRcallTime := 0;
  if m_wGroupRcallTime > dwValue then begin
    Dec(m_wGroupRcallTime, dwValue);
  end else m_wGroupRcallTime := 0;

  if m_wGroupRcallTime > 0 then begin
    SysMsg(Format('%d 秒之后才可以再使用此功能！！！', [m_wGroupRcallTime]), c_Red, t_Hint);
    Exit;
  end;

  for I := 0 to TGUild(m_MyGuild).m_RankList.Count - 1 do begin
    GuildRank := TGUild(m_MyGuild).m_RankList.Items[I];
    if GuildRank = nil then Continue;
    for II := 0 to GuildRank.MemberList.Count - 1 do begin
      PlayObject := TPlayObject(GuildRank.MemberList.Objects[II]);
      if PlayObject <> nil then begin
        if PlayObject = Self then begin
          //Inc(nNoRecallCount);
          Continue;
        end;
        if PlayObject.m_boAllowGuildReCall then begin
          if PlayObject.m_PEnvir.m_boNORECALL then begin
            SysMsg(Format('%s 所在的地图不允许传送。', [PlayObject.m_sCharName]), c_Red, t_Hint);
          end else begin
            RecallHuman(PlayObject.m_sCharName);
            Inc(nRecallCount);
          end;
        end else begin
          Inc(nNoRecallCount);
          SysMsg(Format('%s 不允许行会合一！！！', [PlayObject.m_sCharName]), c_Red, t_Hint);
        end;
      end;
    end;//for
  end;//for
  
  SysMsg(Format('已传送%d个成员，%d个成员未被传送。', [nRecallCount, nNoRecallCount]), c_Green, t_Hint);
  m_dwGroupRcallTick := GetTickCount();
  m_wGroupRcallTime := g_Config.nGuildRecallTime;
end;

{procedure TPlayObject.CmdGuildWar(sCmd, sGuildName: string);//20080812 注释
begin
  if (m_btPermission < 6) then Exit;
end; }
//改变头发
procedure TPlayObject.CmdHair(Cmd: pTGameCmd; sHumanName: string; nHair: Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (nHair < 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 类型值', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    PlayObject.m_btHair := nHair;
    PlayObject.FeatureChanged();
    SysMsg(sHumanName + ' 的头发已改变。', c_Green, t_Hint);
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdHumanInfo(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandInfoHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(PlayObject.GeTBaseObjectInfo(), c_Green, t_Hint);
end;

procedure TPlayObject.CmdHumanLocal(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandHumanLocalHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format(g_sGameCommandHumanLocalMsg, [sHumanName, m_sIPLocal {GetIPLocal(PlayObject.m_sIPaddr)}]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdHunger(sCmd, sHumanName: string; nHungerPoint: Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < 6) then Exit;
  if (sHumanName = '') or (nHungerPoint < 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 人物名称 能量值', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    PlayObject.m_nHungerStatus := nHungerPoint;
    PlayObject.SendMsg(PlayObject, RM_MYSTATUS, 0, 0, 0, 0, '');
    PlayObject.RefMyStatus();
    SysMsg(sHumanName + ' 的能量值已改变。', c_Green, t_Hint);
  end else begin
    SysMsg(sHumanName + '没有在线！！！', c_Red, t_Hint);
  end;
end;
//增加人物PK值
procedure TPlayObject.CmdIncPkPoint(Cmd: pTGameCmd; sHumanName: string; nPoint: Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandIncPkPointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  Inc(PlayObject.m_nPkPoint, nPoint);
  PlayObject.RefNameColor();
  if nPoint > 0 then
    SysMsg(Format(g_sGameCommandIncPkPointAddPointMsg, [sHumanName, nPoint]), c_Green, t_Hint)
  else
    SysMsg(Format(g_sGameCommandIncPkPointDecPointMsg, [sHumanName, -nPoint]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdKickHuman(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumName = '') or ((sHumName <> '') and (sHumName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandKickHumanHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    PlayObject.m_boKickFlag := True;
    PlayObject.m_boEmergencyClose := True;
    PlayObject.m_boPlayOffLine := False;
    PlayObject.m_boNotOnlineAddExp := False;
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdKill(Cmd: pTGameCmd; sHumanName: string);
var
  BaseObject: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName <> '' then begin
    BaseObject := UserEngine.GetPlayObject(sHumanName);
    if BaseObject = nil then begin
      SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
  end else begin
    BaseObject := GetPoseCreate();
    if BaseObject = nil then begin
      SysMsg('命令使用方法不正确，必须与角色面对面站好！！！', c_Red, t_Hint);
      Exit;
    end;
  end;
  BaseObject.Die;
end;

procedure TPlayObject.CmdLockLogin(Cmd: pTGameCmd);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if not g_Config.boLockHumanLogin then begin
    SysMsg('本服务器还没有启用登录锁功能！！！', c_Red, t_Hint);
    Exit;
  end;

  if m_boLockLogon and not m_boLockLogoned then begin
    SysMsg('您还没有打开登录锁或还没有设置锁密码！！！', c_Red, t_Hint);
    Exit;
  end;

  m_boLockLogon := not m_boLockLogon;
  if m_boLockLogon then begin
    SysMsg('已开启登录锁', c_Green, t_Hint);
  end else begin
    SysMsg('已关闭登录锁', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdLotteryTicket(sCmd: string; nPermission: Integer;
  sParam1: string);
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format(g_sGameCommandLotteryTicketMsg, [g_Config.nWinLotteryCount,
      g_Config.nNoWinLotteryCount,
      g_Config.nWinLotteryLevel1,
      g_Config.nWinLotteryLevel2,
      g_Config.nWinLotteryLevel3,
      g_Config.nWinLotteryLevel4,
      g_Config.nWinLotteryLevel5,
      g_Config.nWinLotteryLevel6]), c_Green, t_Hint);
end;
//调整指定人物的幸运值
procedure TPlayObject.CmdLuckPoint(sCmd: string; nPermission: Integer;
  sHumanName, sCtr, sPoint: string);
var
  PlayObject: TPlayObject;
  cMethod: Char;
  nPoint: Integer;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandLuckPointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  if sCtr = '' then begin
    SysMsg(Format(g_sGameCommandLuckPointMsg, [sHumanName, PlayObject.m_nBodyLuckLevel, PlayObject.m_dBodyLuck, PlayObject.m_nLuck]), c_Green, t_Hint);
    Exit;
  end;

  nPoint:= Str_ToInt(sPoint,0);
  cMethod := sCtr[1];//20080811 增加
  case cMethod of
    '=': PlayObject.m_nLuck := nPoint;
    '-': begin
        if PlayObject.m_nLuck >= nPoint then begin
          Dec(PlayObject.m_nLuck, nPoint);
        end else begin
          PlayObject.m_nLuck := 0;
        end;
     end;
    '+':Inc(PlayObject.m_nLuck, nPoint);
  end;
end;
//GM命令:制造物品
procedure TPlayObject.CmdMakeItem(Cmd: pTGameCmd; sItemName: string; nCount: Integer);
var
  I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sItemName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGamecommandMakeHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  if (nCount <= 0) then nCount := 1;
  if (nCount > 10) then nCount := 10;
  if (m_btPermission < Cmd.nPermissionMax) then begin
    if not CanMakeItem(sItemName) then begin
      SysMsg(g_sGamecommandMakeItemNameOrPerMissionNot, c_Red, t_Hint);
      Exit;
    end;
    //if UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurry) then begin
    if g_CastleManager.InCastleWarArea(Self) <> nil then begin//攻城区域，禁止使用此功能
      SysMsg(g_sGamecommandMakeInCastleWarRange, c_Red, t_Hint);
      Exit;
    end;
    if not InSafeZone then begin
      SysMsg(g_sGamecommandMakeInSafeZoneRange, c_Red, t_Hint);
      Exit;
    end;
    nCount := 1;
  end;

  for I := 0 to nCount - 1 do begin
    if m_ItemList.Count >= MAXBAGITEM then Exit;
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem.Price >= 15000) and not g_Config.boTestServer and (m_btPermission < 5) then begin
        Dispose(UserItem);
      end else begin
        if Random(g_Config.nMakeRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
      end;

      if m_btPermission >= Cmd.nPermissionMax then begin
        UserItem.MakeIndex := GetItemNumberEx(); //制造的物品另行取得物品ID
      end;
      m_ItemList.Add(UserItem);
      SendAddItem(UserItem);
      if {g_Config.boShowMakeItemMsg and} (m_btPermission >= 6) then
        MainOutMessage('[制造物品] ' + m_sCharName + ' ' + sItemName + '(' + IntToStr(UserItem.MakeIndex) + ')');
      if StdItem.NeedIdentify = 1 then
        AddGameDataLog('5' + #9 + m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
          '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
          '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
          '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
          '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
          '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
          IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
          IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
          IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
          IntToStr(UserItem.btValue[14])+ #9 + m_sCharName);
    end else begin //004CD114
      Dispose(UserItem);
      SysMsg(Format(g_sGamecommandMakeItemNameNotFound, [sItemName]), c_Red, t_Hint);
      Break;
    end;
  end;
end;

procedure TPlayObject.CmdMapMove(Cmd: pTGameCmd; sMapName: string);
var
  Envir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMoveHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) then begin
    SysMsg(Format(g_sTheMapNotFound, [sMapName]) { + ' 此地图号不存在！！！'}, c_Red, t_Hint);
    Exit;
  end;
  if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(sMapName) then begin
    SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
    MapRandomMove(sMapName, 0);
  end else begin
    SysMsg(Format(g_sTheMapDisableMove, [sMapName, Envir.sMapDesc]) {'地图 ' + sParam1 + ' 不允许传送！！！'}, c_Red, t_Hint);
  end;
end;
//准确移动
procedure TPlayObject.CmdPositionMove(Cmd: pTGameCmd; sMapName, sX, sY: string);
var
  Envir: TEnvirnoment;
  nX, nY: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      Exit;
    end;
    if (sMapName = '') or (sX = '') or (sY = '') or ((sMapName <> '') and (sMapName[1] = '?')) then begin
      if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandPositionMoveHelpMsg]), c_Red, t_Hint);
      Exit;
    end;
    if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(sMapName) then begin
      Envir := g_MapManager.FindMap(sMapName);
      if Envir <> nil then begin
        nX := Str_ToInt(sX, 0);
        nY := Str_ToInt(sY, 0);
        if Envir.CanWalk(nX, nY, True) then begin
          SpaceMove(sMapName, nX, nY, 0);
        end else begin
          SysMsg(Format(g_sGameCommandPositionMoveCanotMoveToMap, [sMapName, sX, sY]), c_Green, t_Hint);
        end;
      end;
    end else begin
      SysMsg(Format(g_sTheMapDisableMove, [sMapName, Envir.sMapDesc]), c_Red, t_Hint);
    end;
  except
    on E: Exception do begin
      MainOutMessage('{异常} TPlayObject.CmdPositionMove');
    end;
  end;
end;

procedure TPlayObject.CmdMapMoveHuman(Cmd: pTGameCmd; sSrcMap, sDenMap: string);
var
  SrcEnvir, DenEnvir: TEnvirnoment;
  HumanList: TList;
  I: Integer;
  MoveHuman: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sDenMap = '') or (sSrcMap = '') or ((sSrcMap <> '') and (sSrcMap[1] = '?')) then begin
   if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMapMoveHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  SrcEnvir := g_MapManager.FindMap(sSrcMap);
  DenEnvir := g_MapManager.FindMap(sDenMap);
  if (SrcEnvir = nil) then begin
    SysMsg(Format(g_sGameCommandMapMoveMapNotFound, [sSrcMap]), c_Red, t_Hint);
    Exit;
  end;
  if (DenEnvir = nil) then begin
    SysMsg(Format(g_sGameCommandMapMoveMapNotFound, [sDenMap]), c_Red, t_Hint);
    Exit;
  end;
  HumanList := TList.Create;
  UserEngine.GetMapRageHuman(SrcEnvir, SrcEnvir.m_nWidth div 2, SrcEnvir.m_nHeight div 2, 1000, HumanList);
  for I := 0 to HumanList.Count - 1 do begin
    MoveHuman := TPlayObject(HumanList.Items[I]);
    if MoveHuman <> Self then MoveHuman.MapRandomMove(sDenMap, 0);
  end;
  HumanList.Free;
end;

procedure TPlayObject.CmdUserCmd(sLable: string);
begin
  if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(Self, sLable, False);
end;
//自定义命令 20080729
function TPlayObject.PlayObjectUserCmd(sLable,sParam: string):Boolean;
var
  I, nCode: Integer;
begin
  Result := False;
  Try
    if (g_UserCmdList = nil) or (g_UserCmdList.Count <= 0) then Exit;
    for I := 0 to g_UserCmdList.Count - 1 do begin
      if CompareText(sLable, g_UserCmdList.Strings[I]) = 0 then begin
        if g_FunctionNPC = nil then break;
        m_nScriptGotoCount:= 0;//20080927 初始化跳转次数
        nCode:= Integer(g_UserCmdList.Objects[I]);
        sLable := '@UserCmd' + IntToStr(nCode);
        if (nCode > 99) or (nCode < 0)  then nCode:= 0;
        m_sString[nCode] := sParam;
        m_nInteger[nCode] := Str_ToInt(sParam, 0);
        CmdUserCmd(sLable);//执行QF触发
        Result := True;
        break;
      end;
    end; 
  except
    MainOutMessage('{异常} TPlayObject.PlayObjectUserCmd');
  end;
end;

procedure TPlayObject.CmdMemberFunction(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('打开会员功能窗口.', c_Red, t_Hint);
    Exit;
  end;
  if g_ManageNPC <> nil then begin
    g_ManageNPC.GotoLable(Self, '@Member', False);
  end;
end;

procedure TPlayObject.CmdMemberFunctionEx(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('打开会员功能窗口.', c_Red, t_Hint);
    Exit;
  end;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@Member', False);
  end;
end;

procedure TPlayObject.CmdMission(Cmd: pTGameCmd; sX, sY: string);
var
  nX, nY: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sX = '') or (sY = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' X  Y', c_Red, t_Hint);
    Exit;
  end;
  nX := Str_ToInt(sX, 0);
  nY := Str_ToInt(sY, 0);
  g_boMission := True;
  g_sMissionMap := m_sMapName;
  g_nMissionX := nX;
  g_nMissionY := nY;
  SysMsg('怪物集中目标已设定为: ' + m_sMapName + '(' + IntToStr(g_nMissionX) + ':' + IntToStr(g_nMissionY) + ')', c_Green, t_Hint);
end;

procedure TPlayObject.CmdMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel, nMonTpye: Integer); //004CC7F4
var
  I: Integer;
  nX, nY: Integer;
  Monster: TBaseObject;
  BoIsNGMon: Boolean;//20081001
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMobHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  if nCount <= 0 then nCount := 1;
  if not (nLevel in [0..10]) then nLevel := 0;
  BoIsNGMon:= False;//20081229
  BoIsNGMon:= nMonTpye <> 0;//20081001 是否内功怪
  nCount := _MIN(64, nCount);
  GetFrontPosition(nX, nY);
  for I := 0 to nCount - 1 do begin
    Monster := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, nX, nY, sMonName);
    if Monster <> nil then begin
      Monster.m_boIsNGMonster := BoIsNGMon;//20081001
      Monster.m_btSlaveMakeLevel := nLevel;
      Monster.m_btSlaveExpLevel := nLevel;
      Monster.RecalcAbilitys;
      Monster.RefNameColor;
    end else begin
      SysMsg(g_sGameCommandMobMsg, c_Red, t_Hint);
      Break;
    end;
  end;
end;

procedure TPlayObject.CmdMobCount(Cmd: pTGameCmd; sMapName: string);
var
  Envir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMobCountHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if Envir = nil then begin
    SysMsg(g_sGameCommandMobCountMapNotFound, c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format(g_sGameCommandMobCountMonsterCount, [UserEngine.GetMapMonster(Envir, nil)]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdHumanCount(Cmd: pTGameCmd; sMapName: string);
var
  Envir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandHumanCountHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if Envir = nil then begin
    SysMsg(g_sGameCommandMobCountMapNotFound, c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format(g_sGameCommandMobCountMonsterCount, [UserEngine.GetMapHuman(sMapName)]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdMobFireBurn(Cmd: pTGameCmd; sMAP, sX, sY, sType,
  sTime, sPoint: string);
var
  nX, nY, nType, nTime, nPoint: Integer;
  FireBurnEvent: TFireBurnEvent;
  Envir: TEnvirnoment;
  OldEnvir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMAP = '') or ((sMAP <> '') and (sMAP[1] = '?')) then begin
   if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandMobFireBurnHelpMsg, [Cmd.sCmd, sMAP, sX, sY, sType, sTime, sPoint]), c_Red, t_Hint);
    Exit;
  end;

  nX := Str_ToInt(sX, -1);
  nY := Str_ToInt(sY, -1);
  nType := Str_ToInt(sType, -1);
  nTime := Str_ToInt(sTime, -1);
  nPoint := Str_ToInt(sPoint, -1);
  if nPoint < 0 then nPoint := 1;

  if (sMAP = '') or (nX < 0) or (nY < 0) or (nType < 0) or (nTime < 0) or (nPoint < 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandMobFireBurnHelpMsg, [Cmd.sCmd, sMAP, sX, sY, sType, sTime, sPoint]), c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMAP);
  if Envir <> nil then begin
    OldEnvir := m_PEnvir;
    m_PEnvir := Envir;
    FireBurnEvent := TFireBurnEvent.Create(Self, nX, nY, nType, nTime * 1000, nPoint);
    g_EventManager.AddEvent(FireBurnEvent);
    m_PEnvir := OldEnvir;
    Exit;
  end;
  SysMsg(Format(g_sGameCommandMobFireBurnMapNotFountMsg, [Cmd.sCmd, sMAP]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdMobLevel(Cmd: pTGameCmd; Param: string); //004CFD5C
var
  I: Integer;
  BaseObjectList: TList;
  BaseObject: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((Param <> '') and (Param[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;

  BaseObjectList := TList.Create;
  m_PEnvir.GetRangeBaseObject(m_nCurrX, m_nCurrY, 2, True, BaseObjectList);
  for I := 0 to BaseObjectList.Count - 1 do begin
    BaseObject := TBaseObject(BaseObjectList.Items[I]);
    SysMsg(BaseObject.GeTBaseObjectInfo(), c_Green, t_Hint);
  end;
  BaseObjectList.Free;
end;
//增加一个NPC
procedure TPlayObject.CmdMobNpc(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3, sParam4: string);
var
  nAppr: Integer;
  boIsCastle: Boolean;
  Merchant: TMerchant;
  nX, nY: Integer;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 = '') or (sParam2 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandMobNpcHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  nAppr := Str_ToInt(sParam3, 0);
  boIsCastle := (Str_ToInt(sParam4, 0) = 1);
  if sParam1 = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' NPC名称 脚本文件名 外形(数字) 属沙城(0,1)', c_Red, t_Hint);
    Exit;
  end;
  Merchant := TMerchant.Create;
  Merchant.m_sCharName := sParam1;
  Merchant.m_sMapName := m_sMapName;
  Merchant.m_PEnvir := m_PEnvir;
  Merchant.m_wAppr := nAppr;
  Merchant.m_nFlag := 0;
  Merchant.m_boCastle := boIsCastle;
  Merchant.m_sScript := sParam2;
  GetFrontPosition(nX, nY);
  Merchant.m_nCurrX := nX;
  Merchant.m_nCurrY := nY;
  Merchant.Initialize();
  UserEngine.AddMerchant(Merchant);
end;
//20081001 修改
procedure TPlayObject.CmdMobPlace(Cmd: pTGameCmd; sX, sY, sMonName, sCount, sNGMon: string);
var
  I: Integer;
  nCount, nX, nY: Integer;
  MEnvir: TEnvirnoment;
  mon: TBaseObject;
  boIsNGMon: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nCount := _MIN(500, Str_ToInt(sCount, 0));
  nX := Str_ToInt(sX, 0);
  nY := Str_ToInt(sY, 0);
  boIsNGMon:= Str_ToInt(sNGMon, 0) <> 0;//20081001
  if (nX <= 0) or (nY <= 0) or (sMonName = '') or (nCount <= 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' X  Y 怪物名称 怪物数量 内功怪(0/1)', c_Red, t_Hint);
    Exit;
  end;
  MEnvir := g_MapManager.FindMap(g_sMissionMap);
  if not g_boMission or (MEnvir = nil) then begin
    SysMsg('还没有设定怪物集中点！！！', c_Red, t_Hint);
    SysMsg('请先用命令' + g_GameCommand.Mission.sCmd + '设置怪物的集中点。', c_Red, t_Hint);
    Exit;
  end;

  for I := 0 to nCount - 1 do begin
    mon := UserEngine.RegenMonsterByName(g_sMissionMap, nX, nY, sMonName);
    if mon <> nil then begin
      mon.m_boIsNGMonster := boIsNGMon;//20081001
      mon.m_boMission := True;
      mon.m_nMissionX := g_nMissionX;
      mon.m_nMissionY := g_nMissionY;
    end else Break;
  end;
  if mon.m_btRaceServer <> 136 then SysMsg(IntToStr(nCount) + ' 只 ' + sMonName + ' 已正在往地图 ' + g_sMissionMap + ' ' + IntToStr(g_nMissionX) + ':' + IntToStr(g_nMissionY) + ' 集中。', c_Green, t_Hint); //20080305
end;

procedure TPlayObject.CmdNpcScript(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3: string);
var
  BaseObject: TBaseObject;
  nNPCType: Integer;
  I: Integer;
  sScriptFileName: string;
  Merchant: TMerchant;
  NormNpc: TNormNpc;
  LoadList: TStringList;
  sScriptLine: string;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandNpcScriptHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  nNPCType := -1;
  BaseObject := GetPoseCreate();
  if BaseObject <> nil then begin
    for I := 0 to UserEngine.m_MerchantList.Count - 1 do begin
      if TBaseObject(UserEngine.m_MerchantList.Items[I]) = BaseObject then begin
        nNPCType := 0;
        Break;
      end;
    end;//for

    for I := 0 to UserEngine.QuestNPCList.Count - 1 do begin
      if TBaseObject(UserEngine.QuestNPCList.Items[I]) = BaseObject then begin
        nNPCType := 1;
        Break;
      end;
    end;//for
  end;
  if nNPCType < 0 then begin
    SysMsg('命令使用方法不正确，必须与NPC面对面，才能使用此命令！！！', c_Red, t_Hint);
    Exit;
  end;

  if sParam1 = '' then begin
    if nNPCType = 0 then begin
      Merchant := TMerchant(BaseObject);
      sScriptFileName := g_Config.sEnvirDir + sMarket_Def + Merchant.m_sScript + '-' + Merchant.m_sMapName + '.txt';
    end;
    if nNPCType = 1 then begin
      NormNpc := TNormNpc(BaseObject);
      sScriptFileName := g_Config.sEnvirDir + sNpc_def + NormNpc.m_sCharName + '-' + NormNpc.m_sMapName + '.txt';
    end;
    if FileExists(sScriptFileName) then begin
      LoadList := TStringList.Create;
      try
        LoadList.LoadFromFile(sScriptFileName);
      except
        SysMsg('读取脚本文件错误: ' + sScriptFileName, c_Red, t_Hint);
      end;
      for I := 0 to LoadList.Count - 1 do begin
        sScriptLine := Trim(LoadList.Strings[I]);
        sScriptLine := ReplaceChar(sScriptLine, ' ', ',');
        SysMsg(IntToStr(I) + ',' + sScriptLine, c_Blue, t_Hint);
      end;
      LoadList.Free;
    end;
  end;
end;

{procedure TPlayObject.CmdOPDeleteSkill(sHumanName, sSkillName: string);//20080812 注释
begin
  if (m_btPermission < 6) then Exit;
end; 

procedure TPlayObject.CmdOPTraining(sHumanName, sSkillName: string;
  nLevel: Integer);
begin
  if (m_btPermission < 6) then Exit;
end; }
//查人物的PK值
procedure TPlayObject.CmdPKpoint(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandPKPointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format(g_sGameCommandPKPointMsg, [sHumanName, PlayObject.m_nPkPoint]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdPrvMsg(sCmd: string; nPermission: Integer;
  sHumanName: string);
var
  I: Integer;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandPrvMsgHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  for I := m_BlockWhisperList.Count - 1 downto 0 do begin
    if m_BlockWhisperList.Count <= 0 then Break;
    if CompareText(m_BlockWhisperList.Strings[I], sHumanName) = 0 then begin
      m_BlockWhisperList.Delete(I);
      SysMsg(Format(g_sGameCommandPrvMsgUnLimitMsg, [sHumanName]), c_Green, t_Hint);
      Exit;
    end;
  end;
  m_BlockWhisperList.Add(sHumanName);
  SysMsg(Format(g_sGameCommandPrvMsgLimitMsg, [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdReAlive(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandReAliveHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  if CompareText(sHumanName, 'Self') = 0 then sHumanName:= m_sCharName;//20080822 增加
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject.ReAlive;
  PlayObject.m_WAbil.HP := PlayObject.m_WAbil.MaxHP;
  PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');

  SysMsg(Format(g_sGameCommandReAliveMsg, [sHumanName]), c_Green, t_Hint);
  SysMsg(sHumanName + ' 已获重生。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdRecallHuman(Cmd: pTGameCmd; sHumanName: string); //004CE250
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandRecallHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  RecallHuman(sHumanName);
end;

procedure TPlayObject.CmdRecallMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel, nAutoChangeColor, nFixColor: Integer); //004CC8C4
var
  I: Integer;
  n10, n14: Integer;
  mon: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandRecallMobHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  if nLevel >= 10 then nLevel := 0;
  if nCount <= 0 then nCount := 1;
  for I := 0 to nCount - 1 do begin
    if m_SlaveList.Count >= 20 then Break;
    GetFrontPosition(n10, n14);
    mon := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, n10, n14, sMonName);
    if mon <> nil then begin
      mon.m_Master := Self;
      mon.m_dwMasterRoyaltyTick := {GetTickCount +} 86400000{24 * 60 * 60 * 1000};
      Mon.m_dwMasterRoyaltyTime := GetTickCount;//20080813 增加
      mon.m_btSlaveMakeLevel := 3;
      mon.m_btSlaveExpLevel := nLevel;
      if nAutoChangeColor = 1 then begin
        mon.m_boAutoChangeColor := True;
      end else
        if nFixColor > 0 then begin
        mon.m_boFixColor := True;
        mon.m_nFixColorIdx := nFixColor - 1;
      end;

      mon.RecalcAbilitys();
      mon.RefNameColor();
      m_SlaveList.Add(mon);
    end;
  end;
end;
//------------------------------------------------------------------------------
//20080122 召唤宝宝
procedure TPlayObject.CmdRECALLMOBEX(Cmd: pTGameCmd; sMonName: string; nNameColor, nX, nY: Integer);
var
  mon: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandRecallMobExHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  if nX < 0 then nX := 0;
  if nY < 0 then nY := 0;
  if nNameColor < 0 then nNameColor:=0;
  if nNameColor > 255 then nNameColor:=255;
    mon := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, nX, nY, sMonName);
    if mon <> nil then begin
      mon.m_Master := Self;
      mon.m_dwMasterRoyaltyTick := {GetTickCount +} 86400000{24 * 60 * 60 * 1000};
      Mon.m_dwMasterRoyaltyTime := GetTickCount;//20080813 增加
      mon.m_btSlaveMakeLevel := 3;
      mon.m_btSlaveExpLevel := 1;
      mon.m_btNameColor:= nNameColor;

      mon.RecalcAbilitys();
      mon.RefNameColor();
      m_SlaveList.Add(mon);
  end;
end;
//------------------------------------------------------------------------------
//20080403 给指定纯度的矿石
//命令格式:GIVEMINE 矿名称 数量 纯度
//如纯度不填,则随机给纯度
procedure TPlayObject.CmdGIVEMINE(Cmd: pTGameCmd; sMINEName: string; nMineCount, nDura: Integer);
var
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMINEName = '') or ((sMINEName <> '') and (sMINEName[1] = '?')) or (nMineCount <= 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGIVEMINEHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  if nDura <= 0 then nDura:=Random(18)+ 3;//如纯度不填,则随机给纯度
  for I := 0 to nMineCount - 1 do begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(sMineName, UserItem) then begin
       StdItem := UserEngine.GetStdItem(UserItem.wIndex);
       if (StdItem <> nil) and (StdItem.StdMode = 43) then begin
         if IsAddWeightAvailable(StdItem.Weight * nMineCount) then begin
           UserItem.Dura:= nDura * 1000;
           if UserItem.Dura > UserItem.DuraMax then UserItem.Dura:= UserItem.DuraMax;
           m_ItemList.Add(UserItem);
           SendAddItem(UserItem);
           if StdItem.NeedIdentify = 1 then
            AddGameDataLog('5' + #9 +
              m_sMapName+ #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              IntToStr(UserItem.Dura )+'/'+IntToStr(UserItem.DuraMax)+ #9 + m_sCharName);
         end;
       end;
     end else begin
       Dispose(UserItem);
       Break;
     end;
  end;
end;
//------------------------------------------------------------------------------
//MOVEMOBTO 怪物名称 原地图 原X 原Y 新地图 新X 新Y    20080123
//将指定坐标的怪物移动到新坐标，名称为ALL则移动该坐标所有怪物
procedure TPlayObject.CmdMOVEMOBTO(Cmd: pTGameCmd; sMonName,OleMap,NewMap: string; nX,nY,OnX,OnY: Integer);
var
  boMoveAll: Boolean;
  SrcEnvir, DenEnvir: TEnvirnoment;
  MonList: TList;
  MoveMon: TBaseObject;
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMonName = '') or (OleMap = '') or (NewMap = '') or((sMonName <> '') and (sMonName[1] = '?')) then begin
   if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMOVEMOBTOHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  boMoveAll:=False;
  if sMonName = 'ALL' then boMoveAll:= True;
  if nX < 0 then nX := 0;
  if nY < 0 then nY := 0;
  if OnX < 0 then OnX := 0;
  if OnY < 0 then OnY := 0;

  SrcEnvir := g_MapManager.FindMap(OleMap);//原地图
  DenEnvir := g_MapManager.FindMap(NewMap);//新地图
  if (SrcEnvir = nil) or (DenEnvir = nil) then Exit;

  MonList := TList.Create;
  if not boMoveAll then begin//指定名称的怪移动
    UserEngine.GetMapRangeMonster(SrcEnvir, OnX, OnY, 10,MonList);//查指定XY范围内的怪
    if MonList.Count > 0 then begin//20080629
      for I := 0 to MonList.Count - 1 do begin
        MoveMon := TBaseObject(MonList.Items[I]);
        if MoveMon <> Self then begin
          if CompareText(MoveMon.m_sCharName, sMonName) = 0 then //是否是指定名称的怪
             MoveMon.SpaceMove(NewMap, nX, nY, 0);
        end;
      end;//for
    end;
  end else begin //所有怪移动
    UserEngine.GetMapRangeMonster(SrcEnvir, OnX, OnY, 1000,MonList);//查指定XY范围内的怪
    for I := 0 to MonList.Count - 1 do begin
      MoveMon := TBaseObject(MonList.Items[I]);
      if MoveMon <> Self then
        MoveMon.SpaceMove(NewMap, nX, nY, 0);
    end;//for
  end;
  MonList.Free;
end;
//------------------------------------------------------------------------------
//CLEARITEMMAP 地图 X Y 范围 物品名称     20080124
//(清除地图物品，ALL则清除所有)
procedure TPlayObject.CmdCLEARITEMMAP(Cmd: pTGameCmd; sMap,sItemName: string; nX,nY,nRange: Integer);
var
  I,nXX,nYY: Integer;
  boClearAll: Boolean;
  Envir: TEnvirnoment;
  MapItem: PTMapItem;
  ItemList:TList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMap = '') or (sItemName='') or (nX < 0) or (nY < 0) or (nRange < 0) or ((sItemName<>'') and(sItemName[1] = '?')) then begin
   if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandCLEARITEMMAPHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  boClearAll:= False;
  if sItemName = 'ALL' then boClearAll:= True;
  Envir := g_MapManager.FindMap(sMap);//查找地图
  if Envir <> nil then begin
    ItemList:= TList.Create;
    Envir.GetMapItem(nX, nY, nRange,ItemList);//取地图上指定范围的物品
    if not boClearAll then begin///清除指定物品
      if ItemList.Count > 0 then begin//20080629
        for I := 0 to ItemList.Count - 1 do begin
        MapItem:= pTMapItem(ItemList.Items[I]);
          if (CompareText(MapItem.name, sItemName) = 0) then begin
            for nXX := nX - nRange to nX + nRange do begin
              for nYY := nY - nRange to nY + nRange do begin
               Envir.DeleteFromMap(nXX, nYY, OS_ITEMOBJECT, TObject(MapItem));
               if TObject(MapItem)=nil then break;
              end;
            end;
          end;
        end;//for
      end;
    end else begin //清除全部物品
      if ItemList.Count > 0 then begin//20080629
        for I := 0 to ItemList.Count - 1 do begin
          MapItem:= pTMapItem(ItemList.Items[I]);
          for nXX := nX - nRange to nX + nRange do begin
            for nYY := nY - nRange to nY + nRange do begin
             Envir.DeleteFromMap(nXX, nYY, OS_ITEMOBJECT, TObject(MapItem));
             if TObject(MapItem)=nil then break;
            end;
          end;
        end;//for
      end;
    end;
    ItemList.Free;
  end;
end;
//------------------------------------------------------------------------------
procedure TPlayObject.CmdReconnection(sCmd, sIPaddr, sPort: string);
//004CE380
begin
  if (m_btPermission < 10) then Exit;
  if (sIPaddr <> '') and (sIPaddr[1] = '?') then begin
    SysMsg('此命令用于改变客户端连接网关的IP及端口。', c_Blue, t_Hint);
    Exit;
  end;

  if (sIPaddr = '') or (sPort = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' IP地址 端口', c_Red, t_Hint);
    Exit;
  end;
  if (sIPaddr <> '') and (sPort <> '') then begin
    SendMsg(Self, RM_RECONNECTION, 0, 0, 0, 0, sIPaddr + '/' + sPort);
  end;
end;

procedure TPlayObject.CmdRefineWeapon(Cmd: pTGameCmd; nDc, nMc, nSc, nHit: Integer); //004CD1C4
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (nDc + nMc + nSc) > 10 then Exit;
  if m_UseItems[U_WEAPON].wIndex <= 0 then Exit;
  m_UseItems[U_WEAPON].btValue[0] := nDc;
  m_UseItems[U_WEAPON].btValue[1] := nMc;
  m_UseItems[U_WEAPON].btValue[2] := nSc;
  m_UseItems[U_WEAPON].btValue[5] := nHit;
  SendUpdateItem(@m_UseItems[U_WEAPON]);
  RecalcAbilitys();
  CompareSuitItem(False);//200080729 套装
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
  MainOutMessage('[武器调整]' + m_sCharName + ' DC:' + IntToStr(nDc) + ' MC' + IntToStr(nMc) + ' SC' + IntToStr(nSc) + ' HIT:' + IntToStr(nHit));
end;

procedure TPlayObject.CmdReGotoHuman(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then  SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandReGotoHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  SpaceMove(PlayObject.m_PEnvir.sMapName, PlayObject.m_nCurrX, PlayObject.m_nCurrY, 0);
end;

procedure TPlayObject.CmdReloadAbuse(sCmd: string; nPermission: Integer;
  sParam1: string);
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
end;

procedure TPlayObject.CmdReLoadAdmin(sCmd: string);
begin
  if (m_btPermission < 6) then Exit;
  FrmDB.LoadAdminList();
  UserEngine.SendServerGroupMsg(213, nServerIndex, '');
  SysMsg('管理员列表重新加载成功...', c_Green, t_Hint);
end;
//重新加载指定行会
procedure TPlayObject.CmdReloadGuild(sCmd: string; nPermission: Integer; sParam1: string);
var
  Guild: TGUild;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandReloadGuildHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg(g_sGameCommandReloadGuildOnMasterserver, c_Red, t_Hint);
    Exit;
  end;
  Guild := g_GuildManager.FindGuild(sParam1);
  if Guild = nil then begin
    SysMsg(Format(g_sGameCommandReloadGuildNotFoundGuildMsg, [sParam1]), c_Red, t_Hint);
    Exit;
  end;
  Guild.LoadGuild();
  SysMsg(Format(g_sGameCommandReloadGuildSuccessMsg, [sParam1]), c_Red, t_Hint);
  UserEngine.SendServerGroupMsg(SS_207, nServerIndex, sParam1);
end;

{procedure TPlayObject.CmdReloadGuildAll;
begin
  if (m_btPermission < 6) then Exit;
end; }

procedure TPlayObject.CmdReloadLineNotice(sCmd: string;
  nPermission: Integer; sParam1: string);
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  if LoadLineNotice(g_Config.sNoticeDir + 'LineNotice.txt') then begin
    SysMsg(g_sGameCommandReloadLineNoticeSuccessMsg, c_Green, t_Hint);
  end else begin
    SysMsg(g_sGameCommandReloadLineNoticeFailMsg, c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdReloadManage(Cmd: pTGameCmd; sParam: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam <> '') and (sParam[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  if sParam = '' then begin
    if g_ManageNPC <> nil then begin
      g_ManageNPC.ClearScript();
      g_ManageNPC.LoadNpcScript();
      SysMsg('重新加载登录脚本完成...', c_Green, t_Hint);
    end else begin
      SysMsg('重新加载登录脚本失败...', c_Green, t_Hint);
    end;
  end else begin
    if g_FunctionNPC <> nil then begin
      g_FunctionNPC.ClearScript();
      g_FunctionNPC.LoadNpcScript();
      SysMsg('重新加载功能脚本完成...', c_Green, t_Hint);
    end else begin
      SysMsg('重新加载功能脚本失败...', c_Green, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdReloadRobot;
begin
  RobotManage.RELOADROBOT();
  SysMsg('重新加载机器人配置完成...', c_Green, t_Hint);
end;
procedure TPlayObject.CmdReloadRobotManage;
begin
  if (m_btPermission < 6) then Exit;
  if g_RobotNPC <> nil then begin
    g_RobotNPC.ClearScript();
    g_RobotNPC.LoadNpcScript();
    SysMsg('重新加载机器人专用脚本完成...', c_Green, t_Hint);
  end else begin
    SysMsg('重新加载机器人专用脚本失败...', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdReloadMonItems;
var
  I: Integer;
  Monster: pTMonInfo;
begin
  if (m_btPermission < 6) then Exit;
  try
    for I := 0 to UserEngine.MonsterList.Count - 1 do begin
      Monster := UserEngine.MonsterList.Items[I];
      FrmDB.LoadMonitems(Monster.sName, Monster.ItemList);
    end;
    SysMsg('怪物爆物品列表重加载完成...', c_Green, t_Hint);
  except
    SysMsg('怪物爆物品列表重加载失败！！！', c_Green, t_Hint);
  end;
end;
//重新加载NPC
procedure TPlayObject.CmdReloadNpc(sParam: string);
var
  I: Integer;
  TmpList: TList;
  Merchant: TMerchant;
  NPC: TNormNpc;
begin
  if (m_btPermission < 6) then Exit;
  if CompareText('all', sParam) = 0 then begin
    FrmDB.ReLoadMerchants();
    UserEngine.ReloadMerchantList();
    SysMsg('交易NPC重新加载完成！！！', c_Red, t_Hint);
    UserEngine.ReloadNpcList();
    SysMsg('管理NPC重新加载完成！！！', c_Red, t_Hint);
    Exit;
  end;
  TmpList := TList.Create;
  if UserEngine.GetMerchantList(m_PEnvir, m_nCurrX, m_nCurrY, 9, TmpList) > 0 then begin
    for I := 0 to TmpList.Count - 1 do begin
      Merchant := TMerchant(TmpList.Items[I]);
      Merchant.ClearScript;
      Merchant.LoadNpcScript;
      SysMsg(Merchant.m_sCharName + '重新加载成功...', c_Green, t_Hint);
    end; // for
  end else begin
    SysMsg('附近未发现任何交易NPC！！！', c_Red, t_Hint);
  end;
  TmpList.Clear;
  if UserEngine.GetNpcList(m_PEnvir, m_nCurrX, m_nCurrY, 9, TmpList) > 0 then begin
    for I := 0 to TmpList.Count - 1 do begin
      NPC := TNormNpc(TmpList.Items[I]);
      NPC.ClearScript;
      NPC.LoadNpcScript;
      SysMsg(NPC.m_sCharName + '重新加载成功...', c_Green, t_Hint);
    end; // for
  end else begin
    SysMsg('附近未发现任何管理NPC！！！', c_Red, t_Hint);
  end;
  TmpList.Free;
end;

procedure TPlayObject.CmdSearchHuman(sCmd, sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if m_boProbeNecklace or (m_btPermission >= 6) then begin
    if (sHumanName = '') then begin
      if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 人物名称', c_Red, t_Hint);
      Exit;
    end;
    if ((GetTickCount - m_dwProbeTick) > 10000) or (m_btPermission >= 3) then begin
      m_dwProbeTick := GetTickCount();
      PlayObject := UserEngine.GetPlayObject(sHumanName);
      if PlayObject <> nil then begin
        SysMsg(sHumanName + ' 现在位于 ' + PlayObject.m_PEnvir.sMapDesc + ' ' + IntToStr(PlayObject.m_nCurrX) + ':' + IntToStr(PlayObject.m_nCurrY), c_Blue, t_Hint);
      end else begin
        SysMsg(sHumanName + ' 现在不在线，或位于其它服务器上！！！', c_Red, t_Hint);
      end;
    end else begin
      SysMsg(IntToStr((GetTickCount - m_dwProbeTick) div 1000 - 10) + ' 秒之后才可以再使用此功能！！！', c_Red, t_Hint);
    end;
  end else begin
    SysMsg('您现在还无法使用此功能！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdShowSbkGold(Cmd: pTGameCmd; sCASTLENAME, sCtr, sGold: string);
var
  I: Integer;
  Ctr: Char;
  nGold: Integer;
  Castle: TUserCastle;
  List: TStringList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sCASTLENAME <> '') and (sCASTLENAME[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  if sCASTLENAME = '' then begin
    List := TStringList.Create;
    g_CastleManager.GetCastleGoldInfo(List);
    for I := 0 to List.Count - 1 do SysMsg(List.Strings[I], c_Green, t_Hint);
    List.Free;
    Exit;
  end;
  Castle := g_CastleManager.Find(sCASTLENAME);
  if Castle = nil then begin
    SysMsg(Format(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCASTLENAME]), c_Red, t_Hint);
    Exit;
  end;

  Ctr := sCtr[1];
  nGold := Str_ToInt(sGold, -1);
  if not (Ctr in ['=', '-', '+']) or (nGold < 0) or (nGold > 100000000) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandSbkGoldHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  case Ctr of
    '=': Castle.m_nTotalGold := nGold;
    '-': Dec(Castle.m_nTotalGold);
    '+': Inc(Castle.m_nTotalGold, nGold);
  end;
  if Castle.m_nTotalGold < 0 then Castle.m_nTotalGold := 0;
end;

procedure TPlayObject.CmdShowUseItemInfo(Cmd: pTGameCmd;
  sHumanName: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandShowUseItemInfoHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  for I := Low(PlayObject.m_UseItems) to High(PlayObject.m_UseItems) do begin
    UserItem := @PlayObject.m_UseItems[I];
    if UserItem.wIndex = 0 then Continue;
    SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]',
      [GetUseItemName(I),
      UserEngine.GetStdItemName(UserItem.wIndex),
        UserItem.wIndex,
        UserItem.MakeIndex,
        UserItem.Dura,
        UserItem.DuraMax]),
        c_Blue, t_Hint);
  end;
end;
//参数：人物名称 物品类型 绑定方法
procedure TPlayObject.CmdBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
  nItem, nBind: Integer;
  ItemBind: pTItemBind;
  nItemIdx, nMakeIdex: Integer;
  sBindName: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nBind := -1;
  nItem := GetUseItemIdx(sItem);
  if CompareText(sType, '帐号') = 0 then nBind := 0;
  if CompareText(sType, '人物') = 0 then nBind := 1;
  if CompareText(sType, 'IP') = 0 then nBind := 2;
  if CompareText(sType, '死亡') = 0 then nBind := 3;//死亡不爆出 20081127

  if (nItem < 0) or (nBind < 0) or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandBindUseItemHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  UserItem := @PlayObject.m_UseItems[nItem];
  if UserItem.wIndex = 0 then begin
    SysMsg(Format(g_sGameCommandBindUseItemNoItemMsg, [sHumanName, sItem]), c_Red, t_Hint);
    Exit;
  end;
  nItemIdx := UserItem.wIndex;
  nMakeIdex := UserItem.MakeIndex;
  case nBind of
    0: begin
        sBindName := PlayObject.m_sUserID;
        g_ItemBindAccount.Lock;
        try
          for I := 0 to g_ItemBindAccount.Count - 1 do begin
            ItemBind := g_ItemBindAccount.Items[I];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
              SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
              Exit;
            end;
          end;//for
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindAccount.Insert(0, ItemBind);
        finally
          g_ItemBindAccount.UnLock;
        end;
        SaveItemBindAccount();
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex, UserItem.MakeIndex, UserItem.Dura, UserItem.DuraMax, sBindName]), c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。',[GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex), sType, sBindName ]), c_Blue, t_Hint);
      end;
    1: begin
        sBindName := PlayObject.m_sCharName;
        g_ItemBindCharName.Lock;
        try
          for I := 0 to g_ItemBindCharName.Count - 1 do begin
            ItemBind := g_ItemBindCharName.Items[I];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
              SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
              Exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindCharName.Insert(0, ItemBind);
        finally
          g_ItemBindCharName.UnLock;
        end;
        SaveItemBindCharName();
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex, UserItem.MakeIndex, UserItem.Dura,
            UserItem.DuraMax, sBindName]), c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
            sType, sBindName ]), c_Blue, t_Hint);
      end;
    2: begin
        sBindName := PlayObject.m_sIPaddr;
        g_ItemBindIPaddr.Lock;
        try
          if g_ItemBindIPaddr.Count > 0 then begin//20080629
            for I := 0 to g_ItemBindIPaddr.Count - 1 do begin
              ItemBind := g_ItemBindIPaddr.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
                SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindIPaddr.Insert(0, ItemBind);
        finally
          g_ItemBindIPaddr.UnLock;
        end;
        SaveItemBindIPaddr();
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex, UserItem.MakeIndex, UserItem.Dura,
            UserItem.DuraMax, sBindName]), c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。', [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex), sType,sBindName ]), c_Blue, t_Hint);
      end;
    3:begin//人物装备死亡不爆绑定 20081127
        sBindName := PlayObject.m_sCharName;
        g_ItemBindDieNoDropName.Lock;
        try
          for I := 0 to g_ItemBindDieNoDropName.Count - 1 do begin
            ItemBind := g_ItemBindDieNoDropName.Items[I];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.sBindName = sBindName) then begin
              SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
              Exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := 0;
          ItemBind.sBindName := sBindName;
          g_ItemBindDieNoDropName.Insert(0, ItemBind);
        finally
          g_ItemBindDieNoDropName.UnLock;
        end;
        SaveItemBindDieNoDropName();//保存人物装备死亡不爆列表 20081127
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，死亡不爆绑定到%s成功。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex, UserItem.MakeIndex, UserItem.Dura,
            UserItem.DuraMax, sBindName]), c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
            sType, sBindName ]), c_Blue, t_Hint);    
      end;  
  end;
end;
//解物品绑定
procedure TPlayObject.CmdUnBindUseItem(Cmd: pTGameCmd; sHumanName, sItem,
  sType: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
  nItem, nBind: Integer;
  ItemBind: pTItemBind;
  nItemIdx, nMakeIdex: Integer;
  sBindName: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nBind := -1;
  nItem := GetUseItemIdx(sItem);
  if CompareText(sType, '帐号') = 0 then nBind := 0;
  if CompareText(sType, '人物') = 0 then nBind := 1;
  if CompareText(sType, 'IP') = 0 then nBind := 2;
  if CompareText(sType, '死亡') = 0 then nBind := 3;//死亡不爆出 20081127
  
  if (nItem < 0) or (nBind < 0) or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandBindUseItemHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  UserItem := @PlayObject.m_UseItems[nItem];
  if UserItem.wIndex = 0 then begin
    SysMsg(Format(g_sGameCommandBindUseItemNoItemMsg, [sHumanName, sItem]), c_Red, t_Hint);
    Exit;
  end;
  nItemIdx := UserItem.wIndex;
  nMakeIdex := UserItem.MakeIndex;
  case nBind of //
    0: begin
        sBindName := PlayObject.m_sUserID;
        g_ItemBindAccount.Lock;
        try
          if g_ItemBindAccount.Count > 0 then begin//20080629
            for I := 0 to g_ItemBindAccount.Count - 1 do begin
              ItemBind := g_ItemBindAccount.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
                SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindAccount.Insert(0, ItemBind);
        finally
          g_ItemBindAccount.UnLock;
        end;
        SaveItemBindAccount();
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    1: begin
        sBindName := PlayObject.m_sCharName;
        g_ItemBindCharName.Lock;
        try
          if g_ItemBindCharName.Count > 0 then begin//20080629
            for I := 0 to g_ItemBindCharName.Count - 1 do begin
              ItemBind := g_ItemBindCharName.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
                SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindCharName.Insert(0, ItemBind);
        finally
          g_ItemBindCharName.UnLock;
        end;
        SaveItemBindCharName();
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    2: begin
        sBindName := PlayObject.m_sIPaddr;
        g_ItemBindIPaddr.Lock;
        try
          if g_ItemBindIPaddr.Count > 0 then begin//20080629
            for I := 0 to g_ItemBindIPaddr.Count - 1 do begin
              ItemBind := g_ItemBindIPaddr.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
                SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindIPaddr.Insert(0, ItemBind);
        finally
          g_ItemBindIPaddr.UnLock;
        end;
        SaveItemBindIPaddr();
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    3:begin//人物装备死亡不爆绑定 20081127
        sBindName := PlayObject.m_sCharName;
        g_ItemBindDieNoDropName.Lock;
        try
          if g_ItemBindDieNoDropName.Count > 0 then begin
            for I := 0 to g_ItemBindDieNoDropName.Count - 1 do begin
              ItemBind := g_ItemBindDieNoDropName.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.sBindName = sBindName) then begin
                SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := 0;
          ItemBind.sBindName := sBindName;
          g_ItemBindDieNoDropName.Insert(0, ItemBind);
        finally
          g_ItemBindDieNoDropName.UnLock;
        end;
        SaveItemBindDieNoDropName();//保存人物装备死亡不爆列表 20081127
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex, UserItem.MakeIndex, UserItem.Dura, UserItem.DuraMax,
            sBindName]), c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。', [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex), sType, sBindName ]), c_Blue, t_Hint);
      end;  
  end;
end;

procedure TPlayObject.CmdShutup(Cmd: pTGameCmd; sHumanName, sTime: string);
var
  dwTime: LongWord;
  nIndex: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sTime = '') or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandShutupHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  dwTime := Str_ToInt(sTime, 5);
  g_DenySayMsgList.Lock;
  try
    nIndex := g_DenySayMsgList.GetIndex(sHumanName);
    if nIndex >= 0 then begin
      g_DenySayMsgList.Objects[nIndex] := TObject(GetTickCount + dwTime * 60000{60 * 1000});
    end else begin
      g_DenySayMsgList.AddRecord(sHumanName, GetTickCount + dwTime * 60000{60 * 1000});
    end;
  finally
    g_DenySayMsgList.UnLock;
  end;
  SysMsg(Format(g_sGameCommandShutupHumanMsg, [sHumanName, dwTime]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdShutupList(Cmd: pTGameCmd; sParam1: string);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;

  if (m_btPermission < 6) then Exit;
  g_DenySayMsgList.Lock;
  try
    if g_DenySayMsgList.Count <= 0 then begin
      SysMsg(g_sGameCommandShutupListIsNullMsg, c_Green, t_Hint);
      Exit;
    end;
    for I := 0 to g_DenySayMsgList.Count - 1 do begin
      SysMsg(g_DenySayMsgList.Strings[I] + ' ' + IntToStr((LongWord(g_DenySayMsgList.Objects[I]) - GetTickCount) div 60000), c_Green, t_Hint);
    end;
  finally
    g_DenySayMsgList.UnLock;
  end;
end;

procedure TPlayObject.CmdShutupRelease(Cmd: pTGameCmd; sHumanName: string; boAll: Boolean);
var
  I: Integer;
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandShutupReleaseHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  g_DenySayMsgList.Lock;
  try
    I := g_DenySayMsgList.GetIndex(sHumanName);
    if I >= 0 then begin
      g_DenySayMsgList.Delete(I);
      PlayObject := UserEngine.GetPlayObject(sHumanName);
      if PlayObject <> nil then begin
        PlayObject.SysMsg(g_sGameCommandShutupReleaseCanSendMsg, c_Red, t_Hint);
      end;
      if boAll then begin
        UserEngine.SendServerGroupMsg(SS_210, nServerIndex, sHumanName);
      end;
      SysMsg(Format(g_sGameCommandShutupReleaseHumanCanSendMsg, [sHumanName]), c_Green, t_Hint);
    end;
  finally
    g_DenySayMsgList.UnLock;
  end;
end;
//调整身上装备附加属性 参数16为吸伤属性  @SUPERMAKE
procedure TPlayObject.CmdSmakeItem(Cmd: pTGameCmd; nWhere, nValueType, nValue: Integer);
var
  sShowMsg: string;
  StdItem: pTStdItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;

  if (nWhere in [0..13]) and (nValueType in [0..16]) and (nValue in [0..255]) then begin//20080417 支持斗笠,0..12改0..13
    if m_UseItems[nWhere].wIndex > 0 then begin
      StdItem := UserEngine.GetStdItem(m_UseItems[nWhere].wIndex);
      if StdItem = nil then Exit;

      m_UseItems[nWhere].btValue[9] := _MIN(255, m_UseItems[nWhere].btValue[9] + 1);//累积升级次数 20080816
      if (nValueType = 16) and (StdItem.Shape = 188) then begin //吸伤属性 20080324
         m_UseItems[nWhere].btValue[20] := nValue;//吸伤属性
         if m_UseItems[nWhere].btValue[20] > 100 then m_UseItems[nWhere].btValue[20]:= 100;
      end else
      if (nValueType > 13) and (nValueType < 16) then begin
        nValue := _MIN(65, nValue);
        if nValueType = 14 then m_UseItems[nWhere].Dura := nValue * 1000;
        if nValueType = 15 then m_UseItems[nWhere].DuraMax := nValue * 1000;
      end else begin
        m_UseItems[nWhere].btValue[nValueType] := nValue;
      end;
      RecalcAbilitys();
      CompareSuitItem(False);//200080729 套装
      SendUpdateItem(@m_UseItems[nWhere]);
      if g_Config.boShowMakeItemMsg then begin//20080927 修改
        sShowMsg := IntToStr(m_UseItems[nWhere].wIndex) + '-' + IntToStr(m_UseItems[nWhere].MakeIndex) + ' ' +
          IntToStr(m_UseItems[nWhere].Dura) + '/' + IntToStr(m_UseItems[nWhere].DuraMax) + ' ' +
          IntToStr(m_UseItems[nWhere].btValue[0]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[1]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[2]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[3]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[4]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[5]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[6]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[7]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[8]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[9]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[10]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[11]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[12]) + '/'+
          IntToStr(m_UseItems[nWhere].btValue[13])+ '/'+
          IntToStr(m_UseItems[nWhere].btValue[20]);
        MainOutMessage('[物品调整] ' + m_sCharName + '(' + StdItem.Name + ' -> ' + sShowMsg + ')');
      end;
      //SysMsg(sShowMsg, c_Blue, t_Hint); //20080919 游戏里不提示
      //if g_Config.boShowMakeItemMsg then
      //  MainOutMessage('[物品调整] ' + m_sCharName + '(' + StdItem.Name + ' -> ' + sShowMsg + ')');
    end else begin
      SysMsg(g_sGamecommandSuperMakeHelpMsg, c_Red, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdSpirtStart(sCmd, sParam1: string);
var
  nTime: Integer;
  dwTime: LongWord;
begin
  if (m_btPermission < 6) then Exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then begin
    SysMsg('此命令用于开始祈祷生效宝宝叛变。', c_Red, t_Hint);
    Exit;
  end;
  nTime := Str_ToInt(sParam1, -1);
  if nTime > 0 then begin
    dwTime := LongWord(nTime) * 1000;
  end else begin
    dwTime := g_Config.dwSpiritMutinyTime;
  end;
  g_dwSpiritMutinyTick := GetTickCount + dwTime;
  SysMsg('祈祷叛变已开始。持续时长 ' + IntToStr(dwTime div 1000) + ' 秒。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdSpirtStop(sCmd, sParam1: string);
begin
  if (m_btPermission < 6) then Exit;
  if {(sParam1 <> '') and} (sParam1[1] = '?') then begin
    SysMsg('此命令用于停止祈祷生效导致宝宝叛变。', c_Red, t_Hint);
    Exit;
  end;
  g_dwSpiritMutinyTick := 0;
  SysMsg('祈祷叛变已停止。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdStartQuest(Cmd: pTGameCmd; sQuestName: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sQuestName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 问答名称', c_Red, t_Hint);
    Exit;
  end;
  UserEngine.SendQuestMsg(sQuestName);
end;

procedure TPlayObject.CmdSuperTing(Cmd: pTGameCmd; sHumanName, sRange: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  MoveHuman: TPlayObject;
  nRange: Integer;
  HumanList: TList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sRange = '') or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandSuperTingHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  nRange := _MAX(10, Str_ToInt(sRange, 2));
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    HumanList := TList.Create;
    UserEngine.GetMapRageHuman(PlayObject.m_PEnvir, PlayObject.m_nCurrX, PlayObject.m_nCurrY, nRange, HumanList);
    if  HumanList.Count > 0 then begin//20080629
      for I := 0 to HumanList.Count - 1 do begin
        MoveHuman := TPlayObject(HumanList.Items[I]);
        if MoveHuman <> Self then
          MoveHuman.MapRandomMove(MoveHuman.m_sHomeMap, 0);
      end;//for
    end;
    HumanList.Free;
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdTakeOffHorse(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('下马命令，在骑马状态输入此命令下马。', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s', [sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;
  if not m_boOnHorse then Exit;
  m_boOnHorse := False;
  FeatureChanged();
end;

procedure TPlayObject.CmdTakeOnHorse(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('上马命令，在戴好马牌后输入此命令就可以骑上马。', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s', [sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;
  if m_boOnHorse then Exit;
  if (m_btHorseType = 0) then begin
    SysMsg('骑马必须先戴上马牌！！！', c_Red, t_Hint);
    Exit;
  end;
  m_boOnHorse := True;
  FeatureChanged();
end;

procedure TPlayObject.CmdTestFire(sCmd: string; nRange, nType, nTime, nPoint: Integer);
var
  nX, nY: Integer;
  FireBurnEvent: TFireBurnEvent;
  nMinX, nMaxX, nMinY, nMaxY: Integer;
begin
  nMinX := m_nCurrX - nRange;
  nMaxX := m_nCurrX + nRange;
  nMinY := m_nCurrY - nRange;
  nMaxY := m_nCurrY + nRange;
  for nX := nMinX to nMaxX do begin
    for nY := nMinY to nMaxY do begin
      if ((nX < nMaxX) and (nY = nMinY)) or
        ((nY < nMaxY) and (nX = nMinX)) or
        (nX = nMaxX) or (nY = nMaxY) then begin
        FireBurnEvent := TFireBurnEvent.Create(Self, nX, nY, nType, nTime * 1000, nPoint);
        g_EventManager.AddEvent(FireBurnEvent);
      end;
    end;
  end;
end;

procedure TPlayObject.CmdTestGetBagItems(Cmd: pTGameCmd; sParam: string);
var
  btDc, btSc, btMc, btDura: Byte;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam <> '') and (sParam[1] = '?') then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandTestGetBagItemsHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  btDc := 0;
  btSc := 0;
  btMc := 0;
  btDura := 0;
  GetBagUseItems(btDc, btSc, btMc, btDura);
  SysMsg(Format('DC:%d SC:%d MC:%d DURA:%d', [btDc, btSc, btMc, btDura]), c_Blue, t_Hint);
end;

procedure TPlayObject.CmdTestSpeedMode(Cmd: pTGameCmd);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  m_boTestSpeedMode := not m_boTestSpeedMode;
  if m_boTestSpeedMode then begin
    SysMsg('开启速度测试模式', c_Red, t_Hint);
  end else begin
    SysMsg('关闭速度测试模式', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdTestStatus(sCmd: string; nType, nTime: Integer);
begin
  if (m_btPermission < 6) then Exit;
  if (not (nType in [Low(TStatusTime)..High(TStatusTime)])) or (nTime < 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 类型(0..11) 时长', c_Red, t_Hint);
    Exit;
  end;
  m_wStatusTimeArr[nType] := nTime * 1000;
  m_dwStatusArrTick[nType] := GetTickCount();
  m_nCharStatus := GetCharStatus();
  StatusChanged('');
  SysMsg(Format('状态编号:%d 时间长度: %d 秒', [nType, nTime]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdTing(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandTingHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    PlayObject.MapRandomMove(m_sHomeMap, 0);
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

{procedure TPlayObject.CmdTraining(sSkillName: string; nLevel: Integer); //004CC414
begin
  if (m_btPermission < 6) then Exit;
end; }

procedure TPlayObject.CmdUserMoveXY(sCmd, sX, sY: string);
var
  nX, nY: Integer;
begin
  if m_boTeleport then begin //传送戒指
    nX := Str_ToInt(sX, -1);
    nY := Str_ToInt(sY, -1);
    
    {if (nX < 0) or (nY < 0) then begin
      SysMsg('命令格式: @' + sCMD + ' 座标X 座标Y',c_Red,t_Hint);
      exit;
    end; }
    
    if not m_PEnvir.m_boNOPOSITIONMOVE then begin
      if m_PEnvir.CanWalkOfItem(nX, nY, g_Config.boUserMoveCanDupObj, g_Config.boUserMoveCanOnItem) then begin
        if (GetTickCount - m_dwTeleportTick) > g_Config.dwUserMoveTime * 1000 {10000} then begin
          m_dwTeleportTick := GetTickCount();
          if (m_UseItems[U_BUJUK].wIndex > 0) and (m_UseItems[U_BUJUK].Dura > 0) then begin //增加传送符功能
            if m_UseItems[U_BUJUK].Dura > 100 then begin
              Dec(m_UseItems[U_BUJUK].Dura, 100);
            end else begin
              SendDelItems(@m_UseItems[U_BUJUK]); //如果使用完，则删除物品 20081005
              m_UseItems[U_BUJUK].Dura := 0;
              m_UseItems[U_BUJUK].wIndex := 0;//20081005
            end;
            SendMsg(Self, RM_DURACHANGE, U_BUJUK, m_UseItems[U_BUJUK].Dura, m_UseItems[U_BUJUK].DuraMax, 0, '');
            SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
            if (nX < 0) or (nY < 0) then begin
              RandomMove;
            end else begin
              SpaceMove(m_sMapName, nX, nY, 0);
            end;
            Exit;
          end;
          SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
          if (nX < 0) or (nY < 0) then begin
            RandomMove;
          end else begin
            SpaceMove(m_sMapName, nX, nY, 0);
          end;
        end else begin
          SysMsg(IntToStr(g_Config.dwUserMoveTime - (GetTickCount - m_dwTeleportTick) div 1000) + '秒之后才可以再使用此功能！！！', c_Red, t_Hint);
        end;
      end else begin
        SysMsg(Format(g_sGameCommandPositionMoveCanotMoveToMap, [m_sMapName, sX, sY]), c_Green, t_Hint);
      end;
    end else begin
      SysMsg('此地图禁止使用此命令！！！', c_Red, t_Hint);
    end;
  end else begin
    SysMsg('您现在还无法使用此功能！！！', c_Red, t_Hint);
  end;
end;
{//未使用 20080823
procedure TPlayObject.CmdViewDiary(sCmd: string; nFlag: Integer);
begin

end;}

procedure TPlayObject.CmdViewWhisper(Cmd: pTGameCmd; sCharName, sParam2: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sCharName = '') or ((sCharName <> '') and (sCharName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandViewWhisperHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sCharName);
  if PlayObject <> nil then begin
    if PlayObject.m_GetWhisperHuman = Self then begin
      PlayObject.m_GetWhisperHuman := nil;
      SysMsg(Format(g_sGameCommandViewWhisperMsg1, [sCharName]), c_Green, t_Hint);
    end else begin
      PlayObject.m_GetWhisperHuman := Self;
      SysMsg(Format(g_sGameCommandViewWhisperMsg2, [sCharName]), c_Green, t_Hint);
    end;
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sCharName]), c_Red, t_Hint);
  end;
end;

constructor TPlayObject.Create;
begin
  inherited;
  m_btRaceServer := RC_PLAYOBJECT;
  m_boEmergencyClose := False;
  m_boSwitchData := False;
  m_boReconnection := False;
  m_boKickFlag := False;
  m_boSoftClose := False;
  m_boReadyRun := False;
  m_dwSaveRcdTick := GetTickCount();
  m_boWantRefMsg := True;
  m_boRcdSaved := False;
  m_boDieInFight3Zone := False;
  m_Script := nil;
  m_boTimeRecall := False;
  m_sMoveMap := '';
  m_nMoveX := 0;
  m_nMoveY := 0;
  m_sLastMapName := ''; //人物死亡地图
  m_nLastCurrX := 0; //人物死亡地图所在座标X
  m_nLastCurrY := 0; //人物死亡地图所在座标Y

  m_boDealing := False;
  m_DealCreat := nil;

  m_GroupOwner := nil;
  m_GroupMembers := TStringList.Create;
  m_boHearWhisper := True;
  m_boBanShout := True;
  m_boBanGmMsg := True; //允许接收所有喊话 20080211
  m_boBanGuildChat := True;
  m_boAllowDeal := True;
  m_boAllowGroupReCall := False;
  m_BlockWhisperList := TStringList.Create;
  m_wGroupRcallTime := 0;
  m_dwGroupRcallTick := GetTickCount();

  m_SellOffItemList := TList.Create;//元宝寄售物品列表 20080316
  m_RefineItemList:= TList.Create;//粹练物品列表 20080502
  m_DealItemList := TList.Create;
  m_nDealGolds := 0;
  m_StorageItemList := TList.Create;
  m_boAllowGroup := False;
  m_boAllowGuild := False;
  m_dwShoutMsgTick := 0;

  m_dwRunTick := GetTickCount();
  m_nRunTime := 250;
  m_dwSearchTime := 1000;
  m_dwSearchTick := GetTickCount();
  m_nViewRange := 12;
  m_boNewHuman := False;
  m_boLoginNoticeOK := False;
  bo6AB := False;
  m_boExpire := False;
  m_boSendNotice := False;
  m_dwCheckDupObjTick := GetTickCount();
  dwTick578 := GetTickCount();
  dwTick57C := GetTickCount();
  m_boInSafeArea := False;
  m_dwMagicAttackTick := GetTickCount();
  m_dwMagicAttackInterval := 0;
  m_dwAttackTick := GetTickCount();
  m_dwMoveTick := GetTickCount();
  m_dwTurnTick := GetTickCount();
  m_dwActionTick := GetTickCount();
  m_dwAttackCount := 0;
  m_dwAttackCountA := 0;
  m_dwMagicAttackCount := 0;
  m_dwMoveCount := 0;
  m_dwMoveCountA := 0;
  m_nOverSpeedCount := 0;

  //m_sOldSayMsg := '';//未使用 20080329
  m_dwSayMsgTick := GetTickCount();
  m_boDisableSayMsg := False;
  m_dwDisableSayMsgTick := GetTickCount();
  m_dLogonTime := Now();
  m_dwLogonTick := GetTickCount();
  m_boSwitchData := False;
  m_boSwitchDataSended := False;
  m_nWriteChgDataErrCount := 0;
  m_dwShowLineNoticeTick := GetTickCount();
  m_nShowLineNoticeIdx := 0;
  m_nSoftVersionDateEx := 0;
  m_CanJmpScriptLableList := TStringList.Create;
  m_nKillMonExpRate := 100;
  m_nOldKillMonExpRate := m_nKillMonExpRate;//20080607
  m_nItmeIncMonExpRate:= 0;//使用套装增加的经验 20080607
  m_dwRateTick := GetTickCount();
  m_nPowerRate := 100;
  m_boSetStoragePwd := False;
  m_boReConfigPwd := False;
  m_boCheckOldPwd := False;
  m_boUnLockPwd := False;
  m_boUnLockStoragePwd := False;
  m_boPasswordLocked := False; //锁仓库
  m_btPwdFailCount := 0;
  m_sTempPwd := '';
  m_sStoragePwd := ''; ;
  m_boFilterSendMsg := False;
  m_boCanDeal := True;
  m_boCanDrop := True;
  m_boCanGetBackItem := True;
  m_boCanWalk := True;
  m_boCanRun := True;
  m_boCanHit := True;
  m_boCanSpell := True;
  m_boCanUseItem := True;
  m_nMemberType := 0;
  m_nMemberLevel := 0;

  m_nGameGold := 0;
  m_nGameDiaMond := 0;//20071226 金刚石
  m_nGameGird := 0;//20071226 灵符

  m_boDecGameGold := False;
  m_nDecGameGold := 1;
  m_dwDecGameGoldTick := GetTickCount();
  m_dwDecGameGoldTime := 60000{60 * 1000};

  m_boIncGameGold := False;
  m_nIncGameGold := 1;
  m_dwIncGameGoldTick := GetTickCount();
  m_dwIncGameGoldTime := 60000{60 * 1000};

  m_nGamePoint := 0;
  m_dwIncGamePointTick := GetTickCount();
  m_dwDecGamePointTick := GetTickCount();//20080413

  m_nPayMentPoint := 0;

  m_DearHuman := nil;
  m_MasterHuman := nil;
  m_MasterList := TList.Create;
  m_boSendMsgFlag := False;
  m_boChangeItemNameFlag := False;

  m_boCanMasterRecall := False;
  m_boCanDearRecall := False;
  m_dwDearRecallTick := GetTickCount();
  m_dwMasterRecallTick := GetTickCount();
  m_btReColorIdx := 0;
  m_GetWhisperHuman := nil;
  m_boOnHorse := False;
  m_wContribution := 0;
  m_sRankLevelName := g_sRankLevelName;
  m_boFixedHideMode := True;
  m_nStep := 0;
  FillChar(m_nMval, SizeOf(m_nMval), #0);
  m_nClientFlagMode := -1;
  m_dwAutoGetExpTick := GetTickCount;
  m_nAutoGetExpPoint := 0;
  m_AutoGetExpEnvir := nil;
  //m_dwHitIntervalTime := g_Config.dwHitIntervalTime; //攻击间隔  20080826 未使用
  m_dwMagicHitIntervalTime := g_Config.dwMagicHitIntervalTime; //魔法间隔
  m_dwRunIntervalTime := g_Config.dwRunIntervalTime; //跑间隔
  m_dwWalkIntervalTime := g_Config.dwWalkIntervalTime; //走路间隔
  m_dwTurnIntervalTime := g_Config.dwTurnIntervalTime; //换方向间隔
  m_dwActionIntervalTime := g_Config.dwActionIntervalTime; //组合操作间隔
  m_dwRunLongHitIntervalTime := g_Config.dwRunLongHitIntervalTime; //组合操作间隔
  m_dwRunHitIntervalTime := g_Config.dwRunHitIntervalTime; //组合操作间隔
  m_dwWalkHitIntervalTime := g_Config.dwWalkHitIntervalTime; //组合操作间隔
  m_dwRunMagicIntervalTime := g_Config.dwRunMagicIntervalTime; //跑位魔法间隔
  m_DynamicVarList := TList.Create;
  m_boTestSpeedMode := False;
  m_boLockLogon := True;
  m_boLockLogoned := False;

  m_boRemoteMsg := False; //是否允许接受消息

  m_boNotOnlineAddExp := False; //是否是离线挂机人物
  m_boStartAutoAddExpPoint := False; //是否开始增加经验
  m_dwStartNotOnlineAddExpTime := 0; //离线挂机开始时间
  m_dwNotOnlineAddExpTime := 0; //离线挂机时长
  m_nNotOnlineAddExpPoint := 0; //离线挂机每分钟增加经验值
  m_dwAutoAddExpPointTick := GetTickCount;
  m_dwAutoAddExpPointTimeTick := GetTickCount;
  m_sAutoSendMsg := '您好，我正在离线泡点中......'; //自动回复信息
  m_boKickAutoAddExpUser := False;
  m_boTimeGoto := False;
  m_dwTimeGotoTick := GetTickCount;
  m_sTimeGotoLable := '';
  m_TimeGotoNPC := nil;
  m_nBigStoragePage := 0; //无限仓库的当前页数
  m_nDealGoldPose := 0;
  m_boPlayOffLine := True; //是否允许下线触发
  m_dwDedingUseTick := 0;
  m_nCopyHumanLevel := 0;
  m_boAllowReAlive := False; //是否允许复活
  //m_nShowMessagePosition := 0;//未使用 20080329

  m_boRunPlayRobotManage := True; //是否运行个人机器人
  m_PlayRobotManage := TPlayRobotManage.Create; //人物个人机器人
  m_PlayRobotManage.PlayObject := Self;

  FillChar(m_nInteger, SizeOf(m_nInteger), #0);
  FillChar(m_sString, SizeOf(m_sString), #0);

  m_wMasterCount := 0; //徒弟数
  m_PlayOrderList := TStringList.Create; //人物排行
  m_nSelPlayOrderType := 0; //选择排行类型
  m_nPlayOrderPage := 0; //选择人物排行页数
  m_boGetMyLevelOrder := False;

  m_BigStorageItemList := nil; //无限仓库

  m_btHearMsgFColor := $00; //喊话字体颜色
  m_btWhisperMsgFColor := $FC; //私聊字体颜色

  m_MyHero := nil; //我的英雄
  m_boHasHero := False;
  m_boHasHeroTwo := False;
  m_sHeroCharName := '';
  m_sTempHeroCharName := '';//20080524
  m_boWaitHeroDate := False;
  m_boCallHero:= True;//是否可以召唤英雄 20080124
  n_HeroSave := 0;//是否保存英雄 20080513
  m_boPlayDrink:= False;//是否请过酒 T-请过酒 20080515
  n_DrinkValue[0]:=0;//喝酒的醉酒值 0-NPC 1-玩家 20080517
  n_DrinkValue[1]:=0;
  n_DrinkCount:= 0;//喝酒的次数(斗酒一次最高6次) 20080517
  m_boMakeWine:= False;//是否酿酒 20080620
  m_MakeWineTime:= 0;//酿酒的时间,即还有多长时间可以取回酒 20080620
  n_MakeWineItmeType:= 0;//酿酒后,应该可以得到酒的类型 2008020
  n_MakeWineQuality:= 0;//酿酒后,应该可以得到酒的品质 20080620
  n_MakeWineAlcohol:= 0;//酿酒后,应该可以得到酒的酒精度 20080620
  n_MakeWineType:= 0;//酿酒的类型 1-普通酒 2-药酒  20080620
  m_dwAddAlcoholTick:= GetTickCount;//增加酒量进度的间隔  20080623
  m_dwDecWineDrinkValueTick:= GetTickCount;//减少醉酒度的间隔  20080623
  n_DrinkWineQuality:= 0;//饮酒时酒的品质 20080623
  n_DrinkWineAlcohol:= 0;//饮酒时酒的度数 20080624
  n_DrinkWineDrunk:= False;//喝酒醉了 20080623
  n_InFountainTime:= 0;//站在泉水眼的时间 20080624
  dw_UseMedicineTime:= 0; //使用药酒时间,计算长时间没使用药酒 20080623
  n_MedicineLevel:= 0;  //药力值等级 20080623
  m_GiveGuildFountationDate:= 0;//取行会泉水日期
  m_Exp68:= 0;//酒气护体当前经验 20080625
  m_MaxExp68:= 0;//酒气护体升级经验 20080625
  bo_NPCMove:= False;//是否点击,让NPC走动 20080704

  n_LevelOrder := 0;//玩家当前等级排名 20080214
  m_Boxs:= TList.Create ;//随机选取的宝箱物品 20080116

  m_boOpenBox:=False;//是否宝箱在打开 20080407

  m_sScriptLable := '';//20080521 从父类移动人物类中
  FillChar(m_dwUserTick, SizeOf(m_dwUserTick), #0);//20080521 从父类移动人物类中
  //m_bo43DragonPoint:=False;//黄条气值相关 20080201   20080619 注释
  m_dwSayMyInfoTick := GetTickCount;

  m_nMasterNo:= 0; //徒弟排名 20080530
  m_MasterNoList:= TStringList.Create;//徒弟排名列表 20080530

  m_boChallengeing:= False; //是否在挑战中 20080705
  m_ChallengeCreat:= nil;//挑战对像 20080705
  m_ChallengeItemList:= TList.Create; //挑战物品列表 20080705
  m_nChallengeGolds:= 0; //挑战的金币数量 20080705
  m_nChallengeGAMEDIAMOND:= 0;//挑战的金刚石 20080705

  m_boAddToMaped := False;//地图是否计数 20080830
  m_boCanQueryBag:= False;//是否可以刷新包裹 20080907
  m_boCanQueryShopItme:= False;//是否可以刷新商铺 20080907
  m_boHeroLogOut:= False;//英雄退出 20080909

  m_boTrainingNG := False;//是否学习过内功 20081002
  m_NGLevel := 1;//内功等级 20081002
  m_ExpSkill69:= 0;//内功心法当前经验 20080930
  m_MaxExpSkill69:= 0;//内功心法升级经验 20080930
  m_Skill69NH:= 0;//当前内力值 20080930
  m_Skill69MaxNH:= 0;//最大内力值 20080930
  m_dwIncNHTick:= GetTickCount;//增加内力值计时 20081002

  m_MagicSkill_200:= nil;//怒之攻杀
  m_MagicSkill_201:= nil;//静之攻杀
  m_MagicSkill_202:= nil;//怒之半月
  m_MagicSkill_203:= nil;//静之半月
  m_MagicSkill_204:= nil;//怒之烈火
  m_MagicSkill_205:= nil;//静之烈火
  m_MagicSkill_206:= nil;//怒之逐日
  m_MagicSkill_207:= nil;//静之逐日
  m_MagicSkill_208:= nil;//怒之火球
  m_MagicSkill_209:= nil;//静之火球
  m_MagicSkill_210:= nil;//怒之大火球
  m_MagicSkill_211:= nil;//静之大火球
  m_MagicSkill_212:= nil;//怒之火墙
  m_MagicSkill_213:= nil;//静之火墙
  m_MagicSkill_214:= nil;//怒之地狱火
  m_MagicSkill_215:= nil;//静之地狱火
  m_MagicSkill_216:= nil;//怒之疾光电影
  m_MagicSkill_217:= nil;//静之疾光电影
  m_MagicSkill_218:= nil;//怒之爆裂火焰
  m_MagicSkill_219:= nil;//静之爆裂火焰
  m_MagicSkill_220:= nil;//怒之冰咆哮
  m_MagicSkill_221:= nil;//静之冰咆哮
  m_MagicSkill_222:= nil;//怒之雷电
  m_MagicSkill_223:= nil;//静之雷电
  m_MagicSkill_224:= nil;//怒之地狱雷光
  m_MagicSkill_225:= nil;//静之地狱雷光
  m_MagicSkill_226:= nil;//怒之寒冰掌
  m_MagicSkill_227:= nil;//静之寒冰掌
  m_MagicSkill_228:= nil;//怒之灭天火
  m_MagicSkill_229:= nil;//静之灭天火
  m_MagicSkill_230:= nil;//怒之火符
  m_MagicSkill_231:= nil;//静之火符
  m_MagicSkill_232:= nil;//怒之噬血
  m_MagicSkill_233:= nil;//静之噬血
  m_MagicSkill_234:= nil;//怒之流星火雨
  m_MagicSkill_235:= nil;//静之流星火雨
  m_MagicSkill_236:= nil;//怒之内功剑法
  m_MagicSkill_237:= nil;//静之内功剑法

  FillChar(m_TagMapInfos, SizeOf(m_TagMapInfos), #0);//人物记路标石 20081019
  m_GetExp:= 0;//人物取得的经验,$GetExp变量使用
end;
//元宝寄售取消出售 20080316
procedure TPlayObject.SellOffCancel;
begin
  SendMsg(Self,RM_SELLOFFCANCEL,0, 0, 0, 0, '');
  GetBackSellOffItems();
end;
//交易取消
procedure TPlayObject.DealCancel;
begin
  if not m_boDealing then Exit;
  m_boDealing := False;
  SendDefMessage(SM_DEALCANCEL, 0, 0, 0, 0, '');
  if m_DealCreat <> nil then begin
    m_DealCreat.DealCancel;
  end;
  m_DealCreat := nil;
  GetBackDealItems();
  SysMsg(g_sDealActionCancelMsg {'交易取消'}, c_Green, t_Hint);
  m_DealLastTick := GetTickCount();
end;

procedure TPlayObject.DealCancelA;
begin
  m_Abil.HP := m_WAbil.HP;
  DealCancel();
end;

function TPlayObject.DecGold(nGold: Integer): Boolean;
begin
  Result := False;
  if m_nGold >= nGold then begin
    Dec(m_nGold, nGold);
    Result := True;
  end;
end;

procedure TPlayObject.DecGameGold(nGameGold: Integer);
begin
  if m_nGameGold >= nGameGold then begin
    Dec(m_nGameGold, nGameGold);
  end else m_nGameGold := 0;
end;
//减游戏点
procedure TPlayObject.DecGamePoint(nGamePoint: Integer);
begin
  if m_nGamePoint >= nGamePoint then begin
    Dec(m_nGamePoint, nGamePoint);
  end else m_nGamePoint := 0;
end;

destructor TPlayObject.Destroy;
var
  I: Integer;
begin
  if m_SellOffItemList <> nil then begin
    if m_SellOffItemList.Count > 0 then begin
      for I := 0 to m_SellOffItemList.Count - 1 do begin //元宝寄售物品列表 20080316
        if pTUserItem(m_SellOffItemList.Items[I]) <> nil then
          Dispose(pTUserItem(m_SellOffItemList.Items[I]));
      end;
    end;
    FreeAndNil(m_SellOffItemList);
  end;

  if m_RefineItemList <> nil then begin
    if m_RefineItemList.Count > 0 then begin
      for I := 0 to m_RefineItemList.Count - 1 do begin //粹练物品列表 20080502
        if pTUserItem(m_RefineItemList.Items[I]) <> nil then
          Dispose(pTUserItem(m_RefineItemList.Items[I]));
      end;
    end;
    FreeAndNil(m_RefineItemList);
  end;

  if m_DealItemList <> nil then begin
    if m_DealItemList.Count > 0 then begin
      for I := 0 to m_DealItemList.Count - 1 do begin
        if pTUserItem(m_DealItemList.Items[I]) <> nil then
          Dispose(pTUserItem(m_DealItemList.Items[I]));
      end;
    end;
    FreeAndNil(m_DealItemList);
  end;

  if m_ChallengeItemList <> nil then begin//挑战物品列表 20080705
    if m_ChallengeItemList.Count > 0 then begin
      for I := 0 to m_ChallengeItemList.Count - 1 do begin
        if pTUserItem(m_ChallengeItemList.Items[I]) <> nil then
          Dispose(pTUserItem(m_ChallengeItemList.Items[I]));
      end;
    end;
    FreeAndNil(m_ChallengeItemList);
  end;

  if m_StorageItemList <> nil then begin
    if m_StorageItemList.Count > 0 then begin
      for I := 0 to m_StorageItemList.Count - 1 do begin
        if pTUserItem(m_StorageItemList.Items[I]) <> nil then
          Dispose(pTUserItem(m_StorageItemList.Items[I]));
      end;
    end;
    FreeAndNil(m_StorageItemList);
  end;

  if m_GroupMembers <> nil then FreeAndNil(m_GroupMembers);
  if m_BlockWhisperList <> nil then FreeAndNil(m_BlockWhisperList);
  if m_MasterList <> nil then FreeAndNil(m_MasterList);
  if m_Boxs <> nil then FreeAndNil(m_Boxs); //随机选取宝箱的物品 20080116

  if m_DynamicVarList <> nil then begin
    if m_DynamicVarList.Count > 0 then begin
      for I := 0 to m_DynamicVarList.Count - 1 do begin
        if pTDynamicVar(m_DynamicVarList.Items[I]) <> nil then
          Dispose(pTDynamicVar(m_DynamicVarList.Items[I]));
      end;
    end;
    FreeAndNil(m_DynamicVarList);
  end;

  if m_CanJmpScriptLableList <> nil then FreeAndNil(m_CanJmpScriptLableList);
  if m_PlayRobotManage <> nil then m_PlayRobotManage.Free;
  if m_PlayOrderList <> nil then m_PlayOrderList.Free;

  if m_MasterNoList <> nil then begin
    if m_MasterNoList.Count > 0 then begin
      for I := 0 to m_MasterNoList.Count - 1 do begin //20080530
        if PTMasterList(m_MasterNoList.Objects[I]) <> nil then
          Dispose(PTMasterList(m_MasterNoList.Objects[I]));
      end;
    end;
    m_MasterNoList.Free;//徒弟排名列表 20080530
  end;

 { if Assigned(zPlugOfEngine.PlayObjectDestroy) then begin//20080813 注释
    zPlugOfEngine.PlayObjectDestroy(Self);
  end;}
  inherited;
end;

procedure TPlayObject.Disappear;
begin
  if m_boReadyRun then DisappearA;
  if m_boTransparent and m_boHideMode then m_wStatusTimeArr[STATE_TRANSPARENT] := 0;

  if m_GroupOwner <> nil then begin
    m_GroupOwner.DelMember(Self);
  end;
  if m_MyGuild <> nil then begin
    TGUild(m_MyGuild).DelHumanObj(Self);
  end;
  LogonTimcCost();
  inherited;
end;
//人物掉落装备物品 20080227
procedure TPlayObject.DropUseItems(BaseObject: TBaseObject);
var
  I: Integer;
  nRate: Integer;
  StdItem: pTStdItem;
  DelList: TStringList;
  nCode: Byte;
resourcestring
  sExceptionMsg = '{异常} TPlayObject::DropUseItems Code:';
begin
  nCode:= 0;
  DelList := nil;
  m_boCanQueryBag:= True;//掉落装备物品时,不能刷新包裹 20080917
  Try
    try
      if m_PEnvir.m_boNODROPITEM then Exit;//地图禁止死亡掉物品则退出 20080503
      nCode:= 1;
      if m_boAngryRing or m_boNoDropUseItem then Exit;
      nCode:= 2;
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin
        nCode:= 3;
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        nCode:= 4;
        if StdItem <> nil then begin
          nCode:= 5;
          if CheckItemValue(@m_UseItems[I],5) then Continue;//20080314 禁止爆出
          if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Continue;//禁止物品规则(永不爆出) 20080729
          if CheckItemBindDieNoDrop(@m_UseItems[I]) then Continue;//人物装备绑定死亡不爆 20081127

          nCode:= 7;
          if StdItem.Reserved and 8 <> 0 then begin
            nCode:= 8;
            if DelList = nil then DelList := TStringList.Create;
            nCode:= 9;
            //DelList.AddObject('', TObject(m_UseItems[I].MakeIndex));//20080803 替换
            if m_UseItems[I].wIndex > 0 then//20080817 增加
              DelList.AddObject(UserEngine.GetStdItemName(m_UseItems[I].wIndex), TObject(m_UseItems[I].MakeIndex));
            nCode:= 18;
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('16' + #9 +
                m_sMapName+'('+IntToStr(m_btRaceServer)+')'+ #9 +
                IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 + StdItem.Name + #9 +
                IntToStr(m_UseItems[I].MakeIndex) + #9 +
                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                IntToStr(m_UseItems[I].btValue[0])+'/'+IntToStr(m_UseItems[I].btValue[1])+'/'+IntToStr(m_UseItems[I].btValue[2])+'/'+
                IntToStr(m_UseItems[I].btValue[3])+'/'+IntToStr(m_UseItems[I].btValue[4])+'/'+IntToStr(m_UseItems[I].btValue[5])+'/'+
                IntToStr(m_UseItems[I].btValue[6])+'/'+IntToStr(m_UseItems[I].btValue[7])+'/'+IntToStr(m_UseItems[I].btValue[8])+'/'+
                IntToStr(m_UseItems[I].btValue[14])+ #9 +'0');
            nCode:= 19;
            if StdItem.Shape in [126..129] then begin //祈祷装备,被怪(不是宝宝)打死,装备才消失,其它打死不消失 20080403
              nCode:= 20;
              if m_LastHiter <> nil then begin//20080727 增加
                nCode:= 21;
                if (m_LastHiter.m_btRaceServer <> RC_PLAYOBJECT) and (m_LastHiter.m_Master =nil) then
                  m_UseItems[I].wIndex := 0
                else Continue;
              end;
            end else
            m_UseItems[I].wIndex := 0;
          end;
        end;
      end;
      nCode:= 10;
      if PKLevel > 2 then nRate := g_Config.nDieRedDropUseItemRate {15}
      else nRate := g_Config.nDieDropUseItemRate {30};
      nCode:= 11;
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin
        nCode:= 12;
        if Random(nRate) <> 0 then Continue;
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        nCode:= 13;
        if InDisableTakeOffList(m_UseItems[I].wIndex) then Continue; //检查是否在禁止取下列表,如果在列表中则不掉此物品
        if CheckItemValue(@m_UseItems[I],5) then Continue;//20080314 禁止爆出
        if StdItem <> nil then
          if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Continue;//禁止物品规则(永不爆出) 20080729
        if CheckItemBindDieNoDrop(@m_UseItems[I]) then Continue;//人物装备绑定死亡不爆 20081127

        nCode:= 15;
        if DropItemDown(@m_UseItems[I], 3, True, True, BaseObject, Self) then begin//爆出装备
          nCode:= 16;
          if StdItem <> nil then begin
            if StdItem.Reserved and 10 = 0 then begin
              if m_btRaceServer = RC_PLAYOBJECT then begin
                nCode:= 17;
                //if StdItem.Reserved = 10 then Continue; //增加不允许掉落装备
                if DelList = nil then DelList := TStringList.Create;
                DelList.AddObject(UserEngine.GetStdItemName(m_UseItems[I].wIndex), TObject(m_UseItems[I].MakeIndex));
              end;
              m_UseItems[I].wIndex := 0;
            end;
          end;
        end;
      end;
      if DelList <> nil then
        SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
    except
      MainOutMessage(sExceptionMsg + inttostr(nCode));
    end;
  finally
    m_boCanQueryBag:= False;//掉落装备物品时,不能刷新包裹 20080917
  end;
end;
//nCode 1-内功怪
procedure TPlayObject.GainExp(dwExp: LongWord; nCode:Byte);
var
  I, n, sumlv, nExp, nHighLevel, nLowLevel: Integer;
  PlayObject: TPlayObject;
  nCheckCode: Integer;
resourcestring
  sExceptionMsg = '{异常} TPlayObject::GainExp Code:';
const
  bonus: array[0..GROUPMAX] of real = (1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2, 2.1, 2.2);
begin
  nCheckCode := 0;
  if self = nil then Exit;//20080803 增加
  try
    nHighLevel := 0;
    nLowLevel := High(Word);
    if dwExp > 0 then begin
      nCheckCode := 8;
      if (m_GroupOwner <> nil) then begin//20090101
        if (m_GroupOwner.m_GroupMembers <> nil) then begin//20090101
          if (m_GroupOwner.m_GroupMembers.Count > 0) then begin
            sumlv := 0;
            n := 0;
            nCheckCode := 1;
            if m_GroupOwner.m_GroupMembers.Count > 0 then begin//20080629
              for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
                PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[I]);
                if PlayObject <> nil then begin
                  if not PlayObject.m_boDeath and (m_PEnvir = PlayObject.m_PEnvir) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) then begin
                    sumlv := sumlv + PlayObject.m_Abil.Level;
                    if PlayObject.m_Abil.Level > nHighLevel then nHighLevel := PlayObject.m_Abil.Level;
                    if PlayObject.m_Abil.Level < nLowLevel then nLowLevel := PlayObject.m_Abil.Level;
                    Inc(n);
                  end;
                end;
              end;//for
            end;
            nCheckCode := 2;
            if (sumlv > 0) and (n > 1) then begin
              if n in [0..GROUPMAX] then dwExp := Round(dwExp * bonus[n]);
              nCheckCode := 3;
              if m_GroupOwner.m_GroupMembers.Count > 0 then begin//20080629
                for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
                  PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[I]);
                  if PlayObject <> nil then begin
                    if not PlayObject.m_boDeath and (m_PEnvir = PlayObject.m_PEnvir) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) then begin
                      if g_Config.boHighLevelKillMonFixExp and g_Config.boHighLevelGroupFixExp then begin //02/08 增加，在高等级经验不变时，把组队的经验平均分配
                        nCheckCode := 4;
                        PlayObject.WinExp(Round(dwExp / n));
                        nCheckCode := 5;
                        if nCode = 1 then PlayObject.GetNGExp(Round(dwExp / n), 0);//取得内力经验 20081224
                      end else
                        if g_Config.boHighLevelGroupFixExp then begin
                        nCheckCode := 6;
                        PlayObject.WinExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level));
                        nCheckCode := 7;
                        if nCode = 1 then PlayObject.GetNGExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level), 0);//取得内力经验 20081224
                      end else
                        if m_Abil.Level > (nLowLevel + 10) then begin //大号杀怪组里人经验不变
                        PlayObject.WinExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level));
                        if nCode = 1 then PlayObject.GetNGExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level), 0);//取得内力经验 20081224
                      end else
                        if m_Abil.Level <= (nLowLevel + 10) then begin
                        if PlayObject.m_Abil.Level > (nLowLevel + 10) then begin //小号杀怪经验组里人大号经验改变
                          nExp := Round(dwExp / PlayObject.m_Abil.Level);
                          if nExp <= 0 then nExp := 1;
                          PlayObject.WinExp(nExp);
                          if nCode = 1 then PlayObject.GetNGExp(nExp, 0);//取得内力经验 20081224
                        end else begin
                          PlayObject.WinExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level)); //小号杀怪经验组里人小号经验不变
                          if nCode = 1 then PlayObject.GetNGExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level), 0);//取得内力经验 20081224
                        end;
                      end;
                    end;
                  end;
                end;//for
              end;
            end else begin
              WinExp(dwExp);
              if nCode = 1 then GetNGExp(dwExp, 0);//取得内力经验 20081224
            end;
          end else begin
            WinExp(dwExp);
            if nCode = 1 then GetNGExp(dwExp, 0);//取得内力经验 20081224
          end;
        end else begin
          WinExp(dwExp);
          if nCode = 1 then GetNGExp(dwExp, 0);//取得内力经验
        end;
      end else begin
        WinExp(dwExp);
        if nCode = 1 then GetNGExp(dwExp, 0);//取得内力经验
      end;
    end;
  except
    MainOutMessage(sExceptionMsg + IntToStr(nCheckCode));
  end;
end;

procedure TPlayObject.GameTimeChanged;
begin
  if m_nBright <> g_nGameTime then begin
    m_nBright := g_nGameTime;
    SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
  end;
end;

//取备份元宝寄售列表物品 20081015 修改
procedure TPlayObject.GetBackSellOffItems();
var
  I: Integer;
begin
  if m_SellOffItemList.Count > 0 then begin
    for I := m_SellOffItemList.Count - 1 downto 0 do begin
      m_ItemList.Add(m_SellOffItemList.Items[I]);
      m_SellOffItemList.Delete(I);
    end;
  end;
  m_boSellOffOK := False; //确认元宝寄售标志 20080316
end;

procedure TPlayObject.GetBackDealItems;
var
  I: Integer;
begin
  if m_DealItemList.Count > 0 then begin
    for I := 0 to m_DealItemList.Count - 1 do begin
      m_ItemList.Add(m_DealItemList.Items[I]);
    end;
  end;
  m_DealItemList.Clear;
  Inc(m_nGold, m_nDealGolds);
  m_nDealGolds := 0;
  m_boDealOK := False;
end;

procedure TPlayObject.GetBagUseItems(var btDc, btSc, btMc, btDura: Byte);
var
  I, II: Integer;
  DuraList: TList;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  DelItemList: TStringList;
  nDc, nSc, nMc, nDcMin, nDcMax, nScMin, nScMax, nMcMin, nMcMax, nDura, nItemCount: Integer;
begin
  nDcMin := 0;
  nDcMax := 0;
  nScMin := 0;
  nScMax := 0;
  nMcMin := 0;
  nMcMax := 0;
  nDura := 0;
  nItemCount := 0;
  DelItemList := nil;
  DuraList := TList.Create;
  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    UserItem := m_ItemList.Items[I];
    if UserItem = nil then Continue;
    if UserEngine.GetStdItemName(UserItem.wIndex) = g_Config.sBlackStone then begin
      DuraList.Add(Pointer(Round(UserItem.Dura / 1.0E3)));
      if DelItemList = nil then DelItemList := TStringList.Create;
      DelItemList.AddObject(g_Config.sBlackStone, TObject(UserItem.MakeIndex));
      Dispose(UserItem);
      m_ItemList.Delete(I);
    end else begin
      if IsUseItem(UserItem.wIndex) then begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then begin
          StdItem80 := StdItem^;
          ItemUnit.GetItemAddValue(UserItem, StdItem80);
          nDc := 0;
          nSc := 0;
          nMc := 0;
          case StdItem80.StdMode of
            19, 20, 21: begin //004A0421
                nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
              end;
            22, 23: begin //004A046E
                nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
              end;
            24, 26: begin
                nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC) + 1;
                nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC) + 1;
                nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC) + 1;
              end;
          end;
          if nDcMin < nDc then begin
            nDcMax := nDcMin;
            nDcMin := nDc;
          end else begin
            if nDcMax < nDc then nDcMax := nDc;
          end;
          if nScMin < nSc then begin
            nScMax := nScMin;
            nScMin := nSc;
          end else begin
            if nScMax < nSc then nScMax := nSc;
          end;
          if nMcMin < nMc then begin
            nMcMax := nMcMin;
            nMcMin := nMc;
          end else begin
            if nMcMax < nMc then nMcMax := nMc;
          end;
          if DelItemList = nil then DelItemList := TStringList.Create;
          DelItemList.AddObject(StdItem.Name, TObject(UserItem.MakeIndex));
          //004A06DB
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('26' + #9 + m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
              '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
              '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
              '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
              '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
              '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
              IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
              IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
              IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
              IntToStr(UserItem.btValue[14])+ #9 +'0');
          Dispose(UserItem);
          m_ItemList.Delete(I);
        end;
      end;
    end;
  end; // for

  if DuraList.Count > 0 then begin//20080628
    for I := 0 to DuraList.Count - 1 do begin
      if DuraList.Count <= 0 then Break;
      for II := DuraList.Count - 1 downto I + 1 do begin
        if Integer(DuraList.Items[II]) > Integer(DuraList.Items[II - 1]) then
          DuraList.Exchange(II, II - 1);
      end; // for
    end; // for

    for I := 0 to DuraList.Count - 1 do begin
      nDura := nDura + Integer(DuraList.Items[I]);
      Inc(nItemCount);
      if nItemCount >= 5 then Break;
    end;
  end;
  btDura := Round(_MIN(5, nItemCount) + _MIN(5, nItemCount) * ((nDura / nItemCount) / 5.0));
  btDc := nDcMin div 5 + nDcMax div 3;
  btSc := nScMin div 5 + nScMax div 3;
  btMc := nMcMin div 5 + nMcMax div 3;
  if DelItemList <> nil then
    SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelItemList), 0, 0, '');
  if DuraList <> nil then DuraList.Free;
end;

function TPlayObject.GeTBaseObjectInfo: string;
begin
  Result := m_sCharName +
    ' 标识:' + IntToHex(Integer(Self), 2) +
    ' 权限等级: ' + IntToStr(m_btPermission) +
    ' 管理模式: ' + BoolToCStr(m_boAdminMode) +
    ' 隐身模式: ' + BoolToCStr(m_boObMode) +
    ' 无敌模式: ' + BoolToCStr(m_boSuperMan) +
    ' 地图:' + m_sMapName + '(' + m_PEnvir.sMapDesc + ')' +
    ' 座标:' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) +
    ' 等级:' + IntToStr(m_Abil.Level) +
    ' 转生等级:' + IntToStr(m_btReLevel) +
    ' 经验:' + IntToStr(m_Abil.Exp) +
    ' 生命值: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP) +
    ' 魔法值: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP) +
    ' 攻击力: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)) +
    ' 魔法力: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)) +
    ' 道术: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)) +
    ' 防御力: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)) +
    ' 魔防力: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)) +
    ' 准确:' + IntToStr(m_btHitPoint) +
    ' 敏捷:' + IntToStr(m_btSpeedPoint) +
    ' 速度:' + IntToStr(m_nHitSpeed) +
    ' 仓库密码:' + m_sStoragePwd +
    ' 登录IP:' + m_sIPaddr + '(' + m_sIPLocal {GetIPLocal(m_sIPaddr)} + ')' +
    ' 登录帐号:' + m_sUserID +
    ' 登录时间:' + DateTimeToStr(m_dLogonTime) +
    ' 在线时长(分钟):' + IntToStr((GetTickCount - m_dwLogonTick) div 60000) +
    ' 登录模式:' + IntToStr(m_nPayMent) +
    ' ' + g_Config.sGameGoldName + ':' + IntToStr(m_nGameGold) +
    ' ' + g_Config.sGameDiaMond + ':' + IntToStr(m_nGameDiaMond) + //20071226 金刚石
    ' ' + g_Config.sGameGird + ':' + IntToStr(m_nGameGird) + //20071226 灵符
    ' ' + g_Config.sGamePointName + ':' + IntToStr(m_nGamePoint) +
    ' ' + g_Config.sPayMentPointName + ':' + IntToStr(m_nPayMentPoint) +
    ' 会员类型:' + IntToStr(m_nMemberType) +
    ' 会员等级:' + IntToStr(m_nMemberLevel) +
    ' 经验倍数:' + CurrToStr(m_nKillMonExpRate / 100) +
    ' 攻击倍数:' + CurrToStr(m_nPowerRate / 100) +
    ' 声望值:' + IntToStr(m_btCreditPoint);
end;

function TPlayObject.GetDigUpMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin//20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if SendMessage <> nil then begin
          if (SendMessage.wIdent = CM_BUTCH) then begin
            Inc(Result);
          end;
        end;
      end;//for
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;
//使用照明物品
procedure TBaseObject.UseLamp;
var
  nOldDura: Integer;
  nDura: Integer;
  PlayObject: TPlayObject;
  StdItem: pTStdItem;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::UseLamp';
begin
  try
    if m_UseItems[U_RIGHTHAND].wIndex > 0 then begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_RIGHTHAND].wIndex);
      if (StdItem = nil) or (StdItem.Source <> 0) then Exit;

      nOldDura := Round(m_UseItems[U_RIGHTHAND].Dura / 1000);
      if g_Config.boDecLampDura then begin
        nDura := m_UseItems[U_RIGHTHAND].Dura - 1;
      end else begin
        nDura := m_UseItems[U_RIGHTHAND].Dura;
      end;
      if nDura <= 0 then begin
        m_UseItems[U_RIGHTHAND].Dura := 0;
        if m_btRaceServer = RC_PLAYOBJECT then begin
          PlayObject := TPlayObject(Self);
          PlayObject.SendDelItems(@m_UseItems[U_RIGHTHAND]);
        end;
        m_UseItems[U_RIGHTHAND].wIndex := 0;
        m_nLight := 0;
        SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');
        SendMsg(Self, RM_LAMPCHANGEDURA, 0, m_UseItems[U_RIGHTHAND].Dura, 0, 0, '');
        RecalcAbilitys();
        CompareSuitItem(False);//200080729 套装
        //        FeatureChanged(); 01/21 取消 蜡烛是本人才可以看到的，不需要发送广播信息
      end else m_UseItems[U_RIGHTHAND].Dura := nDura;
      if nOldDura <> Round(nDura / 1000) then begin
        SendMsg(Self, RM_LAMPCHANGEDURA, 0, m_UseItems[U_RIGHTHAND].Dura, 0, 0, '');
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

function TBaseObject.GetPoseCreate: TBaseObject;
var
  nX, nY: Integer;
begin
  Result := nil;
  if GetFrontPosition(nX, nY) then begin
    Result := m_PEnvir.GetMovingObject(nX, nY, True);
  end;
end;
//客户端查询包裹物品
procedure TPlayObject.ClientQueryBagItems;
var
  I: Integer;
  Item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  StdItem: TStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
 if m_boCanQueryBag then Exit;//是否可以刷新包裹 20080907
 m_boCanQueryBag:= True;
 try
 { if Assigned(zPlugOfEngine.ClientQueryBagItems) then begin //20080813 注释
    zPlugOfEngine.ClientQueryBagItems(Self);
  end else begin}
    if m_nSoftVersionDateEx = 0 then begin
      sSENDMSG := '';
      if m_ItemList.Count > 0 then begin//20080628
        for I := 0 to m_ItemList.Count - 1 do begin
          UserItem := m_ItemList.Items[I];
          Item := UserEngine.GetStdItem(UserItem.wIndex);
          //sItemNewName:=GetItemName(UserItem.MakeIndex);
          if Item <> nil then begin
            StdItem := Item^;
            ItemUnit.GetItemAddValue(UserItem, StdItem);
            //      Move(StdItem,ClientItem.S,SizeOf(TStdItem));
            CopyStdItemToOStdItem(@StdItem, @OClientItem.s);

            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName <> '' then
              OClientItem.s.Name := sUserItemName;

            OClientItem.Dura := UserItem.Dura;
            OClientItem.DuraMax := UserItem.DuraMax;
            OClientItem.MakeIndex := UserItem.MakeIndex;
            if StdItem.StdMode = 50 then begin
              OClientItem.s.Name := OClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
            end;
            sSENDMSG := sSENDMSG + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
          end;
        end;
      end;
      if sSENDMSG <> '' then begin
        m_DefMsg := MakeDefaultMsg(SM_BAGITEMS, Integer(Self), 0, 0, m_ItemList.Count, 0);
        SendSocket(@m_DefMsg, sSENDMSG);
      end;
    end else begin
      sSENDMSG := '';
      if m_ItemList.Count > 0 then begin//20080628
        for I := 0 to m_ItemList.Count - 1 do begin
          UserItem := m_ItemList.Items[I];
          //sItemNewName:=GetItemName(UserItem.MakeIndex);
          Item := UserEngine.GetStdItem(UserItem.wIndex);
          if Item <> nil then begin
            StdItem := Item^;
            ItemUnit.GetItemAddValue(UserItem, StdItem);
            Move(StdItem, ClientItem.s, SizeOf(TStdItem));

            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if UserItem.btValue[12] = 1 then ClientItem.s.Reserved1:=1 //物品发光 20080223
              else ClientItem.s.Reserved1:=0;
            if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;

            if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080622
              if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//酒的品质
              if UserItem.btValue[1] <> 0 then ClientItem.s.MAC:=UserItem.btValue[1];//酒的酒精度
            end;
            if StdItem.StdMode = 8 then begin//酿酒材料 20080726
              if UserItem.btValue[0] <> 0 then ClientItem.s.AC:= UserItem.btValue[0];//材料的品质
            end;
            ClientItem.Dura := UserItem.Dura;
            ClientItem.DuraMax := UserItem.DuraMax;
            ClientItem.MakeIndex := UserItem.MakeIndex;
            {if StdItem.StdMode = 50 then begin//20080726 注释
              ClientItem.s.Name := ClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
            end;}
            sSENDMSG := sSENDMSG + EncodeBuffer(@ClientItem, SizeOf(TClientItem)) + '/';
          end;
        end;
      end;
      if sSENDMSG <> '' then begin
        m_DefMsg := MakeDefaultMsg(SM_BAGITEMS, Integer(Self), 0, 0, m_ItemList.Count, 0);
        SendSocket(@m_DefMsg, sSENDMSG);
      end;
      IsItem_51(1);//发送聚灵珠的经验 20080412
    end;
  //end;//20080813 注释
 finally 
   m_boCanQueryBag:= False; 
 end;
end;
(* //未使用 20080907
procedure TPlayObject.ClientQueryUserSet(ProcessMsg: pTProcessMessage);
//var
//  sPassword: string;
begin
  {sPassword := Md5.EncryptString(ProcessMsg.sMsg);
  if sPassword <> DecodeString('NbA_VsaSTRucMbAjUl') then begin
    MainOutMessage('Fail');
    exit;
  end;
  m_nClientFlagMode := ProcessMsg.wParam;
  MainOutMessage(format('OK:%d', [m_nClientFlagMode]));}
  //'JackyWangFang'
  //'8988e0804091579a2fd8a0db75e9c17a';
  //'NbA_VsaSTRucMbAjUl'
end;  *)
//取玩家的等级排名 20080214
Function TPlayObject.GetUserLevelOrder:Integer;
var
  nIndex: Integer;
  PlayLevelOrder: TStringList;
  sCharName: string;
  CharName: pTCharName;
begin
  Result:= 0;
  EnterCriticalSection(HumanSortCriticalSection);
  try
  PlayLevelOrder := GetPlayObjectOrderList(0);
  if PlayLevelOrder <> nil then begin
    if PlayLevelOrder.Count > 0 then begin//20080629
      for nIndex := 0 to PlayLevelOrder.Count - 1 do begin
        CharName := pTCharName(PlayLevelOrder.Objects[nIndex]);
        sCharName := CharName^;
        if CompareText(m_sCharName, sCharName) = 0 then begin
          Result:=nIndex + 1;
          Break;
        end;
      end;//for
    end;
  end;
  finally
    LeaveCriticalSection(HumanSortCriticalSection);
  end;
end;

procedure TPlayObject.UserLevelOrder(BaseObject: TObject); //获取人物等级排行  NPC
  function Add_space(Str: string; Size: Integer): string;
  begin
    Result := Str;
    if Length(Str) >= Size then Exit;
    while Length(Result) < Size do
      Result := Result + ' ';
  end;
var
  nIndex: Integer;
  nPage: Integer;
  sIndex: string;
  sCharName: string;
  sLevel: string;
  PlayObjectList: TStringList;
  boFound: Boolean;
  n01: Integer;
  n02: Integer;
  s01: string;
  Merchant: TMerchant;
  CharName: pTCharName;
  //resourcestring
const
  sFirstStr1 = '序位                  角色名                      等级\';
  sFirstStr2 = '序位                  角色名                出师徒弟数\';
  sNotFoundStr = '您没有上榜或不在该榜！！！\';
begin
  EnterCriticalSection(HumanSortCriticalSection);
  try
    m_PlayOrderList.Clear;
    if m_nSelPlayOrderType = 4 then begin
      m_PlayOrderList.Add(sFirstStr2);
    end else begin
      m_PlayOrderList.Add(sFirstStr1);
    end;
    PlayObjectList := GetPlayObjectOrderList(m_nSelPlayOrderType);
    nPage := m_nPlayOrderPage;
    if PlayObjectList <> nil then begin
      if m_boGetMyLevelOrder then begin //我的排行
        m_boGetMyLevelOrder := False;
        boFound := False;
        if PlayObjectList.Count > 0 then begin//20080629
          for nIndex := 0 to PlayObjectList.Count - 1 do begin
            CharName := pTCharName(PlayObjectList.Objects[nIndex]);
            sCharName := CharName^;
            if CompareText(m_sCharName, sCharName) = 0 then begin
              sIndex := IntToStr(nIndex + 1);
              sLevel := PlayObjectList.Strings[nIndex];
              sIndex := Add_space(sIndex, 4 + 18);
              sCharName := Add_space(sCharName, 14 + 14);
              m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
              boFound := True;
              Break;
            end;
          end;//for
        end;
        if not boFound then begin
          m_PlayOrderList.Clear;
          m_PlayOrderList.Add(sNotFoundStr);
        end;
      end else begin
        n01 := 0;
        if nPage > 0 then begin
          for nIndex := nPage * 7 to PlayObjectList.Count - 1 do begin
            if n01 >= 7 then Break;
            sIndex := IntToStr(nIndex + 1);
            CharName := pTCharName(PlayObjectList.Objects[nIndex]);
            sCharName := CharName^;
            sLevel := PlayObjectList.Strings[nIndex];
            sIndex := Add_space(sIndex, 4 + 18);
            sCharName := Add_space(sCharName, 14 + 14);
            m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
            Inc(n01);
          end;
        end else begin
          if PlayObjectList.Count > 0 then begin//20080629
            for nIndex := 0 to PlayObjectList.Count - 1 do begin
              if n01 >= 7 then Break;
              sIndex := IntToStr(nIndex + 1);
              CharName := pTCharName(PlayObjectList.Objects[nIndex]);
              sCharName := CharName^;
              sLevel := PlayObjectList.Strings[nIndex];
              sIndex := Add_space(sIndex, 4 + 18);
              sCharName := Add_space(sCharName, 14 + 14);
              m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
              Inc(n01);
            end;
          end;
        end;
      end;
    end;
    if m_PlayOrderList.Count > 0 then begin
      n02 := 8 - m_PlayOrderList.Count;
      if n02 > 0 then begin
        for nIndex := 1 to n02 do begin
          s01 := m_PlayOrderList.Strings[m_PlayOrderList.Count - 1];
          m_PlayOrderList.Strings[m_PlayOrderList.Count - 1] := s01 + ' \';
        end;
      end;
    end;
    Merchant := UserEngine.FindMerchant(BaseObject);
    if Merchant <> nil then begin
      Merchant.GotoLable(Self, '@LevelOrder', False);
    end;
  finally
    LeaveCriticalSection(HumanSortCriticalSection);
  end;
end;
//客户端查看别人的装备
procedure TPlayObject.ClientQueryUserState(BaseObject: TBaseObject; nX, nY: Integer);
var
  I: Integer;
  UserState: TUserStateInfo;
  OUserState: TOUserStateInfo;
  StdItem: pTStdItem;
  StdItem24: TStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
  UserItem: pTUserItem;
  boCopyHum: Byte;//是否是分身 20080413
begin
   boCopyHum:= 0;
  if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then begin
    if not CretInNearXY(BaseObject, nX, nY) then Exit;
    FillChar(OUserState, SizeOf(TOUserStateInfo), #0);
    OUserState.feature := BaseObject.GetFeature(Self);
    OUserState.UserName := BaseObject.m_sCharName;
    OUserState.NAMECOLOR := GetCharColor(BaseObject);
    if BaseObject.m_btRaceServer = RC_PLAYMOSTER then begin
       if BaseObject.m_Master = nil then UserState.UserName := FilterShowName(UserState.UserName);//人形怪过滤有数字的名称 20080409
       if BaseObject.m_Master <> nil then begin
         if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin//人物的分身
           UserState.GuildName := BaseObject.m_Master.m_sCharName;//20080410 人形显示主人名字
           boCopyHum:= 1;
         end else
         if BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT then begin//英雄的分身
           UserState.GuildName := BaseObject.m_Master.m_Master.m_sCharName;//20080414 显示英雄主人名字
           boCopyHum:= 2;
         end;
       end;
    end;
    if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin //如果是英雄 那么就把行会名为主人名 20080229
      OUserState.GuildName :=  BaseObject.m_Master.m_sCharName;
      boCopyHum:= 3;
    end else begin
      if BaseObject.m_MyGuild <> nil then begin
        OUserState.GuildName := TGUild(BaseObject.m_MyGuild).sGuildName;
      end;
      OUserState.GuildRankName := BaseObject.m_sGuildRankName;
    end;
    
    if g_Config.boUnKnowHum and BaseObject.IsUsesZhuLi then begin
      UserState.UserName :='神秘人';//带上斗笠即显示神秘人 20080424
      UserState.GuildRankName:= '';
      UserState.GuildName:= '';
      boCopyHum:= 0;
    end;

    for I := Low(THumItems) to High(THumItems) do begin
      UserItem := @BaseObject.m_UseItems[I];
      if UserItem.wIndex > 0 then begin
        StdItem := UserEngine.GetStdItem(BaseObject.m_UseItems[I].wIndex);
        if StdItem = nil then Continue;
        StdItem24 := StdItem^;
        ItemUnit.GetItemAddValue(@BaseObject.m_UseItems[I], StdItem24);
        //Move(StdItem24,ClientItem.S,SizeOf(TStdItem));
        CopyStdItemToOStdItem(@StdItem24, @OClientItem.s);

        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          OClientItem.s.Name := sUserItemName;

        OClientItem.MakeIndex := BaseObject.m_UseItems[I].MakeIndex;
        OClientItem.Dura := BaseObject.m_UseItems[I].Dura;
        OClientItem.DuraMax := BaseObject.m_UseItems[I].DuraMax;
        OUserState.UseItems[I] := OClientItem;
      end;
    end;
    if ((BaseObject.m_btRaceServer = RC_HEROOBJECT) and (boCopyHum <> 0)) or ((BaseObject.m_btRaceServer = RC_PLAYMOSTER) and (boCopyHum = 2)) then
      m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 1, 0, 0, 0, 0)
    else
    if (boCopyHum = 1) and (BaseObject.m_btRaceServer = RC_PLAYMOSTER) then //20080413 人形客户显示名字+的分身
      m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 2, 0, 0, 0, 0)
    else
      m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 0, 0, 0, 0, 0);
    SendSocket(@m_DefMsg, EncodeBuffer(@OUserState, SizeOf(TOUserStateInfo)));
  end else begin
    if not CretInNearXY(BaseObject, nX, nY) then Exit;
    FillChar(UserState, SizeOf(TUserStateInfo), #0);
    UserState.feature := BaseObject.GetFeature(Self);
    UserState.UserName := BaseObject.m_sCharName;
    UserState.NAMECOLOR := GetCharColor(BaseObject);
    if BaseObject.m_btRaceServer = RC_PLAYMOSTER then begin
       if BaseObject.m_Master = nil then UserState.UserName := FilterShowName(UserState.UserName);//人形怪过滤有数字的名称 20080409
       if BaseObject.m_Master <> nil then begin
         if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin//人物的分身
           UserState.GuildName := BaseObject.m_Master.m_sCharName;//20080410 人形显示主人名字
           boCopyHum:= 1;
         end else
         if BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT then begin//英雄的分身
           UserState.GuildName := BaseObject.m_Master.m_Master.m_sCharName;//20080414 显示英雄主人名字
           boCopyHum:= 2;
         end;
       end;
    end;
    if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin//如果是英雄 那么就把行会名为主人名  20080229
      if g_Config.boUnKnowHum and BaseObject.m_Master.IsUsesZhuLi then//主人为神秘人时 20080806
         UserState.GuildName :='神秘人'
      else UserState.GuildName :=  BaseObject.m_Master.m_sCharName;
      boCopyHum:= 3;
    end else begin
      if BaseObject.m_MyGuild <> nil then begin
        UserState.GuildName := TGUild(BaseObject.m_MyGuild).sGuildName;
      end;
      UserState.GuildRankName := BaseObject.m_sGuildRankName;
    end;

    if g_Config.boUnKnowHum and BaseObject.IsUsesZhuLi then begin
      UserState.UserName :='神秘人';//带上斗笠即显示神秘人 20080424
      UserState.GuildRankName:= '';
      UserState.GuildName:= '';
      boCopyHum:= 0;
    end;

    for I := Low(THumanUseItems) to High(THumanUseItems) do begin
      UserItem := @BaseObject.m_UseItems[I];
      if UserItem.wIndex > 0 then begin
        StdItem := UserEngine.GetStdItem(BaseObject.m_UseItems[I].wIndex);
        if StdItem = nil then Continue;
        StdItem24 := StdItem^;
        ItemUnit.GetItemAddValue(@BaseObject.m_UseItems[I], StdItem24);
        Move(StdItem24, ClientItem.s, SizeOf(TStdItem));

        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if UserItem.btValue[12] = 1 then ClientItem.s.Reserved1:=1//物品发光 20080223
          else ClientItem.s.Reserved1:=0 ;
        if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;

        ClientItem.MakeIndex := BaseObject.m_UseItems[I].MakeIndex;
        ClientItem.Dura := BaseObject.m_UseItems[I].Dura;
        ClientItem.DuraMax := BaseObject.m_UseItems[I].DuraMax;
        UserState.UseItems[I] := ClientItem;
      end;
    end;
    if ((BaseObject.m_btRaceServer = RC_HEROOBJECT) and (boCopyHum <> 0)) or ((BaseObject.m_btRaceServer = RC_PLAYMOSTER) and (boCopyHum = 2)) then//英雄,英雄的分身 20080414
      m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 1, 0, 0, 0, 0)
    else
    if (boCopyHum = 1) and (BaseObject.m_btRaceServer = RC_PLAYMOSTER) then //20080413 人形客户显示名字+的分身
      m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 2, 0, 0, 0, 0)
    else
    m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 0, 0, 0, 0, 0);
    SendSocket(@m_DefMsg, EncodeBuffer(@UserState, SizeOf(TUserStateInfo)));
  end;
end;

procedure TPlayObject.ClientMerchantDlgSelect(nParam1: Integer; sMsg: string);
var
  NPC: TNormNpc;
begin
  if m_boDeath or m_boGhost then Exit;
  NPC := UserEngine.FindMerchant(TObject(nParam1));
  if NPC = nil then NPC := UserEngine.FindNPC(TObject(nParam1));
  if NPC = nil then Exit;
  if ((NPC.m_PEnvir = m_PEnvir) and
    (abs(NPC.m_nCurrX - m_nCurrX) < 15) and
    (abs(NPC.m_nCurrY - m_nCurrY) < 15)) or (NPC.m_boIsHide) then
    NPC.UserSelect(Self, Trim(sMsg));
end;

procedure TPlayObject.ClientMerchantQuerySellPrice(nParam1, nMakeIndex: Integer;
  sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  UserItem18: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  UserItem18 := nil;
  if m_ItemList.Count > 0 then begin//20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nMakeIndex then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if CompareText(sUserItemName, sMsg) = 0 then begin
          UserItem18 := UserItem;
          Break;
        end;
      end;
    end;
  end;
  if UserItem18 = nil then Exit;
  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if Merchant = nil then Exit;
  if ((Merchant.m_PEnvir = m_PEnvir) and
    (Merchant.m_boSell) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQuerySellPrice(Self, UserItem18);
end;
{//接收客户端拍卖的物品数据,并写入列表 20080316          //20080416 去掉拍卖功能
procedure TPlayObject.ClientUserSellOffItem(nParam1, nMakeIndex: Integer; sMsg: string); //拍卖
var
  I: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
  sSellGold: string;
  SellOffInfo: pTSellOffInfo;
begin
  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    UserItem := m_ItemList.Items[I];
    if (UserItem <> nil) and (UserItem.MakeIndex = nMakeIndex) then begin
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      sMsg := GetValidStr3(sMsg, sSellGold, ['/']);
      if CompareText(sUserItemName, sMsg) = 0 then begin
        Merchant := UserEngine.FindMerchant(TObject(nParam1));
        if (Merchant <> nil) and
          (Merchant.m_boSellOff) and
          ((Merchant.m_PEnvir = m_PEnvir) and
          (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
          (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then begin
          New(SellOffInfo);
          SellOffInfo^.sCharName := m_sCharName;
          SellOffInfo^.dSellDateTime := Now;
          SellOffInfo^.nSellGold := Str_ToInt(sSellGold, 0);
          FillChar(SellOffInfo^.UseItems, SizeOf(TUserItem), #0);
          SellOffInfo^.UseItems := UserItem^;
          SellOffInfo^.n := Integer(Self); //nParam1;
          SellOffInfo^.n1 := -1;
          if Merchant.ClientSellOffItem(Self, SellOffInfo, sUserItemName) then begin
            if UserItem.btValue[13] = 1 then begin
              ItemUnit.DelCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              UserItem.btValue[13] := 0;
            end;
            Dispose(UserItem); //物品加到NPC物品列表中了
            m_ItemList.Delete(I);
            WeightChanged();
          end;
        end;
        Break;
      end;
    end;
  end;
end;  }
{ //20080416 去掉拍卖功能
procedure TPlayObject.ClientUserBuySellOffItem(nIdent, nParam1, nInt, nZz: Integer; sMsg: string); //购买寄售物品
var
  Merchant: TMerchant;
begin
  try
    if m_boDealing then Exit;
    Merchant := UserEngine.FindMerchant(TObject(nParam1));
    if (Merchant = nil) or
      (not Merchant.m_boBuyOff) or
      (Merchant.m_PEnvir <> m_PEnvir) or
      (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
      (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then Exit;
    if nIdent = CM_SENDBUYSELLOFFITEM then begin //购买寄售物品
      Merchant.ClientBuySellOffItem(Self, sMsg, nInt);
    end;
    if nIdent = CM_SENDQUERYSELLOFFITEM then begin //发送查询寄售物品列表
      Merchant.ClientGetDetailSellGoodsList(Self, sMsg, nZz);
    end;
  except
    on E: Exception do begin
      MainOutMessage('TPlayObject.ClientUserBuySellOffItem wIdent = ' + IntToStr(nIdent));
      //MainOutMessage(E.Message);
    end;
  end;
end;}
//客户端卖物品(出售物品)
procedure TPlayObject.ClientUserSellItem(nParam1, nMakeIndex: Integer; sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
  StdItem: pTStdItem;
begin
  m_boCanQueryBag:= True;//出售物品时,不能刷新包裹 20080917
  Try
    for I := m_ItemList.Count - 1 downto 0 do begin
      if m_ItemList.Count <= 0 then Break;//20080917
      UserItem := m_ItemList.Items[I];
      if (UserItem <> nil) and (UserItem.MakeIndex = nMakeIndex) then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if CompareText(sUserItemName, sMsg) = 0 then begin
          if CheckItemValue(UserItem ,4 ) or PlugOfCheckCanItem(1, sUserItemName, True, 0, 0) then begin//禁止物品规则(禁止交易) 20080913
            SendMsg(Self, RM_USERSELLITEM_FAIL, 0, 0, 0, 0, '');//出售失败消息
            Break;//20080314 禁止出售
          end;

          Merchant := UserEngine.FindMerchant(TObject(nParam1));
          if (Merchant <> nil) and
            (Merchant.m_boSell) and
            ((Merchant.m_PEnvir = m_PEnvir) and
            (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
            (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then begin
            if Merchant.ClientSellItem(Self, UserItem) then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if (StdItem <> nil) and (StdItem.StdMode = 51) and (StdItem.Shape = 0) and (UserItem.Dura > 0) and (UserItem.btValue[20]= 1) then begin//是聚灵珠 20080501
                m_DealCreat.n_UsesItemTick:= 0;//时间初始
                UserItem.btValue[12]:= 2;//不能聚集的标识
              end;
              if UserItem.btValue[13] = 1 then begin
                ItemUnit.DelCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
                UserItem.btValue[13] := 0;
              end;
              //Dispose(UserItem); //物品加到NPC物品列表中了
              m_ItemList.Delete(I);
              WeightChanged();
            end;
          end;
          Break;
        end;
      end;
    end; // for
  finally
    m_boCanQueryBag:= False;//出售物品时,不能刷新包裹 20080917
  end;
end;
//客户端购买物品
procedure TPlayObject.ClientUserBuyItem(nIdent, nParam1, nInt, nZz: Integer; sMsg: string);
var
  Merchant: TMerchant;
begin
  try
    if m_boDealing then Exit;
    Merchant := UserEngine.FindMerchant(TObject(nParam1));
    if (Merchant = nil) or (not Merchant.m_boBuy) or
      (Merchant.m_PEnvir <> m_PEnvir) or
      (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
      (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then Exit;

    if nIdent = CM_USERBUYITEM then begin//卖入物品 1014
      Merchant.ClientBuyItem(Self, sMsg, nInt);
    end;
    if nIdent = CM_USERGETDETAILITEM then begin//1015
      Merchant.ClientGetDetailGoodsList(Self, sMsg, nZz);
    end;
  except
    on E: Exception do begin
      MainOutMessage('{异常} TPlayObject.ClientUserBuyItem wIdent = ' + IntToStr(nIdent));
    end;
  end;
end;

function TPlayObject.ClientDropGold(nGold: Integer): Boolean;
begin
  Result := False;
  if g_Config.boInSafeDisableDrop and InSafeZone then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropInSafeZoneMsg);
    Exit;
  end;

  if g_Config.boControlDropItem and (nGold < g_Config.nCanDropGold) then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropGoldMsg);
    Exit;
  end;

  if not m_boCanDrop then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
    Exit;
  end;
  if nGold >= m_nGold then Exit;
  Dec(m_nGold, nGold);
  if not DropGoldDown(nGold, False, nil, Self) then Inc(m_nGold, nGold);
  GoldChanged();
  Result := True;
end;
//玩家扔物品
function TPlayObject.ClientDropItem(sItemName: string; nItemIdx: Integer): Boolean;
var
  I, wIndex, MakeIndex: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  sUserItemName: string;
//  sCheckItemName: string;
  nCode: Byte;//20080908 
begin
  Result := False;
  nCode:= 0;
  m_boCanQueryBag:= True;//扔物品时,不能刷新包裹 20080917
  Try
    Try
      if not m_boClientFlag then begin
        if m_nStep = 8 then Inc(m_nStep)
        else m_nStep := 0;
      end;
      nCode:= 1;
      if g_Config.boInSafeDisableDrop and InSafeZone then begin
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropInSafeZoneMsg);
        Exit;
      end;
      nCode:= 2;
      if not m_boCanDrop then begin
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
        Exit;
      end;

      if Pos(' ', sItemName) > 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
        GetValidStr3(sItemName, sItemName, [' ']);
      end;
      nCode:= 3;
      if (GetTickCount - m_DealLastTick) > 3000 then begin
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem = nil then Continue;
            //sItem:=UserEngine.GetStdItemName(UserItem.wIndex);
            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName = '' then
              sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

            if CompareText(sUserItemName, sItemName) = 0 then begin
              nCode:= 4;
              if CheckItemValue(UserItem ,0) then Break;//检查物品是否禁止扔 20080314
              {if Assigned(zPlugOfEngine.CheckCanDropItem) then begin
                sCheckItemName := StdItem.Name;
                if not zPlugOfEngine.CheckCanDropItem(Self, PChar(sCheckItemName)) then Break;
              end;}
              nCode:= 5;
              if PlugOfCheckCanItem(0, StdItem.Name, False, 0, 0) then Break;//禁止物品规则(管理插件功能) 20080729
              nCode:= 6;
              if g_Config.boStartMapEvent then begin
                if m_btRaceServer = RC_PLAYOBJECT then StartMapEventOfDropItem(sUserItemName); //地图触发,扔物品事件
              end;
              if (StdItem.StdMode = 51) and (StdItem.Shape = 0) and (UserItem.Dura > 0) and (UserItem.btValue[20]= 1) then begin//是聚灵珠 20080501
                n_UsesItemTick:= 0;//时间初始
                UserItem.btValue[12]:= 2;//不能聚集的标识
              end;
              nCode:= 7;
              wIndex:= UserItem.wIndex;//20080901
              MakeIndex:= UserItem.MakeIndex;//20080901
              nCode:= 8;
              if g_Config.boControlDropItem and (StdItem.Price < g_Config.nCanDropPrice) then begin
                nCode:= 9;
                Dispose(UserItem);
                m_ItemList.Delete(I);
                nCode:= 10;
                ClearCopyItem(0,wIndex, MakeIndex);//20080901 清理复制品
                Result := True;
                Break;
              end;
              nCode:= 11;
              if DropItemDown(UserItem, 3, False, False, nil, Self) then begin
                nCode:= 12;
                if UserItem <> nil then Dispose(UserItem);//20080915 修改
                nCode:= 15;
                m_ItemList.Delete(I);
                nCode:= 13;
                ClearCopyItem(0,wIndex, MakeIndex);//20080901 清理复制品
                Result := True;
                Break;
              end;
            end;
          end;
        end;
        nCode:= 14;
        if Result then WeightChanged();
      end;//if (GetTickCount - m_DealLastTick) > 3000 then begin
    except
      MainOutMessage('{异常} TPlayObject.ClientDropItem Code:'+inttostr(nCode));
    end;
  finally
    m_boCanQueryBag:= False;//扔物品时,不能刷新包裹 20080917
  end;
end;

procedure TPlayObject.GoldChange(sChrName: string; nGold: Integer);
var
  s10, s14: string;
begin
  if nGold > 0 then begin
    s10 := '14';
    s14 := '增加完成';
  end else begin
    s10 := '13';
    s14 := '以删减';
  end;
  SysMsg(sChrName + ' 的金币 ' + IntToStr(nGold) + ' 金币' + s14, c_Green, t_Hint);
  if g_boGameLogGold then
    AddGameDataLog(s10 + #9 +
      m_sMapName + #9 +
      IntToStr(m_nCurrX) + #9 +
      IntToStr(m_nCurrY) + #9 +
      m_sCharName + #9 +
      sSTRING_GOLDNAME + #9 +
      IntToStr(nGold) + #9 +
      '1' + #9 +
      sChrName);
end;

procedure TPlayObject.ClearStatusTime;
begin
  FillChar(m_wStatusTimeArr, SizeOf(TStatusTime), #0);
end;
//发送地图音乐背景数据
procedure TPlayObject.SendMapDescription;
var
  nMUSICID: Integer;
  sMUSINAME: string;
begin
  nMUSICID := -1;
{$IF HEROVERSION = 1}
  if m_PEnvir.m_boMUSIC then begin
    nMUSICID := m_PEnvir.m_nMUSICID;
    sMUSINAME := m_PEnvir.m_sMUSICName;
  end;
  if nMUSICID >= 0 then begin
    SendDefMessage(SM_MAPDESCRIPTION, nMUSICID, 0, 0, 0, m_PEnvir.sMapDesc);
  end else begin
    SendDefMessage(SM_MAPDESCRIPTION, -1, 0, 0, 0, m_PEnvir.sMapDesc + #13 + sMUSINAME);
  end;
{$ELSE}
  if m_PEnvir.m_boMUSIC then
    nMUSICID := m_PEnvir.m_nMUSICID;
  SendDefMessage(SM_MAPDESCRIPTION, nMUSICID, 0, 0, 0, m_PEnvir.sMapDesc);
{$IFEND}
end;
//发送游戏公告
procedure TPlayObject.SendNotice;
var
  LoadList: TStringList;
  I: Integer;
  sNoticeMsg: string;
begin
  LoadList := TStringList.Create;
  NoticeManager.GetNoticeMsg('Notice', LoadList);
  sNoticeMsg := '';
  if LoadList.Count > 0 then begin//20080629
    for I := 0 to LoadList.Count - 1 do begin
      sNoticeMsg := sNoticeMsg + LoadList.Strings[I] + #$20#$1B;
    end;
  end;
  LoadList.Free;
  SendDefMessage(SM_SENDNOTICE, 2000, 0, 0, 0, sNoticeMsg);
end;
//人物登录游戏
procedure TPlayObject.UserLogon;
var
  I: Integer;
  II: Integer;
  UserItem: pTUserItem;
  UserItem1: pTUserItem;
  StdItem: pTStdItem;
  s14: string;
  sItem: string;
  sIPaddr: string;
  nCode: Byte;
resourcestring
  sExceptionMsg = '{异常} TPlayObject::UserLogon';
  sCheckIPaddrFail = '登录IP地址不匹配！！！';
begin
  sIPaddr := '';
  nCode:= 0;
  try
    if g_Config.boTestServer then begin
      nCode:= 1;
      if m_Abil.Level < g_Config.nTestLevel then m_Abil.Level := g_Config.nTestLevel;
      if m_nGold < g_Config.nTestGold then m_nGold := g_Config.nTestGold;
    end;
    nCode:= 2;
    if g_Config.boTestServer or (g_Config.boServiceMode) then m_nPayMent := 3;
    m_dwMapMoveTick := GetTickCount();
    m_dLogonTime := Now();
    m_dwLogonTick := GetTickCount();
    nCode:= 3;
    Initialize();//初始化
    nCode:= 4;
    SendMsg(Self, RM_LOGON, 0, 0, 0, 0, '');
    nCode:= 5;
    if m_Abil.Level <= 7 then begin
      if GetRangeHumanCount >= 80 then begin
        MapRandomMove(m_PEnvir.sMapName, 0);
      end;
    end;
    if m_boDieInFight3Zone then MapRandomMove(m_PEnvir.sMapName, 0);
    nCode:= 6;
    if UserEngine.GetHumPermission(m_sCharName, sIPaddr, m_btPermission) then begin //取人物权限值
{$IF VEROWNER = WL}
      if not CompareIPaddr(m_sIPaddr, sIPaddr) then begin
        SysMsg(sCheckIPaddrFail, c_Red, t_Hint);
        m_boEmergencyClose := True;
        m_boPlayOffLine := False;
      end;
{$IFEND}
    end;
    nCode:= 7;
    GetStartPoint();
    nCode:= 8;
    for I := 0 to m_MagicList.Count - 1 do begin
      if m_MagicList.Count <= 0 then Break;
      if pTUserMagic(m_MagicList.Items[I]) <> nil then
        sub_4C713C(pTUserMagic(m_MagicList.Items[I]));
    end;
    nCode:= 9;
    //给新人增加新人物品
    if m_boNewHuman then begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sCandle, UserItem) then begin
        m_ItemList.Add(UserItem);
      end else Dispose(UserItem);
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sBasicDrug, UserItem) then begin
        m_ItemList.Add(UserItem);
      end else Dispose(UserItem);
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sWoodenSword, UserItem) then begin
        m_ItemList.Add(UserItem);
      end else Dispose(UserItem);

      New(UserItem);
      if m_btGender = 0 then
        sItem := g_Config.sClothsMan
      else sItem := g_Config.sClothsWoman;

      if UserEngine.CopyToUserItemFromName(sItem, UserItem) then begin
        m_ItemList.Add(UserItem);
      end else Dispose(UserItem);
    end;
    nCode:= 10;
    //检查背包中的物品是否合法
    for I := m_ItemList.Count - 1 downto 0 do begin
      if m_ItemList.Count <= 0 then Break;
      UserItem := m_ItemList.Items[I];                        //20080813 增加，判断制造ID是否为负数
      if (UserEngine.GetStdItemName(UserItem.wIndex) = '') or (UserItem.MakeIndex < 0) or
        CheckIsOKItem(UserItem,0) then begin//检查变态物品 20081006
        MainOutMessage('[登录清包裹非法物品]('+ m_sCharName+')'+ UserEngine.GetStdItemName(UserItem.wIndex)+'('+IntToStr(UserItem.MakeIndex)+')['+
                  IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                  IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                  IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                  IntToStr(UserItem.btValue[14])+'/#'+IntToStr(UserItem.btValue[15])+'/'+IntToStr(UserItem.btValue[16])+'/'+
                  IntToStr(UserItem.btValue[17])+'/'+IntToStr(UserItem.btValue[18])+'/'+IntToStr(UserItem.btValue[19]));//20081219 记录清除非法物品信息
        Dispose(pTUserItem(m_ItemList.Items[I]));
        m_ItemList.Delete(I);
      end;
    end;
   nCode:= 11;
    //检查人物身上的物品是否符合使用规则
    if g_Config.boCheckUserItemPlace then begin
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin
        if m_UseItems[I].wIndex > 0 then begin
          StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
          if StdItem <> nil then begin
            if CheckIsOKItem(@m_UseItems[I], 0) then begin//检查变态物品 20081006
              m_UseItems[I].wIndex := 0;
              Continue;
            end;
            if not CheckUserItems(I, StdItem) then begin
              New(UserItem);
              FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
              //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
              UserItem^ := m_UseItems[I];
              if not AddItemToBag(UserItem) then begin
                m_ItemList.Insert(0, UserItem);
              end;
              m_UseItems[I].wIndex := 0;
            end;
          end else m_UseItems[I].wIndex := 0;
        end;
      end;
    end;
    nCode:= 12;
    //检查背包中是否有复制品
    for I := m_ItemList.Count - 1 downto 0 do begin
      if m_ItemList.Count <= 0 then Break;
      UserItem := m_ItemList.Items[I];
      s14 := UserEngine.GetStdItemName(UserItem.wIndex);
      for II := I - 1 downto 0 do begin
        UserItem1 := m_ItemList.Items[II];
        if (UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
          (UserItem.MakeIndex = UserItem1.MakeIndex) then begin
          MainOutMessage('[登录清包裹复制品]('+ m_sCharName+')'+ s14+'('+IntToStr(UserItem1.MakeIndex)+')');//20081219 记录清除复制品信息
          m_ItemList.Delete(II);
          Break;
        end;
      end;
    end;
    nCode:= 13;
    for I := Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do begin
      if m_wStatusTimeArr[I] > 0 then m_dwStatusArrTick[I] := GetTickCount();
    end;
    nCode:= 14;
    m_nCharStatus := GetCharStatus();
    RecalcLevelAbilitys();//重新计算角色的等级各属性
    RecalcAbilitys();//刷新能力
    CompareSuitItem(True);//套装与身上装备对比 20080712
    nCode:= 15;
    m_Abil.MaxExp := GetLevelExp(m_Abil.Level);
    if btB2 = 0 then begin
      m_nPkPoint := 0;
      Inc(btB2);
    end;
    nCode:= 16;
    if (m_nGold > g_Config.nHumanMaxGold * 2) and (g_Config.nHumanMaxGold > 0) then m_nGold := g_Config.nHumanMaxGold * 2;
    if not bo6AB then begin
      if (m_nSoftVersionDate < g_Config.nSoftVersionDate) then begin //对比客户端版本号 20080302
        nCode:= 17;
        SysMsg(sClientSoftVersionError, c_Red, t_Hint);
        SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
        SysMsg(sForceDisConnect, c_Red, t_Hint);
        m_boEmergencyClose := True;
        m_boPlayOffLine := False;
        Exit;
      end;
      if (m_nSoftVersionDateEx = 0) then begin
        if (not g_Config.boCanOldClientLogon) then begin //如果不允许普通客户端登录,则退出
          nCode:= 18;
          SysMsg(sClientSoftVersionError, c_Red, t_Hint);
          SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
          SysMsg(sForceDisConnect, c_Red, t_Hint);
          m_boEmergencyClose := True;
          m_boPlayOffLine := False;
          Exit;
        end;
        if g_Config.boOldClientShowHiLevel then begin
           nCode:= 19;
           SysMsg(sClientSoftVersionTooOld, c_Blue, t_Hint);
           SysMsg(sDownLoadAndUseNewClient, c_Red, t_Hint);
        end;
      end;
      nCode:= 20;
      case m_btAttatckMode of
        HAM_ALL:begin //20080331 加入聊天框中提示
             SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfAll); //[攻击模式: 全体攻击]
             SysMsg(sAttackModeOfAll, c_Green, t_Hint); //[攻击模式: 全体攻击]
           end;
        HAM_PEACE:begin
             SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfPeaceful); //[攻击模式: 和平攻击]
             SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint); //[攻击模式: 和平攻击]
           end;
        HAM_DEAR:begin
             SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfDear); //[攻击模式: 夫妻攻击]
             SysMsg(sAttackModeOfDear, c_Green, t_Hint); //[攻击模式: 夫妻攻击]
           end;
        HAM_MASTER:begin
             SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfMaster); //[攻击模式: 师徒攻击]
             SysMsg(sAttackModeOfMaster, c_Green, t_Hint); //[攻击模式: 师徒攻击]
           end;
        HAM_GROUP:begin
             SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfGroup); //[攻击模式: 编组攻击]
             SysMsg(sAttackModeOfGroup, c_Green, t_Hint); //[攻击模式: 编组攻击]
           end;
        HAM_GUILD:begin
             SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfGuild); //[攻击模式: 行会攻击]
             SysMsg(sAttackModeOfGuild, c_Green, t_Hint); //[攻击模式: 行会攻击]
           end;
        HAM_PKATTACK:begin
             SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfRedWhite); //[攻击模式: 红名攻击]
             SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint); //[攻击模式: 红名攻击]
           end;
      end;
      SysMsg(sStartChangeAttackModeHelp, c_Green, t_Hint); //使用组合快捷键 CTRL-H 更改攻击...
      nCode:= 21;
      if m_dwKillMonExpRateTime > 0 then begin//双倍经验时间内,进入游戏提示 20080615
        SysMsg(Format(g_sChangeKillMonExpRateMsg, [m_nKillMonExpRate / 100, m_dwKillMonExpRateTime]), c_Green, t_Hint);
      end;
      nCode:= 22;
      if g_Config.boTestServer then
        SysMsg(sStartNoticeMsg, c_Green, t_Hint); //欢迎进入本服务器进行游戏...
      if UserEngine.PlayObjectCount > g_Config.nTestUserLimit then begin
        if m_btPermission < 2 then begin
          nCode:= 23;
          SysMsg(sOnlineUserFull, c_Red, t_Hint);
          SysMsg(sForceDisConnect, c_Red, t_Hint);
          m_boEmergencyClose := True;
          m_boPlayOffLine := False;
        end;
      end;
    end;
    nCode:= 24;
    m_nBright := g_nGameTime;
    m_Abil.MaxExp := GetLevelExp(m_Abil.Level); //jacky 2004/09/15 登录重新取得升级所需经验值
    if m_boTrainingNG then begin//学过内功
      m_MaxExpSkill69:= GetSkill69Exp(m_NGLevel, m_Skill69MaxNH);//登录重新取内功心法升级经验 20081002
      SendMsg(Self, RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, ''); //内力值让别人看到 20081002
      SendMsg(Self, RM_MAGIC69SKILLEXP, 0, 0, 0, m_NGLevel, EncodeString(Inttostr(m_ExpSkill69)+'/'+Inttostr(m_MaxExpSkill69)));
    end;
    nCode:= 25;
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');//发送白天或晚上的状态
    SendMsg(Self, RM_SENDUSEITEMS, 0, 0, 0, 0, '');//发送使用的物品
    SendMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');//发送使用的魔法
    nCode:= 26;
    if m_MyHero <> nil then begin //发送英雄信息 人物是离线挂机状态
      SendDelayMsg(Self, RM_RECALLHERO, 0, Integer(m_MyHero), 0, 0, '', 1000);
      case THeroObject(m_MyHero).m_btStatus of
        1: THeroObject(m_MyHero).SysMsg( g_sHeroFollow, c_Green, t_Hint);//20080316
        0: THeroObject(m_MyHero).SysMsg( g_sHeroAttack, c_Green, t_Hint);//20080316
        2: THeroObject(m_MyHero).SysMsg( g_sHeroRest, c_Green, t_Hint);//20080316
      end;
      THeroObject(m_MyHero).SysMsg(g_sHeroLoginMsg, c_Green, t_Hint);
      if THeroObject(m_MyHero).m_nFirDragonPoint > g_Config.nMaxFirDragonPoint then THeroObject(m_MyHero).m_nFirDragonPoint:= g_Config.nMaxFirDragonPoint;//20080528 防止怒气调整后超过
      THeroObject(m_MyHero).SendMsg(m_MyHero, RM_FIRDRAGONPOINT, g_Config.nMaxFirDragonPoint, THeroObject(m_MyHero).m_nFirDragonPoint, 0, 0, '');//发送英雄怒气值
    end;
    nCode:= 27;
    //  FeatureChanged(); //增加，广播人物骑马信息
    m_MyGuild := g_GuildManager.MemberOfGuild(m_sCharName);
    if m_MyGuild <> nil then begin
      m_sGuildRankName := TGUild(m_MyGuild).GetRankName(Self, m_nGuildRankNo);
      if TGUild(m_MyGuild).GuildWarList.Count > 0 then begin//20080629
        for I := 0 to TGUild(m_MyGuild).GuildWarList.Count - 1 do begin
          SysMsg(TGUild(m_MyGuild).GuildWarList.Strings[I] + ' 正在与本行会进行行会战。', c_Green, t_Hint);
        end;
      end;
    end;
    nCode:= 28;
    RefShowName();
    if (m_nPayMent = 1) then begin
      if not bo6AB then SysMsg(sYouNowIsTryPlayMode, c_Red, t_Hint);
      nCode:= 29;
      m_nGoldMax := g_Config.nHumanTryModeMaxGold;
      if m_Abil.Level > g_Config.nTryModeLevel then begin
        SysMsg('测试状态可以使用到第 ' + IntToStr(g_Config.nTryModeLevel) + ' 级。', c_Red, t_Hint);
        SysMsg('链接中断，请到以下地址获得相关信息。(http://www.IGEM2.com.cn)', c_Red, t_Hint);
        m_boEmergencyClose := True;
        m_boPlayOffLine := False;
      end;
    end;
    nCode:= 30;
    if (m_nPayMent = 3) and (not bo6AB) then SysMsg(g_sNowIsFreePlayMode {'当前服务器运行于测试模式.'}, c_Green, t_Hint);
    if g_Config.boVentureServer then SysMsg('当前服务器运行于 不刷怪模式.', c_Green, t_Hint);
    if (m_MagicErgumSkill <> nil) and (not m_boUseThrusting) then begin
      m_boUseThrusting := True;
      SendSocket(nil, '+LNG');
    end;
    nCode:= 31;
    if m_PEnvir.m_boNORECONNECT then MapRandomMove(m_PEnvir.sNoReconnectMap, 0);
    nCode:= 32;
    if CheckDenyLogon() then begin //如果人物在禁止登录列表里则直接掉线而不执行下面内容
      m_boEmergencyClose := True; //2006-11-18 修正禁止人物登陆不下线的问题
      m_boPlayOffLine := False;
      Exit;
    end;
    {==============================人物超过限制踢下线===========================}
{$IF UserMode1 = 1}
    nCode:= 33;
    if UserEngine.PlayObjectCount > UserEngine.m_nLimitUserCount then begin //20080630(注册)
      if m_btPermission < 10 then begin
        m_boPlayOffLine := False;
        m_boEmergencyClose := True;
        Exit;
      end;
    end;
{$IFEND}
    {==============================================================================}
    nCode:= 34;
    if g_ManageNPC <> nil then begin
      g_ManageNPC.GotoLable(Self, '@Login', False);
    end;

    nCode:= 35;
    m_boFixedHideMode := False; //01/21 增加
    // PlayObject.Create 过程里被置为True，在执行完登录脚本后再置False
    if m_sDearName <> '' then CheckMarry();
    CheckMaster();
    nCode:= 36;
    m_boFilterSendMsg := GetDisableSendMsgList(m_sCharName);
    nCode:= 37;
    //密码保护系统
    if g_Config.boPasswordLockSystem then begin
      if m_boPasswordLocked then begin
        m_boCanGetBackItem := not g_Config.boLockGetBackItemAction;
      end;
      nCode:= 38;
      if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked then begin
        m_boCanDeal := not g_Config.boLockDealAction;
        m_boCanDrop := not g_Config.boLockDropAction;
        m_boCanUseItem := not g_Config.boLockUserItemAction;
        m_boCanWalk := not g_Config.boLockWalkAction;
        m_boCanRun := not g_Config.boLockRunAction;
        m_boCanHit := not g_Config.boLockHitAction;
        m_boCanSpell := not g_Config.boLockSpellAction;
        m_boCallHero:= not g_Config.boLockCallHeroAction;//是否锁定召唤英雄操作  20080529
        m_boCanSendMsg := not g_Config.boLockSendMsgAction;
        m_boObMode := g_Config.boLockInObModeAction;
        //m_boAdminMode := g_Config.boLockInObModeAction;
{$IF VEROWNER = WL}
        SysMsg(g_sActionIsLockedMsg + ' 开锁命令: @' + g_GameCommand.LOCKLOGON.sCmd, c_Red, t_Hint);
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sActionIsLockedMsg + '\ \'
          + '密码命令: @' + g_GameCommand.PASSWORDLOCK.sCmd);
      end;
      if not m_boPasswordLocked then begin
        SysMsg(Format(g_sPasswordNotSetMsg, [g_GameCommand.PASSWORDLOCK.sCmd]), c_Red, t_Hint);
      end;
      if not m_boLockLogon and m_boPasswordLocked then begin
        SysMsg(Format(g_sNotPasswordProtectMode, [g_GameCommand.LOCKLOGON.sCmd]), c_Red, t_Hint);
      end;
{$ELSE}
      nCode:= 39;
      SysMsg(g_sActionIsLockedMsg + ' 开锁命令: @' + g_GameCommand.UnLock.sCmd, c_Red, t_Hint);
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sActionIsLockedMsg + '\ \'
        + '开锁命令: @' + g_GameCommand.UnLock.sCmd + '\'
        + '加锁命令: @' + g_GameCommand.Lock.sCmd + '\'
        + '设置密码命令: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
        + '修改密码命令: @' + g_GameCommand.CHGPASSWORD.sCmd);
    end;
{$IFEND}    
  end;
  nCode:= 40;
  //重置泡点方面计时
  m_dwIncGamePointTick := GetTickCount();
  m_dwIncGameGoldTick := GetTickCount();
  m_dwAutoGetExpTick := GetTickCount();
  nCode:= 31;
  GetSellOffGlod;//检查是否有元宝寄售交易结束还没得到元宝 20080318
  nCode:= 32;
  IsItem_51(1);//发送聚灵珠的经验 20080404
  if (m_btMagBubbleDefenceLevel = 4) and (m_dwStatusArrTick[STATE_BUBBLEDEFENCEUP] > 0) then StatusChanged('444')//20080811 4级盾,发个消息给客户端显示特有的效果;
  except
    on E: Exception do begin
      MainOutMessage(sExceptionMsg+' Name:'+m_sCharName+'  Code:'+inttostr(nCode));
    end;
  end;
end;

(*未使用 20080329
procedure TPlayObject.ReadAllBook();
//var
//  I: Integer;
//  Magic: pTMagic;
//  UserMagic: pTUserMagic;
//  OldMagicList: TList;
begin
  {UserMagic := nil;
  Magic := nil;
  if (UserEngine.m_boStartLoadMagic) and (UserEngine.OldMagicList.Count > 0) then begin
    OldMagicList := TList(UserEngine.OldMagicList.Items[0]);
    for i := 0 to OldMagicList.Count - 1 do begin
      Magic := OldMagicList.Items[i];
      New(UserMagic);
      UserMagic.MagicInfo := Magic;
      UserMagic.wMagIdx := Magic.wMagicId;
      UserMagic.btLevel := 2;
      UserMagic.btKey := 0;
      UserMagic.btLevel := 0;
      UserMagic.nTranPoint := 100000;
      m_MagicList.Add(UserMagic);
      SendAddMagic(UserMagic);
    end;
  end else begin
    for i := 0 to UserEngine.m_MagicList.Count - 1 do begin
      Magic := UserEngine.m_MagicList.Items[i];
      New(UserMagic);
      UserMagic.MagicInfo := Magic;
      UserMagic.wMagIdx := Magic.wMagicId;
      UserMagic.btLevel := 2;
      UserMagic.btKey := 0;
      UserMagic.btLevel := 0;
      UserMagic.nTranPoint := 100000;
      m_MagicList.Add(UserMagic);
      SendAddMagic(UserMagic);
    end;
  end;}
end; *)

procedure TPlayObject.SendGoldInfo(boSendName: Boolean);
var
  sMsg: string;
begin
  //if m_nSoftVersionDateEx = 0 then Exit;
  if boSendName then
    sMsg := g_Config.sGameGoldName + #13 + g_Config.sGamePointName + #13 + g_Config.sGameDiaMond + #13 + g_Config.sGameGird;
  SendDefMessage(SM_GAMEGOLDNAME, //20080211 向客户端发送游戏币,游戏点,金刚石,灵符数量
    m_nGameGold,//游戏币
    m_nGamePoint,//游戏点
    m_nGameDiaMond,//金刚石
    m_nGameGird,//灵符
    sMsg);
end;
//发送荣誉值 20080511
procedure TPlayObject.SendGloryInfo;
begin
  SendDefMessage(SM_GLORY, //20080511 向客户端发送荣誉值
    m_btGameGlory,//荣誉值
    0,
    0,
    0, '');
end;
//发送登录
procedure TPlayObject.SendLogon;
var
  MessageBodyWL: TMessageBodyWL;
  nRecog: Integer;
begin
  m_DefMsg := MakeDefaultMsg(SM_LOGON, Integer(Self), m_nCurrX, m_nCurrY, MakeWord(m_btDirection, m_nLight), 0);
  MessageBodyWL.lParam1 := GetFeatureToLong();//人物着装
  MessageBodyWL.lParam2 := m_nCharStatus;//人物状态
  m_boAllowGroup:= False;//20080803 关闭组队状态
  {if m_boAllowGroup then MessageBodyWL.lTag1 := MakeLong(MakeWord(1, 0), GetFeatureEx)//20080615 注释  实现上线自动关组
  else }MessageBodyWL.lTag1 := 0;
  MessageBodyWL.lTag2 := 0;
  SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));

  nRecog := GetFeatureToLong();
  SendDefMessage(SM_FEATURECHANGED,
    Integer(Self),
    LoWord(nRecog),
    HiWord(nRecog),
    GetFeatureEx,
    '');
end;
//发送配置文件(客户端相关)
procedure TPlayObject.SendServerConfig;
var
  nRecog, nParam: Integer;
  nRunHuman, nRunMon, nRunNpc, nWarRunAll: Integer;
  ClientConf: TClientConf;
  sMsg: string;
begin
  if m_nSoftVersionDateEx = 0 then Exit;

  nRunHuman := 0;
  nRunMon := 0;
  nRunNpc := 0;
  nWarRunAll := 0;

  if g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) or (g_Config.boSafeAreaLimited and InSafeZone) then begin
    nRunHuman := 1;
    nRunMon := 1;
    nRunNpc := 1;
    nWarRunAll := 1;
  end else begin
    if g_Config.boRUNHUMAN or m_PEnvir.m_boRUNHUMAN then nRunHuman := 1;
    if g_Config.boRUNMON or m_PEnvir.m_boRUNMON then nRunMon := 1;
    if g_Config.boRunNpc then nRunNpc := 1;
    if g_Config.boWarDisHumRun then nWarRunAll := 1;
  end;
  ClientConf := g_Config.ClientConf;

  ClientConf.boRUNHUMAN := nRunHuman = 1;
  ClientConf.boRUNMON := nRunMon = 1;
  ClientConf.boRunNpc := nRunNpc = 1;
  ClientConf.boWarRunAll := nWarRunAll = 1;
  ClientConf.wSpellTime := g_Config.dwMagicHitIntervalTime + 300;
  ClientConf.wHitIime := g_Config.dwHitIntervalTime + 500;
  ClientConf.boSkill31Effect:= g_Config.boSkill31Effect;//魔法盾效果 T-特色效果 F-盛大效果 20080808

  sMsg := EncodeBuffer(@ClientConf, SizeOf(ClientConf));
  nRecog := MakeLong(MakeWord(nRunHuman, nRunMon), MakeWord(nRunNpc, nWarRunAll));
  //nParam := MakeWord(5, 0);
  nParam := MakeWord(ClientConf.btDieColor, 0);//20080423 修改
  SendDefMessage(SM_SERVERCONFIG, nRecog, nParam, 0, 0, sMsg);
end;
//发送解包内容
procedure TPlayObject.SendUnBind;
var
  I: Integer;
  UnbindInfo: TUnbindInfo;
  sMsg: string;
  msg: TDefaultMessage;
begin
  sMsg := '';
  if g_UnbindList.Count > 0 then begin//20080629
    for I := 0 to g_UnbindList.Count - 1 do begin
      UnbindInfo.sItemName := g_UnbindList.Strings[I];
      UnbindInfo.nUnbindCode := Integer(g_UnbindList.Objects[I]);
      sMsg := sMsg + EncodeBuffer(@UnbindInfo, SizeOf(TUnbindInfo)) + '/';
    end;
  end;
  if sMsg <> '' then begin
    msg := MakeDefaultMsg(SM_SERVERUNBIND, 0, 0, 0, 0, 0);
    SendSocket(@msg, sMsg);
  end;
end;

procedure TPlayObject.SendServerStatus;
begin
  if m_btPermission < 10 then Exit;
  SysMsg(IntToStr(CalcFileCRC(Application.ExeName)), c_Red, t_Hint);
end;
//检查角色的座标是否在指定误差范围以内
//TargeTBaseObject 为要检查的角色，nX,nY 为比较的座标
//检查角色是否在指定座标的1x1 范围以内，如果在则返回True 否则返回 False
function TBaseObject.CretInNearXY(TargeTBaseObject: TBaseObject; nX,
  nY: Integer): Boolean;
var
  I: Integer;
  nCX, nCY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
begin
  Result := False;
  if m_PEnvir = nil then begin
    MainOutMessage('CretInNearXY nil PEnvir');
    Exit;
  end;
  for nCX := nX - 1 to nX + 1 do begin
    for nCY := nY - 1 to nY + 1 do begin
      if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin//20080629
          for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := pTOSObject(MapCellInfo.ObjList.Items[I]);
            if OSObject <> nil then begin
              if OSObject.btType = OS_MOVINGOBJECT then begin
                BaseObject := TBaseObject(OSObject.CellObj);
                if BaseObject <> nil then begin
                  if not BaseObject.m_boGhost and (BaseObject = TargeTBaseObject) then begin
                    Result := True;
                    Exit;
                  end;
                end;
              end;
            end;
          end;//for
        end;
      end;
    end;
  end;
end;
                    
function TBaseObject.CretInNearXY(TargeTBaseObject: TBaseObject; nX,
  nY: Integer; nRange: Integer): Boolean;
var
  I: Integer;
  nCX, nCY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
begin
  Result := False;
  if m_PEnvir = nil then begin
    MainOutMessage('CretInNearXY nil PEnvir');
    Exit;
  end;
  for nCX := nX - nRange to nX + nRange do begin
    for nCY := nY - nRange to nY + nRange do begin
      if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin//20080629
          for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := pTOSObject(MapCellInfo.ObjList.Items[I]);
            if OSObject <> nil then begin
              if OSObject.btType = OS_MOVINGOBJECT then begin
                BaseObject := TBaseObject(OSObject.CellObj);
                if BaseObject <> nil then begin
                  if not BaseObject.m_boGhost and (BaseObject = TargeTBaseObject) then begin
                    Result := True;
                    Exit;
                  end;
                end;
              end;
            end;
          end;//for
        end;
      end;
    end;
  end;
end;
//清除下属 20080124 除英雄,135怪外
procedure TBaseObject.KillSlave;
var
  I: Integer;
  Slave: TBaseObject;
begin
  if m_SlaveList.Count > 0 then begin//20080629
    for I := 0 to m_SlaveList.Count - 1 do begin
      Slave := TBaseObject(m_SlaveList.Items[I]);
      if Slave <> nil then begin
        case Slave.m_btRaceServer of
         11..65,67..99,101..107,110..111,115..120,136,150: begin
            Slave.m_WAbil.HP := 0;
            Slave.MakeGhost;//20081005
          end;
        end;
      end;
    end;
  end;
end;
//发送内功数据 20081005
procedure TBaseObject.SendNGData;
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    TPlayObject(self).m_MaxExpSkill69:= GetSkill69Exp(TPlayObject(self).m_NGLevel, TPlayObject(self).m_Skill69MaxNH);//取内功心法升级经验 20081002
    TPlayObject(self).m_Skill69NH:= TPlayObject(self).m_Skill69MaxNH;
    TPlayObject(self).SendRefMsg(RM_MAGIC69SKILLNH, 0, TPlayObject(self).m_Skill69NH, TPlayObject(self).m_Skill69MaxNH, 0, ''); //内力值让别人看到 20081002
    SendMsg(self, RM_MAGIC69SKILLEXP, 0, 0,
                         0, TPlayObject(self).m_NGLevel, EncodeString(Inttostr(TPlayObject(self).m_ExpSkill69)+'/'+Inttostr(TPlayObject(self).m_MaxExpSkill69)));
  end else
  if m_btRaceServer = RC_HEROOBJECT then begin
    THEROOBJECT(self).m_MaxExpSkill69:= GetSkill69Exp(THEROOBJECT(self).m_NGLevel, THEROOBJECT(self).m_Skill69MaxNH);//取内功心法升级经验 20081002
    THEROOBJECT(self).m_Skill69NH:= THEROOBJECT(self).m_Skill69MaxNH;
    THEROOBJECT(self).SendRefMsg(RM_MAGIC69SKILLNH, 0, THEROOBJECT(self).m_Skill69NH, THEROOBJECT(self).m_Skill69MaxNH, 0, ''); //内力值让别人看到 20081002
    THEROOBJECT(self).SendMsg(self, RM_HEROMAGIC69SKILLEXP, 0, 0,
                  0, THEROOBJECT(self).m_NGLevel, EncodeString(Inttostr(THEROOBJECT(self).m_ExpSkill69)+'/'+Inttostr(THEROOBJECT(self).m_MaxExpSkill69)));
  end;
end;
//检查物品附加属性是否正常 20081006
function TBaseObject.CheckIsOKItem(UserItem: pTUserItem; nType: Integer): Boolean;
begin
  Result:= False;
  if UserItem <> nil then begin
      if (UserItem.btValue[15] > 1) or (UserItem.btValue[16] > 1) or
         (UserItem.btValue[17] > 1) or (UserItem.btValue[18] > 1) or 
         (UserItem.btValue[19] > 1) then Result := True;
{    case nType of
      5, 6: begin//武器
        if (UserItem.btValue[0] > g_Config.nWeaponDCAddValueMaxLimit) or
           (UserItem.btValue[1] > g_Config.nWeaponMCAddValueMaxLimit) or
           (UserItem.btValue[2] > g_Config.nWeaponSCAddValueMaxLimit) then Result:= True;
      end;
      10, 11: begin//衣服
        if (UserItem.btValue[0] > g_Config.nDressACAddValueMaxLimit) or
           (UserItem.btValue[1] > g_Config.nDressMACAddValueMaxLimit) or
           (UserItem.btValue[2] > g_Config.nDressDCAddValueMaxLimit) or
           (UserItem.btValue[3] > g_Config.nDressMCAddValueMaxLimit) or
           (UserItem.btValue[4] > g_Config.nDressSCAddValueMaxLimit) then Result:= True;
      end;
      19: begin//项链(幸运型)
        if (UserItem.btValue[0] > g_Config.nNeckLace19ACAddValueMaxLimit) or
           (UserItem.btValue[1] > g_Config.nNeckLace19MACAddValueMaxLimit) or
           (UserItem.btValue[2] > g_Config.nNeckLace19DCAddValueMaxLimit) or
           (UserItem.btValue[3] > g_Config.nNeckLace19MCAddValueMaxLimit) or
           (UserItem.btValue[4] > g_Config.nNeckLace19SCAddValueMaxLimit) then Result:= True;
      end;
      20, 21, 24: begin//项链(准确敏捷型、体力魔法恢复型)、手镯(特别型)
        if (UserItem.btValue[0] > g_Config.nNeckLace202124ACAddValueMaxLimit) or
           (UserItem.btValue[1] > g_Config.nNeckLace202124MACAddValueMaxLimit) or
           (UserItem.btValue[2] > g_Config.nNeckLace202124DCAddValueMaxLimit) or
           (UserItem.btValue[3] > g_Config.nNeckLace202124MCAddValueMaxLimit) or
           (UserItem.btValue[4] > g_Config.nNeckLace202124SCAddValueMaxLimit) then Result:= True;
      end;
      26: begin//手套手镯
        if (UserItem.btValue[0] > g_Config.nArmRing26ACAddValueMaxLimit) or
           (UserItem.btValue[1] > g_Config.nArmRing26MACAddValueMaxLimit) or
           (UserItem.btValue[2] > g_Config.nArmRing26DCAddValueMaxLimit) or
           (UserItem.btValue[3] > g_Config.nArmRing26MCAddValueMaxLimit) or
           (UserItem.btValue[4] > g_Config.nArmRing26SCAddValueMaxLimit) then Result:= True;
      end;
      22: begin//戒指
        if (UserItem.btValue[2] > g_Config.nRing22DCAddValueMaxLimit) or
           (UserItem.btValue[3] > g_Config.nRing22MCAddValueMaxLimit) or
           (UserItem.btValue[4] > g_Config.nRing22SCAddValueMaxLimit) then Result:= True;
      end;
      23: begin//戒指(特别型)
        if (UserItem.btValue[0] > g_Config.nRing23ACAddValueMaxLimit) or
           (UserItem.btValue[1] > g_Config.nRing23MACAddValueMaxLimit) or
           (UserItem.btValue[2] > g_Config.nRing23DCAddValueMaxLimit) or
           (UserItem.btValue[3] > g_Config.nRing23MCAddValueMaxLimit) or
           (UserItem.btValue[4] > g_Config.nRing23SCAddValueMaxLimit) then Result:= True;
      end;
      15,16: begin//头盔,斗笠
        if (UserItem.btValue[0] > g_Config.nHelMetACAddValueMaxLimit) or
           (UserItem.btValue[1] > g_Config.nHelMetMACAddValueMaxLimit) or
           (UserItem.btValue[2] > g_Config.nHelMetDCAddValueMaxLimit) or
           (UserItem.btValue[3] > g_Config.nHelMetMCAddValueMaxLimit) or
           (UserItem.btValue[4] > g_Config.nHelMetSCAddValueMaxLimit) then Result:= True;
      end;
      52,54,62,64: begin//鞋子，腰带
        if (UserItem.btValue[0] > g_Config.nBootsACAddValueMaxLimit) or
           (UserItem.btValue[1] > g_Config.nBootsMACAddValueMaxLimit) or
           (UserItem.btValue[2] > g_Config.nBootsDCAddValueMaxLimit) or
           (UserItem.btValue[3] > g_Config.nBootsMCAddValueMaxLimit) or
           (UserItem.btValue[4] > g_Config.nBootsSCAddValueMaxLimit) then Result:= True;
      end;
    end;//case   }
  end;
end;

//盛大吸伤装备,减少受伤值  20080223     U_RINGR//右戒指  U_RINGL//左戒指   衣服武器不能吸伤 20080315
function TBaseObject.ItemStruckDamage(nDamage: Integer): Integer;
var
  I,nCount: Integer;
  StdItem: pTStdItem;
begin
  nCount:= 0;//吸伤装备带在身,减少受伤值的百分比
  try
    for I := Low(THumanUseItems) to High(THumanUseItems) do begin
      if m_UseItems[I].wIndex > 0 then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if StdItem <> nil then begin
          Case StdItem.StdMode of
            15,16,19..24,26,30,52,54,62,64:begin//头盔,项链,戒指,手镯,鞋子,腰带,勋章
               if StdItem.Shape = 188 then begin
                 nCount:= nCount + StdItem.Source + m_UseItems[I].btValue[20];
               end;
             end;
          end;
        end; //if pSItem <> nil then begin
      end; //if UseItems[i].wIndex > 0 then begin
    end; // for i:=Low(UseItems) to High(UseItems) do begin
    if nCount > 100 then nCount:= 100;
  except
    MainOutMessage('{异常} TBaseObject.ItemStruckDamage');
  end;
  Result:= Round(nDamage * (100 - nCount) div 100); //20080812 吸伤百分率
end;
//------------------------------------------------------------------------------
//套装与身上装备对比 20080226  boHint-是否进入触发段
procedure TBaseObject.CompareSuitItem(boHint: boolean);
  function IsChar(str:string):integer;//判断有几个'|'号
  var I:integer;
  begin
    Result:= 0;
    if length(str) <=0 then Exit;
      for I:=1 to length(str) do
        if (str[I] = '|') then Inc(Result);
  end;
var
  SuitItem: pTSuitItem;
  I,K,J,nCount: Integer;
  Str, Str1: String;
  StdItem: pTStdItem;
  boSuitItem: Boolean;
  Temp:TstringList;
  nMaxHP, nMaxMP: Word;
  nCode: Byte;
begin
  nCode:= 0;
  try
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer =RC_HEROOBJECT) then begin//20081231 英雄和人才进行套装配对
      boSuitItem:= False;
      nMaxHP:= 0;
      nMaxMP:= 0;
      if SuitItemList.count > 0 then begin//20080629
        nCode:= 1;
        for I:= 0 to SuitItemList.count -1 do begin
          SuitItem:= pTSuitItem(SuitItemList.Items[I]);
          nCode:= 2;
          if SuitItem <> nil then begin
            nCount:= 0;
            Str1:= SuitItem.Name;
            nCode:= 3;
            Temp:= TstringList.Create;
            Try
              for K:= 0 to IsChar(Str1) do begin
                str1:=GetValidStr3(Str1,str,['|']);
                if str <> '' then Temp.Add(str);
              end;
              nCode:= 4;
              for J := Low(THumanUseItems) to High(THumanUseItems) do begin
                if m_UseItems[J].wIndex > 0 then begin
                  StdItem := UserEngine.GetStdItem(m_UseItems[J].wIndex);
                  if StdItem <> nil then begin
                    for K:= Temp.Count -1 downto 0 do begin
                      if Temp.Count <=0 then break;//20080917
                      str:= Temp.Strings[K];
                      if CompareText(Str, StdItem.Name) = 0 then begin
                        Inc(nCount);
                        Temp.Delete(K);
                        Break;
                      end;
                    end;
                  end;
                  nCode:= 5;
                  if nCount = SuitItem.ItemCount then begin//数量一样
                    nMaxHP := _MIN(High(Word), nMaxHP + Round(m_WAbil.MaxHP * (SuitItem.MaxHP / 100)));//HP上限增加比率 20081018
                    nMaxMP := _MIN(High(Word), nMaxMP + Round(m_WAbil.MaxMP * (SuitItem.MaxMP / 100)));//MP上限增加比率 20081018

                    m_WAbil.AC := MakeLong(LoWord(SuitItem.MaxAC) + LoWord(m_WAbil.AC) , SuitItem.AC + HiWord(m_WAbil.AC));//防御
                    m_WAbil.MAC := MakeLong(LoWord(SuitItem.MaxMAC) + LoWord(m_WAbil.MAC), SuitItem.MAC + HiWord(m_WAbil.MAC));//魔防
                    m_WAbil.DC := MakeLong(LoWord(SuitItem.MaxDC) + LoWord(m_WAbil.DC), SuitItem.DC + HiWord(m_WAbil.DC));//攻击力
                    m_WAbil.MC := MakeLong(LoWord(SuitItem.MaxMC) + LoWord(m_WAbil.MC), SuitItem.MC + HiWord(m_WAbil.MC));//魔法
                    m_WAbil.SC := MakeLong(LoWord(SuitItem.MaxSC) + LoWord(m_WAbil.SC), SuitItem.SC + HiWord(m_WAbil.SC));//道术
                    Inc(m_btHitPoint, SuitItem.HitPoint);//准确
                    Inc(m_btSpeedPoint, SuitItem.SpeedPoint);//敏捷
                    Inc(m_nHealthRecover, SuitItem.HealthRecover);//体力恢复
                    Inc(m_nSpellRecover, SuitItem.SpellRecover);//魔法恢复
                    Inc(m_nLuck, SuitItem.RiskRate);//人物的幸运值Luck (爆率机率)
                    Inc(m_nAntiMagic, SuitItem.nAntiMagic);//魔法躲避
                    Inc(m_btAntiPoison, SuitItem.nAntiPoison);//中毒躲避
                    Inc(m_nPoisonRecover, SuitItem.nPoisonRecover);//中毒恢复
                    Inc(m_nHongMoSuite,SuitItem.btReserved);//吸血(虹吸) 20080824
                    if SuitItem.nPowerRate > 0 then
                      m_WAbil.DC :=MakeLong(LoWord(m_WAbil.DC)* SuitItem.nPowerRate, HiWord(m_WAbil.DC)* SuitItem.nPowerRate);//攻击倍数
                    if SuitItem.nMagicRate > 0 then
                      m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC)* SuitItem.nMagicRate,  HiWord(m_WAbil.MC)* SuitItem.nMagicRate);//魔法倍数
                    if SuitItem.nSCRate > 0 then
                       m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC)* SuitItem.nSCRate, HiWord(m_WAbil.SC)* SuitItem.nSCRate);//道术倍数
                    if SuitItem.nACRate > 0 then
                       m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) * SuitItem.nACRate, HiWord(m_WAbil.AC) * SuitItem.nACRate);//防御倍数
                    if SuitItem.nMACRate > 0 then
                       m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) * SuitItem.nMACRate, HiWord(m_WAbil.MAC) * SuitItem.nMACRate);//魔御倍数
                    if (m_btRaceServer = RC_PLAYOBJECT) and (SuitItem.nEXPRATE > 0) then begin
                      TPlayObject(self).m_nItmeIncMonExpRate:= (SuitItem.nEXPRATE -1) * TPlayObject(self).m_nOldKillMonExpRate;//使用套装增加的经验 20080607
                      TPlayObject(self).m_nKillMonExpRate:= SuitItem.nEXPRATE * TPlayObject(self).m_nOldKillMonExpRate; //经验倍数 20080607
                    end else
                    if (m_btRaceServer =RC_HEROOBJECT) and (SuitItem.nEXPRATE > 0) then begin
                      THeroObject(self).m_nKillMonExpRate:= SuitItem.nEXPRATE * THeroObject(self).m_nOldKillMonExpRate; //经验倍数 20080607
                    end;
                    nCode:= 6;
                    if SuitItem.boTeleport then m_boTeleport := True;//传送 20080824
                    if SuitItem.boParalysis then m_boParalysis := True;//麻痹
                    if SuitItem.boRevival then m_boRevival := True;//复活
                    if SuitItem.boMagicShield then m_boMagicShield := True;//护身
                    if SuitItem.boUnParalysis then m_boUnParalysis := True;//防麻痹
                    nCode:= 7;
                    if (g_FunctionNPC <> nil) and boHint then begin
                      if m_btRaceServer = RC_PLAYOBJECT then begin
                        g_FunctionNPC.GotoLable(TPlayObject(Self), '@SuitItem'+inttostr(I), False); //套装触发 20080712
                      end else
                      if (m_btRaceServer =RC_HEROOBJECT) and (m_Master <> nil) then begin
                        g_FunctionNPC.GotoLable(TPlayObject(m_Master), '@SuitItem'+inttostr(I), False); //套装触发 20080712
                      end;
                    end;
                    boSuitItem:= True;
                    Break;
                  end;
                end;
              end;
            finally
              Temp.Free;
            end;
          end;
        end;//for
        m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + nMaxHP);
        m_WAbil.MaxMP := _MIN(High(Word), m_WAbil.MaxMP + nMaxMP);
      end;
      nCode:= 8;
      if not boSuitItem then begin//不带上套装,则恢复原来的经验倍数
        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(self).m_nKillMonExpRate := TPlayObject(self).m_nOldKillMonExpRate;//20080522
          TPlayObject(self).m_nItmeIncMonExpRate:= 0;//使用套装增加的经验 20080607
        end else
        if m_btRaceServer =RC_HEROOBJECT then
          THeroObject(self).m_nKillMonExpRate:= THeroObject(self).m_nOldKillMonExpRate;//20080522
      end;
    end;
  except
    MainOutMessage('{异常} TBaseObject.CompareSuitItem Code:'+inttostr(nCode));
  end;
end;
//------------------------------------------------------------------------------
function TBaseObject.CheckItemValue(UserItem: pTUserItem; nType: Integer): Boolean;//判断绑定物品的属性 20080314
begin
  Result:=False;
  if UserItem <> nil then begin
    case nType of
      0: if UserItem.btValue[14] = 1 then Result := True;//禁止扔
      1: if UserItem.btValue[15] = 1 then Result := True;//禁止交易
      2: if UserItem.btValue[16] = 1 then Result := True;//禁止存
      3: if UserItem.btValue[17] = 1 then Result := True;//禁止修
      4: if UserItem.btValue[18] = 1 then Result := True;//禁止出售
      5: if UserItem.btValue[19] = 1 then Result := True;//禁止爆出
    end;
  end;
end;
//------------------------------------------------------------------------------
procedure TPlayObject.SendUseitems;
var
  I: Integer;
  Item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  StdItem: TStdItem;
  sUserItemName: string;
begin
  {if Assigned(zPlugOfEngine.SendUseitemsMsg) then begin//20080813 注释
    zPlugOfEngine.SendUseitemsMsg(Self);
  end else begin}
    if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then begin
      sSENDMSG := '';
      for I := Low(THumItems) to High(THumItems) do begin
        if m_UseItems[I].wIndex > 0 then begin
          Item := UserEngine.GetStdItem(m_UseItems[I].wIndex);
          if Item <> nil then begin
            StdItem := Item^;
            ItemUnit.GetItemAddValue(@m_UseItems[I], StdItem);
            CopyStdItemToOStdItem(@StdItem, @OClientItem.s);

            //取自定义物品名称
            sUserItemName := '';
            if m_UseItems[I].btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[I].MakeIndex, m_UseItems[I].wIndex);
            if sUserItemName <> '' then
              OClientItem.s.Name := sUserItemName;

            OClientItem.Dura := m_UseItems[I].Dura;
            OClientItem.DuraMax := m_UseItems[I].DuraMax;
            OClientItem.MakeIndex := m_UseItems[I].MakeIndex;
            sSENDMSG := sSENDMSG + IntToStr(I) + '/' + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
          end;
        end;
      end;
      if sSENDMSG <> '' then begin
        m_DefMsg := MakeDefaultMsg(SM_SENDUSEITEMS, 0, 0, 0, 0, 0);
        SendSocket(@m_DefMsg, sSENDMSG);
      end;
    end else begin
      sSENDMSG := '';
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin
        if m_UseItems[I].wIndex > 0 then begin
          //sItemNewName:=GetItemName(m_UseItems[i].MakeIndex);
          Item := UserEngine.GetStdItem(m_UseItems[I].wIndex);
          if Item <> nil then begin
            StdItem := Item^;
            ItemUnit.GetItemAddValue(@m_UseItems[I], StdItem);
            Move(StdItem, ClientItem.s, SizeOf(TStdItem));

            //取自定义物品名称
            sUserItemName := '';
            if m_UseItems[I].btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[I].MakeIndex, m_UseItems[I].wIndex);
            if sUserItemName <> '' then
              ClientItem.s.Name := sUserItemName;
            if m_UseItems[I].btValue[12] = 1 then ClientItem.s.Reserved1:=1//物品发光 20080224
            else ClientItem.s.Reserved1:= 0;

            ClientItem.Dura := m_UseItems[I].Dura;
            ClientItem.DuraMax := m_UseItems[I].DuraMax;
            ClientItem.MakeIndex := m_UseItems[I].MakeIndex;
            sSENDMSG := sSENDMSG + IntToStr(I) + '/' + EncodeBuffer(@ClientItem, SizeOf(TClientItem)) + '/';
          end;
        end;
      end;
      if sSENDMSG <> '' then begin
        m_DefMsg := MakeDefaultMsg(SM_SENDUSEITEMS, 0, 0, 0, 0, 0);
        SendSocket(@m_DefMsg, sSENDMSG);
      end;
    end;
  //end;//20080813 注释
end;
//发送使用的魔法
procedure TPlayObject.SendUseMagic;
var
  I: Integer;
  sSENDMSG: string;
  UserMagic: pTUserMagic;
  ClientMagic: TClientMagic;
begin
 { if Assigned(zPlugOfEngine.SendUseMagicMsg) then begin //20080813 注释
    zPlugOfEngine.SendUseMagicMsg(Self);
  end else begin}
    sSENDMSG := '';
    if m_MagicList.Count > 0 then begin//20080629
      for I := 0 to m_MagicList.Count - 1 do begin
        UserMagic := m_MagicList.Items[I];
        if UserMagic <> nil then begin
          ClientMagic.Key := Chr(UserMagic.btKey);
          ClientMagic.Level := UserMagic.btLevel;
          ClientMagic.CurTrain := UserMagic.nTranPoint;
          ClientMagic.Def := UserMagic.MagicInfo^;
          sSENDMSG := sSENDMSG + EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)) + '/';
        end;
      end;//for
    end;
    if sSENDMSG <> '' then begin
      m_DefMsg := MakeDefaultMsg(SM_SENDMYMAGIC, 0, 0, 0, m_MagicList.Count, 0);
      SendSocket(@m_DefMsg, sSENDMSG);
    end;
 //end;//20080813 注释
end;
//客户端改变方向
function TPlayObject.ClientChangeDir(wIdent: Word; nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean; //4CAEB8
var
  dwCheckTime: LongWord;
begin
  Result := False;
  if m_boDeath or (m_wStatusTimeArr[POISON_STONE {5}]<> 0) then Exit; //防麻
  if not CheckActionStatus(wIdent, dwDelayTime) then begin
    m_boFilterAction := False;
    Exit;
  end;
  m_boFilterAction := True;
  dwCheckTime := GetTickCount - m_dwTurnTick;
  if dwCheckTime < g_Config.dwTurnIntervalTime then begin
    dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
    {
    if dwCheckTime <= g_Config.dwTurnIntervalTime div 2 then begin
      SysMsg('ClientChangeDir ' + IntToStr(dwCheckTime);
      m_boEmergencyClose:=True;
      Result:=True;
    end;
    }
    Exit;
  end;

  if (nX = m_nCurrX) and (nY = m_nCurrY) then begin
    m_btDirection := nDir;
    if Walk(RM_TURN) then begin
      m_dwTurnTick := GetTickCount();
      Result := True;
    end;
  end;
end;
//客户端蹲下的动作
function TPlayObject.ClientSitDownHit(nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean; //004CC248
var
  dwCheckTime: LongWord;
begin
  Result := False;
  if m_boDeath or (m_wStatusTimeArr[POISON_STONE {5}]<> 0) then Exit; //防麻

  dwCheckTime := GetTickCount - m_dwTurnTick;

  if dwCheckTime < g_Config.dwTurnIntervalTime then begin
    dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
    Exit;
  end;
  m_dwTurnTick := GetTickCount;
  SendRefMsg(RM_POWERHIT, 0, 0, 0, 0, '');
  Result := True;
end;
//开门,人物走到地图的某个过门点时
procedure TPlayObject.ClientOpenDoor(nX, nY: Integer);
var
  Door: pTDoorInfo;
  Castle: TUserCastle;
begin
  Door := m_PEnvir.GetDoor(nX, nY);
  if Door = nil then Exit;
  Castle := g_CastleManager.IsCastleEnvir(m_PEnvir);
  if (Castle = nil) or
    (Castle.m_DoorStatus <> Door.Status) or
    (m_btRaceServer <> RC_PLAYOBJECT) or
    Castle.CheckInPalace(m_nCurrX, m_nCurrY, Self) then begin
    UserEngine.OpenDoor(m_PEnvir, nX, nY);
  end;
  {
  if (UserCastle.m_MapCastle <> m_PEnvir) or
     (UserCastle.m_DoorStatus <> Door.Status) or
     (m_btRaceServer <> RC_PLAYOBJECT) or
     UserCastle.CheckInPalace(m_nCurrX,m_nCurrY,Self) then begin

    UserEngine.OpenDoor(m_PEnvir,nX,nY);
  end;
  }
end;
{$IF HEROVERSION = 1}
//创建英雄
function TPlayObject.MakeHero(PlayObject: TPlayObject; HumanRcd: THumDataInfo): TBaseObject;
var
  nX, nY: Integer;
  MonObj: TBaseObject;
begin
  Result := nil;
  GetFrontPosition(nX, nY);
  if (CompareText(PlayObject.m_sHeroCharName,HumanRcd.Data.sChrName) <> 0) or (not HumanRcd.Header.boIsHero) or (HumanRcd.Header.boDeleted) then Exit;//20080907
  MonObj := UserEngine.RegenMyHero(PlayObject, nX, nY, HumanRcd);
  //MonObj := UserEngine.AddHeroObject(PlayObject, nX, nY, @PlayObject.m_HeroData);
  if MonObj <> nil then begin
    MonObj.m_Master := Self;
    MonObj.m_dwMasterRoyaltyTick := {GetTickCount +} 1000000{1000 * 1000};
    MonObj.m_dwMasterRoyaltyTime := GetTickCount;//20080813 增加
    MonObj.m_btSlaveMakeLevel := Self.m_Abil.Level;
    MonObj.m_btSlaveExpLevel := Self.m_Abil.MaxExp;
    MonObj.RecalcAbilitys;
    MonObj.CompareSuitItem(False);//200080729 套装
    {if MonObj.m_WAbil.HP < MonObj.m_WAbil.MaxHP then begin//20080506 英雄下线,再召唤,HP还是原来的值
      MonObj.m_WAbil.HP := MonObj.m_WAbil.HP + (MonObj.m_WAbil.MaxHP - MonObj.m_WAbil.HP) div 2;
    end;}
    if MonObj.m_WAbil.HP <= 0 then begin//20080509 增加
       MonObj.m_WAbil.HP := (MonObj.m_WAbil.MaxHP div 15)+ 2;
    end;
    MonObj.RefNameColor;//刷新名字颜色
    Result := MonObj;
  end;
end;

//增加召唤英雄的时间间隔限制 20071201
procedure TPlayObject.ClientRecallHero(); //召唤英雄
begin
  if m_boWaitHeroDate or m_boDeath or m_boGhost then Exit;//20081022 死亡不能再召唤英雄
  if not m_boCallHero then Exit;//不能召唤英雄 20080124
  if m_MyHero <> nil then begin
    if m_MyHero.m_boDeath or m_MyHero.m_boGhost then m_MyHero := nil;
  end;
  if m_MyHero <> nil then begin
    SendUpdateMsg(Self, RM_RECALLHERO, 0, Integer(m_MyHero), 0, 0, '');
    Exit;
  end;
  m_boHeroLogOut:= False;//英雄退出 20080909
  if n_HeroSave <> 1 then begin
    if ((not m_boHasHero) or (not m_boHasHeroTwo)) and (m_sHeroCharName = '') then begin
      SysMsg(g_sNotHero{您还没有创建英雄！！！}, c_Red, t_Hint);
    end else begin
      if (GetTickCount() - m_nRecallHeroTime) > g_Config.nRecallHeroTime  then begin  //召唤英雄间隔 20071201
        m_nRecallHeroTime:=GetTickCount();//召唤英雄间隔 20071201
        FrontEngine.AddToLoadHeroRcdList(m_sHeroCharName, '', Self, 0);
      end else SysMsg(Format(g_sRecallHeroHint, [(g_Config.nRecallHeroTime-(GetTickCount() - m_nRecallHeroTime))div 1000]), c_Red, t_Hint); //召唤英雄间隔 20071201
    end;
  end else begin
    if m_sHeroCharName <> '' then begin
      if (GetTickCount() - m_nRecallHeroTime) > g_Config.nRecallHeroTime  then begin  //召唤英雄间隔 20071201
        m_nRecallHeroTime:=GetTickCount();//召唤英雄间隔 20071201
        FrontEngine.AddToLoadHeroRcdList(m_sHeroCharName, '', Self, 0);
      end else SysMsg(Format(g_sRecallHeroHint, [(g_Config.nRecallHeroTime-(GetTickCount() - m_nRecallHeroTime))div 1000]), c_Red, t_Hint); //召唤英雄间隔 20071201
    end;
  end;
end;

procedure TPlayObject.ClientHeroLogOut(nCode: Byte); //英雄退出
var
  FlowerEvent: TFlowerEvent;
begin
  try
    if m_boWaitHeroDate then Exit;
    if m_MyHero <> nil then begin
      if m_MyHero.m_TargetCret <> nil then begin//英雄攻击目标为英雄时,收回英雄,目标英雄则需要攻击主人
        if (m_MyHero.m_TargetCret.m_btRaceServer = RC_HEROOBJECT) then begin
          SetTargetCreat(m_MyHero.m_TargetCret);//20081023
          m_MyHero.m_TargetCret.SetLastHiter(self);//20081023
        end else
        if (m_MyHero.m_TargetCret.m_btRaceServer = RC_PLAYOBJECT) and (TPlayObject(m_MyHero.m_TargetCret).m_MyHero <> nil) then begin
          SetTargetCreat(m_MyHero.m_TargetCret);//20081023
          TPlayObject(m_MyHero.m_TargetCret).m_MyHero.SetLastHiter(self);//20081023
        end;
      end;
      m_boHeroLogOut:= True;//英雄退出 20080909
      THeroObject(m_MyHero).boCallLogOut:= True;//英雄正常退出
      THeroObject(m_MyHero).m_boDeath := True;//20081020
      UserEngine.SaveHeroRcd(Self);//保存英雄数据
      FlowerEvent := TFlowerEvent.Create(m_MyHero.m_PEnvir, m_MyHero.m_nCurrX, m_MyHero.m_nCurrY, SM_HEROLOGOUT, 4000); //英雄退出动画显示 20080629
      g_EventManager.AddEvent(FlowerEvent);
      SendDelayMsg(m_MyHero, RM_MAKEGHOSTHERO, 0, 0, 0, 0, '', 800);
      SendUpdateMsg(m_MyHero, RM_DESTROYHERO, 0, Integer(m_MyHero), 0, 0, '');//英雄销毁,左上角图标隐藏
      m_nRecallHeroTime:= GetTickCount();//召唤英雄间隔 20071201
      if nCode= 0 then SysMsg(g_sHeroClose{神奇的力量散去，你的英雄开始沉睡。}, c_Green, t_Hint);//20080426
    end;
  except
    MainOutMessage('{异常} TPlayObject.ClientHeroLogOut');
  end;
end;
//客户端改变英雄状态
procedure TPlayObject.ClientChgHeroStatus();
begin
  if m_boWaitHeroDate then Exit;
  if THeroObject(m_MyHero) <> nil then begin
    if THeroObject(m_MyHero).m_boProtectStatus then THeroObject(m_MyHero).m_boProtectStatus:= False;//守护时,一改变状态,则停止守护 20080913
    if THeroObject(m_MyHero).m_btStatus >= 2 then THeroObject(m_MyHero).m_btStatus := 0
    else Inc(THeroObject(m_MyHero).m_btStatus);
    case THeroObject(m_MyHero).m_btStatus of
      1: begin
          if THeroObject(m_MyHero).m_TargetCret <> nil then THeroObject(m_MyHero).m_TargetCret:= nil;//20080604
          THeroObject(m_MyHero).SysMsg(g_sHeroFollow, C_HeroHint, t_Hint);//20080316
        end;
      0: begin
          THeroObject(m_MyHero).SysMsg(g_sHeroAttack, C_HeroHint, t_Hint);//20080316
        end;
      2: begin
          if THeroObject(m_MyHero).m_TargetCret <> nil then THeroObject(m_MyHero).m_TargetCret:= nil;//20080604
          THeroObject(m_MyHero).SysMsg(g_sHeroRest, C_HeroHint, t_Hint);//20080316
        end;
    end;
  end;
end;
//英雄守护
procedure TPlayObject.ClientHeroProtect(nX, nY: Integer);
begin
  if m_boWaitHeroDate then Exit;
  if (g_Config.boNoSafeProtect and InSafeZone) or (m_PEnvir.m_boNOHEROPROTECT) then Exit;//20080603 增加英雄安全区内不能守护,地图禁止守护 20080629
  if THeroObject(m_MyHero) <> nil then begin
    THeroObject(m_MyHero).m_boProtectStatus := not THeroObject(m_MyHero).m_boProtectStatus;
    if THeroObject(m_MyHero).m_boProtectStatus then begin
      THeroObject(m_MyHero).m_boProtectOK:= False;//20080603
      THeroObject(m_MyHero).m_nProtectTargetX := nX;
      THeroObject(m_MyHero).m_nProtectTargetY := nY;
      THeroObject(m_MyHero).SysMsg(Format(g_sHeroProtect{'英雄:开始守护(%d/%d)'}, [nX, nY]), BB_Fuchsia, t_Hint)//20080316
    end else begin
      THeroObject(m_MyHero).m_boProtectOK:= False;//20080603
      THeroObject(m_MyHero).m_nProtectTargetX := -1;
      THeroObject(m_MyHero).m_nProtectTargetY := -1;
      THeroObject(m_MyHero).SysMsg(Format(g_sHeroNotProtect{'英雄:停止守护(%d/%d)'}, [nX, nY]), BB_Fuchsia, t_Hint);//20080316
    end;
  end;
end;
//锁定攻击目标
procedure TPlayObject.ClientHeroAttack(BaseObject: TBaseObject; nX, nY: Integer);
begin
  if GetTickCount - m_TargetTime > 1500 then begin //20080615 锁定目标间隔
    if m_boWaitHeroDate then Exit;
    if THeroObject(m_MyHero) <> nil then begin
      //if (THeroObject(m_MyHero).m_Abil.Level <= 22) then Exit;//英雄22级以下不能锁定 20080709
      if CretInNearXY(BaseObject, nX, nY) and (not THeroObject(m_MyHero).m_boDeath) then begin//20081020 修改
        if (BaseObject <> Self) and (BaseObject <> m_MyHero) and (not BaseObject.m_boDeath) then begin //20080415 加入,怪死后不能再锁定
          if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then begin
            if {(BaseObject.m_btRaceServer <> RC_GUARD) and
              (BaseObject.m_btRaceServer <> RC_ARCHERGUARD) and }
             (BaseObject.m_btRaceServer <> 110) and
             (BaseObject.m_btRaceServer <> 111) then begin
              //m_btAttatckMode := HAM_ALL;
              //m_MyHero.m_btAttatckMode := HAM_ALL; //英雄在保护状态 攻击模式 = 全体攻击模式
              if IsProperTarget(BaseObject) then begin
                m_TargetTime:= GetTickCount();//20080615 锁定目标间隔
                //自动切换英雄状态 20080129
                if THeroObject(m_MyHero).m_boProtectStatus then THeroObject(m_MyHero).m_boProtectStatus:= False;//守护时,锁定则停止守护 20081020
                if (not m_PEnvir.m_boMISSION) and (THeroObject(m_MyHero).m_btStatus <> 0) then begin
                  THeroObject(m_MyHero).m_btStatus := 0;
                  THeroObject(m_MyHero).SysMsg(g_sHeroAttack{(英雄)状态：攻击}, C_HeroHint, t_Hint); //20080312
                end;
                if g_Config.boUnKnowHum and BaseObject.IsUsesZhuLi then //20080424 带上斗笠,不显示人的真正名字
                  SysMsg(Format('攻击目标:%s', ['神秘人']), c_Red, t_Hint)
                else begin
                  if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_btRaceServer = RC_HEROOBJECT) then
                    SysMsg(Format('攻击目标:%s', [BaseObject.m_sCharName]), c_Red, t_Hint)//20080522
                  else SysMsg(Format('攻击目标:%s', [FilterShowName(BaseObject.m_sCharName)]), c_Red, t_Hint);//20080421
                end;
                
                THeroObject(m_MyHero).m_boTarget := True;
                THeroObject(m_MyHero).SetTargetXY(BaseObject.m_nCurrX,BaseObject.m_nCurrY);
                THeroObject(m_MyHero).SetTargetCreat(BaseObject);//20080327
                SetTargetCreat(BaseObject);//20080328
                if BaseObject.IsProperTarget(m_MyHero) then BaseObject.SetTargetCreat(m_MyHero);//20081020 对方也把英雄当成目标

                if (THeroObject(m_MyHero).m_btJob = 0) then begin//20080716
                  if (abs(m_MyHero.m_nCurrX - THeroObject(m_MyHero).m_nTargetX) > 1) or (abs(m_MyHero.m_nCurrY - THeroObject(m_MyHero).m_nTargetY) > 1) then//20080924
                   THeroObject(m_MyHero).RunToTargetXY(BaseObject.m_nCurrX,BaseObject.m_nCurrY);//20080716 走向锁定的目标
                end else begin
                   if (abs(m_MyHero.m_nCurrX - THeroObject(m_MyHero).m_nTargetX) > 3) or (abs(m_MyHero.m_nCurrY - THeroObject(m_MyHero).m_nTargetY) > 3) then begin
                     THeroObject(m_MyHero).GetGotoXY(THeroObject(m_MyHero).m_TargetCret,3);//道法只走向目标3格范围
                     THeroObject(m_MyHero).RunToTargetXY(THeroObject(m_MyHero).m_nTargetX, THeroObject(m_MyHero).m_nTargetY);
                   end;
                end;

                if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_btRaceServer = RC_HEROOBJECT) then begin
                  BaseObject.SetPKFlag(self);//设置主人灰名 20081020
                  BaseObject.SetPKFlag(m_MyHero);//设置英雄灰名 20081020
                end;

                if THeroObject(m_MyHero).m_boDecDragonPoint then begin//减怒气时,直接放合击 20080726
                  ClientHeroUseSpell;
                end;
                Exit;
              end;
            end;
          end;
        end;
      end;
      THeroObject(m_MyHero).m_TargetCret := nil;
      THeroObject(m_MyHero).m_boTarget := False;
    end;
  end;
end;

procedure TPlayObject.ClientHeroUseSpell; //开始合击(去掉英雄守护不能合击 20080602)
var
  TogetherMagic: pTUserMagic;
  nSpellPoint: Integer;
begin
  try
    if m_boWaitHeroDate then Exit;
    if (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) and (not m_boDeath) and (not m_boGhost) then begin
      if (THeroObject(m_MyHero).m_btStatus <> 2) {and (not THeroObject(m_MyHero).m_boProtectStatus)} and (m_MyHero.m_PEnvir = m_PEnvir) and (abs(m_MyHero.m_nCurrX - m_nCurrX) <= 13) and (abs(m_MyHero.m_nCurrY - m_nCurrY) <= 13) and (THeroObject(m_MyHero).WearFirDragon) then begin//20080707 戴火龙之心才能放合击
         if THeroObject(m_MyHero).m_boTarget then begin //锁定目标
          if (m_MyHero.m_TargetCret <> nil) and (abs(m_MyHero.m_TargetCret.m_nCurrX - m_nCurrX) <= 13) and (abs(m_MyHero.m_TargetCret.m_nCurrY - m_nCurrY) <= 13) then begin
            if (THeroObject(m_MyHero).m_nFirDragonPoint >= g_Config.nMaxFirDragonPoint) or (THeroObject(m_MyHero).m_boDecDragonPoint) then begin//气槽满
              TogetherMagic := THeroObject(m_MyHero).FindTogetherMagic;
              if TogetherMagic <> nil then begin
                nSpellPoint := GetSpellPoint(TogetherMagic);
                if (nSpellPoint <= m_WAbil.MP) and (nSpellPoint <= m_MyHero.m_WAbil.MP) then begin
                  case TogetherMagic.wMagIdx of
                    60:begin//破魂斩 20080419
                        {if m_TargetCret <> nil then begin//20081219  修正英雄锁定后，主人被其它目标打时，合击会打不是锁定的目标
                          m_MyHero.SetTargetCreat(m_TargetCret);
                        end else}
                        if (m_MyHero.m_TargetCret <> nil) then begin
                          SetTargetCreat(m_MyHero.m_TargetCret);//20081207 修改
                        end;
                        if ((m_wStatusTimeArr[POISON_STONE] <> 0) or (THeroObject(m_MyHero).m_wStatusTimeArr[POISON_STONE] <> 0))
                           and (not g_Config.ClientConf.boParalyCanSpell) then begin//20080913 麻痹不能合击
                           THeroObject(m_MyHero).m_boDecDragonPoint := True;//开始减怒气
                           Exit;
                        end;
                        if ((abs(m_MyHero.m_TargetCret.m_nCurrX - THeroObject(m_MyHero).m_nCurrX) > 2) or (abs(m_MyHero.m_TargetCret.m_nCurrY - THeroObject(m_MyHero).m_nCurrY) > 2)) then begin
                           THeroObject(m_MyHero).m_boDecDragonPoint := True;//20080418 开始减怒气
                           THeroObject(m_MyHero).GotoTargetXY(m_MyHero.m_TargetCret.m_nCurrX, m_MyHero.m_TargetCret.m_nCurrY,1);//英雄走向目标 20080419
                           Exit;
                        end else
                        if ((abs(m_MyHero.m_TargetCret.m_nCurrX - m_nCurrX) > 2) or (abs(m_MyHero.m_TargetCret.m_nCurrY - m_nCurrY) > 2)) then begin
                           THeroObject(m_MyHero).m_boDecDragonPoint := True;//20080418 开始减怒气
                           Exit;
                        end;
                     end;
                    61,62: begin //劈星斩,雷霆一击(近攻合击,战要近目标) 20080415
                        {if m_TargetCret <> nil then begin//20081219 修正英雄锁定后，主人被其它目标打时，合击会打不是锁定的目标
                          m_MyHero.SetTargetCreat(m_TargetCret);
                        end else}
                        if (m_MyHero.m_TargetCret <> nil) then begin
                          SetTargetCreat(m_MyHero.m_TargetCret);//20081207 修改
                        end;
                        if ((m_wStatusTimeArr[POISON_STONE] <> 0) or (THeroObject(m_MyHero).m_wStatusTimeArr[POISON_STONE] <> 0))
                           and (not g_Config.ClientConf.boParalyCanSpell) then begin//20080913 麻痹不能合击
                           THeroObject(m_MyHero).m_boDecDragonPoint := True;//开始减怒气
                           Exit;
                        end;
                        if (m_btJob = 0) and ((abs(m_MyHero.m_TargetCret.m_nCurrX - m_nCurrX) > 2) or (abs(m_MyHero.m_TargetCret.m_nCurrY - m_nCurrY) > 2)) then begin
                           THeroObject(m_MyHero).m_boDecDragonPoint := True;//20080418 开始减怒气
                           Exit;
                        end else
                        if (THeroObject(m_MyHero).m_btJob = 0) and ((abs(m_MyHero.m_TargetCret.m_nCurrX - THeroObject(m_MyHero).m_nCurrX) > 2) or (abs(m_MyHero.m_TargetCret.m_nCurrY - THeroObject(m_MyHero).m_nCurrY) > 2)) then begin
                           THeroObject(m_MyHero).m_boDecDragonPoint := True;//20080418 开始减怒气
                           THeroObject(m_MyHero).GotoTargetXY(m_MyHero.m_TargetCret.m_nCurrX, m_MyHero.m_TargetCret.m_nCurrY,1);//英雄走向目标 20080419
                           Exit;
                        end;
                      end;
                    63,64,65: begin
                       if ((m_wStatusTimeArr[POISON_STONE] <> 0) or (THeroObject(m_MyHero).m_wStatusTimeArr[POISON_STONE] <> 0))
                          and (not g_Config.ClientConf.boParalyCanSpell) then begin//20080913 麻痹不能合击
                          THeroObject(m_MyHero).m_boDecDragonPoint := True;//开始减怒气
                          Exit;
                       end;
                       { if (m_TargetCret = nil) then begin
                          THeroObject(m_MyHero).m_boDecDragonPoint := True;//20080418 开始减怒气
                          Exit;
                        end;}
                      end;
                  end;
                  THeroObject(m_MyHero).m_boStartUseSpell := True;
                  THeroObject(m_MyHero).m_boDecDragonPoint := False;//20080418 停止减怒气
                  THeroObject(m_MyHero).m_nFirDragonPoint := 0;//清空怒气值
                  THeroObject(m_MyHero).m_dwStartUseSpellTick := GetTickCount();

                  THeroObject(m_MyHero).m_dwHitTick := GetTickCount();//20081221 直接进入魔法过程,以加速合击速度
                  if THeroObject(m_MyHero).ClientSpellXY(TogetherMagic, m_MyHero.m_TargetCret.m_nCurrX, m_MyHero.m_TargetCret.m_nCurrY, m_MyHero.m_TargetCret) then begin
                    THeroObject(m_MyHero).m_boStartUseSpell := False;
                  end;
                end else begin//MP不足时提示 20080603
                  if nSpellPoint > m_WAbil.MP then SysMsg('MP不足,不能使用合击技能！！！', c_Red, t_Hint);
                  if nSpellPoint > m_MyHero.m_WAbil.MP then SysMsg('(英雄) MP不足,不能使用合击技能！！！', c_Red, t_Hint);
                end;
              end;
            end;
          end;
        end else begin //没有锁定目标,则攻击当前目标,
          if m_TargetCret <> nil then begin
            m_MyHero.m_TargetCret:= m_TargetCret; // 20071227 释放合击时,如果英雄目标为空,则默认攻击主人的目标
          end else
          if (m_MyHero.m_TargetCret <> nil) then begin
            SetTargetCreat(m_MyHero.m_TargetCret);//20081207 修改
          end;
          //if (m_TargetCret = nil) and (m_MyHero.m_TargetCret <> nil) then m_TargetCret:= m_MyHero.m_TargetCret;
          if (m_MyHero.m_TargetCret <> nil) and (abs(m_MyHero.m_TargetCret.m_nCurrX - m_nCurrX) <= 13) and (abs(m_MyHero.m_TargetCret.m_nCurrY - m_nCurrY) <= 13) then begin
            if (THeroObject(m_MyHero).m_nFirDragonPoint >= g_Config.nMaxFirDragonPoint) or (THeroObject(m_MyHero).m_boDecDragonPoint) then begin
              TogetherMagic := THeroObject(m_MyHero).FindTogetherMagic;
              if TogetherMagic <> nil then begin
                nSpellPoint := GetSpellPoint(TogetherMagic);
                if (nSpellPoint <= m_WAbil.MP) and (nSpellPoint <= m_MyHero.m_WAbil.MP) then begin
                  case TogetherMagic.wMagIdx of
                    60:begin//破魂斩 20080419
                        {if m_TargetCret <> nil then m_MyHero.m_TargetCret:= m_TargetCret;
                        if (m_TargetCret = nil) and (m_MyHero.m_TargetCret <> nil) then m_TargetCret:= m_MyHero.m_TargetCret;}
                        if m_TargetCret <> nil then begin
                          m_MyHero.SetTargetCreat(m_TargetCret);
                        end else
                        if (m_MyHero.m_TargetCret <> nil) then begin
                          SetTargetCreat(m_MyHero.m_TargetCret);//20081207 修改
                        end;
                        if ((m_wStatusTimeArr[POISON_STONE] <> 0) or (THeroObject(m_MyHero).m_wStatusTimeArr[POISON_STONE] <> 0))
                           and (not g_Config.ClientConf.boParalyCanSpell) then begin//20080913 麻痹不能合击
                           THeroObject(m_MyHero).m_boDecDragonPoint := True;//开始减怒气
                           Exit;
                        end;
                        if ((abs(m_TargetCret.m_nCurrX - THeroObject(m_MyHero).m_nCurrX) > 2) or (abs(m_TargetCret.m_nCurrY - THeroObject(m_MyHero).m_nCurrY) > 2)) then begin
                           THeroObject(m_MyHero).m_boDecDragonPoint := True;//20080418 开始减怒气
                           THeroObject(m_MyHero).GotoTargetXY(THeroObject(m_MyHero).m_TargetCret.m_nCurrX,THeroObject(m_MyHero).m_TargetCret.m_nCurrY,1);//英雄走向目标 20080419
                           Exit;
                        end else
                        if ((abs(m_TargetCret.m_nCurrX - m_nCurrX) > 2) or (abs(m_TargetCret.m_nCurrY - m_nCurrY) > 2)) then begin
                           THeroObject(m_MyHero).m_boDecDragonPoint := True;//20080418 开始减怒气
                           Exit;
                        end;
                      end;
                    61,62: begin //劈星斩,雷霆一击(近攻合击,战要近目标) 20080415
                        if m_TargetCret <> nil then begin
                          m_MyHero.SetTargetCreat(m_TargetCret);
                        end else
                        if (m_MyHero.m_TargetCret <> nil) then begin
                          SetTargetCreat(m_MyHero.m_TargetCret);//20081207 修改
                        end;
                        if ((m_wStatusTimeArr[POISON_STONE] <> 0) or (THeroObject(m_MyHero).m_wStatusTimeArr[POISON_STONE] <> 0))
                           and (not g_Config.ClientConf.boParalyCanSpell) then begin//20080913 麻痹不能合击
                           THeroObject(m_MyHero).m_boDecDragonPoint := True;//开始减怒气
                           Exit;
                        end;
                        if (m_btJob = 0) and ((abs(m_TargetCret.m_nCurrX - m_nCurrX) > 1) or (abs(m_TargetCret.m_nCurrY - m_nCurrY) > 1)) then begin
                           THeroObject(m_MyHero).m_boDecDragonPoint := True;//20080418 开始减怒气
                           Exit;
                        end else
                        if (THeroObject(m_MyHero).m_btJob = 0) and ((abs(m_TargetCret.m_nCurrX - THeroObject(m_MyHero).m_nCurrX) > 2) or (abs(m_TargetCret.m_nCurrY - THeroObject(m_MyHero).m_nCurrY) > 2)) then begin
                           THeroObject(m_MyHero).m_boDecDragonPoint := True;//20080418 开始减怒气
                           THeroObject(m_MyHero).GotoTargetXY(m_MyHero.m_TargetCret.m_nCurrX, m_MyHero.m_TargetCret.m_nCurrY,1);//英雄走向目标 20080419
                           Exit;
                        end;
                      end;
                    63,64,65: begin
                       if ((m_wStatusTimeArr[POISON_STONE] <> 0) or (THeroObject(m_MyHero).m_wStatusTimeArr[POISON_STONE] <> 0))
                          and (not g_Config.ClientConf.boParalyCanSpell) then begin//20080913 麻痹不能合击
                          THeroObject(m_MyHero).m_boDecDragonPoint := True;//开始减怒气
                          Exit;
                       end;                
                       {if m_TargetCret = nil then begin
                          THeroObject(m_MyHero).m_boDecDragonPoint := True;//20080418 开始减怒气
                          Exit;
                        end;}
                      end; 
                  end;
                  THeroObject(m_MyHero).m_boStartUseSpell := True;
                  THeroObject(m_MyHero).m_boDecDragonPoint := False;//20080418 停止减怒气
                  THeroObject(m_MyHero).m_nFirDragonPoint := 0; //清空怒气值
                  THeroObject(m_MyHero).m_dwStartUseSpellTick := GetTickCount();

                  THeroObject(m_MyHero).m_dwHitTick := GetTickCount();//20081221 直接进入魔法过程,以加速合击速度
                  if THeroObject(m_MyHero).ClientSpellXY(TogetherMagic, m_MyHero.m_TargetCret.m_nCurrX, m_MyHero.m_TargetCret.m_nCurrY, m_MyHero.m_TargetCret) then begin
                    THeroObject(m_MyHero).m_boStartUseSpell := False;
                  end;
                end else begin//MP不足时提示 20080603
                  if nSpellPoint > m_WAbil.MP then SysMsg('MP值不足,不能使用合击技能！！！', c_Red, t_Hint);
                  if nSpellPoint > m_MyHero.m_WAbil.MP then SysMsg('(英雄) MP值不足,不能使用合击技能！！！', c_Red, t_Hint);
                end;
              end;
            end;     //20080803 怒气值满时,才可以减怒气
          end else if (THeroObject(m_MyHero).m_nFirDragonPoint >= g_Config.nMaxFirDragonPoint) then THeroObject(m_MyHero).m_boDecDragonPoint := True;//没有目标也,开始减怒气  20080525
        end;
      end;
    end;
  except
  end;
end;
//从装备栏取装备放到包裹里
procedure TPlayObject.ClientTakeOnItemsFormBag(nIndex: Integer; btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  I, n14, n18: Integer;
  UserItem, TakeOffItem: pTUserItem;
  StdItem, StdItem20: pTStdItem;
  StdItem58: TStdItem;
  sUserItemName: string;
label FailExit;
begin
  StdItem := nil;
  UserItem := nil;
  n14 := -1;
  n18 := -1;//20080522
  if (m_MyHero = nil) or m_boWaitHeroDate then begin
    goto FailExit;
  end;

  case nIndex of
    CM_HEROTAKEONITEMFORMMASTERBAG: begin
      if m_ItemList.Count > 0 then begin//20080628
        for I := 0 to m_ItemList.Count - 1 do begin
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName = '' then
              sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if UserItem.btValue[12] = 1 then StdItem.Reserved1:=1//物品发光 20080223
              else  StdItem.Reserved1:= 0;
            if StdItem <> nil then begin
              if CompareText(sUserItemName, sItemName) = 0 then begin
                n14 := I;
                Break;
              end;
            end;
          end;
          UserItem := nil;
        end;
        n18 := 0;
        if (StdItem <> nil) and (UserItem <> nil) then begin
          if CheckUserItems(btWhere, StdItem) then begin
            StdItem58 := StdItem^;
            ItemUnit.GetItemAddValue(UserItem, StdItem58);
            if THeroObject(m_MyHero).CheckTakeOnItems(btWhere, StdItem58) then begin
              TakeOffItem := nil;
              if btWhere in [0..13] then begin //20080417 支持斗笠,0..12改0..13
                if THeroObject(m_MyHero).m_UseItems[btWhere].wIndex > 0 then begin
                  StdItem20 := UserEngine.GetStdItem(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);
                  if (StdItem20 <> nil) and
                    (StdItem20.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) then begin
                    if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
                      THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                      n18 := -4;
                      goto FailExit;
                    end;
                  end;
                  if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0) then begin
                    THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                    n18 := -4;
                    goto FailExit;
                  end;
                  if (StdItem20.Reserved and 4) <> 0 then begin
                    THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                    n18 := -4;
                    goto FailExit;
                  end;
                  if InDisableTakeOffList(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex) then begin
                    THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                    goto FailExit;
                  end;
                  New(TakeOffItem);
                  TakeOffItem^ := THeroObject(m_MyHero).m_UseItems[btWhere];
                end; //if m_UseItems[btWhere].wIndex > 0 then begin

                if (StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) and
                  (UserItem.btValue[8] <> 0) then
                  UserItem.btValue[8] := 0;

                THeroObject(m_MyHero).m_UseItems[btWhere] := UserItem^;
                DelBagItem(n14);
                if TakeOffItem <> nil then begin
                  if AddItemToBag(TakeOffItem) then begin
                    SendAddItem(TakeOffItem);
                  end;
                end;
                THeroObject(m_MyHero).RecalcAbilitys();
                m_MyHero.CompareSuitItem(False);//200080729 套装
                THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, '');
                THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROSUBABILITY, 0, 0, 0, 0, '');
                THeroObject(m_MyHero).WeightChanged();                                                               //20080227 修改
                THeroObject(m_MyHero).SendDefMessage(SM_HEROTAKEON_OK, THeroObject(m_MyHero).GetFeatureToLong, m_MyHero.GetFeatureEx {THeroObject(m_MyHero).GetFeatureEx}, 0, 0, '');
                THeroObject(m_MyHero).FeatureChanged();
                n18 := 1;
              end;
            end else n18 := -1;
          end else n18 := -1;
        end;
       end; 
      end;
    CM_TAKEONITEMFORMHEROBAG: begin
       if THeroObject(m_MyHero).m_ItemList.Count > 0 then begin//20080628
        for I := 0 to THeroObject(m_MyHero).m_ItemList.Count - 1 do begin
          UserItem := THeroObject(m_MyHero).m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName = '' then
              sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if UserItem.btValue[12] = 1 then StdItem.Reserved1:=1//物品发光 20080223
             else StdItem.Reserved1:= 0;
            if StdItem <> nil then begin
              if CompareText(sUserItemName, sItemName) = 0 then begin
                n14 := I;
                Break;
              end;
            end;
          end;
          UserItem := nil;
        end;
        n18 := 0;
        if (StdItem <> nil) and (UserItem <> nil) then begin
          if CheckUserItems(btWhere, StdItem) then begin
            StdItem58 := StdItem^;
            ItemUnit.GetItemAddValue(UserItem, StdItem58);
            if CheckTakeOnItems(btWhere, StdItem58) then begin
              TakeOffItem := nil;
              if btWhere in [0..13] then begin //20080417 支持斗笠,0..12改0..13
                if m_UseItems[btWhere].wIndex > 0 then begin
                  StdItem20 := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
                  if (StdItem20 <> nil) and
                    (StdItem20.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) then begin
                    if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
                      SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                      n18 := -4;
                      goto FailExit;
                    end;
                  end;
                  if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0) then begin
                    SysMsg(g_sCanotTakeOffItem{'无法取下物品！！！'}, c_Red, t_Hint);
                    n18 := -4;
                    goto FailExit;
                  end;
                  if (StdItem20.Reserved and 4) <> 0 then begin
                    SysMsg(g_sCanotTakeOffItem{'无法取下物品！！！'}, c_Red, t_Hint);
                    n18 := -4;
                    goto FailExit;
                  end;
                  if InDisableTakeOffList(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex) then begin
                    SysMsg(g_sCanotTakeOffItem{'无法取下物品！！！'}, c_Red, t_Hint);
                    goto FailExit;
                  end;
                  New(TakeOffItem);
                  TakeOffItem^ := m_UseItems[btWhere];
                end; //004DAEC7 if m_UseItems[btWhere].wIndex > 0 then begin

                if (StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) and
                  (UserItem.btValue[8] <> 0) then
                  UserItem.btValue[8] := 0;

                m_UseItems[btWhere] := UserItem^;
                THeroObject(m_MyHero).DelBagItem(n14);

                if TakeOffItem <> nil then begin
                  if THeroObject(m_MyHero).AddItemToBag(TakeOffItem) then begin
                    THeroObject(m_MyHero).SendAddItem(TakeOffItem);
                  end;
                end;
                RecalcAbilitys();
                CompareSuitItem(False);//200080729 套装
                SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
                SendDefMessage(SM_TAKEON_OK, GetFeatureToLong, GetFeatureEx, 0, 0, '');
                FeatureChanged();
                n18 := 1;
              end;
            end else n18 := -1;
          end else n18 := -1;
        end;
       end;
      end;
  end;

  FailExit:
  case nIndex of
    CM_HEROTAKEONITEMFORMMASTERBAG: begin
        if n18 <= 0 then
          SendDefMessage(SM_TAKEON_FAIL, n18, 0, 0, 0, '');
      end;
    CM_TAKEONITEMFORMHEROBAG: begin
        if n18 <= 0 then
          SendDefMessage(SM_HEROTAKEON_FAIL, n18, 0, 0, 0, '');
      end;
  end;
end;
//英雄穿上装备
procedure TPlayObject.ClientHeroTakeOnItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  I, n14, n18: Integer;
  UserItem, TakeOffItem: pTUserItem;
  StdItem, StdItem20: pTStdItem;
  StdItem58: TStdItem;
  sUserItemName: string;
  //sCheckItemName: string;
  Slave: TBaseObject;//20080806
label FailExit;
begin
  StdItem := nil;
  UserItem := nil;
  n14 := -1;
  n18 := -1;//20080522
  if (m_MyHero = nil) or m_boWaitHeroDate then begin
    goto FailExit;
  end;
  if THeroObject(m_MyHero).m_ItemList.Count > 0 then begin//20080628
    for I := 0 to THeroObject(m_MyHero).m_ItemList.Count - 1 do begin
      UserItem := THeroObject(m_MyHero).m_ItemList.Items[I];
      if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if UserItem.btValue[12] = 1 then StdItem.Reserved1:=1//物品发光 20080223
         else  StdItem.Reserved1:=0;
        if StdItem <> nil then begin
          if CompareText(sUserItemName, sItemName) = 0 then begin
            n14 := I;
            Break;
          end;
        end;
      end;
      UserItem := nil;
    end;
  end;
  n18 := 0;
  if (StdItem <> nil) and (UserItem <> nil) then begin
    if CheckIsOKItem(UserItem,0) then begin//检查变态物品 20081007
      n18 := -1 ;
      goto FailExit;    
    end;
    if (btWhere = 13) and (g_Config.nIsUseZhuLi = 1) then begin //如果没有设置人物可带,则不能带上斗笠 20080417
      n18 := -1 ;
      goto FailExit;
    end;
    if PlugOfCheckCanItem(8, sUserItemName, False, 0, 0) then begin//禁止物品规则(禁止英雄使用) 20080729
      n18 := -1 ;
      goto FailExit;
    end;

    if CheckUserItems(btWhere, StdItem) then begin
      StdItem58 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem58);
      if THeroObject(m_MyHero).CheckTakeOnItems(btWhere, StdItem58) then begin
        TakeOffItem := nil;
        if btWhere in [0..13] then begin//20080417 支持斗笠,0..12改0..13
          if THeroObject(m_MyHero).m_UseItems[btWhere].wIndex > 0 then begin
            StdItem20 := UserEngine.GetStdItem(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);
            (*if (StdItem20 <> nil) and //200802229 修改
              (StdItem20.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) then begin
              if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
                THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n18 := -4;
                goto FailExit;
              end;
            end; *)
            if (StdItem20 <> nil) then begin //200802229
              case StdItem20.StdMode of
                15,16, 19..24, 26:begin
                  if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
                    THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                    n18 := -4;
                    goto FailExit;
                  end;
                end;
              end;
            end;

            if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0) then begin
              THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
              n18 := -4;
              goto FailExit;
            end;
            if (StdItem20.Reserved and 4) <> 0 then begin
              THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
              n18 := -4;
              goto FailExit;
            end;
            if InDisableTakeOffList(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex) then begin
              THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
              goto FailExit;
            end;
            New(TakeOffItem);
            TakeOffItem^ := THeroObject(m_MyHero).m_UseItems[btWhere];
          end; //004DAEC7 if m_UseItems[btWhere].wIndex > 0 then begin

          {if (StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) and //20080229 修改
            (UserItem.btValue[8] <> 0) then
            UserItem.btValue[8] := 0;  }
          if UserItem.btValue[8] <> 0 then begin //20080229
            case StdItem.StdMode of
              15,16, 19..24, 26:UserItem.btValue[8] := 0;
            end;
          end;

          THeroObject(m_MyHero).m_UseItems[btWhere] := UserItem^;
          THeroObject(m_MyHero).DelBagItem(n14);
          if TakeOffItem <> nil then begin
            if THeroObject(m_MyHero).AddItemToBag(TakeOffItem) then begin
              THeroObject(m_MyHero).SendAddItem(TakeOffItem);
            end;
          end;
          
          if btWhere = U_BUJUK then begin
            if not THeroObject(m_MyHero).WearFirDragon then begin//没火龙之心,不显示怒气值  20080721
              THeroObject(m_MyHero).SendMsg(self, RM_FIRDRAGONPOINT, 0, 0, 0, 0, '');//发送英雄怒气值
            end;
          end;

          THeroObject(m_MyHero).RecalcAbilitys();
          m_MyHero.CompareSuitItem(True);//套装与身上装备对比 20080712
          THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, '');
          THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROSUBABILITY, 0, 0, 0, 0, '');                     //20080227 修改
          THeroObject(m_MyHero).SendDefMessage(SM_HEROTAKEON_OK, THeroObject(m_MyHero).GetFeatureToLong, m_MyHero.GetFeatureEx{THeroObject(m_MyHero).GetFeatureEx}, 0, 0, '');
          THeroObject(m_MyHero).FeatureChanged();
          if StdItem.StdMode= 16 then begin
            THeroObject(m_MyHero).RefShowName();//20080424 如果是斗笠则更新名字
            if m_MyHero.m_SlaveList.Count > 0 then begin//20080806 宝宝也更新名字
               for I := 0 to m_MyHero.m_SlaveList.Count -1 do begin
                 Slave := TBaseObject(m_MyHero.m_SlaveList.Items[I]);
                 if (Slave <> nil) and (not Slave.m_boDeath) then begin
                   Slave.RefShowName();
                 end;
               end;
            end;
          end;
          n18 := 1;
        end;
      end else n18 := -2;
    end else n18 := -1;
  end;
  FailExit:
  if n18 <= 0 then
    SendDefMessage(SM_HEROTAKEON_FAIL, n18, 0, 0, 0, '');
end;
//英雄脱下装备
procedure TPlayObject.ClientHeroTakeOffItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  n10, I: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
  Slave: TBaseObject;//20080806
label FailExit;
begin
  n10 := 0;
  if (m_MyHero = nil) or m_boWaitHeroDate then begin
    goto FailExit;
  end;
  if not m_boDealing and (btWhere < 14) then begin//20080417 支持斗笠
    if THeroObject(m_MyHero).m_UseItems[btWhere].wIndex > 0 then begin
      if THeroObject(m_MyHero).m_UseItems[btWhere].MakeIndex = nItemIdx then begin
        StdItem := UserEngine.GetStdItem(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);
        if (StdItem <> nil) and
          (StdItem.StdMode in [15,16, 19, 20, 21, 22, 23, 24, 26]) then begin
          if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
            THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
            n10 := -4;
            goto FailExit;
          end;
        end;
        if not m_boUserUnLockDurg and ((StdItem.Reserved and 2) <> 0) then begin
          THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
          n10 := -4;
          goto FailExit;
        end;
        if (StdItem.Reserved and 4) <> 0 then begin
          THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
          n10 := -4;
          goto FailExit;
        end;
        if InDisableTakeOffList(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex) then begin
          THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
          goto FailExit;
        end;
        //取自定义物品名称
        sUserItemName := '';
        if THeroObject(m_MyHero).m_UseItems[btWhere].btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(THeroObject(m_MyHero).m_UseItems[btWhere].MakeIndex, THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then begin
          New(UserItem);
          FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
          //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
          UserItem^ := THeroObject(m_MyHero).m_UseItems[btWhere];
          if THeroObject(m_MyHero).AddItemToBag(UserItem) then begin
            THeroObject(m_MyHero).m_UseItems[btWhere].wIndex := 0;
            THeroObject(m_MyHero).SendAddItem(UserItem);
            THeroObject(m_MyHero).RecalcAbilitys();
            m_MyHero.CompareSuitItem(False);//套装与身上装备对比 20080712
            THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, '');
            THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROSUBABILITY, 0, 0, 0, 0, '');                      //20080227 修改
            THeroObject(m_MyHero).SendDefMessage(SM_HEROTAKEOFF_OK, THeroObject(m_MyHero).GetFeatureToLong, m_MyHero.GetFeatureEx{THeroObject(m_MyHero).GetFeatureEx}, 0, 0, '');
            THeroObject(m_MyHero).FeatureChanged();
            if StdItem.StdMode= 16 then begin
              THeroObject(m_MyHero).RefShowName();//20080424 如果是斗笠则更新名字
              if m_MyHero.m_SlaveList.Count > 0 then begin//20080806 宝宝也更新名字
                 for I := 0 to m_MyHero.m_SlaveList.Count -1 do begin
                   Slave := TBaseObject(m_MyHero.m_SlaveList.Items[I]);
                   if (Slave <> nil) and (not Slave.m_boDeath) then begin
                     Slave.RefShowName();
                   end;
                 end;
              end;
            end;
          end else begin
            Dispose(UserItem);
            n10 := -3;
          end;
        end;
      end;
    end else n10 := -2;
  end else n10 := -1;
  FailExit:
  if n10 <= 0 then
    SendDefMessage(SM_HEROTAKEOFF_FAIL, n10, 0, 0, 0, '');
end;

procedure TPlayObject.ClientHeroTakeOffItemsToBag(nIndex: Integer; btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  n10: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
label FailExit;
begin
  n10 := 0;
  if (m_MyHero = nil) or m_boWaitHeroDate then begin
    goto FailExit;
  end;
  case nIndex of
    CM_TAKEOFFITEMHEROBAG: begin //装备脱下到英雄包裹
        if not m_boDealing and (btWhere < 13) then begin
          if m_UseItems[btWhere].wIndex > 0 then begin
            if m_UseItems[btWhere].MakeIndex = nItemIdx then begin
              StdItem := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
              if (StdItem <> nil) and
                (StdItem.StdMode in [15,16, 19, 20, 21, 22, 23, 24, 26]) then begin
                if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
                  SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                  n10 := -4;
                  goto FailExit;
                end;
              end;
              if not m_boUserUnLockDurg and ((StdItem.Reserved and 2) <> 0) then begin
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n10 := -4;
                goto FailExit;
              end;
              if (StdItem.Reserved and 4) <> 0 then begin
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n10 := -4;
                goto FailExit;
              end;
              if InDisableTakeOffList(m_UseItems[btWhere].wIndex) then begin
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                goto FailExit;
              end;
              //取自定义物品名称
              sUserItemName := '';
              if m_UseItems[btWhere].btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[btWhere].MakeIndex, m_UseItems[btWhere].wIndex);
              if sUserItemName = '' then
                sUserItemName := UserEngine.GetStdItemName(m_UseItems[btWhere].wIndex);

              if CompareText(sUserItemName, sItemName) = 0 then begin
                New(UserItem);
                FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
                //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
                UserItem^ := m_UseItems[btWhere];
                if THeroObject(m_MyHero).AddItemToBag(UserItem) then begin
                  THeroObject(m_MyHero).SendAddItem(UserItem);
                  m_UseItems[btWhere].wIndex := 0;
                  RecalcAbilitys();
                  CompareSuitItem(False);//200080729 套装
                  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                  SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
                  SendDefMessage(SM_TAKEOFFTOHEROBAG_OK, GetFeatureToLong, GetFeatureEx, 0, 0, '');
                  FeatureChanged();
                  n10 := 1;
                end else begin
                  Dispose(UserItem);
                  n10 := -3;
                end;
              end;
            end;
          end else n10 := -2;
        end else n10 := -1;
      end;

    CM_TAKEOFFITEMTOMASTERBAG: begin //装备脱下到主人包裹
        if not m_boDealing and (btWhere < 13) then begin
          if THeroObject(m_MyHero).m_UseItems[btWhere].wIndex > 0 then begin
            if THeroObject(m_MyHero).m_UseItems[btWhere].MakeIndex = nItemIdx then begin
              StdItem := UserEngine.GetStdItem(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);
              if (StdItem <> nil) and
                (StdItem.StdMode in [15,16, 19, 20, 21, 22, 23, 24, 26]) then begin
                if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
                  THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                  n10 := -4;
                  goto FailExit;
                end;
              end;
              if not m_boUserUnLockDurg and ((StdItem.Reserved and 2) <> 0) then begin
                THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n10 := -4;
                goto FailExit;
              end;
              if (StdItem.Reserved and 4) <> 0 then begin
                THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n10 := -4;
                goto FailExit;
              end;
              if InDisableTakeOffList(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex) then begin
                THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                goto FailExit;
              end;
              //取自定义物品名称
              sUserItemName := '';
              if THeroObject(m_MyHero).m_UseItems[btWhere].btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(THeroObject(m_MyHero).m_UseItems[btWhere].MakeIndex, THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);
              if sUserItemName = '' then
                sUserItemName := UserEngine.GetStdItemName(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);

              if CompareText(sUserItemName, sItemName) = 0 then begin
                New(UserItem);
                FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
                //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
                UserItem^ := THeroObject(m_MyHero).m_UseItems[btWhere];
                if AddItemToBag(UserItem) then begin
                  SendAddItem(UserItem);
                  WeightChanged();
                  THeroObject(m_MyHero).m_UseItems[btWhere].wIndex := 0;
                  THeroObject(m_MyHero).RecalcAbilitys();
                  m_MyHero.CompareSuitItem(False);//200080729 套装
                  THeroObject(m_MyHero).WeightChanged();
                  THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, '');
                  THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROSUBABILITY, 0, 0, 0, 0, '');                            //20080227 修改
                  THeroObject(m_MyHero).SendDefMessage(SM_TAKEOFFTOMASTERBAG_OK, THeroObject(m_MyHero).GetFeatureToLong, m_MyHero.GetFeatureEx{THeroObject(m_MyHero).GetFeatureEx}, 0, 0, '');
                  THeroObject(m_MyHero).FeatureChanged();
                  n10 := 1;
                end else begin
                  Dispose(UserItem);
                  n10 := -3;
                end;
              end;
            end;
          end else n10 := -2;
        end else n10 := -1;
      end;
  end;
  FailExit:
  case nIndex of
    CM_TAKEOFFITEMHEROBAG: begin //装备脱下到英雄包裹
        if n10 <= 0 then
          SendDefMessage(SM_TAKEOFFTOHEROBAG_FAIL, n10, 0, 0, 0, '');
      end;
    CM_TAKEOFFITEMTOMASTERBAG: begin //装备脱下到主人包裹
        if n10 <= 0 then
          SendDefMessage(SM_TAKEOFFTOMASTERBAG_FAIL, n10, 0, 0, 0, '');
      end;
  end;
end;
//包裹到包裹
procedure TPlayObject.ClientBagToBag(nIndex: Integer; nItemIdx: Integer; sItemName: string);
var
  I, n10, wIndex, MakeIndex: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
label FailExit;
begin
  n10 := 0;
  if (m_MyHero = nil) or m_boWaitHeroDate or m_boHeroLogOut then begin
    goto FailExit;
  end;
  case nIndex of
    CM_SENDITEMTOHEROBAG: begin //主人包裹到英雄包裹
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;//20080917
          UserItem := pTUserItem(m_ItemList.Items[I]);
          if UserItem.MakeIndex = nItemIdx then begin
            if PlugOfCheckCanItem(8, sItemName, False, 0, 0) then begin//禁止物品规则,禁止英雄使用(管理插件功能) 20080929
              goto FailExit;
              Break;
            end;
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem = nil then begin
              goto FailExit;
              Break;
            end;
            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName = '' then
              sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
            if (CompareText(sUserItemName, sItemName) = 0) and (CompareText(m_sHeroCharName,m_MyHero.m_sCharName) = 0) then begin//20080902
              THeroObject(m_MyHero).ClearCopyItem(UserItem.wIndex, UserItem.MakeIndex);//20080901 先清理英雄包裹复制品
              if m_boHeroLogOut then begin//英雄退出,则失败 20080909
                 goto FailExit;
              end;
              if THeroObject(m_MyHero).AddItemToBag(UserItem) then begin
                m_ItemList.Delete(I);
                THeroObject(m_MyHero).SendAddItem(UserItem);
                IsItem_51(1);//发送聚灵珠的经验 20080427
                THeroObject(m_MyHero).SendDefMessage(SM_SENDITEMTOHEROBAG_OK, 0, 0, 0, 0, '');
                WeightChanged;//负重改变 20080228
                THeroObject(m_MyHero).WeightChanged;//负重改变 20080228
                n10 := 1;
              end else begin
                n10 := -3;
              end;
              Break;
            end;
          end;
        end;
      end;
    CM_SENDITEMTOMASTERBAG: begin //英雄包裹到主人包裹
      for I := m_MyHero.m_ItemList.Count - 1 downto 0 do begin
        if m_MyHero.m_ItemList.Count <= 0 then Break;//20080917
        UserItem := pTUserItem(m_MyHero.m_ItemList.Items[I]);
        if UserItem.MakeIndex = nItemIdx then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem = nil then begin
            goto FailExit;
            Break;
          end;
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
          if (CompareText(sUserItemName, sItemName) = 0) and (CompareText(m_sHeroCharName,m_MyHero.m_sCharName) = 0) then begin//20080902
            ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//20080828 增加
            if m_boHeroLogOut then begin//英雄退出,则失败 20080909
               goto FailExit;
            end;
            if AddItemToBag(UserItem) then begin
              m_MyHero.m_ItemList.Delete(I);
              wIndex:= UserItem.wIndex;//20080901
              MakeIndex:= UserItem.MakeIndex;//20080901
              THeroObject(m_MyHero).ClearCopyItem(wIndex, MakeIndex);//20080901
              SendAddItem(UserItem);
              IsItem_51(1);//发送聚灵珠的经验 20080427
              SendDefMessage(SM_SENDITEMTOMASTERBAG_OK, 0, 0, 0, 0, '');
              WeightChanged;//负重改变 20080228
              THeroObject(m_MyHero).WeightChanged;//负重改变 20080228
              //FeatureChanged();
              n10 := 1;
            end else begin
              n10 := -3;
            end;
            Break;
          end;
        end;
      end;
    end;
  end;
  FailExit:
  case nIndex of
    CM_SENDITEMTOHEROBAG: begin //主人包裹到英雄包裹
        if n10 <= 0 then SendDefMessage(SM_SENDITEMTOHEROBAG_FAIL, n10, 0, 0, 0, '');
      end;
    CM_SENDITEMTOMASTERBAG: begin //英雄包裹到主人包裹
        if n10 <= 0 then SendDefMessage(SM_SENDITEMTOMASTERBAG_FAIL, n10, 0, 0, 0, '');
      end;
  end;
end;

procedure TPlayObject.ClientHeroUseItems(nItemIdx: Integer; sItemName: string); //英雄吃药
begin
  if m_boWaitHeroDate then Exit;
  if THeroObject(m_MyHero) <> nil then begin
    THeroObject(m_MyHero).ClientHeroUseItems(nItemIdx, sItemName);
  end;
end;
//nSortType 0-人物榜 1-英雄榜 2-师徒榜
//nType 1-等级榜 2-战士榜 3-法师榜 4-道士榜
procedure TPlayObject.ClientGetUserOrder(nSortType, nType, nPage: Integer); //用户排行
  function GetSortStringList: TStringList;
  begin
    Result := nil;
    case nSortType of
      0: begin
          case nType of
            1: Result := UserEngine.m_PlayObjectLevelList;
            2: Result := UserEngine.m_WarrorObjectLevelList;
            3: Result := UserEngine.m_WizardObjectLevelList;
            4: Result := UserEngine.m_TaoistObjectLevelList;
          end;
        end;
      1: begin
          case nType of
            1: Result := UserEngine.m_HeroObjectLevelList;
            2: Result := UserEngine.m_WarrorHeroObjectLevelList;
            3: Result := UserEngine.m_WizardHeroObjectLevelList;
            4: Result := UserEngine.m_TaoistHeroObjectLevelList;
          end;
        end;
      2: begin
          Result := UserEngine.m_PlayObjectMasterList;
        end;
    end;
  end;
  function GetPageCount(List: TStringList): Integer;
  begin
    Result := List.Count div 10;
    if List.Count mod 10 > 0 then Inc(Result);
  end;
var
  sCharName: string;
  sHeroName: string;
  nIndex: Integer;
  StringList: TStringList;
  n01, nPageCount, nBeginPage: Integer;
  sSendText: string;

  UserLevelSort: TUserLevelSort;
  HeroLevelSort: THeroLevelSort;
  UserMasterSort: TUserMasterSort;

  CharName: pTCharName;
  HeroName: pTHeroName;
  nCode: Byte;
begin
  EnterCriticalSection(HumanSortCriticalSection);
  try
    nCode:= 0;
    Try
      StringList := GetSortStringList;
      nCode:= 1;
      if StringList <> nil then begin
        n01 := 0;
        sSendText := '';
        nPageCount := GetPageCount(StringList);
        nCode:= 2;
        nBeginPage := nPage;
        if nPage >= nPageCount then nBeginPage := nPageCount - 1;
        if nBeginPage < 0 then nBeginPage := 0;

        if nPage < 0 then begin //我的排行
          for nIndex := 0 to StringList.Count - 1 do begin
            sCharName := '';
            nCode:= 3;
            if nSortType = 1 then begin
              HeroName := pTHeroName(StringList.Objects[nIndex]);
              if HeroName <> nil then sHeroName := HeroName^;//20081204 修改
              sHeroName := GetValidStr3(sHeroName, sCharName, [#13]);
            end else begin
              CharName := pTCharName(StringList.Objects[nIndex]);
              if CharName <> nil then sCharName := CharName^;//20081204 修改
            end;
            nCode:= 4;
            if (sCharName <> '') and (sCharName = m_sCharName) then begin
              case nSortType of
                0: begin
                    nCode:= 5;
                    UserLevelSort.nIndex := nIndex + 1;
                    //UserLevelSort.wLevel := StrToInt(StringList.Strings[nIndex]);
                    UserLevelSort.wLevel := Str_ToInt(StringList.Strings[nIndex], 0);//20081222
                    if UserLevelSort.wLevel > 0 then begin
                      UserLevelSort.sChrName := sCharName;
                      sSendText := sSendText + EncodeBuffer(@UserLevelSort, SizeOf(TUserLevelSort)) + '/';
                    end;
                  end;
                1: begin
                    nCode:= 6;
                    HeroLevelSort.nIndex := nIndex + 1;
                    //HeroLevelSort.wLevel := StrToInt(StringList.Strings[nIndex]);
                    HeroLevelSort.wLevel := Str_ToInt(StringList.Strings[nIndex], 0);//20081222
                    if HeroLevelSort.wLevel > 0 then begin
                      HeroLevelSort.sChrName := sCharName;
                      HeroLevelSort.sHeroName := sHeroName;
                      sSendText := sSendText + EncodeBuffer(@HeroLevelSort, SizeOf(THeroLevelSort)) + '/';
                    end;
                  end;
                2: begin
                    nCode:= 7;
                    UserMasterSort.nIndex := nIndex + 1;
                    //UserMasterSort.nMasterCount := StrToInt(StringList.Strings[nIndex]);
                    UserMasterSort.nMasterCount := Str_ToInt(StringList.Strings[nIndex], 0);//20081222
                    if UserMasterSort.nMasterCount > 0 then begin
                      UserMasterSort.sChrName := CharName^;
                      sSendText := sSendText + EncodeBuffer(@UserMasterSort, SizeOf(TUserMasterSort)) + '/';
                    end;
                  end;
              end;
              Break;
            end;
          end;
        end else begin
          nCode:= 8;
          for nIndex := nBeginPage * 10 to StringList.Count - 1 do begin
            if n01 >= 10 then Break;
            case nSortType of
              0: begin
                  nCode:= 9;
                  UserLevelSort.nIndex := nIndex + 1;
                  nCode:= 95;
                  //UserLevelSort.wLevel := StrToInt(StringList.Strings[nIndex]);
                  UserLevelSort.wLevel := Str_ToInt(StringList.Strings[nIndex], 0);//20081222
                  nCode:= 92;
                  CharName := pTCharName(StringList.Objects[nIndex]);
                  if (CharName <> nil) and (UserLevelSort.wLevel > 0) then begin//20081204
                    nCode:= 93;
                    UserLevelSort.sChrName := CharName^;
                    nCode:= 94;
                    sSendText := sSendText + EncodeBuffer(@UserLevelSort, SizeOf(TUserLevelSort)) + '/';
                  end;
                end;
              1: begin
                  nCode:= 10;
                  HeroLevelSort.nIndex := nIndex + 1;
                  nCode:= 108;
                  //HeroLevelSort.wLevel := StrToInt(StringList.Strings[nIndex]);//20081219
                  HeroLevelSort.wLevel := Str_ToInt(StringList.Strings[nIndex], 0);//20081219
                  nCode:= 102;
                  HeroName := pTHeroName(StringList.Objects[nIndex]);
                  nCode:= 103;
                  if (HeroName <> nil) and (HeroLevelSort.wLevel > 0) then begin//20081109
                    nCode:= 104;
                    sHeroName := HeroName^;
                    nCode:= 105;
                    sHeroName := GetValidStr3(sHeroName, sCharName, [#13]);
                    nCode:= 106;
                    HeroLevelSort.sChrName := sCharName;
                    HeroLevelSort.sHeroName := sHeroName;
                    nCode:= 107;
                    sSendText := sSendText + EncodeBuffer(@HeroLevelSort, SizeOf(THeroLevelSort)) + '/';
                  end;
                end;
              2: begin
                  nCode:= 11;
                  UserMasterSort.nIndex := nIndex + 1;
                  //UserMasterSort.nMasterCount := StrToInt(StringList.Strings[nIndex]);
                  UserMasterSort.nMasterCount := Str_ToInt(StringList.Strings[nIndex], 0);//20081219
                  if UserMasterSort.nMasterCount > 0 then begin
                    CharName := pTCharName(StringList.Objects[nIndex]);
                    UserMasterSort.sChrName := CharName^;
                    sSendText := sSendText + EncodeBuffer(@UserMasterSort, SizeOf(TUserMasterSort)) + '/';
                  end;
                end;
            end;
            Inc(n01);
          end;
        end;
        nCode:= 12;
        if nPage >= 0 then begin
          nCode:= 13;
          if sSendText <> '' then begin{客户端对应Param   Recog     Tag     Series }
            SendMsg(Self, RM_QUERYUSERLEVELSORT, nPage, nSortType, nType, nPageCount, sSendText);
          end;
        end else begin
          nCode:= 14;
          if sSendText <> '' then begin
            SendMsg(Self, RM_QUERYUSERLEVELSORT, nPage, nSortType, nType, 0, sSendText);
          end else begin
            SendMsg(Self, RM_QUERYUSERLEVELSORT, nPage, -1, nType, 0, '');
          end;
        end;
      end;
    except
      MainOutMessage('{异常} TPlayObject.ClientGetUserOrder Code:'+inttostr(nCode));
    end;
  finally
    LeaveCriticalSection(HumanSortCriticalSection);
  end;   
end;
{$IFEND}
//人物:把包裹物品到身上
procedure TPlayObject.ClientTakeOnItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  I, n14, n18: Integer;
  UserItem, TakeOffItem: pTUserItem;
  StdItem, StdItem20: pTStdItem;
  StdItem58: TStdItem;
  sUserItemName: string;
  Slave: TBaseObject;//20080806
label FailExit;
begin
  StdItem := nil;
  UserItem := nil;
  n14 := -1;
  if m_ItemList.Count > 0 then begin//20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if UserItem.btValue[12] = 1 then StdItem.Reserved1:=1//物品发光 20080223
         else  StdItem.Reserved1:=0 ;
        if StdItem <> nil then begin
          if CompareText(sUserItemName, sItemName) = 0 then begin
            n14 := I;
            Break;
          end;
        end;
      end;
      UserItem := nil;
    end;
  end;
  n18 := 0;
  if (StdItem <> nil) and (UserItem <> nil) then begin
    if CheckIsOKItem(UserItem,0) then begin//检查变态物品 20081007
      n18 := -1 ;
      goto FailExit;    
    end;
    if (btWhere = 13) and (g_Config.nIsUseZhuLi > 1) then begin //如果没有设置人物可带,则不能带上斗笠 20080417
      n18 := -1 ;
      goto FailExit;
    end;
    if CheckUserItems(btWhere, StdItem) then begin
      StdItem58 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem58);
      if CheckTakeOnItems(btWhere, StdItem58) and CheckItemBindUse(UserItem) then begin
        TakeOffItem := nil;
        if btWhere in [0..13] then begin//20080417 支持斗笠,0..12改0..13
          if m_UseItems[btWhere].wIndex > 0 then begin
            StdItem20 := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
            (*if (StdItem20 <> nil) and //20080229 修改
              (StdItem20.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) then begin
              if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7] <> 0) then begin
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n18 := -4;
                goto FailExit;
              end;
            end; *)
            if StdItem20 <> nil then begin //20080229
              case StdItem20.StdMode of
                15,16, 19..24, 26:begin
                  if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7] <> 0) then begin
                    SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                    n18 := -4;
                    goto FailExit;
                  end;
                end;
              end;//case
            end;

            if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0) then begin
              SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
              n18 := -4;
              goto FailExit;
            end;
            if (StdItem20.Reserved and 4) <> 0 then begin
              SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
              n18 := -4;
              goto FailExit;
            end;   
            if InDisableTakeOffList(m_UseItems[btWhere].wIndex) then begin
              SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
              goto FailExit;
            end;
            New(TakeOffItem);
            TakeOffItem^ := m_UseItems[btWhere];
          end; //004DAEC7 if m_UseItems[btWhere].wIndex > 0 then begin

         { if (StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) and //20080229 修改
            (UserItem.btValue[8] <> 0) then
            UserItem.btValue[8] := 0; }
          if UserItem.btValue[8] <> 0 then begin  //20080229
            case StdItem.StdMode of
              15, 16, 19..24, 26:UserItem.btValue[8] := 0;
            end;
          end;

          m_UseItems[btWhere] := UserItem^;
          DelBagItem(n14);
          if TakeOffItem <> nil then begin
            AddItemToBag(TakeOffItem);
            SendAddItem(TakeOffItem);
          end;
          RecalcAbilitys();
          if btWhere <> U_BUJUK then//20080918 物品位,不进入触发,以避免施毒术时不停的触发
            CompareSuitItem(True)//套装与身上装备对比 20080918
          else CompareSuitItem(False);
          
          SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
          SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
          SendDefMessage(SM_TAKEON_OK, GetFeatureToLong, GetFeatureEx, 0, 0, '');
          FeatureChanged();
          if StdItem.StdMode= 16 then begin
             RefShowName();//20080424 如果是斗笠则更新名字
             if m_SlaveList.Count > 0 then begin//20080806 宝宝也更新名字
               for I := 0 to m_SlaveList.Count -1 do begin
                 Slave := TBaseObject(m_SlaveList.Items[I]);
                 if (Slave <> nil) and (not Slave.m_boDeath) then begin
                   Slave.RefShowName();
                 end;
               end;
             end;
          end;
          n18 := 1;
        end; { else begin
        if m_AddUseItems[btWhere].wIndex > 0 then begin
          StdItem20:=UserEngine.GetStdItem(m_AddUseItems[btWhere].wIndex);
          if (StdItem20 <> nil) and
             (StdItem20.StdMode in [15,19,20,21,22,23,24,26]) then begin
            if (not m_boUserUnLockDurg) and (m_AddUseItems[btWhere].btValue[7] <> 0)then begin
              SysMsg('无法取下物品！！！',c_Red,t_Hint);
              n18:=-4;
              goto FailExit;
            end;
          end;
          if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0)then begin
            SysMsg('无法取下物品！！！',c_Red,t_Hint);
            n18:=-4;
            goto FailExit;
          end; //004DAE78
          if (StdItem20.Reserved and 4) <> 0 then begin
            SysMsg('无法取下物品！！！',c_Red,t_Hint);
            n18:=-4;
            goto FailExit;
          end;
          New(TakeOffItem);
          TakeOffItem^:=m_AddUseItems[btWhere];
        end; //004DAEC7 if m_UseItems[btWhere].wIndex > 0 then begin

        if (StdItem.StdMode in [15,19,20,21,22,23,24,26]) and   //004DAEC7
           (UserItem.btValue[8] <> 0) then
          UserItem.btValue[8]:=0;

        m_AddUseItems[btWhere]:=UserItem^;
        if TakeOffItem <> nil then begin
          AddItemToBag(TakeOffItem);
          SendAddItem(TakeOffItem);
        end;
        RecalcAbilitys();
        SendMsg(Self,RM_ABILITY,0,0,0,0,'');
        SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
        SendDefMessage(SM_TAKEON_OK,GetFeatureToLong,0,0,0,'');
        FeatureChanged();
        n18:=1;
      end;
      }
      end else n18 := -1;
    end else n18 := -1;
  end;
  FailExit:
  if n18 <= 0 then begin
    SendDefMessage(SM_TAKEON_FAIL, n18, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.ClientTakeOffItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  n10, I: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
  Slave: TBaseObject;//20080806
label FailExit;
begin
  n10 := 0;
  if not m_boDealing and (btWhere < 14) then begin  //btWhere < 13 扩展斗笠 btWhere < 14  20080417
    if m_UseItems[btWhere].wIndex > 0 then begin
      if m_UseItems[btWhere].MakeIndex = nItemIdx then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
        if (StdItem <> nil) and
          (StdItem.StdMode in [15, 16, 19, 20, 21, 22, 23, 24, 26]) then begin
          if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7] <> 0) then begin
            SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
            n10 := -4;
            goto FailExit;
          end;
        end;
        if not m_boUserUnLockDurg and ((StdItem.Reserved and 2) <> 0) then begin
          SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
          n10 := -4;
          goto FailExit;
        end;
        if (StdItem.Reserved and 4) <> 0 then begin
          SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
          n10 := -4;
          goto FailExit;
        end;
        if InDisableTakeOffList(m_UseItems[btWhere].wIndex) then begin
          SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
          goto FailExit;
        end;
        //取自定义物品名称
        sUserItemName := '';
        if m_UseItems[btWhere].btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[btWhere].MakeIndex, m_UseItems[btWhere].wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(m_UseItems[btWhere].wIndex);
        if CompareText(sUserItemName, sItemName) = 0 then begin
          New(UserItem);
          FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
          //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
          UserItem^ := m_UseItems[btWhere];
          if AddItemToBag(UserItem) then begin
            m_UseItems[btWhere].wIndex := 0;
            SendAddItem(UserItem);
            RecalcAbilitys();
            CompareSuitItem(False);//套装与身上装备对比 20080729
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
            SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
            SendDefMessage(SM_TAKEOFF_OK, GetFeatureToLong, GetFeatureEx, 0, 0, '');
            FeatureChanged();
            if StdItem.StdMode= 16 then begin
              RefShowName();//20080424 如果是斗笠则更新名字
              if m_SlaveList.Count > 0 then begin//20080806 宝宝也更新名字
                 for I := 0 to m_SlaveList.Count -1 do begin
                  Slave := TBaseObject(m_SlaveList.Items[I]);
                  if (Slave <> nil) and (not Slave.m_boDeath) then begin
                    Slave.RefShowName();
                  end;
                end;
              end;
            end;
          end else begin
            Dispose(UserItem);
            n10 := -3;
          end;
        end;
      end;
    end else n10 := -2;
  end else n10 := -1;
  FailExit:
  if n10 <= 0 then
    SendDefMessage(SM_TAKEOFF_FAIL, n10, 0, 0, 0, '');
end;
//召唤强化卷,把招出的宝宝变成7级  20080221
function TPlayObject.CallMobeItem(): Boolean;
var
  I: Integer;
  Slave: TBaseObject;
begin
  Result:= False;
  if m_SlaveList.Count= 0 then begin
    SysMsg('您没有召唤宝宝,不能使用此物品!',  c_Red, t_Hint);
    Exit;
  end;
  if m_SlaveList.Count > 0 then begin//20080629
    for I := 0 to m_SlaveList.Count - 1 do begin
      Slave := TBaseObject(m_SlaveList.Items[I]);
      if Slave.m_btRaceServer = RC_PLAYMOSTER then Continue;//20081102 分身不能调级
      if Slave.m_btSlaveExpLevel < 7 then begin //20080323
        Slave.m_btSlaveExpLevel:= 7;
        Slave.RecalcAbilitys;//20080328 改变等级,刷新属性
        Slave.RefNameColor;//20080408
        Slave.SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP,0, 0, 0, ''); //宝宝升级动画  20080328
        Result:= True;
        SysMsg('在神秘的力量影响下，您的宠物:'+Slave.m_sCharName+' 成长为7级', BB_Fuchsia, t_Hint);
        Break;
      end;
    end;
  end;
end;

//全部修复,需要的持久值 20080325
Function TPlayObject.RepairAllItemDura:Integer;
var
  nWhere: Integer;
//  sCheckItemName: string;
  StdItem: pTStdItem;
begin
  Result:= 0;
  for nWhere := Low(THumanUseItems) to High(THumanUseItems) do begin
    if m_UseItems[nWhere].wIndex > 0 then begin
      StdItem := UserEngine.GetStdItem(m_UseItems[nWhere].wIndex);
      if StdItem <> nil then begin
        if ((m_UseItems[nWhere].DuraMax div 1000) > (m_UseItems[nWhere].Dura div 1000)) and  (StdItem.StdMode<>7) and (StdItem.StdMode<>25) and (StdItem.StdMode<>43) and (StdItem.AniCount<>21) then begin
          if CheckItemValue(@m_UseItems[nWhere], 3) then Continue //20080314 禁止修
          else
          {if Assigned(zPlugOfEngine.CheckCanRepairItem) then begin
            sCheckItemName := StdItem.Name;
            if not zPlugOfEngine.CheckCanRepairItem(m_Master, PChar(sCheckItemName)) then Continue;//检查是否是不能修复的物品
          end;}
          if PlugOfCheckCanItem(3, StdItem.Name, False, 0, 0) then Continue;//禁止物品规则(管理插件功能) 20080729

          Inc(Result,(m_UseItems[nWhere].DuraMax - m_UseItems[nWhere].Dura));
        end;
      end;
    end;
  end;
end;

//全部修复
procedure TPlayObject.RepairAllItem(DureCount: Integer; boDec: Boolean);
var
  nWhere,RepCount: Integer;
//  sCheckItemName: string;
  StdItem: pTStdItem;
begin
  for nWhere := Low(THumanUseItems) to High(THumanUseItems) do begin
    if m_UseItems[nWhere].wIndex > 0 then begin
      StdItem := UserEngine.GetStdItem(m_UseItems[nWhere].wIndex);
      if StdItem <> nil then begin
        if ((m_UseItems[nWhere].DuraMax div 1000) > (m_UseItems[nWhere].Dura div 1000)) and (StdItem.StdMode<>7) and (StdItem.StdMode<>25) and (StdItem.StdMode<>43) and (StdItem.AniCount<>21) then begin
          if CheckItemValue(@m_UseItems[nWhere], 3) then Continue //20080314 禁止修
          else
          {if Assigned(zPlugOfEngine.CheckCanRepairItem) then begin
            sCheckItemName := StdItem.Name;
            if not zPlugOfEngine.CheckCanRepairItem(m_Master, PChar(sCheckItemName)) then Continue;//检查是否是不能修复的物品
          end;}
          if PlugOfCheckCanItem(3, StdItem.Name, False, 0, 0) then Continue;//禁止物品规则(管理插件功能) 20080729

          if not boDec then begin//修复点够,则直接修复不计算
              if (m_UseItems[nWhere].DuraMax div 1000) - (m_UseItems[nWhere].Dura div 1000) > 0 then
                 SysMsg('装备 【'+StdItem.Name+'】已成功修复!', c_Green, t_Hint);
              m_UseItems[nWhere].Dura := m_UseItems[nWhere].DuraMax;
              SendMsg(Self, RM_DURACHANGE, nWhere, m_UseItems[nWhere].Dura, m_UseItems[nWhere].DuraMax, 0, '');//20071229          
          end else begin
            RepCount:= (m_UseItems[nWhere].DuraMax div 1000) - (m_UseItems[nWhere].Dura div 1000);
            if DureCount >= RepCount then begin
              Dec(DureCount,RepCount);
              if (m_UseItems[nWhere].DuraMax div 1000) - (m_UseItems[nWhere].Dura div 1000) > 0 then
                 SysMsg('装备 【'+StdItem.Name+'】已成功修复!', c_Green, t_Hint); //20071229
              m_UseItems[nWhere].Dura := m_UseItems[nWhere].DuraMax;
              SendMsg(Self, RM_DURACHANGE, nWhere, m_UseItems[nWhere].Dura, m_UseItems[nWhere].DuraMax, 0, '');//20071229
            end else
            if DureCount > 0 then begin
               DureCount:= 0;
               m_UseItems[nWhere].Dura :=m_UseItems[nWhere].Dura + DureCount * 1000;
               SendMsg(Self, RM_DURACHANGE, nWhere, m_UseItems[nWhere].Dura, m_UseItems[nWhere].DuraMax, 0, '');//20071229
               Break;
            end;
          end;
        end;
      end;
    end;
  end;
end;
//随机移动
procedure TPlayObject.RandomMove();
var
  nX, nY: Integer;
begin
  if m_PEnvir = nil then Exit;
  nX := Random(m_PEnvir.m_nWidth);
  nY := Random(m_PEnvir.m_nHeight);
  SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
  SpaceMove(m_sMapName, nX, nY, 0);
end;
//客户端使用物品
procedure TPlayObject.ClientUseItems(nItemIdx: Integer; sItemName: string);
  function GetUnbindItemName(nShape: Integer): string;
  var
    I: Integer;
  begin
    Result := '';
    if g_UnbindList.Count > 0 then begin//20080629
      for I := 0 to g_UnbindList.Count - 1 do begin
        if Integer(g_UnbindList.Objects[I]) = nShape then begin
          Result := g_UnbindList.Strings[I];
          Break;
        end;
      end;
    end;
  end;
  function GetUnBindItems(sItemName: string; nCount: Integer): Boolean;
  var
    I: Integer;
    UserItem: pTUserItem;
  begin
    Result := False;
    if nCount <= 0 then nCount:=1;//20080629
    for I := 0 to nCount - 1 do begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
        m_ItemList.Add(UserItem);
        if m_btRaceServer = RC_PLAYOBJECT then SendAddItem(UserItem);
        Result := True;
      end else begin
        Dispose(UserItem);
        Break;
      end;
    end;
  end;
  function FoundUserItem(Item: pTUserItem): Boolean;
  var
    I: Integer;
    UserItem: pTUserItem;
  begin
    Result := False;
    if m_ItemList.Count > 0 then begin//20080628
      for I := 0 to m_ItemList.Count - 1 do begin
        UserItem := m_ItemList.Items[I];
        if UserItem = Item then begin
          Result := True;
          Break;
        end;
      end;
    end;
  end;
var
  I, ItemCount: Integer;
  boEatOK: Boolean;
  boSendUpDate: Boolean;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  UserItem34: TUserItem;
  sMapName: string;
  nCurrX, nCurrY: Integer;
  nCode: Byte;
  dwExp: LongWord;
begin
  nCode:= 0;
  m_boCanQueryBag:= True;//使用物品时,不能刷新包裹 20080917
  Try
    try
      boEatOK := False;
      boSendUpDate := False;
      StdItem := nil;
      if m_boCanUseItem then begin //能使用物品
        if not m_boDeath then begin
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem := m_ItemList.Items[I];
            if UserItem = nil then Continue;
            if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
              UserItem34 := UserItem^;
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if not m_PEnvir.AllowStdItems(UserItem.wIndex) then begin//检查地图是否禁用此物品
                  SysMsg(Format(g_sCanotMapUseItemMsg, [StdItem.Name]), c_Red, t_Hint);
                  Break;
                end;
                case StdItem.StdMode of
                  0, 1, 3: begin //药
                      if EatItems(StdItem) then begin
                        nCode:= 1;
                        if UserItem <> nil then begin
                          m_ItemList.Delete(I);
                          DisPoseAndNil(UserItem);
                        end;
                        boEatOK := True;
                      end;
                      Break;
                    end;
                  2: begin
                      if StdItem.AniCount= 21 then begin //祝福罐 类型的物品  20080315
                        if StdItem.Reserved <> 56 then begin
                          if UserItem.Dura > 0 then begin
                            if (m_ItemList.Count  - 1) <= MAXBAGITEM then begin
                              if UserItem.Dura >= 1000 then begin //修改为1000,20071229
                                Dec(UserItem.Dura, 1000);
                                Dec(UserItem.DuraMax, 1000);//20080324 减少存物品数量
                                if UserItem.DuraMax <= 0 then begin //不能存取物品,则删除物品
                                  if UserItem <> nil then begin
                                    m_ItemList.Delete(I);
                                    DisPoseAndNil(UserItem);
                                    boEatOK := True;
                                  end;
                                end;
                              end else begin
                                UserItem.Dura := 0;
                                UserItem.DuraMax:= 0;//20080324 减少存物品数量
                                if UserItem.DuraMax <= 0 then begin //能存取物品,则删除物品
                                  if UserItem <> nil then begin
                                    m_ItemList.Delete(I);
                                    DisPoseAndNil(UserItem);
                                    boEatOK := True;
                                  end;
                                end;
                              end;
                               //需要修改UnbindList.txt,加入 3 祝福油  20071229  3---为 祝福罐的外观值
                               GetUnBindItems(GetUnbindItemName(StdItem.Shape), 1); //给一个祝福油  20080310
                            end;
                          end;
                        end else begin//泉水罐
                          if UserItem.Dura >= 1000 then begin
                            if (m_ItemList.Count  - 1) <= MAXBAGITEM then begin
                              if UserItem.Dura >= 1000 then begin
                                Dec(UserItem.Dura, 1000);
                                //Dec(UserItem.DuraMax, 1000);//20080324 减少存物品数量
                              end else begin
                                UserItem.Dura := 0;
                                //UserItem.DuraMax:= 0;//20080324 减少存物品数量
                              end;
                               //需要修改UnbindList.txt,加入 1 泉水   1---为 泉水的外观值
                               GetUnBindItems(GetUnbindItemName(StdItem.Shape), 1); //给一个泉水
                              { if UserItem.DuraMax = 0 then begin //20080324 不能存取物品,则删除物品
                                  m_ItemList.Delete(I);
                                  DisPoseAndNil(UserItem);
                                  boEatOK := True;
                               end;}
                            end;
                          end;
                        end;
                         boSendUpDate := True;
                      end else

                      case StdItem.Shape of
                        0: begin     //计次物品 20080129
                          nCode:= 3;
                          if (StdItem.Source <> 0) and (StdItem.Reserved <> 0) then begin//捆绳类物品 20081217
                            if UserItem <> nil then begin
                              if UserItem.Dura > 0 then begin
                                if CheckStdmodeFunItem(StdItem) then begin
                                  if UserItem.Dura >= 1000 then begin
                                    Dec(UserItem.Dura, 1000);
                                    boEatOK := True;
                                    nCode:= 31;
                                    if UserItem.Dura > 0 then begin
                                       boSendUpDate := True;
                                       boEatOK := False;
                                    end else begin
                                      if UserItem <> nil then begin
                                        UserItem.wIndex:= 0;
                                        nCode:= 32;
                                        m_ItemList.Delete(I);
                                        nCode:= 33;
                                        DisPoseAndNil(UserItem);
                                      end;
                                    end;
                                  end else begin
                                    UserItem.Dura := 0;
                                    if UserItem <> nil then begin
                                      UserItem.wIndex:= 0;
                                      nCode:= 34;
                                      m_ItemList.Delete(I);
                                      nCode:= 35;
                                      DisPoseAndNil(UserItem);
                                    end;
                                  end;
                                  nCode:= 36;
                                  UseStdmodeFunItem(StdItem);
                                end;
                              end else UserItem.wIndex:= 0;
                            end;
                          end else begin//其它计次物品
                            if UserItem <> nil then begin//20081009 修改
                              if UserItem.Dura > 0 then begin
                                if UserItem.Dura >= 1000 then begin
                                  Dec(UserItem.Dura, 1000);
                                  boEatOK := True;
                                  nCode:= 37;
                                  if UserItem.Dura > 0 then begin
                                     boSendUpDate := True;
                                     boEatOK := False;
                                  end else begin
                                    if UserItem <> nil then begin
                                      UserItem.wIndex:= 0;
                                      nCode:= 38;
                                      m_ItemList.Delete(I);
                                      nCode:= 39;
                                      DisPoseAndNil(UserItem);
                                    end;
                                  end;
                                end else begin
                                  UserItem.Dura := 0;
                                  if UserItem <> nil then begin
                                    UserItem.wIndex:= 0;
                                    nCode:= 201;
                                    m_ItemList.Delete(I);
                                    nCode:= 202;
                                    DisPoseAndNil(UserItem);
                                  end;
                                end;
                                nCode:= 203;
                                UseStdmodeFunItem(StdItem);
                              end else UserItem.wIndex:= 0;
                            end;
                          end;
                        end;//0
                        1: begin //召唤强化卷 20080221
                            nCode:= 4;
                            if UserItem.Dura > 0 then begin
                              if UserItem.Dura >= 1000 then begin
                                 if CallMobeItem() then begin //召唤强化卷,把招出的宝宝变成7级  20080221
                                   Dec(UserItem.Dura, 1000);
                                   boEatOK := True;
                                 end;
                              end else begin
                               UserItem.Dura := 0;
                               UserItem.wIndex:= 0;
                              end;
                            end;
                            if UserItem.Dura > 0 then begin
                              boSendUpDate := True;
                              boEatOK := False;
                            end else begin
                              if UserItem <> nil then begin
                                m_ItemList.Delete(I);
                                DisPoseAndNil(UserItem);
                              end;
                            end;
                         end;
                        9: begin //原为1  修复神水 20071229
                            nCode:= 5;
                            ItemCount:= RepairAllItemDura;
                            if (UserItem.Dura > 0) and (ItemCount > 0) then begin
                              if UserItem.Dura >= (ItemCount div 10 ) then begin //20080325
                                Dec(UserItem.Dura, (ItemCount div 10 ));//20080325
                                RepairAllItem(ItemCount div 1000, False);//全部修复
                                if UserItem.Dura < 100 then UserItem.Dura:= 0;
                              end else begin
                                UserItem.Dura:= 0;
                                RepairAllItem(ItemCount div 1000, True);
                              end;
                            end;
                            boEatOK := False;
                            if UserItem.Dura > 0 then begin
                              boSendUpDate := True;
                            end else begin
                              if UserItem <> nil then begin
                                m_ItemList.Delete(I);
                                DisPoseAndNil(UserItem);
                              end;
                              boEatOK := True;
                            end;
                          end;
                        2: begin //随机传送石
                            nCode:= 6;
                            if not m_PEnvir.m_boNORANDOMMOVE then begin//地图没有禁止随机传送时才能使用 20080831
                              if UserItem.Dura > 0 then begin
                                if UserItem.Dura >= 1000 then begin
                                  Dec(UserItem.Dura, 1000);
                                end else begin
                                  UserItem.Dura := 0;
                                  UserItem.wIndex:= 0;//20081014
                                end;
                                boEatOK := True;
                                RandomMove();
                              end;
                              if UserItem.Dura > 0 then begin
                                boSendUpDate := True;
                                boEatOK := False;
                              end else begin
                                if UserItem <> nil then begin
                                  m_ItemList.Delete(I);
                                  DisPoseAndNil(UserItem);
                                end;
                              end;
                            end;
                          end;
                         3:begin
                             case StdItem.AniCount of
                               15,16,17:begin //双倍卷轴 双倍秘籍 双倍宝典 20071230---使用时,必进入这里,是脚本触发 ActionOfKillMonExpRate
                                  nCode:= 7;
                                  if UserItem.Dura > 0 then begin
                                    if UserItem.Dura >= 1000{100} then begin
                                      Dec(UserItem.Dura, 1000{100});
                                    end else begin
                                      UserItem.Dura := 0;
                                      UserItem.wIndex:= 0;//20081014
                                    end;
                                      m_nKillMonExpRate:= m_nKillMonExpRate * 2; //调整杀怪经验为双倍数
                                      m_nOldKillMonExpRate := m_nKillMonExpRate;//20080607
                                      m_dwKillMonExpRateTime:= m_dwKillMonExpRateTime + 180 ;//经验倍数时间(秒)
                                      if m_MyHero <> nil then begin //英雄也同时双倍经验  20080406
                                         THeroObject(m_MyHero).m_nKillMonExpRate:= THeroObject(m_MyHero).m_nKillMonExpRate * 2;
                                         THeroObject(m_MyHero).m_nOldKillMonExpRate := THeroObject(m_MyHero).m_nKillMonExpRate;//20080607
                                      end;
                                      SysMsg(Format(g_sChangeKillMonExpRateMsg, [m_nKillMonExpRate / 100, m_dwKillMonExpRateTime]), c_Green, t_Hint);
                                      boEatOK := True;
                                  end;
                                  if UserItem.Dura > 0 then begin
                                    boSendUpDate := True;
                                    boEatOK := False;
                                  end else begin
                                    if UserItem <> nil then begin
                                      m_ItemList.Delete(I);
                                      DisPoseAndNil(UserItem);
                                    end;
                                  end;
                                end;
                             end;//case
                          end;//20071229
                      end;
                    end;
                  4: begin //书
                      nCode:= 8;
                      if ReadBook(StdItem) then begin
                        if UserItem <> nil then begin
                          m_ItemList.Delete(I);
                          DisPoseAndNil(UserItem);
                        end;
                        boEatOK := True;
                      end;
                    end;
                  7: begin //使用次数  {数据库中没有分类是7的物品 20071229}
                      nCode:= 9;
                      case StdItem.Shape of //修复神水
                        0: begin
                            if UserItem.Dura > 0 then begin
                              if UserItem.Dura >= 1000 then begin
                                Dec(UserItem.Dura, 1000);
                              end else begin
                                UserItem.Dura := 0;
                                UserItem.wIndex:= 0;//20081014
                              end;
                              //RepairAllItem();
                              boEatOK := True;
                            end;
                            if UserItem.Dura > 0 then begin
                              boSendUpDate := True;
                              boEatOK := False;
                            end else begin
                              if UserItem <> nil then begin
                                m_ItemList.Delete(I);
                                DisPoseAndNil(UserItem);
                              end;
                            end;
                          end;
                      end;
                    end;
                  31: begin //解包物品
                      nCode:= 10;
                      case StdItem.AniCount of
                         0..3:begin
                           if (m_ItemList.Count + 6 - 1) <= MAXBAGITEM then begin
                              if UserItem <> nil then begin
                                m_ItemList.Delete(I);
                                DisPoseAndNil(UserItem);
                              end;
                              GetUnBindItems(GetUnbindItemName(StdItem.Shape), 6);
                              boEatOK := True;
                           end;
                         end;
                         4..255:begin
                         case StdItem.Shape of
                          0: begin
                              if FoundUserItem(UserItem) then begin//20080819 先查找物品，删除物品后再触发
                                if UserItem <> nil then begin
                                  m_ItemList.Delete(I);
                                  ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理复制品 20080901
                                  DisPoseAndNil(UserItem);
                                  UseStdmodeFunItem(StdItem);//使用物品触发脚本段
                                end;
                                boEatOK := True;
                              end; 
                            end;
                          1: begin
                              if ItemDblClick(StdItem.Name, UserItem.MakeIndex, sMapName, nCurrX, nCurrY) then begin
                                if UserItem <> nil then begin
                                   m_ItemList.Delete(I);
                                   DisPoseAndNil(UserItem);
                                end;
                                SpaceMove(sMapName, nCurrX, nCurrY, 0);
                                boEatOK := True;
                              end else begin
                                SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '当前地图坐标保存成功！！！\再次双击，将传送到\地图：' + m_sMapName + ' 坐标：' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY));
                              end;
                            end;
                        end; //case StdItem.Shape of
                        end;
                       end;
                    end; //31  
                  51:begin //20080221 聚灵珠
                      nCode:= 11;
                      if StdItem.Shape = 0 then begin
                        if UserItem.btValue[12] = 2 then begin //聚集满了经验，或是聚集时间到,才可使用
                           //GetExp(UserItem.Dura * 10000,True);//增加人物的经验  20080522

                          dwExp:= UserItem.Dura * 10000;//20080817 修改
                          if m_MyHero <> nil then begin
                            THeroObject(m_MyHero).GetExp(abs(Round((g_Config.nHeroNoKillMonExpRate / 100) * dwExp)));//20081018 修改
                            dwExp:= abs(Round(((100 - g_Config.nHeroNoKillMonExpRate) / 100) * dwExp));//20081018 修改
                          end;
                          Inc(m_Abil.Exp, dwExp);
                          SendMsg(self, RM_WINEXP, 0, dwExp, 0, 0, '');
                          if m_Abil.Exp >= m_Abil.MaxExp then begin//20080825
                            Dec(m_Abil.Exp, m_Abil.MaxExp);
                            if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then Inc(m_Abil.Level);//增加限制等级
                            if m_Abil.Level < g_Config.nLimitExpLevel then HasLevelUp(m_Abil.Level - 1);//增加限制等级
                            AddGameDataLog('12' + #9 + m_sMapName + #9 + //人物升级记录日志
                              IntToStr(m_Abil.Level) + #9 +
                              IntToStr(m_Abil.Exp)+'/'+IntToStr(m_Abil.MaxExp) + #9 +
                              m_sCharName + #9 + '0' + #9 +'0' + #9 + '1' + #9 + '聚灵珠');
                          end;
                          if m_Magic68Skill <> nil then begin//学过酒气护体 20080825
                            if m_Magic68Skill.btLevel < 100 then Inc(m_Exp68, dwExp);
                            if m_Exp68 >= m_MaxExp68 then begin//超过升级经验,则升级技能
                              Dec(m_Exp68, m_MaxExp68);
                              if m_Magic68Skill.btLevel < 100 then Inc(m_Magic68Skill.btLevel);
                              m_MaxExp68 := GetSkill68Exp(m_Magic68Skill.btLevel);
                              SendDelayMsg(self, RM_MAGIC_LVEXP, 0, m_Magic68Skill.MagicInfo.wMagicId, m_Magic68Skill.btLevel, m_Magic68Skill.nTranPoint, '', 100);
                            end;
                            if m_Magic68Skill.btLevel < 100 then //20080830 增加
                              SendMsg(self, RM_MAGIC68SKILLEXP, 0, 0, 0, 0, EncodeString(Inttostr(m_Exp68)+'/'+Inttostr(m_MaxExp68)));//发送酒气护体经验
                          end;

                          if UserItem <> nil then begin
                            m_ItemList.Delete(I);
                            DisPoseAndNil(UserItem);
                          end;
                          boEatOK := True;
                        end;
                      end;
                    end;//51
                  60:begin//饮酒 20080622
                    nCode:= 12;
                    if (StdItem.Shape <> 0) then begin//除烧酒外
                      if not n_DrinkWineDrunk then begin //没有喝醉
                        if m_Abil.MaxAlcohol >= StdItem.Need then begin//酒量值达到要求
                          if UserItem.Dura > 0 then begin
                            if UserItem.Dura >= 1000 then begin
                              Dec(UserItem.Dura, 1000);
                            end else begin
                              UserItem.Dura := 0;
                            end;
                            SendRefMsg(RM_MYSHOW, 7, 0, 0, 0, ''); //喝酒自身动画  20080623
                            if m_Abil.WineDrinkValue = 0 then begin//如果醉酒度为0,则初始时间间隔
                               m_dwDecWineDrinkValueTick:= GetTickCount();
                               m_dwAddAlcoholTick := GetTickCount();
                            end;

                            Inc(m_Abil.WineDrinkValue, (UserItem.btValue[1] * m_Abil.MaxAlcohol div 200));//增加醉酒度 20080623
                            n_DrinkWineAlcohol:= UserItem.btValue[1];//饮酒时酒的度数 20080624
                            n_DrinkWineQuality:= UserItem.btValue[0];//饮酒时酒的品质 20080623
                            if m_Abil.WineDrinkValue >= m_Abil.MaxAlcohol then begin//醉酒度超过上限,即喝醉了
                               m_Abil.WineDrinkValue:=  m_Abil.MaxAlcohol;
                               n_DrinkWineDrunk:= True;//喝酒醉了 20080623
                               SysMsg('自觉头晕不已,酒虽为情所系,奈何量去甚多,暂无余力再饮!',c_Red,t_Hint);
                               SendRefMsg(RM_MYSHOW, 9 ,0, 0, 0, ''); //喝醉自身动画  20080623
                            end;
                            //普通酒,品质2以上,25%机率加临时属性 20080713
                            if (StdItem.Anicount = 1) and (n_DrinkWineQuality > 2) and (Random(4)=0) and (not n_DrinkWineDrunk) then begin
                               Case Random(2) of
                                 0: DefenceUp(300);//增加防御力300秒
                                 1: MagDefenceUp(300);//增加魔御300秒
                               end;
                            end;
                            if (StdItem.Anicount = 2) and (not n_DrinkWineDrunk) then begin//药酒可增加药力值
                              //品质为4以上,药酒增加临时属性 20080626
                              if n_DrinkWineQuality > 4 then begin
                                case StdItem.Shape of
                                  8:begin//虎骨酒 增加攻击上限,魔法上限或道术上限2点,效果持续600秒
                                      Case m_btJob of
                                        0:begin
                                           m_wStatusArrValue[0]:= 2;
                                           m_dwStatusArrTimeOutTick[0]:= GetTickCount + 600000{600 * 1000};
                                        end;
                                        1:begin
                                           m_wStatusArrValue[1]:= 2;
                                           m_dwStatusArrTimeOutTick[1]:= GetTickCount + 600000{600 * 1000};
                                        end;
                                        2:begin
                                           m_wStatusArrValue[2]:= 2;
                                           m_dwStatusArrTimeOutTick[2]:= GetTickCount + 600000{600 * 1000};
                                        end;
                                        {3:begin//刺客
                                        end; }
                                      end;
                                   end;
                                  9:begin//金箔酒  增加生命值上限100点,效果持续600秒
                                     m_wStatusArrValue[4]:= 100;
                                     m_dwStatusArrTimeOutTick[4]:= GetTickCount + 600000{600 * 1000};
                                  end;
                                  10:begin//活脉酒  增加敏捷2点,效果持续600秒
                                     m_wStatusArrValue[11]:= 2;
                                     m_dwStatusArrTimeOutTick[11]:= GetTickCount + 600000{600 * 1000};
                                  end;
                                  11:begin//玄参酒  增加防御上限4点,效果持续600秒
                                      m_wStatusTimeArr[9]:= 4;
                                      m_dwStatusArrTimeOutTick[9]:= GetTickCount + 600000{600 * 1000};
                                  end;
                                  12:begin//蛇胆酒  增加魔法值上限200点,效果持续600秒
                                     m_wStatusArrValue[5]:= 200;
                                     m_dwStatusArrTimeOutTick[5]:= GetTickCount + 600000{600 * 1000};
                                  end;
                                end;
                              end;
                              dw_UseMedicineTime:= g_Config.nDesMedicineTick;//始化使用药酒时间(12小时)
                              Inc(m_Abil.MedicineValue,UserItem.btValue[2]);//增加药力值
                              if m_Abil.MedicineValue >= m_Abil.MaxMedicineValue then begin//当前药力值达到当前等级上限时
                                 Dec(m_Abil.MedicineValue, m_Abil.MaxMedicineValue);
                                 Case (n_MedicineLevel mod 6) of//增加永久属性
                                   0:begin//攻击/魔法/道术上限(看职业)
                                      Case m_btJob of
                                        0: m_Abil.DC := MakeLong(m_Abil.DC, m_Abil.DC+1);
                                        1: m_Abil.MC := MakeLong(m_Abil.MC, m_Abil.MC+1);
                                        2: m_Abil.SC := MakeLong(m_Abil.SC, m_Abil.SC+1);
                                        //3:;//刺客
                                      end;
                                   end;
                                   1: m_Abil.MAC := MakeLong(m_Abil.MAC+1, m_Abil.MAC);//加魔御下限
                                   2: m_Abil.AC := MakeLong(m_Abil.AC+1, m_Abil.AC);//加防御下限
                                   3:begin//攻击/魔法/道术下限(看职业)
                                      Case m_btJob of
                                        0: m_Abil.DC := MakeLong(m_Abil.DC+1, m_Abil.DC);
                                        1: m_Abil.MC := MakeLong(m_Abil.MC+1, m_Abil.MC);
                                        2: m_Abil.SC := MakeLong(m_Abil.SC+1, m_Abil.SC);
                                        //3:;//刺客
                                      end;
                                   end;
                                   4: m_Abil.MAC := MakeLong(m_Abil.MAC, m_Abil.MAC+1);//魔御上限
                                   5: m_Abil.AC := MakeLong(m_Abil.AC, m_Abil.AC+1);//防御上限
                                 end;//Case (n_MedicineLevel mod 6) of
                                 if n_MedicineLevel < MAXUPLEVEL then Inc(n_MedicineLevel);//增加等级
                                 m_Abil.MaxMedicineValue := GetMedicineExp(n_MedicineLevel);//取升级后的等级对应的药力值
                                 SysMsg('酒劲在周身弥漫,感觉身体状态有所改变',c_Red,t_Hint);//提示用户
                              end;
                            end;//if StdItem.Anicount = 2 then
                            RecalcAbilitys();
                            CompareSuitItem(False);//套装与身上装备对比 20080729
                            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                            boEatOK := True;
                          end;
                          if UserItem.Dura > 0 then begin
                            boSendUpDate := True;
                            boEatOK := False;
                          end else begin
                            if UserItem <> nil then begin
                              UserItem.wIndex:= 0;//20081014
                              m_ItemList.Delete(I);
                              DisPoseAndNil(UserItem);
                            end;  
                          end;
                        end else begin
                           SysMsg('酒量需达到'+inttostr(StdItem.Need)+'才能饮用!',c_Red,t_Hint);//提示用户
                        end;
                      end else begin
                         SysMsg('自觉头晕不已,酒虽为情所系,奈何量去甚多,暂无余力再饮!',c_Red,t_Hint);
                      end;
                    end;//if (StdItem.Shape <> 0)
                  end;//60
                end;
                Break;
              end;
            end;
          end;//for
        end;//
      end else begin
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotUseItemMsg);
      end;
      if boEatOK then begin
        nCode:= 13;
        WeightChanged();
        SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('11' + #9 + m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 + StdItem.Name + #9 +
            IntToStr(UserItem34.MakeIndex) + #9 +
            '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
            '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
            '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
            '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
            '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
            IntToStr(UserItem34.btValue[0])+'/'+IntToStr(UserItem34.btValue[1])+'/'+IntToStr(UserItem34.btValue[2])+'/'+
            IntToStr(UserItem34.btValue[3])+'/'+IntToStr(UserItem34.btValue[4])+'/'+IntToStr(UserItem34.btValue[5])+'/'+
            IntToStr(UserItem34.btValue[6])+'/'+IntToStr(UserItem34.btValue[7])+'/'+IntToStr(UserItem34.btValue[8])+'/'+
            IntToStr(UserItem34.btValue[14])+ #9 +'0');
      end else begin
        nCode:= 14;
        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
      end;
      if (UserItem <> nil) and boSendUpDate then SendUpdateItem(UserItem);
    except
      MainOutMessage('{异常} TPlayObject.ClientUseItems Code:'+inttostr(nCode));
    end;
  finally
    m_boCanQueryBag:= False;
  end;
end;

function TPlayObject.ItemDblClick(sItemName: string; nMakeIndex: Integer; var sMapName: string; var nCurrX, nCurrY: Integer): Boolean;
var
  I: Integer;
  ItemEvent: pTItemEvent;
begin
  Result := False;
  sMapName := '';
  nCurrX := -1;
  nCurrY := -1;
  g_ItemDblClickList.Lock;
  try
    for I := g_ItemDblClickList.Count - 1 downto 0 do begin
      if g_ItemDblClickList.Count <= 0 then Break;//20080917
      ItemEvent := g_ItemDblClickList.Items[I];
      if ItemEvent.m_nMakeIndex = nMakeIndex then begin
        sMapName := ItemEvent.m_sMapName;
        nCurrX := ItemEvent.m_nCurrX;
        nCurrY := ItemEvent.m_nCurrY;
        g_ItemDblClickList.Delete(I);
        Dispose(ItemEvent);
        Result := True;
        Break;
      end;
    end;//for
    if not Result then begin
      New(ItemEvent);
      ItemEvent.m_sItemName := sItemName;
      ItemEvent.m_nMakeIndex := nMakeIndex;
      ItemEvent.m_sMapName := m_sMapName;
      ItemEvent.m_nCurrX := m_nCurrX;
      ItemEvent.m_nCurrY := m_nCurrY;
      g_ItemDblClickList.Add(ItemEvent);
    end;
  finally
    g_ItemDblClickList.UnLock;
  end;
  SaveItemDblClickList();
end;
//使用物品触发
function TPlayObject.UseStdmodeFunItem(StdItem: pTStdItem): Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@StdModeFunc' + IntToStr(StdItem.AniCount), False);
    Result := True;
  end;
end;
//检查包裹是否有指定物品，是否达到指定数 药绳捆使用 20081217
function TPlayObject.CheckStdmodeFunItem(StdItem: pTStdItem): Boolean;
var
  I, nCount: Integer;
  UserItem: pTUserItem;
  StdItem1: pTStdItem;
begin
  Result := False;
  try
    nCount := 0;
    if m_ItemList.Count > 0 then begin
      for I := 0 to m_ItemList.Count - 1 do begin
        UserItem := m_ItemList.Items[I];
        if UserItem <> nil then begin
          StdItem1 := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem1 <> nil then begin
            if (StdItem1.StdMode = 0) and (StdItem1.Source = StdItem.Source) then begin//是药品，并与捆绳对应
              Inc(nCount);
              if nCount >= StdItem.Reserved then begin
                Result := True;
                Break;
              end;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage('{异常} TPlayObject.CheckStdmodeFunItem');
  end;
end;

//人物死亡触发
function TPlayObject.DieFunc: Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@PlayDie', False);
    Result := True;
  end;
end;

//人物学技能触发 20080324
function TPlayObject.AddSkillFunc(MagicID: Integer): Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@HeroplaySkill'+inttostr(MagicID), False);
    Result := True;
  end;
end;

//英雄学技能触发 20080324
function TPlayObject.HeroAddSkillFunc(MagicID: Integer): Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@playSkill'+inttostr(MagicID), False);
    Result := True;
  end;
end;

//宝宝杀死怪触发  清清 20080126
function TPlayObject.KillMissionMob: Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@KillMissionMob', False);
    Result := True;
  end;
end;

//人物升级触发
function TPlayObject.LevelUpFunc: Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@PlayLevelUp', False);
    Result := True;
  end;
end;
//杀人触发
function TPlayObject.KillPlayFunc: Boolean;
begin
  Result := False;
  try
    if g_FunctionNPC <> nil then begin
      //20080415 地图杀人触发
      if m_PEnvir <> nil then begin//20090101
        if m_PEnvir.m_boKILLFUNC then g_FunctionNPC.GotoLable(Self, '@KillPlay'+ Inttostr(m_PEnvir.m_nKILLFUNC), False);
      end;
      g_FunctionNPC.GotoLable(Self, '@KillPlay', False);
      Result := True;
    end;
  except
    MainOutMessage('{异常} TPlayObject.KillPlayFunc');
  end;
end;
//20080120 客户端挖尸体东西
function TPlayObject.ClientGetButchItem(BaseObject: TBaseObject; nX, nY: Integer; btDir: Byte; var dwDelayTime: LongWord): Boolean; //004DB7E0
var
  n10, n14: Integer;
  dwCheckTime: LongWord;
  Butch:Boolean;
  ButchChargeCount, I, K, ButchChargeClass: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sCheckItemName: string;
  MonItem: pTMonItemInfo;
  nItemCount:Byte;//进入触发段前的包裹物品数量 20080925
  nLevel: Word;//进入触发段前的等级 20081018
  nExp: LongWord;//进入触发段前的经验 20081018
  nGameDiamond, nCreditPoint, nGameGird:Integer;//进入触发段前的金刚石,声望,灵符 20081018
  nCode: Byte;//20080528 异常提示
begin
  Result := False;
  Butch:= False;
  if (BaseObject = nil) or (m_boGhost) or (m_boDeath) then Exit;//20080703 增加人死后不能挖人形物品
  //if not m_PEnvir.IsValidObject(nX, nY, 2, BaseObject) then Exit;
  if BaseObject.m_boGhost then Exit;//20081216
  if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit;//如果快要清理尸体时，则不再进入 20081222
  nCode:= 36;
  dwDelayTime := 0;
  nItemCount := 0;
  nLevel:= 0;
  nExp := 0;
  nGameDiamond := 0;
  nCreditPoint := 0;
  nGameGird := 0;
  ButchChargeCount:= 0;
  dwCheckTime := GetTickCount - m_dwTurnTick;
  if dwCheckTime < g_Config.dwTurnIntervalTime then begin
    dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
    Exit;
  end;
  m_dwTurnTick := GetTickCount;
  try
    case BaseObject.m_btRaceServer of
      121:begin//巨镰蜘蛛 20080810
          ButchChargeClass:= TGiantSickleSpiderATMonster(BaseObject).m_nButchChargeClass;
          nCode:= 42;
          if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) {and (BaseObject.m_btSlaveExpLevel = 0)} and (BaseObject.m_btSlaveMakeLevel=0) then begin
            nCode:= 43;
            ButchChargeCount:= TGiantSickleSpiderATMonster(BaseObject).m_nButchChargeCount;
            case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
              0:begin //金币模式
                 if m_nGold >= ButchChargeCount then begin
                   Butch:= True;
                 end else SysMsg('您的金币没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
                end;
              1:begin//元宝模式
                  if m_nGameGold >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameGoldName+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
                end;
              2:begin//金刚石模式
                  if m_nGAMEDIAMOND >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameDiaMond+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
               end;
              3:begin//灵符模式
                  if m_nGAMEGIRD >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameGird+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
               end;
            end; //Case
            nCode:= 44;
            if Butch then begin//挖所需的条件达到
               case Random(3) of//随机处理挖
                 0:begin//挖取列表中的物品
                    nCode:= 45;
                    if (BaseObject<> nil) then begin
                      if BaseObject.m_boGhost then Exit;//20081216
                      for I := TGiantSickleSpiderATMonster(BaseObject).m_ButchItemList.count-1 downto 0 do begin//20080916 修改
                        if BaseObject.m_boGhost then Exit;//20081216
                        if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit;//如果快要清理尸体时，则不再进入 20081222
                        if TGiantSickleSpiderATMonster(BaseObject).m_ButchItemList.Count <= 0 then Break;//20080916
                        MonItem := pTMonItemInfo(TGiantSickleSpiderATMonster(BaseObject).m_ButchItemList.Items[I]);
                        if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                           nCode:= 46;
                           m_nGold := m_nGold + MonItem.Count;
                           if MonItem.Count > 0 then begin
                              if g_boGameLogGold then
                                AddGameDataLog('37' + #9 +m_sMapName + #9 +
                                  IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                  sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 +'1' + #9 + BaseObject.m_sCharName);
                           end;
                           GoldChanged;
                           if BaseObject <> nil then TGiantSickleSpiderATMonster(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0:begin //金币模式
                                  Dec(m_nGold,ButchChargeCount);
                                  GoldChanged();//20080414 更新玩家的金币
                                end;
                              1:begin//元宝模式
                                  Dec(m_nGameGold,ButchChargeCount);
                                  GameGoldChanged;//更新元宝数量  20080414
                                end;
                              2:begin//金刚石模式
                                  Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                  GameGoldChanged();//更新金刚石数量 20080414
                               end;
                              3:begin//灵符模式
                                  Dec(m_nGAMEGIRD,ButchChargeCount);
                                  GameGoldChanged();//更新灵符数量 20080414
                               end;
                            end; //Case
                           SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示
                           Break;
                        end else begin
                          New(UserItem);
                          if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                            nCode:= 47;
                            UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                            if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                            nCode:= 48;
                            if (UserItem <> nil) then begin
                              nCode:= 49;
                              case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                0:begin //金币模式
                                    Dec(m_nGold,ButchChargeCount);
                                    GoldChanged();//20080414 更新玩家的金币
                                  end;
                                1:begin//元宝模式
                                    Dec(m_nGameGold,ButchChargeCount);
                                    GameGoldChanged;//更新元宝数量  20080414
                                  end;
                                2:begin//金刚石模式
                                    Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                    GameGoldChanged();//更新金刚石数量 20080414
                                 end;
                                3:begin//灵符模式
                                    Dec(m_nGAMEGIRD,ButchChargeCount);
                                    GameGoldChanged();//更新灵符数量 20080414
                                 end;
                              end; //Case
                              nCode:= 50;
                              if BaseObject <> nil then TGiantSickleSpiderATMonster(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                              SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示 20080325
                              sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                              PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0);//禁止物品规则(管理插件功能) 20080729

                              if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                    if StdItem.NeedIdentify = 1 then
                                      AddGameDataLog('37' + #9 +m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                      IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +StdItem.Name + #9 +
                                      IntToStr(UserItem.MakeIndex) + #9 +
                                      '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                      '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                      '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                      '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                      '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                      IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                      IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                                      IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                                      IntToStr(UserItem.btValue[14])+ #9 + BaseObject.m_sCharName);
                                    m_ItemList.Add(UserItem);
                                    nCode:= 51;
                                    if m_btRaceServer = RC_PLAYOBJECT then begin
                                       nCode:= 52;
                                       SendAddItem(UserItem);
                                       SendUpdateItem(UserItem);//更新物品
                                    end;
                                    Break; //一次只给玩家一件物品 20080121
                                end;
                              end else begin
                                nCode:= 53;
                                DropItemDown(UserItem, 3, False, False, self, self);//20080610
                                SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                Break; //一次只给玩家一件物品 20080121
                              end;
                            end;
                          end else Dispose(UserItem);//if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                        end;
                        //if TGiantSickleSpiderATMonster(BaseObject).m_ButchItemList.count = 0 then SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red, t_Hint);
                      end; //for I := TGiantSickleSpiderATMonster(BaseObject).m_ItemList.count-1 downto 0 do begin
                    end;
                  end;//0
                 1,2:begin//进入触发段
                    if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                    if (g_FunctionNPC <> nil) and TGiantSickleSpiderATMonster(BaseObject).boIntoTrigger and IsEnoughBag then begin//20080716
                      if g_FunctionNPC.m_boGotoCount < 80 then begin//防止Goto数量过多,引起M2挂死 20081004
                        nItemCount:= m_ItemList.Count;//进入触发段前的包裹物品数量 20080925
                        nLevel:= m_Abil.Level;//进入触发段前的等级 20081018
                        nExp := m_Abil.Exp;//进入触发段前的经验 20081018
                        nGameDiamond := m_nGAMEDIAMOND;//进入触发段前的金刚石 20081018
                        nCreditPoint := m_btCreditPoint;//进入触发段前的声望 20081018
                        nGameGird := m_nGameGird;//进入触发段前的灵符 20081018
                        g_FunctionNPC.GotoLable(Self, '@ButchCloneItem'+BaseObject.m_sCharName, False);
                        if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.Exp) and (nLevel = m_Abil.Level)) or
                          ((nExp > m_Abil.Exp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                          (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                          case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                            0:begin //金币模式
                                Dec(m_nGold,ButchChargeCount);
                                GoldChanged();//20080414 更新玩家的金币
                              end;
                            1:begin//元宝模式
                                Dec(m_nGameGold,ButchChargeCount);
                                GameGoldChanged;//更新元宝数量  20080414
                              end;
                            2:begin//金刚石模式
                                Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                GameGoldChanged();//更新金刚石数量 20080414
                             end;
                            3:begin//灵符模式
                                Dec(m_nGAMEGIRD,ButchChargeCount);
                                GameGoldChanged();//更新灵符数量 20080414
                             end;
                          end; //Case
                          SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示 20080607
                        end;//if nItemCount < m_ItemList.Count then begin
                      end;
                    end;
                  end;//1
               end;//case Random(2)
            end;//if Butch then
         end;//if BaseObject.m_boDeath
       end;//121
      122:begin//狂热火蜥蜴 20080810
          ButchChargeClass:= TSalamanderATMonster(BaseObject).m_nButchChargeClass;
          nCode:= 54;
          if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) {and (BaseObject.m_btSlaveExpLevel = 0)} and (BaseObject.m_btSlaveMakeLevel=0) then begin
            nCode:= 55;
            ButchChargeCount:= TSalamanderATMonster(BaseObject).m_nButchChargeCount;
            case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
              0:begin //金币模式
                 if m_nGold >= ButchChargeCount then begin
                   Butch:= True;
                 end else SysMsg('您的金币没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
                end;
              1:begin//元宝模式
                  if m_nGameGold >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameGoldName+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
                end;
              2:begin//金刚石模式
                  if m_nGAMEDIAMOND >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameDiaMond+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
               end;
              3:begin//灵符模式
                  if m_nGAMEGIRD >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameGird+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
               end;
            end; //Case
            nCode:= 56;
            if Butch then begin//挖所需的条件达到
               case Random(3) of//随机处理挖
                 0:begin//挖取列表中的物品
                    nCode:= 57;
                    if (BaseObject<> nil) then begin
                      if BaseObject.m_boGhost then Exit;//20081216
                      for I := TSalamanderATMonster(BaseObject).m_ButchItemList.count-1 downto 0 do begin//20080916 修改
                        if BaseObject.m_boGhost then Exit;//20081216
                        if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit;//如果快要清理尸体时，则不再进入 20081222
                        if TSalamanderATMonster(BaseObject).m_ButchItemList.count <= 0 then Break;//20080916
                        MonItem := pTMonItemInfo(TSalamanderATMonster(BaseObject).m_ButchItemList.Items[I]);
                        if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                           nCode:= 58;
                           m_nGold := m_nGold + MonItem.Count;
                           if MonItem.Count > 0 then begin
                              if g_boGameLogGold then
                                AddGameDataLog('37' + #9 +m_sMapName + #9 +
                                  IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                  sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 +'1' + #9 + BaseObject.m_sCharName);
                           end;
                           GoldChanged;
                           if BaseObject <> nil then TSalamanderATMonster(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0:begin //金币模式
                                  Dec(m_nGold,ButchChargeCount);
                                  GoldChanged();//20080414 更新玩家的金币
                                end;
                              1:begin//元宝模式
                                  Dec(m_nGameGold,ButchChargeCount);
                                  GameGoldChanged;//更新元宝数量  20080414
                                end;
                              2:begin//金刚石模式
                                  Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                  GameGoldChanged();//更新金刚石数量 20080414
                               end;
                              3:begin//灵符模式
                                  Dec(m_nGAMEGIRD,ButchChargeCount);
                                  GameGoldChanged();//更新灵符数量 20080414
                               end;
                            end; //Case
                           SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示
                           Break;
                        end else begin
                          New(UserItem);
                          if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                            nCode:= 59;
                            UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                            if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                            nCode:= 60;
                            if (UserItem <> nil) then begin
                              nCode:= 61;
                              case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                0:begin //金币模式
                                    Dec(m_nGold,ButchChargeCount);
                                    GoldChanged();//20080414 更新玩家的金币
                                  end;
                                1:begin//元宝模式
                                    Dec(m_nGameGold,ButchChargeCount);
                                    GameGoldChanged;//更新元宝数量  20080414
                                  end;
                                2:begin//金刚石模式
                                    Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                    GameGoldChanged();//更新金刚石数量 20080414
                                 end;
                                3:begin//灵符模式
                                    Dec(m_nGAMEGIRD,ButchChargeCount);
                                    GameGoldChanged();//更新灵符数量 20080414
                                 end;
                              end; //Case
                              nCode:= 62;
                              if BaseObject <> nil then TSalamanderATMonster(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                              SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示 20080325
                              sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                              PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0);//禁止物品规则(管理插件功能) 20080729

                              if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                    if StdItem.NeedIdentify = 1 then
                                      AddGameDataLog('37' + #9 +m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                      IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +StdItem.Name + #9 +
                                      IntToStr(UserItem.MakeIndex) + #9 +
                                      '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                      '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                      '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                      '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                      '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                      IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                      IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                                      IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                                      IntToStr(UserItem.btValue[14])+ #9 + BaseObject.m_sCharName);
                                    m_ItemList.Add(UserItem);
                                    nCode:= 63;
                                    if m_btRaceServer = RC_PLAYOBJECT then begin
                                       nCode:= 64;
                                       SendAddItem(UserItem);
                                       SendUpdateItem(UserItem);//更新物品
                                    end;
                                    Break; //一次只给玩家一件物品 20080121
                                end;
                              end else begin
                                nCode:= 65;
                                DropItemDown(UserItem, 3, False, False, self, self);//20080610
                                SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                Break; //一次只给玩家一件物品 20080121
                              end;
                            end;
                          end else Dispose(UserItem);//if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                        end;
                        //if TSalamanderATMonster(BaseObject).m_ButchItemList.count = 0 then SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red, t_Hint);
                      end; //for I :=TSalamanderATMonster(BaseObject).m_ItemList.count-1 downto 0 do begin
                    end;
                  end;//0
                 1,2:begin//进入触发段
                    if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                    if (g_FunctionNPC <> nil) and TSalamanderATMonster(BaseObject).boIntoTrigger and IsEnoughBag then begin//20080716
                      if g_FunctionNPC.m_boGotoCount < 80 then begin//防止Goto数量过多,引起M2挂死 20081004
                        nItemCount:= m_ItemList.Count;//进入触发段前的包裹物品数量 20080925
                        nLevel:= m_Abil.Level;//进入触发段前的等级 20081018
                        nExp := m_Abil.Exp;//进入触发段前的经验 20081018
                        nGameDiamond := m_nGAMEDIAMOND;//进入触发段前的金刚石 20081018
                        nCreditPoint := m_btCreditPoint;//进入触发段前的声望 20081018
                        nGameGird := m_nGameGird;//进入触发段前的灵符 20081018
                        g_FunctionNPC.GotoLable(Self, '@ButchCloneItem'+BaseObject.m_sCharName, False);
                        if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.Exp) and (nLevel = m_Abil.Level)) or
                          ((nExp > m_Abil.Exp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                          (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                          case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                            0:begin //金币模式
                                Dec(m_nGold,ButchChargeCount);
                                GoldChanged();//20080414 更新玩家的金币
                              end;
                            1:begin//元宝模式
                                Dec(m_nGameGold,ButchChargeCount);
                                GameGoldChanged;//更新元宝数量  20080414
                              end;
                            2:begin//金刚石模式
                                Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                GameGoldChanged();//更新金刚石数量 20080414
                             end;
                            3:begin//灵符模式
                                Dec(m_nGAMEGIRD,ButchChargeCount);
                                GameGoldChanged();//更新灵符数量 20080414
                             end;
                          end; //Case
                          SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示 20080607
                        end;
                      end;
                    end;
                  end;//1
               end;//case Random(2)
            end;//if Butch then
         end;//if BaseObject.m_boDeath
       end;//122
      123:begin//圣殿卫士 20080810
          ButchChargeClass:= TTempleGuardian(BaseObject).m_nButchChargeClass;
          nCode:= 66;
          if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) {and (BaseObject.m_btSlaveExpLevel = 0)} and (BaseObject.m_btSlaveMakeLevel=0) then begin
            nCode:= 67;
            ButchChargeCount:= TTempleGuardian(BaseObject).m_nButchChargeCount;
            case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
              0:begin //金币模式
                 if m_nGold >= ButchChargeCount then begin
                   Butch:= True;
                 end else SysMsg('您的金币没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
                end;
              1:begin//元宝模式
                  if m_nGameGold >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameGoldName+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
                end;
              2:begin//金刚石模式
                  if m_nGAMEDIAMOND >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameDiaMond+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
               end;
              3:begin//灵符模式
                  if m_nGAMEGIRD >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameGird+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
               end;
            end; //Case
            nCode:= 68;
            if Butch then begin//挖所需的条件达到
               case Random(3) of//随机处理挖
                 0:begin//挖取列表中的物品
                    nCode:= 69;
                    if (BaseObject<> nil) then begin
                      if BaseObject.m_boGhost then Exit;//20081216
                      for I := TTempleGuardian(BaseObject).m_ButchItemList.count-1 downto 0 do begin//20080916 修改
                        if BaseObject.m_boGhost then Exit;//20081216
                        if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit;//如果快要清理尸体时，则不再进入 20081222
                        if TTempleGuardian(BaseObject).m_ButchItemList.count <= 0 then Break;//20080916
                        MonItem := pTMonItemInfo(TTempleGuardian(BaseObject).m_ButchItemList.Items[I]);
                        if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                           nCode:= 70;
                           m_nGold := m_nGold + MonItem.Count;
                           if MonItem.Count > 0 then begin
                              if g_boGameLogGold then
                                AddGameDataLog('37' + #9 +m_sMapName + #9 +
                                  IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                  sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 +'1' + #9 + BaseObject.m_sCharName);
                           end;
                           GoldChanged;
                           if BaseObject <> nil then TTempleGuardian(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0:begin //金币模式
                                  Dec(m_nGold,ButchChargeCount);
                                  GoldChanged();//20080414 更新玩家的金币
                                end;
                              1:begin//元宝模式
                                  Dec(m_nGameGold,ButchChargeCount);
                                  GameGoldChanged;//更新元宝数量  20080414
                                end;
                              2:begin//金刚石模式
                                  Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                  GameGoldChanged();//更新金刚石数量 20080414
                               end;
                              3:begin//灵符模式
                                  Dec(m_nGAMEGIRD,ButchChargeCount);
                                  GameGoldChanged();//更新灵符数量 20080414
                               end;
                            end; //Case
                           SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示
                           Break;
                        end else begin
                          New(UserItem);
                          if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                            nCode:= 71;
                            UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                            if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                            nCode:= 72;
                            if (UserItem <> nil) then begin
                              nCode:= 73;
                              case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                0:begin //金币模式
                                    Dec(m_nGold,ButchChargeCount);
                                    GoldChanged();//20080414 更新玩家的金币
                                  end;
                                1:begin//元宝模式
                                    Dec(m_nGameGold,ButchChargeCount);
                                    GameGoldChanged;//更新元宝数量  20080414
                                  end;
                                2:begin//金刚石模式
                                    Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                    GameGoldChanged();//更新金刚石数量 20080414
                                 end;
                                3:begin//灵符模式
                                    Dec(m_nGAMEGIRD,ButchChargeCount);
                                    GameGoldChanged();//更新灵符数量 20080414
                                 end;
                              end; //Case
                              nCode:= 74;
                              if BaseObject <> nil then TTempleGuardian(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                              SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示 20080325
                              sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                              PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0);//禁止物品规则(管理插件功能) 20080729

                              if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                    if StdItem.NeedIdentify = 1 then
                                      AddGameDataLog('37' + #9 +m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                      IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +StdItem.Name + #9 +
                                      IntToStr(UserItem.MakeIndex) + #9 +
                                      '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                      '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                      '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                      '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                      '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                      IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                      IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                                      IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                                      IntToStr(UserItem.btValue[14])+ #9 + BaseObject.m_sCharName);
                                    m_ItemList.Add(UserItem);
                                    nCode:= 75;
                                    if m_btRaceServer = RC_PLAYOBJECT then begin
                                       nCode:= 76;
                                       SendAddItem(UserItem);
                                       SendUpdateItem(UserItem);//更新物品
                                    end;
                                    Break; //一次只给玩家一件物品 20080121
                                end;
                              end else begin
                                nCode:= 77;
                                DropItemDown(UserItem, 3, False, False, self, self);//20080610
                                SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                Break; //一次只给玩家一件物品 20080121
                              end;
                            end;
                          end else Dispose(UserItem);//if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                        end;
                        //if TTempleGuardian(BaseObject).m_ButchItemList.count = 0 then SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red, t_Hint);
                      end; //for I := TTempleGuardian(BaseObject).m_ItemList.count-1 downto 0 do begin
                    end;
                  end;//0
                 1,2:begin//进入触发段
                    if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                    if (g_FunctionNPC <> nil) and TTempleGuardian(BaseObject).boIntoTrigger and IsEnoughBag then begin//20080716
                      if g_FunctionNPC.m_boGotoCount < 80 then begin//防止Goto数量过多,引起M2挂死 20081004
                        nItemCount:= m_ItemList.Count;//进入触发段前的包裹物品数量 20080925
                        nLevel:= m_Abil.Level;//进入触发段前的等级 20081018
                        nExp := m_Abil.Exp;//进入触发段前的经验 20081018
                        nGameDiamond := m_nGAMEDIAMOND;//进入触发段前的金刚石 20081018
                        nCreditPoint := m_btCreditPoint;//进入触发段前的声望 20081018
                        nGameGird := m_nGameGird;//进入触发段前的灵符 20081018
                        g_FunctionNPC.GotoLable(Self, '@ButchCloneItem'+BaseObject.m_sCharName, False);
                        if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.Exp) and (nLevel = m_Abil.Level)) or
                          ((nExp > m_Abil.Exp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                          (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                          case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                            0:begin //金币模式
                                Dec(m_nGold,ButchChargeCount);
                                GoldChanged();//20080414 更新玩家的金币
                              end;
                            1:begin//元宝模式
                                Dec(m_nGameGold,ButchChargeCount);
                                GameGoldChanged;//更新元宝数量  20080414
                              end;
                            2:begin//金刚石模式
                                Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                GameGoldChanged();//更新金刚石数量 20080414
                             end;
                            3:begin//灵符模式
                                Dec(m_nGAMEGIRD,ButchChargeCount);
                                GameGoldChanged();//更新灵符数量 20080414
                             end;
                          end; //Case
                          SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示 20080607
                        end;
                      end;
                    end;
                  end;//1
               end;//case Random(2)
            end;//if Butch then
         end;//if BaseObject.m_boDeath
       end;//123
      124:begin//金杖蜘蛛 20080810
          ButchChargeClass:= TheCrutchesSpider(BaseObject).m_nButchChargeClass;
          nCode:= 78;
          if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) {and (BaseObject.m_btSlaveExpLevel = 0)} and (BaseObject.m_btSlaveMakeLevel=0) then begin
            nCode:= 79;
            ButchChargeCount:= TheCrutchesSpider(BaseObject).m_nButchChargeCount;
            case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
              0:begin //金币模式
                 if m_nGold >= ButchChargeCount then begin
                   Butch:= True;
                 end else SysMsg('您的金币没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
                end;
              1:begin//元宝模式
                  if m_nGameGold >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameGoldName+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
                end;
              2:begin//金刚石模式
                  if m_nGAMEDIAMOND >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameDiaMond+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
               end;
              3:begin//灵符模式
                  if m_nGAMEGIRD >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameGird+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
               end;
            end; //Case
            nCode:= 80;
            if Butch then begin//挖所需的条件达到
               case Random(3) of//随机处理挖
                 0:begin//挖取列表中的物品
                    nCode:= 81;
                    if (BaseObject<> nil) then begin
                      if BaseObject.m_boGhost then Exit;//20081216
                      for I := TheCrutchesSpider(BaseObject).m_ButchItemList.count-1 downto 0 do begin//20080916 修改
                        if BaseObject.m_boGhost then Exit;//20081216
                        if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit;//如果快要清理尸体时，则不再进入 20081222
                        if TheCrutchesSpider(BaseObject).m_ButchItemList.count <= 0 then Break;//20080916
                        MonItem := pTMonItemInfo(TheCrutchesSpider(BaseObject).m_ButchItemList.Items[I]);
                        if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                           nCode:= 82;
                           m_nGold := m_nGold + MonItem.Count;
                           if MonItem.Count > 0 then begin
                              if g_boGameLogGold then
                                AddGameDataLog('37' + #9 +m_sMapName + #9 +
                                  IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                  sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 +'1' + #9 + BaseObject.m_sCharName);
                           end;
                           GoldChanged;
                           if BaseObject <> nil then TheCrutchesSpider(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0:begin //金币模式
                                  Dec(m_nGold,ButchChargeCount);
                                  GoldChanged();//20080414 更新玩家的金币
                                end;
                              1:begin//元宝模式
                                  Dec(m_nGameGold,ButchChargeCount);
                                  GameGoldChanged;//更新元宝数量  20080414
                                end;
                              2:begin//金刚石模式
                                  Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                  GameGoldChanged();//更新金刚石数量 20080414
                               end;
                              3:begin//灵符模式
                                  Dec(m_nGAMEGIRD,ButchChargeCount);
                                  GameGoldChanged();//更新灵符数量 20080414
                               end;
                            end; //Case
                           SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示
                           Break;
                        end else begin
                          New(UserItem);
                          if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                            nCode:= 83;
                            UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                            if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                            nCode:= 84;
                            if (UserItem <> nil) then begin
                              nCode:= 85;
                              case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                0:begin //金币模式
                                    Dec(m_nGold,ButchChargeCount);
                                    GoldChanged();//20080414 更新玩家的金币
                                  end;
                                1:begin//元宝模式
                                    Dec(m_nGameGold,ButchChargeCount);
                                    GameGoldChanged;//更新元宝数量  20080414
                                  end;
                                2:begin//金刚石模式
                                    Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                    GameGoldChanged();//更新金刚石数量 20080414
                                 end;
                                3:begin//灵符模式
                                    Dec(m_nGAMEGIRD,ButchChargeCount);
                                    GameGoldChanged();//更新灵符数量 20080414
                                 end;
                              end; //Case
                              nCode:= 86;
                              if BaseObject <> nil then TheCrutchesSpider(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                              SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示 20080325
                              sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                              PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0);//禁止物品规则(管理插件功能) 20080729

                              if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                    if StdItem.NeedIdentify = 1 then
                                      AddGameDataLog('37' + #9 +m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                      IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +StdItem.Name + #9 +
                                      IntToStr(UserItem.MakeIndex) + #9 +
                                      '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                      '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                      '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                      '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                      '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                      IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                      IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                                      IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                                      IntToStr(UserItem.btValue[14])+ #9 + BaseObject.m_sCharName);
                                    m_ItemList.Add(UserItem);
                                    nCode:= 87;
                                    if m_btRaceServer = RC_PLAYOBJECT then begin
                                       nCode:= 88;
                                       SendAddItem(UserItem);
                                       SendUpdateItem(UserItem);//更新物品
                                    end;
                                    Break; //一次只给玩家一件物品 20080121
                                end;
                              end else begin
                                nCode:= 89;
                                DropItemDown(UserItem, 3, False, False, self, self);//20080610
                                SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                Break; //一次只给玩家一件物品 20080121
                              end;
                            end;
                          end else Dispose(UserItem);//if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                        end;
                        //if TheCrutchesSpider(BaseObject).m_ButchItemList.count = 0 then SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red, t_Hint);
                      end; //for I := TheCrutchesSpider(BaseObject).m_ItemList.count-1 downto 0 do begin
                    end;
                  end;//0
                 1,2:begin//进入触发段
                    if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                    if (g_FunctionNPC <> nil) and TheCrutchesSpider(BaseObject).boIntoTrigger and IsEnoughBag then begin//20080716
                      if g_FunctionNPC.m_boGotoCount < 80 then begin//防止Goto数量过多,引起M2挂死 20081004
                        nItemCount:= m_ItemList.Count;//进入触发段前的包裹物品数量 20080925
                        nLevel:= m_Abil.Level;//进入触发段前的等级 20081018
                        nExp := m_Abil.Exp;//进入触发段前的经验 20081018
                        nGameDiamond := m_nGAMEDIAMOND;//进入触发段前的金刚石 20081018
                        nCreditPoint := m_btCreditPoint;//进入触发段前的声望 20081018
                        nGameGird := m_nGameGird;//进入触发段前的灵符 20081018
                        g_FunctionNPC.GotoLable(Self, '@ButchCloneItem'+BaseObject.m_sCharName, False);
                        if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.Exp) and (nLevel = m_Abil.Level)) or
                          ((nExp > m_Abil.Exp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                          (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                          case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                            0:begin //金币模式
                                Dec(m_nGold,ButchChargeCount);
                                GoldChanged();//20080414 更新玩家的金币
                              end;
                            1:begin//元宝模式
                                Dec(m_nGameGold,ButchChargeCount);
                                GameGoldChanged;//更新元宝数量  20080414
                              end;
                            2:begin//金刚石模式
                                Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                GameGoldChanged();//更新金刚石数量 20080414
                             end;
                            3:begin//灵符模式
                                Dec(m_nGAMEGIRD,ButchChargeCount);
                                GameGoldChanged();//更新灵符数量 20080414
                             end;
                          end; //Case
                          SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示 20080607
                        end;
                      end;
                    end;
                  end;//1
               end;//case Random(2)
            end;//if Butch then
         end;//if BaseObject.m_boDeath
       end;//124
      125:begin//雷炎蛛王 20080811
          ButchChargeClass:= TYanLeiWangSpider(BaseObject).m_nButchChargeClass;
          nCode:= 90;
          if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) {and (BaseObject.m_btSlaveExpLevel = 0)} and (BaseObject.m_btSlaveMakeLevel=0) then begin
            nCode:= 91;
            ButchChargeCount:= TYanLeiWangSpider(BaseObject).m_nButchChargeCount;
            case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
              0:begin //金币模式
                 if m_nGold >= ButchChargeCount then begin
                   Butch:= True;
                 end else SysMsg('您的金币没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
                end;
              1:begin//元宝模式
                  if m_nGameGold >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameGoldName+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
                end;
              2:begin//金刚石模式
                  if m_nGAMEDIAMOND >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameDiaMond+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
               end;
              3:begin//灵符模式
                  if m_nGAMEGIRD >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameGird+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
               end;
            end; //Case
            nCode:= 80;
            if Butch then begin//挖所需的条件达到
               case Random(3) of//随机处理挖
                 0:begin//挖取列表中的物品
                    nCode:= 92;
                    if (BaseObject<> nil) then begin
                      if BaseObject.m_boGhost then Exit;//20081216
                      for I := TYanLeiWangSpider(BaseObject).m_ButchItemList.count-1 downto 0 do begin//20080916
                        if BaseObject.m_boGhost then Exit;//20081216
                        if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit;//如果快要清理尸体时，则不再进入 20081222
                        if TYanLeiWangSpider(BaseObject).m_ButchItemList.count <= 0 then Break;//20080916
                        MonItem := pTMonItemInfo(TYanLeiWangSpider(BaseObject).m_ButchItemList.Items[I]);
                        if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                           nCode:= 94;
                           m_nGold := m_nGold + MonItem.Count;
                           if MonItem.Count > 0 then begin
                              if g_boGameLogGold then
                                AddGameDataLog('37' + #9 +m_sMapName + #9 +
                                  IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                  sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 +'1' + #9 + BaseObject.m_sCharName);
                           end;
                           GoldChanged;
                           if BaseObject <> nil then TYanLeiWangSpider(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0:begin //金币模式
                                  Dec(m_nGold,ButchChargeCount);
                                  GoldChanged();//20080414 更新玩家的金币
                                end;
                              1:begin//元宝模式
                                  Dec(m_nGameGold,ButchChargeCount);
                                  GameGoldChanged;//更新元宝数量  20080414
                                end;
                              2:begin//金刚石模式
                                  Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                  GameGoldChanged();//更新金刚石数量 20080414
                               end;
                              3:begin//灵符模式
                                  Dec(m_nGAMEGIRD,ButchChargeCount);
                                  GameGoldChanged();//更新灵符数量 20080414
                               end;
                            end; //Case
                           SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示
                           Break;
                        end else begin
                          New(UserItem);
                          if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                            nCode:= 95;
                            UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                            if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                            nCode:= 96;
                            if (UserItem <> nil) then begin
                              nCode:= 97;
                              case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                0:begin //金币模式
                                    Dec(m_nGold,ButchChargeCount);
                                    GoldChanged();//20080414 更新玩家的金币
                                  end;
                                1:begin//元宝模式
                                    Dec(m_nGameGold,ButchChargeCount);
                                    GameGoldChanged;//更新元宝数量  20080414
                                  end;
                                2:begin//金刚石模式
                                    Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                    GameGoldChanged();//更新金刚石数量 20080414
                                 end;
                                3:begin//灵符模式
                                    Dec(m_nGAMEGIRD,ButchChargeCount);
                                    GameGoldChanged();//更新灵符数量 20080414
                                 end;
                              end; //Case
                              nCode:= 98;
                              if BaseObject <> nil then TYanLeiWangSpider(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                              SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示 20080325
                              sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                              PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0);//禁止物品规则(管理插件功能) 20080729

                              if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                    if StdItem.NeedIdentify = 1 then
                                      AddGameDataLog('37' + #9 +m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                      IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +StdItem.Name + #9 +
                                      IntToStr(UserItem.MakeIndex) + #9 +
                                      '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                      '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                      '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                      '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                      '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                      IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                      IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                                      IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                                      IntToStr(UserItem.btValue[14])+ #9 + BaseObject.m_sCharName);
                                    m_ItemList.Add(UserItem);
                                    nCode:= 99;
                                    if m_btRaceServer = RC_PLAYOBJECT then begin
                                       nCode:= 100;
                                       SendAddItem(UserItem);
                                       SendUpdateItem(UserItem);//更新物品
                                    end;
                                    Break; //一次只给玩家一件物品 20080121
                                end;
                              end else begin
                                nCode:= 101;
                                DropItemDown(UserItem, 3, False, False, self, self);//20080610
                                SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                Break; //一次只给玩家一件物品 20080121
                              end;
                            end;
                          end else Dispose(UserItem);//if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                        end;
                        //if TYanLeiWangSpider(BaseObject).m_ButchItemList.count = 0 then SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red, t_Hint);
                       end; //for I := TYanLeiWangSpider(BaseObject).m_ItemList.count-1 downto 0 do begin
                    end;
                  end;//0
                 1,2:begin//进入触发段
                    if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                    if (g_FunctionNPC <> nil) and TYanLeiWangSpider(BaseObject).boIntoTrigger and IsEnoughBag then begin//20080716
                      if g_FunctionNPC.m_boGotoCount < 80 then begin//防止Goto数量过多,引起M2挂死 20081004
                        nItemCount:= m_ItemList.Count;//进入触发段前的包裹物品数量 20080925
                        nLevel:= m_Abil.Level;//进入触发段前的等级 20081018
                        nExp := m_Abil.Exp;//进入触发段前的经验 20081018
                        nGameDiamond := m_nGAMEDIAMOND;//进入触发段前的金刚石 20081018
                        nCreditPoint := m_btCreditPoint;//进入触发段前的声望 20081018
                        nGameGird := m_nGameGird;//进入触发段前的灵符 20081018
                        g_FunctionNPC.GotoLable(Self, '@ButchCloneItem'+BaseObject.m_sCharName, False);
                        if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.Exp) and (nLevel = m_Abil.Level)) or
                          ((nExp > m_Abil.Exp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                          (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                          case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                            0:begin //金币模式
                                Dec(m_nGold,ButchChargeCount);
                                GoldChanged();//20080414 更新玩家的金币
                              end;
                            1:begin//元宝模式
                                Dec(m_nGameGold,ButchChargeCount);
                                GameGoldChanged;//更新元宝数量  20080414
                              end;
                            2:begin//金刚石模式
                                Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                GameGoldChanged();//更新金刚石数量 20080414
                             end;
                            3:begin//灵符模式
                                Dec(m_nGAMEGIRD,ButchChargeCount);
                                GameGoldChanged();//更新灵符数量 20080414
                             end;
                          end; //Case
                          SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示 20080607
                        end;
                      end;
                    end;
                  end;//1
               end;//case Random(2)
            end;//if Butch then
         end;//if BaseObject.m_boDeath
       end;//125
      RC_PLAYMOSTER:begin//人形怪
        if (GetTickCount() - TPlayMonster(BaseObject).m_nButchItemTime >1000) then begin //人形怪 20080120
          nCode:= 1;
          Butch:= False;
          TPlayMonster(BaseObject).m_nButchItemTime:= GetTickCount();
          ButchChargeClass:= TPlayMonster(BaseObject).m_nButchChargeClass;
          nCode:= 2;
          //如果目标是人形怪,已死亡且尸体存在,并且没有主人 20080605
          if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) {and (BaseObject.m_btSlaveExpLevel = 0)} and (BaseObject.m_btSlaveMakeLevel=0) then begin //20080614
            nCode:= 3;
            ButchChargeCount:= TPlayMonster(BaseObject).m_nButchChargeCount;
            case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
              0:begin //金币模式
                 if m_nGold >= ButchChargeCount then begin
                   Butch:= True;
                 end else SysMsg('您的金币没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
                end;
              1:begin//元宝模式
                  if m_nGameGold >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameGoldName+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
                end;
              2:begin//金刚石模式
                  if m_nGAMEDIAMOND >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameDiaMond+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
               end;
              3:begin//灵符模式
                  if m_nGAMEGIRD >= ButchChargeCount then begin
                    Butch:= True;
                  end else SysMsg('您的'+g_Config.sGameGird+'没有达到'+IntToStr(ButchChargeCount)+',将挖取不到任何物品!', c_Red, t_Hint);
               end;
            end; //Case
             nCode:= 4;
            if Butch then begin//挖所需的条件达到
              case Random(4) of//随机处理挖
                0:begin//挖取列表中的物品
                  nCode:= 5;
                  if BaseObject <> nil then begin//20080628
                    nCode:= 51;
                    if BaseObject.m_boGhost then Exit;//20081216
                    nCode:= 52;
                    for I := TPlayMonster(BaseObject).m_ButchItemList.count-1 downto 0 do begin//20080916
                      nCode:= 53;
                      if BaseObject.m_boGhost then Exit;//20081216
                      if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit;//如果快要清理尸体时，则不再进入 20081222
                      nCode:= 54;
                      if TPlayMonster(BaseObject).m_ButchItemList.count <= 0 then Break;//20080916
                      nCode:= 55;
                      MonItem := pTMonItemInfo(TPlayMonster(BaseObject).m_ButchItemList.Items[I]);
                      nCode:= 103;
                      //if Random(MonItem.MaxPoint) > MonItem.SelPoint then Continue;//不在机率内,则继续  20080711
                      if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                         m_nGold := m_nGold + MonItem.Count;
                         if MonItem.Count > 0 then begin
                            if g_boGameLogGold then
                              AddGameDataLog('37' + #9 +m_sMapName + #9 +
                                IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 +'1' + #9 + BaseObject.m_sCharName);
                         end;
                         GoldChanged;
                         TPlayMonster(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                          case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                            0:begin //金币模式
                                Dec(m_nGold,ButchChargeCount);
                                GoldChanged();//20080414 更新玩家的金币
                              end;
                            1:begin//元宝模式
                                Dec(m_nGameGold,ButchChargeCount);
                                GameGoldChanged;//更新元宝数量  20080414
                              end;
                            2:begin//金刚石模式
                                Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                GameGoldChanged();//更新金刚石数量 20080414
                             end;
                            3:begin//灵符模式
                                Dec(m_nGAMEGIRD,ButchChargeCount);
                                GameGoldChanged();//更新灵符数量 20080414
                             end;
                          end; //Case
                         SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示
                         Break;
                      end else begin
                        New(UserItem);
                        if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                          nCode:= 7;
                          UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                          if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                          nCode:= 8;
                          if (UserItem <> nil) then begin
                            nCode:= 9;
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0:begin //金币模式
                                  Dec(m_nGold,ButchChargeCount);
                                  GoldChanged();//20080414 更新玩家的金币
                                end;
                              1:begin//元宝模式
                                  Dec(m_nGameGold,ButchChargeCount);
                                  GameGoldChanged;//更新元宝数量  20080414
                                end;
                              2:begin//金刚石模式
                                  Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                  GameGoldChanged();//更新金刚石数量 20080414
                               end;
                              3:begin//灵符模式
                                  Dec(m_nGAMEGIRD,ButchChargeCount);
                                  GameGoldChanged();//更新灵符数量 20080414
                               end;
                            end; //Case
                            nCode:= 10;
                            if BaseObject <> nil then TPlayMonster(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                            SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //人物挖尸体得到物品显示 20080325
                            sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                            PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0);//禁止物品规则(管理插件功能) 20080729

                            if IsEnoughBag then begin //人物的包裹是否满了 20080414
                              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                              if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                  if StdItem.NeedIdentify = 1 then
                                    AddGameDataLog('37' + #9 +m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                    IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +StdItem.Name + #9 +
                                    IntToStr(UserItem.MakeIndex) + #9 +
                                    '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                    '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                    '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                    '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                    '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                    IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                    IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                                    IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                                    IntToStr(UserItem.btValue[14])+ #9 + BaseObject.m_sCharName);
                                  m_ItemList.Add(UserItem);
                                  nCode:= 11;
                                  if m_btRaceServer = RC_PLAYOBJECT then begin
                                     nCode:= 12;
                                     SendAddItem(UserItem);
                                     SendUpdateItem(UserItem);//更新物品
                                  end;
                                  Break; //一次只给玩家一件物品 20080121
                              end;
                            end else begin
                              nCode:= 13;
                              DropItemDown(UserItem, 3, False, False, self, self);//20080610
                              SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                              Break; //一次只给玩家一件物品 20080121
                            end;
                          end;
                        end else Dispose(UserItem);//if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                      end;
                      //if TPlayMonster(BaseObject).m_ButchItemList.count = 0 then SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red, t_Hint);
                     end; //for I := TPlayMonster(BaseObject).m_ItemList.count-1 downto 0 do begin
                    end;
                  end;//0
                1:begin//挖身上装备
                    nCode:= 15;
                    if (BaseObject <> nil) then begin
                      if TPlayMonster(BaseObject).m_boButchUseItem then begin//可以挖身上装备
                        if BaseObject.m_boGhost then Exit;//20081216
                        Randomize;//播下随机种子
                        for I := Low(THumanUseItems) to High(THumanUseItems) do begin
                          if BaseObject.m_boGhost then Exit;//20081216
                          if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit;//如果快要清理尸体时，则不再进入 20081222
                          if Random(TPlayMonster(BaseObject).m_nButchRate) <> 0 then Continue;//挖取身上装备机率0为百分百，数字越大，机率越小
                          K:= Random(14);//20080527 修正不能挖到斗笠位物品
                          if InDisableTakeOffList(TPlayMonster(BaseObject).m_UseItems[K].wIndex) or (TPlayMonster(BaseObject).m_UseItems[K].wIndex=0) then Continue; //检查是否在禁止取下列表,如果在列表中则不掉此物品
                          StdItem := UserEngine.GetStdItem(TPlayMonster(BaseObject).m_UseItems[K].wIndex);
                          nCode:= 17;
                          if (StdItem <> nil) then begin
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0:begin //金币模式
                                  Dec(m_nGold,ButchChargeCount);
                                  GoldChanged();//20080414 更新玩家的金币
                                end;
                              1:begin//元宝模式
                                  Dec(m_nGameGold,ButchChargeCount);
                                  GameGoldChanged;//更新元宝数量  20080414
                                end;
                              2:begin//金刚石模式
                                  Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                  GameGoldChanged();//更新金刚石数量 20080414
                               end;
                              3:begin//灵符模式
                                  Dec(m_nGAMEGIRD,ButchChargeCount);
                                  GameGoldChanged();//更新灵符数量 20080414
                               end;
                            end; //Case
                            //if Random(TPlayMonster(BaseObject).m_nButchUserItemRate{StdItem.Stock}) = 0 then begin //20080610 增加
                              New(UserItem);
                              FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
                              //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
                              if TPlayMonster(BaseObject).m_UseItems[K].wIndex <> 0 then begin
                                 UserItem^:= TPlayMonster(BaseObject).m_UseItems[K];//20080727 修改,
                              //if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem) then begin
                                  //if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);//人形支持极品装备 20080724
                                  SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //人物挖尸体得到物品显示 20080325
                                  TPlayMonster(BaseObject).m_UseItems[K].wIndex:=0;
                                  sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                                  nCode:= 22;
                                  PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0);//禁止物品规则(管理插件功能) 20080729

                                 if IsEnoughBag and IsAddWeightAvailable(StdItem.Weight) then begin //物品是数据库里的物品,并人物的负重没有超过
                                    if StdItem.NeedIdentify = 1 then
                                      AddGameDataLog('37' + #9 +m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                      IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +StdItem.Name + #9 +
                                      IntToStr(UserItem.MakeIndex) + #9 +
                                      '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                      '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                      '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                      '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                      '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                      IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                      IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                                      IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                                      IntToStr(UserItem.btValue[14])+ #9 + BaseObject.m_sCharName);

                                    m_ItemList.Add(UserItem);
                                    if m_btRaceServer = RC_PLAYOBJECT then begin
                                      SendAddItem(UserItem);
                                      SendUpdateItem(UserItem);//更新物品
                                    end;
                                    Break;
                                 end else begin
                                    nCode:= 14;
                                    if UserItem <> nil then//20080817 增加
                                      DropItemDown(UserItem, 3, False, False, self, self);//20080610
                                    SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);  
                                    Break;
                                 end;
                              end else Dispose(UserItem);
                            //end;
                          end;//if (StdItem <> nil) then begin
                        end;//for I := Low(THumanUseItems) to High(THumanUseItems) do begin
                      end else begin//if TPlayMonster(BaseObject).m_boButchUseItem then begin//可以挖身上装备
                        nCode:= 23;
                        if (BaseObject <> nil) then begin//20080628
                          if BaseObject.m_boGhost then Exit;//20081216
                          nCode:= 231;
                          for I := TPlayMonster(BaseObject).m_ButchItemList.count - 1 downto 0 do begin//20080916
                            if BaseObject.m_boGhost then Exit;//20081216
                            if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit;//如果快要清理尸体时，则不再进入 20081222
                            nCode:= 24;
                            if TPlayMonster(BaseObject).m_ButchItemList.count <= 0 then Break;//20080916
                            MonItem := pTMonItemInfo(TPlayMonster(BaseObject).m_ButchItemList.Items[I]);
                            //if Random(MonItem.MaxPoint) > MonItem.SelPoint then Continue;//不在机率内,则继续 20080711
                            if MonItem <> nil then//20080722 增加
                            if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                               nCode:= 25;
                               m_nGold := m_nGold + MonItem.Count;
                               GoldChanged;
                               if MonItem.Count > 0 then begin
                                  if g_boGameLogGold then
                                    AddGameDataLog('37' + #9 +m_sMapName + #9 +
                                      IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                      sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 +'1' + #9 + BaseObject.m_sCharName);
                               end;
                               if BaseObject <> nil then TPlayMonster(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                                case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                  0:begin //金币模式
                                      Dec(m_nGold,ButchChargeCount);
                                      GoldChanged();//20080414 更新玩家的金币
                                    end;
                                  1:begin//元宝模式
                                      Dec(m_nGameGold,ButchChargeCount);
                                      GameGoldChanged;//更新元宝数量  20080414
                                    end;
                                  2:begin//金刚石模式
                                      Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                      GameGoldChanged();//更新金刚石数量 20080414
                                   end;
                                  3:begin//灵符模式
                                      Dec(m_nGAMEGIRD,ButchChargeCount);
                                      GameGoldChanged();//更新灵符数量 20080414
                                   end;
                                end; //Case
                               SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //挖尸体得到物品显示
                               Break;
                            end else begin
                              New(UserItem);
                              nCode:= 26;
                              if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                                UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                                nCode:= 27;
                                if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                                if (UserItem <> nil) then begin
                                  case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                    0:begin //金币模式
                                        Dec(m_nGold,ButchChargeCount);
                                        GoldChanged();//20080414 更新玩家的金币
                                      end;
                                    1:begin//元宝模式
                                        Dec(m_nGameGold,ButchChargeCount);
                                        GameGoldChanged;//更新元宝数量  20080414
                                      end;
                                    2:begin//金刚石模式
                                        Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                        GameGoldChanged();//更新金刚石数量 20080414
                                     end;
                                    3:begin//灵符模式
                                        Dec(m_nGAMEGIRD,ButchChargeCount);
                                        GameGoldChanged();//更新灵符数量 20080414
                                     end;
                                  end; //Case
                                  nCode:= 28;
                                  if BaseObject <> nil then TPlayMonster(BaseObject).m_ButchItemList.Delete(I);//挖到后,删除对应的物品
                                  SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //人物挖尸体得到物品显示 20080325
                                  sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                                  nCode:= 129;
                                  PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0);//禁止物品规则(管理插件功能) 20080729

                                  if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                    if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                       if StdItem.NeedIdentify = 1 then
                                         AddGameDataLog('37' + #9 +m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                         IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +StdItem.Name + #9 +
                                         IntToStr(UserItem.MakeIndex) + #9 +
                                         '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                         '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                         '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                         '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                         '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                         IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                         IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                                         IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                                         IntToStr(UserItem.btValue[14])+ #9 + BaseObject.m_sCharName);

                                        m_ItemList.Add(UserItem);
                                        nCode:= 30;
                                        if m_btRaceServer = RC_PLAYOBJECT then begin
                                           SendAddItem(UserItem);
                                           SendUpdateItem(UserItem);//更新物品
                                        end;
                                        Break; //一次只给玩家一件物品 20080121
                                    end;
                                  end else begin
                                    nCode:= 31;
                                    DropItemDown(UserItem, 3, False, False, self, self);//20080610
                                    SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                    Break; //一次只给玩家一件物品 20080121
                                  end;
                                end;
                              end else Dispose(UserItem);//if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                            end;
                          //if TPlayMonster(BaseObject).m_ButchItemList.count = 0 then SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red, t_Hint);
                          end; //for I := TPlayMonster(BaseObject).m_ItemList.count-1 downto 0 do begin
                        end;
                      end;
                    end;
                  end;//1
                2,3:begin
                    if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg{'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                    if (BaseObject <> nil) and (g_FunctionNPC <> nil) and TPlayMonster(BaseObject).boIntoTrigger and IsEnoughBag then begin//20080716
                      nCode:= 35;
                      if g_FunctionNPC.m_boGotoCount < 80 then begin
                        nItemCount:= m_ItemList.Count;//进入触发段前的包裹物品数量 20080925
                        nLevel:= m_Abil.Level;//进入触发段前的等级 20081018
                        nExp := m_Abil.Exp;//进入触发段前的经验 20081018
                        nGameDiamond := m_nGAMEDIAMOND;//进入触发段前的金刚石 20081018
                        nCreditPoint := m_btCreditPoint;//进入触发段前的声望 20081018
                        nGameGird := m_nGameGird;//进入触发段前的灵符 20081018
                        g_FunctionNPC.GotoLable(Self, '@ButchCloneItem' + BaseObject.m_sCharName, False);
                        if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.Exp) and (nLevel = m_Abil.Level)) or
                          ((nExp > m_Abil.Exp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                          (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                          case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                            0:begin //金币模式
                                Dec(m_nGold,ButchChargeCount);
                                GoldChanged();//20080414 更新玩家的金币
                              end;
                            1:begin//元宝模式
                                Dec(m_nGameGold,ButchChargeCount);
                                GameGoldChanged;//更新元宝数量  20080414
                              end;
                            2:begin//金刚石模式
                                Dec(m_nGAMEDIAMOND,ButchChargeCount);
                                GameGoldChanged();//更新金刚石数量 20080414
                             end;
                            3:begin//灵符模式
                                Dec(m_nGAMEGIRD,ButchChargeCount);
                                GameGoldChanged();//更新灵符数量 20080414
                             end;
                          end; //Case
                          SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON,0, 0, 0, ''); //人物挖尸体得到物品显示 20080607
                        end;
                      end;
                    end;
                  end;//2
              end;//case Random(2) of
            end;//if Butch then
          end;
        end;
      end;//RC_PLAYMOSTER
      else begin//其它
        nCode:= 37;
        if (abs(nX - m_nCurrX) <= 2) and (abs(nY - m_nCurrY) <= 2) then begin
          nCode:= 38;
          if m_PEnvir.IsValidObject(nX, nY, 2, BaseObject) then begin
            nCode:= 39;
            if BaseObject.m_boDeath and (not BaseObject.m_boSkeleton) and (BaseObject.m_boAnimal) then begin
              n10 := Random(16) + 5;
              n14 := Random(201) + 100;
              Dec(BaseObject.m_nBodyLeathery, n10);
              Dec(BaseObject.m_nMeatQuality, n14);
              nCode:= 40;
              if BaseObject.m_nMeatQuality < 0 then BaseObject.m_nMeatQuality := 0;
               nCode:= 41;
              if BaseObject.m_nBodyLeathery <= 0 then begin
                if (BaseObject.m_btRaceServer >= RC_ANIMAL) and (BaseObject.m_btRaceServer < RC_MONSTER) then begin
                  BaseObject.m_boSkeleton := True;
                  ApplyMeatQuality();//设置肉的品质
                  BaseObject.SendRefMsg(RM_SKELETON, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');//彻底死了,不再有动作
                end;
                if not TakeBagItems(BaseObject) then SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red, t_Hint);
                BaseObject.m_nBodyLeathery := 50;
              end;
              m_dwDeathTick := GetTickCount();
            end;
          end else begin
            (*if not TakeBagItems(BaseObject) then begin
              SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red, t_Hint);
            end;*)
          end;
          m_btDirection := btDir;
        end;
        nCode:= 42;
        //SendRefMsg(RM_BUTCH, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
      end;
    end;//case
    SendRefMsg(RM_BUTCH, m_btDirection, m_nCurrX, m_nCurrY, 0, '');//让别人看到挖的动作 20080930
  except
    on E: Exception do begin
      MainOutMessage('{异常} TPlayObject.ClientGetButchItem Code:'+inttostr(nCode));
    end;
  end;
end;
//客户端改变魔法快键
procedure TPlayObject.ClientChangeMagicKey(nSkillIdx, nKey: Integer);
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  if m_MagicList.Count > 0 then begin//20080629
    for I := 0 to m_MagicList.Count - 1 do begin
      UserMagic := m_MagicList.Items[I];
      if UserMagic.MagicInfo.wMagicId = nSkillIdx then begin
        UserMagic.btKey := nKey;
        Break;
      end;
    end;
  end;
end;
//关闭组队
procedure TPlayObject.ClientGropuClose;
begin
  if m_GroupOwner = nil then begin
    m_boAllowGroup := False;
    Exit;
  end;
  if m_GroupOwner <> Self then begin
    m_GroupOwner.DelMember(Self);
    m_boAllowGroup := False;
  end else begin
    SysMsg('如果您想退出，使用编组功能（删除按钮）', c_Red, t_Hint);
  end;
end;
//新建组队
procedure TPlayObject.ClientCreateGroup(sHumName: string);
var
  PlayObject: TPlayObject;
begin
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if m_GroupOwner <> nil then begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -1, 0, 0, 0, '');
    Exit;
  end;
  if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boDeath or PlayObject.m_boGhost then begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -2, 0, 0, 0, '');
    Exit;
  end;
  if (PlayObject.m_GroupOwner <> nil) then begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -3, 0, 0, 0, '');
    Exit;
  end;
  if (not PlayObject.m_boAllowGroup) then begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -4, 0, 0, 0, '');
    Exit;
  end;
  m_GroupMembers.Clear;
  m_GroupMembers.AddObject(m_sCharName, Self);
  m_GroupMembers.AddObject(sHumName, PlayObject);
  JoinGroup(Self);
  PlayObject.JoinGroup(Self);
  m_boAllowGroup := True;
  SendDefMessage(SM_CREATEGROUP_OK, 0, 0, 0, 0, '');
  SendGroupMembers();
end;
//增加组队成员
procedure TPlayObject.ClientAddGroupMember(sHumName: string);
var
  PlayObject: TPlayObject;
begin
  PlayObject := UserEngine.GetPlayObject(sHumName);

  if m_GroupOwner <> Self then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -1, 0, 0, 0, '');
    Exit;
  end;
  if m_GroupMembers.Count > g_Config.nGroupMembersMax then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -5, 0, 0, 0, '');
    Exit;
  end;
  if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boDeath or PlayObject.m_boGhost then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -2, 0, 0, 0, '');
    Exit;
  end;
  if (PlayObject.m_GroupOwner <> nil) then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -3, 0, 0, 0, '');
    Exit;
  end;
  if (not PlayObject.m_boAllowGroup) then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -4, 0, 0, 0, '');
    Exit;
  end;
  m_GroupMembers.AddObject(sHumName, PlayObject);
  PlayObject.JoinGroup(Self);
  SendDefMessage(SM_GROUPADDMEM_OK, 0, 0, 0, 0, '');
  SendGroupMembers();
end;

procedure TPlayObject.ClientDelGroupMember(sHumName: string);
var
  PlayObject: TPlayObject;
begin
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if m_GroupOwner <> Self then begin
    SendDefMessage(SM_GROUPDELMEM_FAIL, -1, 0, 0, 0, '');
    Exit;
  end;
  if PlayObject = nil then begin
    SendDefMessage(SM_GROUPDELMEM_FAIL, -2, 0, 0, 0, '');
    Exit;
  end;
  if not IsGroupMember(PlayObject) then begin
    SendDefMessage(SM_GROUPDELMEM_FAIL, -3, 0, 0, 0, '');
    Exit;
  end;
  DelMember(PlayObject);
  SendDefMessage(SM_GROUPDELMEM_OK, 0, 0, 0, 0, sHumName);
end;
//判断对方是否面对面,是则可以交易
procedure TPlayObject.ClientDealTry(sHumName: string);
var
  BaseObject: TBaseObject;
  PlayObject: TPlayObject;
begin
  if g_Config.boDisableDeal then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sDisableDealItemsMsg);
    Exit;
  end;
  if m_boDealing then Exit;
  if GetTickCount - m_DealLastTick < g_Config.dwTryDealTime {3000} then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sPleaseTryDealLaterMsg);
    Exit;
  end;
  if not m_boCanDeal then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotTryDealMsg);
    Exit;
  end;
  BaseObject := GetPoseCreate();
  if (BaseObject <> nil) and (BaseObject <> Self) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
    PlayObject := TPlayObject(BaseObject);
    if (PlayObject <> nil) and (PlayObject.GetPoseCreate = Self) and (not PlayObject.m_boDealing) then begin
      if (PlayObject.m_boAllowDeal and PlayObject.m_boCanDeal) then begin
        PlayObject.SysMsg(m_sCharName + g_sOpenedDealMsg, c_Green, t_Hint);
        SysMsg(PlayObject.m_sCharName + g_sOpenedDealMsg, c_Green, t_Hint);
        TPlayObject(Self).OpenDealDlg(PlayObject);
        PlayObject.OpenDealDlg(Self);
      end else begin
        SysMsg(g_sPoseDisableDealMsg {'对方禁止进入交易'}, c_Red, t_Hint);
      end;
    end else begin
      SendDefMessage(SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
    end;
  end else begin
    SendDefMessage(SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
  end;
end;
//-------------------------元宝寄售系统-----------------------------------------
//交易成功后修改数据标识 20080319
procedure TPlayObject.UpdateSellOffInfo(code: integer);
var
  I:Integer;
  DealOffInfo: pTDealOffInfo;
begin
  if bo_YBDEAL then begin //已开通元宝服务
    for I:= sSellOffItemList.Count - 1 downto 0 do begin//20080916 修改
      if sSellOffItemList.Count <= 0 then break;//20080916
      DealOffInfo:= pTDealOffInfo(sSellOffItemList.Items[I]);
      if (DealOffInfo <> nil) then begin
        if (DealOffInfo.N = 2) then begin
          Case code of
            0:begin//出售者
              if DealOffInfo.sDealCharName = m_sCharName then begin
                sSellOffItemList.Delete(I);
                Dispose(DealOffInfo);//20081022
                Break;
              end;
            end;
            1:begin//购买者
              if DealOffInfo.sBuyCharName = m_sCharName then begin
                sSellOffItemList.Delete(I);
                Dispose(DealOffInfo);//20081022 
                Break;
              end;
            end;
          end;//case
        end;
      end;
    end;//for
  end;  
end;
//客户端增加寄售物品到出售框中   20080316
procedure TPlayObject.ClientAddSellOffItem(nItemIdx: Integer; sItemName: string);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  m_boCanQueryBag:= True;//增加寄售物品时,不能刷新包裹 20080917
  Try
    if Pos(' ', sItemName) >= 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
      GetValidStr3(sItemName, sItemName, [' ']);
    end;
    bo11 := False;
    if not m_boSellOffOK then begin
      for I := m_ItemList.Count - 1 downto 0 do begin
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem = nil then Continue;
        if UserItem.MakeIndex = nItemIdx then begin
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

          if (CompareText(sUserItemName, sItemName) = 0) and (m_SellOffItemList.Count < 9) then begin
            if CheckItemValue(UserItem ,1) then Break //20080314 禁止交易
            else
            {if Assigned(zPlugOfEngine.CheckCanDealItem) then begin //20080308 禁止交易物品
              if not zPlugOfEngine.CheckCanDealItem(Self, PChar(sUserItemName)) then Break;
            end; }
            if PlugOfCheckCanItem(1, sUserItemName, False, 0, 0) then Break;//禁止物品规则(管理插件功能) 20080729

            m_SellOffItemList.Add(UserItem);
            SendMsg(Self, RM_SELLOFFADDITEM_OK, 0, 0, 0, 0, '');//放物品成功
            m_ItemList.Delete(I);
            ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
            bo11 := True;
            Break;
          end;
        end;
      end;
    end;
    if not bo11 then SendMsg(Self, RM_SellOffADDITEM_FAIL, 0, 0, 0, 0, '');
  finally
    m_boCanQueryBag:= False;//增加寄售物品时,不能刷新包裹 20080917
  end;
end;

//客户端删除出售物品窗里的物品
procedure TPlayObject.ClientDelSellOffItem(nItemIdx: Integer; sItemName: string);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if Pos(' ', sItemName) >= 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
    GetValidStr3(sItemName, sItemName, [' ']);
  end;
  bo11 := False;
  if not m_boSellOffOK then begin
    for I := m_SellOffItemList.Count - 1 downto 0 do begin
      if m_SellOffItemList.Count <= 0 then Break;
      UserItem := m_SellOffItemList.Items[I];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nItemIdx then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then begin
          ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
          m_ItemList.Add(UserItem);

          SendMsg(Self, RM_SELLOFFDELITEM_OK, 0, 0, 0, 0, '');
          m_SellOffItemList.Delete(I);
          bo11 := True;
          Break;
        end;
      end;
    end;//for
  end;
  if not bo11 then SendMsg(Self, RM_SELLOFFDELITEM_FAIL, 0, 0, 0, 0, '');
end;

//出售人取消正在出售中的交易 20080316
procedure TPlayObject.ClientCancelSellOffIng();
var
  I, K:Integer;
  DealOffInfo: pTDealOffInfo;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  nCode: Byte;
begin
  nCode:= 0;
  try
    if (sSellOffItemList = nil) or (sSellOffItemList.Count = 0) or (not IsEnoughBag) then Exit;//20080612
    for I := sSellOffItemList.Count - 1 downto 0 do begin
      if sSellOffItemList.Count <= 0 then Break;//20080916
      nCode:= 1;
      DealOffInfo := pTDealOffInfo(sSellOffItemList.Items[I]);
      nCode:= 2;
      if (DealOffInfo <> nil) then begin
        nCode:= 12;
        if (CompareText(DealOffInfo.sDealCharName, m_sCharName)= 0) and ((DealOffInfo.N = 0) or (DealOffInfo.N = 3)) then begin
          DealOffInfo.N := 4;//20081022 正在操作中
          nCode:= 3;
          for K:= 0 to 9 do begin
            nCode:= 4;
            StdItem := UserEngine.GetStdItem(DealOffInfo.UseItems[K].wIndex);
            if (StdItem <> nil) then begin
              nCode:= 5;
              New(UserItem);
              FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
              //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
              UserItem^:= DealOffInfo.UseItems[K];
              nCode:= 6;
              if IsEnoughBag then begin //人物的包裹是否满了 20080712
                if IsAddWeightAvailable(StdItem.Weight) then begin//检查负重
                  nCode:= 7;
                  if AddItemToBag(UserItem) then SendAddItem(UserItem);//20080322 修改
                end;
              end else begin
                DropItemDown(UserItem, 3, False, False, self, self);//20080712
              end;
            end else
            if (DealOffInfo.UseItems[K].MakeIndex > 0 ) and (DealOffInfo.UseItems[K].wIndex=High(Word)) and  //是金刚石
             (DealOffInfo.UseItems[K].Dura = High(Word)) and (DealOffInfo.UseItems[K].DuraMax = High(Word)) then begin
              nCode:= 8;
              Inc(m_nGAMEDIAMOND,DealOffInfo.UseItems[K].MakeIndex);//增加金刚石
              nCode:= 9;
              GameGoldChanged;//更新金刚石数量
            end;
          end;// for K:=0 to 9 do begin
          nCode:= 10;
          sSellOffItemList.Delete(I);
          Dispose(DealOffInfo);//20081022 增加
          nCode:= 11;
          SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '取消寄售成功！');
          //FrmDB.SaveSellOffItemList;//保存元宝寄售列表
        end;
      end;
    end;//for
  except
    MainOutMessage('{异常} TPlayObject.ClientCancelSellOffIng Code:'+inttostr(nCode));
  end;
end;

//购买人取消交易 20080316
procedure TPlayObject.ClientBuyCancelSellOff(DealCharName:String);
var
  I :Integer;
  DealOffInfo: pTDealOffInfo;
begin
  for I := sSellOffItemList.Count - 1 downto 0 do begin//20080916 修改
    if sSellOffItemList.Count <= 0 then Break;//20080916
    DealOffInfo := pTDealOffInfo(sSellOffItemList.Items[I]);
    if (DealOffInfo <> nil) then begin
      if (CompareText(DealOffInfo.sDealCharName, DealCharName)= 0) and
         (CompareText(DealOffInfo.sBuyCharName, m_sCharName)= 0) and (DealOffInfo.N = 0) then begin
        DealOffInfo.N := 3;//购买人取消标识
        //sSellOffItemList.Delete(I);//20081022
        //sSellOffItemList.Add(DealOffInfo);//20081022
        SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '取消交易成功！');
        Break;
      end;
    end;
  end;
end;

//购买寄售物品 20080318
procedure TPlayObject.ClientBuySellOffItme( DealCharName:String);
var
  I, K:Integer;
  DealOffInfo: pTDealOffInfo;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  PlayObject:TPlayObject;
  nCode: Byte;
begin
  nCode:= 0;
  Try
    for I := sSellOffItemList.Count - 1 downto 0 do begin//20080916 修改
      if sSellOffItemList.Count <= 0 then Break;//20080916
      nCode:= 1;
      DealOffInfo := pTDealOffInfo(sSellOffItemList.Items[I]);
      if (DealOffInfo <> nil) then begin
        if (CompareText(DealOffInfo.sDealCharName, DealCharName)= 0) and
           (CompareText(DealOffInfo.sBuyCharName, m_sCharName)= 0) and (DealOffInfo.N = 0) then begin
          nCode:= 2;
          DealOffInfo.N:= 4;//20081022 正在操作中
          if  m_nGameGold >= (DealOffInfo.nSellGold + g_Config.nDecUserGameGold) then begin  //每次扣多少元宝(元宝寄售) 20080319
            Dec(m_nGameGold,DealOffInfo.nSellGold + g_Config.nDecUserGameGold);//扣出元宝
            if m_nGameGold < 0 then m_nGameGold:= 0;
            GameGoldChanged;//更新元宝数量
            nCode:= 3;
            //给出售人元宝
            PlayObject := UserEngine.GetPlayObject(DealOffInfo.sDealCharName);
            if PlayObject = nil then begin//出售人不在线
              DealOffInfo.N:= 1;//物品已出售,出售人未得到元宝
              //sSellOffItemList.Delete(I);//20081022
              //sSellOffItemList.Add(DealOffInfo);//20081022
            end else begin
              if PlayObject.m_boNotOnlineAddExp then begin//挂机 20081204
                DealOffInfo.N:= 1;//物品已出售,出售人未得到元宝
              end else begin
                nCode:= 10;
                UpdateSellOffInfo(1);
                DealOffInfo.N:= 2;//交易结束
                Inc(PlayObject.m_nGameGold,DealOffInfo.nSellGold);
                PlayObject.GameGoldChanged();
                nCode:= 7;
                PlayObject.SysMsg(Format(sGetSellOffGlod, [DealOffInfo.nSellGold]), c_Red, t_Hint);
                nCode:= 8;
                if g_boGameLogGameGold then
                  AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, PlayObject.m_sMapName,
                      PlayObject.m_nCurrX, PlayObject.m_nCurrY, PlayObject.m_sCharName,
                      g_Config.sGameGoldName, PlayObject.m_nGameGold,
                      '寄售获得('+inttostr(DealOffInfo.nSellGold)+')', m_sCharName]));
              end;
            end;
            //FrmDB.SaveSellOffItemList;//保存元宝寄售列表 20080317

            for K:=0 to 9 do begin
              StdItem := UserEngine.GetStdItem(DealOffInfo.UseItems[K].wIndex);
              if (StdItem <> nil) then begin
                nCode:= 12;
                //if IsAddWeightAvailable(StdItem.Weight) then begin//检查负重 20080824
                   New(UserItem);
                   FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
                   //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
                   UserItem^:= DealOffInfo.UseItems[K];
                   nCode:= 13;
                   if IsEnoughBag then begin //检查人物的包裹是否满了 20080917
                     ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
                     if AddItemToBag(UserItem) then begin
                       nCode:= 14;
                       SendAddItem(UserItem);//20080322 修改
                       if StdItem.NeedIdentify = 1 then
                          AddGameDataLog('9' + #9 + m_sMapName+'(*)' + #9 +
                            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                            m_sCharName + #9 + StdItem.Name + #9 +
                            IntToStr(UserItem.MakeIndex) + #9 +
                            '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                            '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                            '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                            '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                            '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                            IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                            IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                            IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                            IntToStr(UserItem.btValue[14])+ #9 +DealOffInfo.sDealCharName);
                     end;
                   end else begin//20080917 包裹没位了,则把物品扔出来
                     DropItemDown(UserItem, 3, False, False, self, self);
                   end;
                //end;
              end else
                if (DealOffInfo.UseItems[K].MakeIndex > 0 ) and (DealOffInfo.UseItems[K].wIndex=High(Word)) and  //是金刚石
                 (DealOffInfo.UseItems[K].Dura = High(Word)) and (DealOffInfo.UseItems[K].DuraMax = High(Word)) then begin
                  nCode:= 15;
                  Inc(m_nGAMEDIAMOND,DealOffInfo.UseItems[K].MakeIndex);//增加金刚石
                  SysMsg(IntToStr(DealOffInfo.UseItems[K].MakeIndex)+' 颗金刚石增加', c_Blue, t_Hint);
                end;
            end;// for K:=0 to 9 do begin
            nCode:= 16;
            SendMsg(Self, RM_SELLOFFBUY_OK, 0, 0, 0, 0, '');//购买成功
            SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '[成功] 系统已经成功接受您的申请');
            Break;
          end else begin //if  m_nGameGold >= DealOffInfo.nSellGold then begin
            DealOffInfo.N:= 0;//20081204 购买不成功则改为原来的状态
            SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '[错误] 您的申请提交不成功');
            Break;
          end;
        end;
      end;
    end;//for
  except
    MainOutMessage('{异常} TPlayObject.ClientBuySellOffItme Code:'+inttostr(nCode));
  end;
end;

//人物上线,检查是否有交易结束还没得到元宝 20080318
procedure TPlayObject.GetSellOffGlod;
var
  I :Integer;
  DealOffInfo: pTDealOffInfo;
  nCode:Byte;
begin
  nCode:= 0;
  if m_boNotOnlineAddExp then Exit;//挂机则退出 20081204
  Try
    for I := sSellOffItemList.Count - 1 downto 0 do begin//20080916 修改
      nCode:= 1;
      if sSellOffItemList.Count <= 0 then Break;//20080916
      nCode:= 2;
      DealOffInfo := pTDealOffInfo(sSellOffItemList.Items[I]);
      nCode:= 3;
      if (DealOffInfo <> nil) then begin
        if (CompareText(DealOffInfo.sDealCharName, m_sCharName)= 0) and (DealOffInfo.N = 1) then begin
           nCode:= 4;
           UpdateSellOffInfo(0);
           nCode:= 5;
           DealOffInfo.N := 2;//交易结束
           //sSellOffItemList.Delete(I);//20081022
           //sSellOffItemList.Add(DealOffInfo);//20081022
           nCode:= 7;
           Inc(m_nGameGold,DealOffInfo.nSellGold);
           GameGoldChanged();
           nCode:= 8;
           SysMsg(Format(sGetSellOffGlod, [DealOffInfo.nSellGold]), c_Red, t_Hint);
           nCode:= 9;
           if g_boGameLogGameGold then
             AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
                m_sMapName, m_nCurrX, m_nCurrY, m_sCharName,
                g_Config.sGameGoldName, m_nGameGold,
                '寄售获得('+inttostr(DealOffInfo.nSellGold)+')', DealOffInfo.sBuyCharName]));
           Break;
        end;
      end;
    end;//for
  except
    MainOutMessage('{异常} TPlayObject.GetSellOffGlod Code:'+inttostr(nCode));
  end;
end;

//客户端取消元宝寄售 20080316
procedure TPlayObject.ClientCancelSellOff;
begin
  SellOffCancel();
end;

//查询玩家交易记录  20080318
Function TPlayObject.SelectSellDate:String;
var
  I: Integer;
  DealOffInfo: pTDealOffInfo;
begin
  Result:='您未开通元宝寄售服务,请先开通！！！\ \<返回/@main>';
  if bo_YBDEAL then begin //已开通元宝服务
    if sSellOffItemList.Count > 0 then begin//20080629
      for I := 0 to sSellOffItemList.Count - 1 do begin
        DealOffInfo:= pTDealOffInfo(sSellOffItemList.Items[I]);
        if (DealOffInfo <> nil) then begin
          if (CompareText(DealOffInfo.sDealCharName , m_sCharName) = 0) and (DealOffInfo.N = 2)then begin
            Result:='最后一笔出售记录:\'+ FormatdateTime('   yyyy年mm月dd日 hh时nn分',DealOffInfo.dSellDateTime)+',\  您与'
                    +DealOffInfo.sBuyCharName+'交易成功,获得了'+IntToStr(DealOffInfo.nSellGold)+'个'+g_Config.sGameGoldName+'。\ \<返回/@main>';
            Exit;
          end else
          if (CompareText(DealOffInfo.sBuyCharName , m_sCharName)= 0) and ((DealOffInfo.N = 1) or (DealOffInfo.N = 2)) then begin
            Result:='最后一笔购买记录:\'+ FormatdateTime('   yyyy年mm月dd日 hh时nn分',DealOffInfo.dSellDateTime)+',\  您与'
                    +DealOffInfo.sDealCharName+'交易成功,支付了'+IntToStr(DealOffInfo.nSellGold)+'个'+g_Config.sGameGoldName+'。\ \<返回/@main>';
            Exit;
          end;
        end;
      end;//for
    end;
    Result:='您未进行任何寄售交易！！！\ \<返回/@main>';
  end;
end;

//查询玩家是否操作过寄售 20080317
Function TPlayObject.SellOffInTime(nCode:Integer):Boolean;
var
  I: Integer;
  DealOffInfo: pTDealOffInfo;
begin
  Result:=False;
  if sSellOffItemList.Count > 0 then begin//20080629
    for I := 0 to sSellOffItemList.Count - 1 do begin
      DealOffInfo:= pTDealOffInfo(sSellOffItemList.Items[I]);
      if DealOffInfo <> nil then begin
        case nCode of
          0:begin //出售者
            if (CompareText(DealOffInfo.sDealCharName, m_sCharName) = 0 ) and ((DealOffInfo.N = 0) or (DealOffInfo.N = 3)) then begin
              Result:= True;
              Break;
            end;
          end;
          1:begin//购买者
            if (CompareText(DealOffInfo.sBuyCharName, m_sCharName) = 0 ) and (DealOffInfo.N = 0) then begin
              Result:= True;
              Break;
            end;
          end;
        end;
      end;
    end;//for
  end;
end;

//客户端元宝寄售结束 20080316  把临时列表数据写入元宝寄售列表中,并清空临时列表
procedure TPlayObject.ClientSellOffEnd(sBuyCharName:String; nSellGold, nGAMEDIAMOND, nCode:Integer);
var
  I,K: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  DealOffInfo: pTDealOffInfo;
begin
  m_boSellOffOK := True;
  bo11:= False;
  if m_boSellOffOK and ((m_SellOffItemList.Count > 0) or (nGAMEDIAMOND >0)) and (m_SellOffItemList.Count < 10)
  and (length(sBuyCharName)< ACTORNAMELEN + 1) and (nSellGold > 0) and (nSellGold < 100000) then begin
    New(DealOffInfo);
    for K := 0 to 9 do begin
      with DealOffInfo.UseItems[K] do begin
        MakeIndex:=0;
        wIndex:=0;
        Dura:=0;
        DuraMax:=0;
        btValue[0]:=0;
        btValue[1]:=0;
        btValue[2]:=0;
        btValue[3]:=0;
        btValue[4]:=0;
        btValue[5]:=0;
        btValue[6]:=0;
        btValue[7]:=0;
        btValue[8]:=0;
        btValue[9]:=0;
        btValue[10]:=0;
        btValue[11]:=0;
        btValue[12]:=0;
        btValue[13]:=0;
        btValue[14]:=0;
        btValue[15]:=0;
        btValue[16]:=0;
        btValue[17]:=0;
        btValue[18]:=0;
        btValue[19]:=0;
        btValue[20]:=0;
      end;
    end; 

    if m_SellOffItemList.Count > 0 then begin//20080629
      for I := 0 to m_SellOffItemList.Count - 1 do begin
        UserItem := m_SellOffItemList.Items[I];
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if (StdItem <> nil) and (StdItem.StdMode = 51) and (StdItem.Shape = 0) and (UserItem.Dura > 0) and (UserItem.btValue[20]= 1) then begin//是聚灵珠 20080501
          n_UsesItemTick:= 0;//时间初始
          UserItem.btValue[12]:= 2;//不能聚集的标识
        end;
        if (UserItem <> nil) and (UserItem.MakeIndex > 0) then DealOffInfo.UseItems[I]:= UserItem^;
      end;//for
    end;
    for K:=0 to 9 do begin
      StdItem := UserEngine.GetStdItem(DealOffInfo.UseItems[K].wIndex);
        if (StdItem = nil) and (nGAMEDIAMOND > 0) and (nGAMEDIAMOND < 10000) and (nCode = High(Word)) then begin//物品是金刚石
           if nGAMEDIAMOND > m_nGAMEDIAMOND then begin //金刚石数量大于玩家的数量时则反回失败
             SendMsg(Self, RM_SELLOFFEND_FAIL, 0, 0, 0, 0, '');
             SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '[错误] 你没有那么多'+ g_Config.sGameDiaMond);
             GetBackSellOffItems();//返回物品
             Exit;
           end;
           Dec(m_nGAMEDIAMOND,nGAMEDIAMOND);
           GameGoldChanged();//更新金刚石数量
           DealOffInfo.UseItems[K].MakeIndex:= nGAMEDIAMOND;//金刚石数量
           DealOffInfo.UseItems[K].wIndex:= High(Word);
           DealOffInfo.UseItems[K].Dura:= High(Word);
           DealOffInfo.UseItems[K].DuraMax:= High(Word);
           Break;
        end;
    end;
    DealOffInfo.sDealCharName:= m_sCharName;//寄售人
    DealOffInfo.sBuyCharName:= Trim(sBuyCharName);//购买人
    DealOffInfo.nSellGold:= nSellGold;//元宝数
    DealOffInfo.dSellDateTime:= Now();//操作时间
    DealOffInfo.N:= 0;//标识
    sSellOffItemList.Add(DealOffInfo);//增加到元宝寄售列表中
    SendMsg(Self, RM_SELLOFFEND_OK, 0, 0, 0, 0, '');
    Dec(m_nGameGold,g_Config.nDecUserGameGold);//每次扣多少元宝(元宝寄售) 20080319
    if m_nGameGold < 0 then m_nGameGold:= 0;
    SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '[成功] 系统已经成功接受您的申请');
    bo11:= True;
    //FrmDB.SaveSellOffItemList;//保存元宝寄售列表 20080317
    m_boSellOffOK := False;
    m_SellOffItemList.Clear;
  end;
  if not bo11 then begin //失败则返回物品给玩家
    SendMsg(Self, RM_SELLOFFEND_FAIL, 0, 0, 0, 0, '');
    SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '[错误:] 寄售物品失败');
    GetBackSellOffItems();
  end;
end;
//------------------------------------------------------------------------------
//客户端增加交易物品到交易框中
procedure TPlayObject.ClientAddDealItem(nItemIdx: Integer; sItemName: string);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if (m_DealCreat = nil) or (not m_boDealing) then Exit;
  m_boCanQueryBag:= True;//交易增加物品时,不能刷新包裹 20080917
  Try
    if Pos(' ', sItemName) >= 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
      GetValidStr3(sItemName, sItemName, [' ']);
    end;
    bo11 := False;
    if not m_DealCreat.m_boDealOK then begin
      for I := m_ItemList.Count - 1 downto 0 do begin
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem = nil then Continue;
        if UserItem.MakeIndex = nItemIdx then begin
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

          if (CompareText(sUserItemName, sItemName) = 0) and (m_DealItemList.Count < 12) then begin
            if CheckItemValue(UserItem ,1) then Break //20080314 禁止交易
            else
            {if Assigned(zPlugOfEngine.CheckCanDealItem) then begin //20080308 禁止交易物品
              if not zPlugOfEngine.CheckCanDealItem(Self, PChar(sUserItemName)) then Break;
            end;}
            if PlugOfCheckCanItem(1, sUserItemName, False, 0, 0) then Break;//禁止物品规则(管理插件功能) 20080729

            m_DealItemList.Add(UserItem);
            TPlayObject(Self).SendAddDealItem(UserItem);
            m_ItemList.Delete(I);
            ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
            bo11 := True;
            Break;
          end;
        end;
      end;
    end;
    if not bo11 then SendDefMessage(SM_DEALADDITEM_FAIL, 0, 0, 0, 0, '');
  finally
    m_boCanQueryBag:= False;//交易增加物品时,不能刷新包裹 20080917
  end;
end;
//客户端删除交易物品
procedure TPlayObject.ClientDelDealItem(nItemIdx: Integer; sItemName: string);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if g_Config.boCanNotGetBackDeal then begin //禁止取回物品
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sDealItemsDenyGetBackMsg);
    SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
  if (m_DealCreat = nil) or (not m_boDealing) then Exit;
  if Pos(' ', sItemName) >= 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
    GetValidStr3(sItemName, sItemName, [' ']);
  end;
  bo11 := False;
  if not m_DealCreat.m_boDealOK then begin
    for I := m_DealItemList.Count - 1 downto 0 do begin
      if m_DealItemList.Count <= 0 then Break;
      UserItem := m_DealItemList.Items[I];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nItemIdx then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then begin
          m_ItemList.Add(UserItem);
          TPlayObject(Self).SendDelDealItem(UserItem);
          m_DealItemList.Delete(I);
          bo11 := True;
          Break;
        end;
      end;
    end;//for
  end;
  if not bo11 then
    SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
end;
//客户端取消交易
procedure TPlayObject.ClientCancelDeal;
begin
  DealCancel();
end;
//客户端把金币放到交易框中
procedure TPlayObject.ClientChangeDealGold(nGold: Integer);
var
  bo09: Boolean;
begin
  //禁止取回放入交易栏内的金币
  if (m_nDealGolds > 0) and g_Config.boCanNotGetBackDeal then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sDealItemsDenyGetBackMsg);
    SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
  if nGold < 0 then begin
    SendDefMessage(SM_DEALCHGGOLD_FAIL, m_nDealGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
    Exit;
  end;
  bo09 := False;
  if (m_DealCreat <> nil) and (GetPoseCreate = m_DealCreat) then begin
    if not m_DealCreat.m_boDealOK then begin
      if (m_nGold + m_nDealGolds) >= nGold then begin
        m_nGold := (m_nGold + m_nDealGolds) - nGold;
        m_nDealGolds := nGold;
        SendDefMessage(SM_DEALCHGGOLD_OK, m_nDealGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
        m_DealCreat.SendDefMessage(SM_DEALREMOTECHGGOLD, m_nDealGolds, 0, 0, 0, '');
        m_DealCreat.m_DealLastTick := GetTickCount();
        bo09 := True;
        m_DealLastTick := GetTickCount();
      end;
    end;
  end;
  if not bo09 then begin
    SendDefMessage(SM_DEALCHGGOLD_FAIL, m_nDealGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
  end;
end;
//交易结束
procedure TPlayObject.ClientDealEnd;
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  PlayObject: TPlayObject;
begin
  m_boDealOK := True;
  if m_DealCreat = nil then Exit;
  if ((GetTickCount - m_DealLastTick) < g_Config.dwDealOKTime {1000}) or ((GetTickCount - m_DealCreat.m_DealLastTick) < g_Config.dwDealOKTime {1000}) then begin
    SysMsg(g_sDealOKTooFast, c_Red, t_Hint);
    DealCancel();
    Exit;
  end;
  if m_DealCreat.m_boDealOK then begin
    bo11 := True;
    if (MAXBAGITEM - m_ItemList.Count) < m_DealCreat.m_DealItemList.Count then begin
      bo11 := False;
      SysMsg(g_sYourBagSizeTooSmall, c_Red, t_Hint);
    end;
    if (m_nGoldMax - m_nGold) < m_DealCreat.m_nDealGolds then begin
      SysMsg(g_sYourGoldLargeThenLimit, c_Red, t_Hint);
      bo11 := False;
    end;
    if (MAXBAGITEM - m_DealCreat.m_ItemList.Count) < m_DealItemList.Count then begin
      SysMsg(g_sDealHumanBagSizeTooSmall, c_Red, t_Hint);
      bo11 := False;
    end;
    if (m_DealCreat.m_nGoldMax - m_DealCreat.m_nGold) < m_nDealGolds then begin
      SysMsg(g_sDealHumanGoldLargeThenLimit, c_Red, t_Hint);
      bo11 := False;
    end;
    if bo11 then begin
      if m_DealItemList.Count > 0 then begin//20080629
        for I := 0 to m_DealItemList.Count - 1 do begin
          UserItem := m_DealItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (StdItem.StdMode = 51) and (StdItem.Shape = 0) and (UserItem.Dura > 0) and (UserItem.btValue[20]= 1) then begin//是聚灵珠 20080501
            n_UsesItemTick:= 0;//时间初始
            UserItem.btValue[12]:= 2;//不能聚集的标识
          end;
          m_DealCreat.ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
          m_DealCreat.AddItemToBag(UserItem);
          m_DealCreat.SendAddItem(UserItem);
          if StdItem <> nil then begin
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('8' + #9 + m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 + StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                IntToStr(UserItem.btValue[14])+ #9 + m_DealCreat.m_sCharName);
          end;
        end; //for
      end;
      if m_nDealGolds > 0 then begin
        Inc(m_DealCreat.m_nGold, m_nDealGolds);
        m_DealCreat.GoldChanged();
        if g_boGameLogGold then
          AddGameDataLog('8' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 +
            IntToStr(m_nGold) + #9 +
            '1' + #9 +
            m_DealCreat.m_sCharName);
      end;
      if m_DealCreat.m_DealItemList.Count > 0 then begin//20080629
        for I := 0 to m_DealCreat.m_DealItemList.Count - 1 do begin
          UserItem := m_DealCreat.m_DealItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (StdItem.StdMode = 51) and (StdItem.Shape = 0) and (UserItem.Dura > 0) and (UserItem.btValue[20]= 1) then begin//是聚灵珠 20080501
            m_DealCreat.n_UsesItemTick:= 0;//时间初始
            UserItem.btValue[12]:= 2;//不能聚集的标识
          end;
          ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
          AddItemToBag(UserItem);
          TPlayObject(Self).SendAddItem(UserItem);
          if StdItem <> nil then begin
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('8' + #9 +
                  m_DealCreat.m_sMapName + #9 +
                  IntToStr(m_DealCreat.m_nCurrX) + #9 + IntToStr(m_DealCreat.m_nCurrY) + #9 +
                  m_DealCreat.m_sCharName + #9 + StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                  '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                  '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                  '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                  '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                  IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                  IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                  IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                  IntToStr(UserItem.btValue[14])+ #9 + m_sCharName);
          end;
        end; //for
      end;
      if m_DealCreat.m_nDealGolds > 0 then begin
        Inc(m_nGold, m_DealCreat.m_nDealGolds);
        GoldChanged();
        if g_boGameLogGold then
          AddGameDataLog('8' + #9 +
            m_DealCreat.m_sMapName + #9 +
            IntToStr(m_DealCreat.m_nCurrX) + #9 +
            IntToStr(m_DealCreat.m_nCurrY) + #9 +
            m_DealCreat.m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 +
            IntToStr(m_DealCreat.m_nGold) + #9 +
            '1' + #9 + m_sCharName);
      end;
      PlayObject := TPlayObject(m_DealCreat);
      PlayObject.SendDefMessage(SM_DEALSUCCESS, 0, 0, 0, 0, '');
      PlayObject.SysMsg(g_sDealSuccessMsg {'交易成功...'}, c_Green, t_Hint);
      PlayObject.m_DealCreat := nil;
      PlayObject.m_boDealing := False;
      PlayObject.m_DealItemList.Clear;
      PlayObject.m_nDealGolds := 0;
      PlayObject.m_boDealOK := False; //Jacky 增加
      SendDefMessage(SM_DEALSUCCESS, 0, 0, 0, 0, '');
      SysMsg(g_sDealSuccessMsg {'交易成功...'}, c_Green, t_Hint);
      m_DealCreat := nil;
      m_boDealing := False;
      m_DealItemList.Clear;
      m_nDealGolds := 0;
      m_boDealOK := False; //Jacky 增加
    end else begin //004DE42F
      DealCancel();
    end;
  end else begin //004DE439
    SysMsg(g_sYouDealOKMsg {'你已经确认交易了'}, c_Green, t_Hint);
    m_DealCreat.SysMsg(g_sPoseDealOKMsg {'对方已经确认交易了'}, c_Green, t_Hint);
  end;
end;

procedure TPlayObject.ClientGetMinMap;
var
  nMinMap: Integer;
begin
  nMinMap := m_PEnvir.nMinMap;
  if nMinMap > 0 then begin
    SendDefMessage(SM_READMINIMAP_OK, 0, nMinMap, 0, 0, '');
  end else begin
    SendDefMessage(SM_READMINIMAP_FAIL, 0, 0, 0, 0, '');
  end;
end;
//客户端取制造的药品
procedure TPlayObject.ClientMakeDrugItem(NPC: TObject; nItemName: string);
var
  Merchant: TMerchant;
begin
  Merchant := UserEngine.FindMerchant(NPC);
  if (Merchant = nil) or (not Merchant.m_boMakeDrug) then Exit;
  if ((Merchant.m_PEnvir = m_PEnvir) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientMakeDrugItem(Self, nItemName);
end;
//客户端打开行会对话框
procedure TPlayObject.ClientOpenGuildDlg;
var
  I: Integer;
  SC: string;
begin
  if m_MyGuild <> nil then begin
    SC := TGUild(m_MyGuild).sGuildName + #13 + ' ' + #13;
    if m_nGuildRankNo = 1 then begin
      SC := SC + '1' + #13;
    end else begin
      SC := SC + '0' + #13;
    end;
    SC := SC + '<Notice>' + #13;
    if TGUild(m_MyGuild).NoticeList.Count > 0 then begin//20080629
      for I := 0 to TGUild(m_MyGuild).NoticeList.Count - 1 do begin
        if Length(SC) > 5000 then Break;
        SC := SC + TGUild(m_MyGuild).NoticeList.Strings[I] + #13;
      end; // for
    end;
    SC := SC + '<KillGuilds>' + #13;
    if TGUild(m_MyGuild).GuildWarList.Count > 0 then begin//20080629
      for I := 0 to TGUild(m_MyGuild).GuildWarList.Count - 1 do begin
        if Length(SC) > 5000 then Break;
        SC := SC + TGUild(m_MyGuild).GuildWarList.Strings[I] + #13;
      end; // for
    end;
    SC := SC + '<AllyGuilds>' + #13;
    if TGUild(m_MyGuild).GuildAllList.Count > 0 then begin//20080629
      for I := 0 to TGUild(m_MyGuild).GuildAllList.Count - 1 do begin
        if Length(SC) > 5000 then Break;
        SC := SC + TGUild(m_MyGuild).GuildAllList.Strings[I] + #13;
      end; // for
    end;
    m_DefMsg := MakeDefaultMsg(SM_OPENGUILDDLG, 0, 0, 0, 1, 0);
    SendSocket(@m_DefMsg, EncodeString(SC));
  end else begin
    SendDefMessage(SM_OPENGUILDDLG_FAIL, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.ClientGuildHome;
begin
  ClientOpenGuildDlg();
end;

procedure TPlayObject.ClientGuildMemberList;
var
  GuildRank: pTGuildRank;
  I, II: Integer;
  sSENDMSG: string;
begin
  if m_MyGuild = nil then Exit;
  if TGUild(m_MyGuild).m_RankList.Count > 0 then begin//20080629
    for I := 0 to TGUild(m_MyGuild).m_RankList.Count - 1 do begin
      GuildRank := TGUild(m_MyGuild).m_RankList.Items[I];
      if GuildRank = nil then Continue;
      sSENDMSG := sSENDMSG + '#' + IntToStr(GuildRank.nRankNo) + '/*' + GuildRank.sRankName + '/';
      if GuildRank.MemberList.Count > 0 then begin//20080629
        for II := 0 to GuildRank.MemberList.Count - 1 do begin
          if Length(sSENDMSG) > 5000 then Break;
          sSENDMSG := sSENDMSG + GuildRank.MemberList.Strings[II] + '/';
        end;
      end;
    end;
  end;
  m_DefMsg := MakeDefaultMsg(SM_SENDGUILDMEMBERLIST, 0, 0, 0, 1, 0);
  SendSocket(@m_DefMsg, EncodeString(sSENDMSG));
end;
//客户端行会增加成员
procedure TPlayObject.ClientGuildAddMember(sHumName: string);
var
  nC: Integer;
  PlayObject: TPlayObject;
begin
  nC := 1; //'你没有权利使用这个命令。'
  if IsGuildMaster then begin
    PlayObject := UserEngine.GetPlayObject(sHumName);
    if (PlayObject <> nil) and (not PlayObject.m_boNotOnlineAddExp) then begin //2006-10-30增加检测不是离线挂机人物
      if (PlayObject.GetPoseCreate = Self) and (PlayObject.GetPoseCreate <> nil) then begin
        if PlayObject.m_boAllowGuild then begin
          if not TGUild(m_MyGuild).IsMember(sHumName) then begin
            if (PlayObject.m_MyGuild = nil) and (TGUild(m_MyGuild).m_RankList.Count < 400) then begin
              TGUild(m_MyGuild).AddMember(PlayObject);
              UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);
              PlayObject.m_MyGuild := m_MyGuild;
              PlayObject.m_sGuildRankName := TGUild(m_MyGuild).GetRankName(PlayObject, PlayObject.m_nGuildRankNo);
              PlayObject.RefShowName();
              PlayObject.SysMsg('您已加入行会: ' + TGUild(m_MyGuild).sGuildName + ' 当前封号为: ' + PlayObject.m_sGuildRankName, c_Green, t_Hint);
              nC := 0;
            end else nC := 4; //'对方已经加入其他行会。'
          end else nC := 3; //'对方已经加入我们的行会。'
        end else begin //
          nC := 5; //'对方不允许加入行会。'
          PlayObject.SysMsg('您拒绝加入行会。 [允许命令为 @' + g_GameCommand.LETGUILD.sCmd + ']', c_Red, t_Hint);
        end;
      end else nC := 2; //'想加入行会的应该来面对行会掌门人'
    end else nC := 2;
  end;
  if nC = 0 then begin
    SendDefMessage(SM_GUILDADDMEMBER_OK, 0, 0, 0, 0, '');
  end else begin
    SendDefMessage(SM_GUILDADDMEMBER_FAIL, nC, 0, 0, 0, '');
  end;
end;
//客户端行会删除成员
procedure TPlayObject.ClientGuildDelMember(sHumName: string);
var
  nC: Integer;
  s14: string;
  PlayObject: TPlayObject;
begin
  nC := 1;
  if IsGuildMaster then begin
    if TGUild(m_MyGuild).IsMember(sHumName) then begin
      if m_sCharName <> sHumName then begin
        if TGUild(m_MyGuild).DelMember(sHumName) then begin
          PlayObject := UserEngine.GetPlayObject(sHumName);
          if PlayObject <> nil then begin
            PlayObject.m_MyGuild := nil;
            PlayObject.RefRankInfo(0, '');
            PlayObject.RefShowName(); //10/31
          end;
          UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);
          nC := 0;
        end else nC := 4;
      end else begin
        nC := 3;
        s14 := TGUild(m_MyGuild).sGuildName;
        if TGUild(m_MyGuild).CancelGuld(sHumName) then begin
          g_GuildManager.DELGUILD(s14);
          UserEngine.SendServerGroupMsg(SS_206, nServerIndex, s14);
          m_MyGuild := nil;
          RefRankInfo(0, '');
          RefShowName(); //10/31
          SysMsg('行会' + s14 + '已被取消！！！', c_Red, t_Hint);
          nC := 0;
        end
      end;
    end else nC := 2;
  end;
  if nC = 0 then begin
    SendDefMessage(SM_GUILDDELMEMBER_OK, 0, 0, 0, 0, '');
  end else begin
    SendDefMessage(SM_GUILDDELMEMBER_FAIL, nC, 0, 0, 0, '');
  end;
end;
//客户端行会更新公告
procedure TPlayObject.ClientGuildUpdateNotice(sNotict: string);
var
  SC: string;
begin
  if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then Exit;
  TGUild(m_MyGuild).NoticeList.Clear;
  while (sNotict <> '') do begin
    sNotict := GetValidStr3(sNotict, SC, [#$D]);
    TGUild(m_MyGuild).NoticeList.Add(SC);
  end; // while
  TGUild(m_MyGuild).SaveGuildInfoFile();
  UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);
  ClientOpenGuildDlg();
end;
//修改行会成员封号,等级
procedure TPlayObject.ClientGuildUpdateRankInfo(sRankInfo: string);
var
  nC: Integer;
begin
  if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then Exit;//没有行会或不是行会老大则退出
  nC := TGUild(m_MyGuild).UpdateRank(sRankInfo);
  if nC = 0 then begin
    UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);
    ClientGuildMemberList();
  end else begin
    if nC <= -2 then begin
      SendDefMessage(SM_GUILDRANKUPDATE_FAIL, nC, 0, 0, 0, '');
    end;
  end;
end;
//行会联盟
procedure TPlayObject.ClientGuildAlly;
var
  n8: Integer;
  nCode: Integer;
  BaseObjectC: TBaseObject;
resourcestring
  sExceptionMsg = '{异常} TPlayObject::ClientGuildAlly %d';
begin
  nCode := 1;
  try
    n8 := -1;
    BaseObjectC := GetPoseCreate();
    nCode := 2;
    if (BaseObjectC <> nil) and
      (BaseObjectC.m_MyGuild <> nil) and
      (BaseObjectC.m_btRaceServer = RC_PLAYOBJECT) and
      (BaseObjectC.GetPoseCreate = Self) then begin
      if (TGUild(BaseObjectC.m_MyGuild) <> nil) and (TGUild(BaseObjectC.m_MyGuild).m_boEnableAuthAlly) then begin
        nCode := 3;
        if BaseObjectC.IsGuildMaster and IsGuildMaster then begin
          nCode := 4;
          if (TGUild(m_MyGuild) <> nil) and TGUild(m_MyGuild).IsNotWarGuild(TGUild(BaseObjectC.m_MyGuild)) and
            TGUild(BaseObjectC.m_MyGuild).IsNotWarGuild(TGUild(m_MyGuild)) then begin
            nCode := 6;
            TGUild(m_MyGuild).AllyGuild(TGUild(BaseObjectC.m_MyGuild));
            nCode := 7;
            TGUild(BaseObjectC.m_MyGuild).AllyGuild(TGUild(m_MyGuild));
            nCode := 8;
            TGUild(m_MyGuild).SendGuildMsg(TGUild(BaseObjectC.m_MyGuild).sGuildName + '行会已经和您的行会联盟成功。');
            nCode := 9;
            TGUild(BaseObjectC.m_MyGuild).SendGuildMsg(TGUild(m_MyGuild).sGuildName + '行会已经和您的行会联盟成功。');
            nCode := 10;
            TGUild(m_MyGuild).RefMemberName;
            nCode := 11;
            TGUild(BaseObjectC.m_MyGuild).RefMemberName;
            nCode := 12;
            UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);
            nCode := 13;
            UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(BaseObjectC.m_MyGuild).sGuildName);
            nCode := 14;
            n8 := 0;
          end else n8 := -2;
        end else n8 := -3;
      end else n8 := -4;
    end;
    if n8 = 0 then begin
      SendDefMessage(SM_GUILDMAKEALLY_OK, 0, 0, 0, 0, '');
    end else begin
      SendDefMessage(SM_GUILDMAKEALLY_FAIL, n8, 0, 0, 0, '');
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg, [nCode]));
      //MainOutMessage(E.Message);
    end;
  end;
end;

procedure TPlayObject.ClientGuildBreakAlly(sGuildName: string);
var
  n10: Integer;
  Guild: TGUild;
begin
//  n10 := -1;
  if not IsGuildMaster() then Exit;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if (Guild <> nil) and (m_MyGuild <> nil) then begin
    if TGUild(m_MyGuild).IsAllyGuild(Guild) then begin
      TGUild(m_MyGuild).DelAllyGuild(Guild);
      Guild.DelAllyGuild(TGUild(m_MyGuild));
      TGUild(m_MyGuild).SendGuildMsg(Guild.sGuildName + ' 行会与您的行会解除联盟成功！！！');
      Guild.SendGuildMsg(TGUild(m_MyGuild).sGuildName + ' 行会解除了与您行会的联盟！！！');
      TGUild(m_MyGuild).RefMemberName();
      Guild.RefMemberName();
      UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);
      UserEngine.SendServerGroupMsg(SS_207, nServerIndex, Guild.sGuildName);
      n10 := 0;
    end else n10 := -2;
  end else n10 := -3;
  if n10 = 0 then begin
    SendDefMessage(SM_GUILDBREAKALLY_OK, 0, 0, 0, 0, '');
  end else begin
    SendDefMessage(SM_GUILDMAKEALLY_FAIL, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.RecalcAdjusBonus();
  procedure AdjustAb(Abil: Word{Byte}; Val: Word; var lov, hiv: Word);//参数为BYTE时，出现越界 20081204
  var
    Lo, Hi: Byte;
    I: Integer;
  begin
    Lo := LoByte(Abil);
    Hi := HiByte(Abil);
    lov := 0; hiv := 0;
    for I := 1 to Val do begin
      if Lo + 1 < Hi then begin
        Inc(Lo);
        Inc(lov);
      end else begin
        Inc(Hi);
        Inc(hiv);
      end;
    end;
  end;
var
  BonusTick: pTNakedAbility;
  NakedAbil: pTNakedAbility;
  adc, amc, asc, aac, amac: Integer;
  ldc, lmc, lsc, lac, lmac, hdc, hmc, hsc, hac, hmac: Word;
begin
try
  BonusTick := nil;
  NakedAbil := nil;
  case m_btJob of
    0: begin
        BonusTick := @g_Config.BonusAbilofWarr;
        NakedAbil := @g_Config.NakedAbilofWarr;
      end;
    1: begin
        BonusTick := @g_Config.BonusAbilofWizard;
        NakedAbil := @g_Config.NakedAbilofWizard;
      end;
    2: begin
        BonusTick := @g_Config.BonusAbilofTaos;
        NakedAbil := @g_Config.NakedAbilofTaos;
      end;
    {3: begin//刺客(暂时用战士参数)
        BonusTick := @g_Config.BonusAbilofWarr;
        NakedAbil := @g_Config.NakedAbilofWarr;
      end; }
  end;
  adc := m_BonusAbil.DC div BonusTick.DC;
  amc := m_BonusAbil.MC div BonusTick.MC;
  asc := m_BonusAbil.SC div BonusTick.SC;
  aac := m_BonusAbil.AC div BonusTick.AC;
  amac := m_BonusAbil.MAC div BonusTick.MAC;

  AdjustAb(NakedAbil.DC, adc, ldc, hdc);
  AdjustAb(NakedAbil.MC, amc, lmc, hmc);
  AdjustAb(NakedAbil.SC, asc, lsc, hsc);
  AdjustAb(NakedAbil.AC, aac, lac, hac);
  AdjustAb(NakedAbil.MAC, amac, lmac, hmac);
  //lac  := 0;  hac := aac;
  //lmac := 0;  hmac := amac;
  m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + ldc, HiWord(m_WAbil.DC) + hdc);
  m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC) + lmc, HiWord(m_WAbil.MC) + hmc);
  m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + lsc, HiWord(m_WAbil.SC) + hsc);
  m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + lac, HiWord(m_WAbil.AC) + hac);
  m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + lmac, HiWord(m_WAbil.MAC) + hmac);

  m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_BonusAbil.HP div BonusTick.HP);
  m_WAbil.MaxMP := _MIN(High(Word), m_WAbil.MaxMP + m_BonusAbil.MP div BonusTick.MP);
  //m_btSpeedPoint:=m_btSpeedPoint + m_BonusAbil.Speed div BonusTick.Speed;
  //m_btHitPoint:=m_btHitPoint + m_BonusAbil.Hit div BonusTick.Hit;
except
  MainOutMessage('{异常} TPlayObject.RecalcAdjusBonus');
end;
end;

procedure TPlayObject.ClientAdjustBonus(nPoint: Integer; sMsg: string);
var
  BonusAbil: TNakedAbility;
  nTotleUsePoint: Integer;
begin
  FillChar(BonusAbil, SizeOf(TNakedAbility), #0);
  DecodeBuffer(sMsg, @BonusAbil, SizeOf(TNakedAbility));
  nTotleUsePoint := BonusAbil.DC +
    BonusAbil.MC +
    BonusAbil.SC +
    BonusAbil.AC +
    BonusAbil.MAC +
    BonusAbil.HP +
    BonusAbil.MP +
    BonusAbil.Hit +
    BonusAbil.Speed +
    BonusAbil.X2;
  if ((nPoint + nTotleUsePoint) = m_nBonusPoint) and (m_nBonusPoint > 0) and (nPoint >= 0) and (m_nBonusPoint >= nPoint) then begin
    if nTotleUsePoint > 0 then begin
      m_nBonusPoint := nPoint;
      Inc(m_BonusAbil.DC, BonusAbil.DC);
      Inc(m_BonusAbil.MC, BonusAbil.MC);
      Inc(m_BonusAbil.SC, BonusAbil.SC);
      Inc(m_BonusAbil.AC, BonusAbil.AC);
      Inc(m_BonusAbil.MAC, BonusAbil.MAC);
      Inc(m_BonusAbil.HP, BonusAbil.HP);
      Inc(m_BonusAbil.MP, BonusAbil.MP);
      Inc(m_BonusAbil.Hit, BonusAbil.Hit);
      Inc(m_BonusAbil.Speed, BonusAbil.Speed);
      Inc(m_BonusAbil.X2, BonusAbil.X2);
      RecalcAbilitys();
      CompareSuitItem(False);//套装与身上装备对比 20080729
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    end;
  end else begin
    SysMsg('非法数据调整！！！', c_Red, t_Hint);
  end;
end;

function TPlayObject.GetMyStatus: Integer;
begin
  Result := m_nHungerStatus div 1000;
  if Result > 4 then Result := 4;
end;

procedure TPlayObject.SendAdjustBonus;
var
  sSENDMSG: string;
  //NakedAbil:TNakedAbility;
begin
  m_DefMsg := MakeDefaultMsg(SM_ADJUST_BONUS, m_nBonusPoint, 0, 0, 0, 0);
  sSENDMSG := '';
  //NakedAbil:=m_BonusAbil;
  //FillChar(NakedAbil,SizeOf(TNakedAbility),#0);
  case m_btJob of //
    0: sSENDMSG := EncodeBuffer(@g_Config.BonusAbilofWarr, SizeOf(TNakedAbility)) + '/' +
      EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@g_Config.NakedAbilofWarr, SizeOf(TNakedAbility));
    1: sSENDMSG := EncodeBuffer(@g_Config.BonusAbilofWizard, SizeOf(TNakedAbility)) + '/' +
      EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@g_Config.NakedAbilofWizard, SizeOf(TNakedAbility));
    2: sSENDMSG := EncodeBuffer(@g_Config.BonusAbilofTaos, SizeOf(TNakedAbility)) + '/' +
      EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@g_Config.NakedAbilofTaos, SizeOf(TNakedAbility));
    {3: sSENDMSG := EncodeBuffer(@g_Config.BonusAbilofWarr, SizeOf(TNakedAbility)) + '/' + //刺客(暂时用战士参数)
      EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@g_Config.NakedAbilofWarr, SizeOf(TNakedAbility));}
  end; // case
  SendSocket(@m_DefMsg, sSENDMSG);
end;

function TBaseObject.GetAttackDir(BaseObject: TBaseObject; var btDir: Byte): Boolean;
begin
  Result := False;
  if (m_nCurrX - 1 <= BaseObject.m_nCurrX) and
    (m_nCurrX + 1 >= BaseObject.m_nCurrX) and
    (m_nCurrY - 1 <= BaseObject.m_nCurrY) and
    (m_nCurrY + 1 >= BaseObject.m_nCurrY) and
    ((m_nCurrX <> BaseObject.m_nCurrX) or
    (m_nCurrY <> BaseObject.m_nCurrY)) then begin
    Result := True;
    if ((m_nCurrX - 1) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then begin
      btDir := DR_LEFT;
      Exit;
    end;
    if ((m_nCurrX + 1) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then begin
      btDir := DR_RIGHT;
      Exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then begin
      btDir := DR_UP;
      Exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then begin
      btDir := DR_DOWN;
      Exit;
    end;
    if ((m_nCurrX - 1) = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then begin
      btDir := DR_UPLEFT;
      Exit;
    end;
    if ((m_nCurrX + 1) = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then begin
      btDir := DR_UPRIGHT;
      Exit;
    end;
    if ((m_nCurrX - 1) = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then begin
      btDir := DR_DOWNLEFT;
      Exit;
    end;
    if ((m_nCurrX + 1) = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then begin
      btDir := DR_DOWNRIGHT;
      Exit;
    end;
    btDir := 0;
  end;
end;

function TBaseObject.TargetInSpitRange(BaseObject: TBaseObject; var btDir: Byte): Boolean; //004C3E68
var
  n14, n18: Integer;
begin
  Result := False;
  if (abs(BaseObject.m_nCurrX - m_nCurrX) <= 2) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 2) then begin
    n14 := BaseObject.m_nCurrX - m_nCurrX;
    n18 := BaseObject.m_nCurrY - m_nCurrY;
    if (abs(n14) <= 1) and (abs(n18) <= 1) then begin
      GetAttackDir(BaseObject, btDir);
      Result := True;
      Exit;
    end;
    Inc(n14, 2);
    Inc(n18, 2);
    if ((n14 >= 0) and (n14 <= 4)) and ((n18 >= 0) and (n18 <= 4)) then begin
      btDir := GetNextDirection(m_nCurrX, m_nCurrY, BaseObject.m_nCurrX, BaseObject.m_nCurrY);
      if g_Config.SpitMap[btDir, n18, n14] = 1 then
        Result := True;
    end;
  end;
end;
//刷新包裹重量
function TBaseObject.RecalcBagWeight: Integer;
var
  I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  Result := 0;
  try
    if m_ItemList.Count > 0 then begin//20080628
      for I := 0 to m_ItemList.Count - 1 do begin
        UserItem := m_ItemList.Items[I];
        if UserItem <> nil then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            Inc(Result, StdItem.Weight);
          end;
        end;
      end;
    end;
  except
    MainOutMessage('{异常} TBaseObject.RecalcBagWeight');
  end;
end;
//重新计算攻击敏捷
procedure TBaseObject.RecalcHitSpeed;
var
  I: Integer;
  UserMagic: pTUserMagic;
  BonusTick: pTNakedAbility;
begin
  BonusTick := nil;
  case m_btJob of
    0: BonusTick := @g_Config.BonusAbilofWarr;
    1: BonusTick := @g_Config.BonusAbilofWizard;
    2: BonusTick := @g_Config.BonusAbilofTaos;
    //3: BonusTick := @g_Config.BonusAbilofWarr;//刺客(暂时用战士参数)
  end;
  m_btHitPoint := DEFHIT + m_BonusAbil.Hit div BonusTick.Hit;

  case m_btJob of
    TAOS: m_btSpeedPoint := DEFSPEED + m_BonusAbil.Speed div BonusTick.Speed + 3; 
  else m_btSpeedPoint := DEFSPEED + m_BonusAbil.Speed div BonusTick.Speed;
  end;

  m_nHitPlus := 0;
  m_nHitDouble := 0;

  m_MagicOneSwordSkill := nil;
  m_MagicPowerHitSkill := nil;
  m_MagicErgumSkill := nil;
  m_MagicBanwolSkill := nil;
  m_MagicFireSwordSkill := nil;
  m_Magic74Skill := nil; //逐日剑法 20080511
  m_MagicCrsSkill := nil;
  m_Magic41Skill := nil;
  m_Magic42Skill := nil;
  m_Magic43Skill := nil;
  m_Magic60Skill := nil;
  m_Magic67Skill := nil;//先天元力 20080626
  m_Magic68Skill := nil;//酒气护体 20080625
  m_Magic75Skill := nil; //护体神盾 20080218
  if m_btRaceServer = RC_PLAYOBJECT then begin
    TPlayObject(self).m_MagicSkill_200 := nil;//怒之攻杀
    TPlayObject(self).m_MagicSkill_201 := nil;//静之攻杀
    TPlayObject(self).m_MagicSkill_202 := nil;//怒之半月
    TPlayObject(self).m_MagicSkill_203 := nil;//静之半月
    TPlayObject(self).m_MagicSkill_204 := nil;//怒之烈火
    TPlayObject(self).m_MagicSkill_205 := nil;//静之烈火
    TPlayObject(self).m_MagicSkill_206 := nil;//怒之逐日
    TPlayObject(self).m_MagicSkill_207 := nil;//静之逐日
    TPlayObject(self).m_MagicSkill_208 := nil;//怒之火球
    TPlayObject(self).m_MagicSkill_209 := nil;//静之火球
    TPlayObject(self).m_MagicSkill_210 := nil;//怒之大火球
    TPlayObject(self).m_MagicSkill_211 := nil;//静之大火球
    TPlayObject(self).m_MagicSkill_212 := nil;//怒之火墙
    TPlayObject(self).m_MagicSkill_213 := nil;//静之火墙
    TPlayObject(self).m_MagicSkill_214 := nil;//怒之地狱火
    TPlayObject(self).m_MagicSkill_215 := nil;//静之地狱火
    TPlayObject(self).m_MagicSkill_216 := nil;//怒之疾光电影
    TPlayObject(self).m_MagicSkill_217 := nil;//静之疾光电影
    TPlayObject(self).m_MagicSkill_218 := nil;//怒之爆裂火焰
    TPlayObject(self).m_MagicSkill_219 := nil;//静之爆裂火焰
    TPlayObject(self).m_MagicSkill_220 := nil;//怒之冰咆哮
    TPlayObject(self).m_MagicSkill_221 := nil;//静之冰咆哮
    TPlayObject(self).m_MagicSkill_222 := nil;//怒之雷电
    TPlayObject(self).m_MagicSkill_223 := nil;//静之雷电
    TPlayObject(self).m_MagicSkill_224 := nil;//怒之地狱雷光
    TPlayObject(self).m_MagicSkill_225 := nil;//静之地狱雷光
    TPlayObject(self).m_MagicSkill_226 := nil;//怒之寒冰掌
    TPlayObject(self).m_MagicSkill_227 := nil;//静之寒冰掌
    TPlayObject(self).m_MagicSkill_228 := nil;//怒之灭天火
    TPlayObject(self).m_MagicSkill_229 := nil;//静之灭天火
    TPlayObject(self).m_MagicSkill_230 := nil;//怒之火符
    TPlayObject(self).m_MagicSkill_231 := nil;//静之火符
    TPlayObject(self).m_MagicSkill_232 := nil;//怒之噬血
    TPlayObject(self).m_MagicSkill_233 := nil;//静之噬血
    TPlayObject(self).m_MagicSkill_234 := nil;//怒之流星火雨
    TPlayObject(self).m_MagicSkill_235 := nil;//静之流星火雨
    TPlayObject(self).m_MagicSkill_236 := nil;//怒之内功剑法
    TPlayObject(self).m_MagicSkill_237 := nil;//静之内功剑法
  end else
  if m_btRaceServer = RC_HEROOBJECT then begin
    THEROOBJECT(self).m_Magic46Skill:= nil; //分身术 20081217
    THEROOBJECT(self).m_MagicSkill_200 := nil;//怒之攻杀
    THEROOBJECT(self).m_MagicSkill_201 := nil;//静之攻杀
    THEROOBJECT(self).m_MagicSkill_202 := nil;//怒之半月
    THEROOBJECT(self).m_MagicSkill_203 := nil;//静之半月
    THEROOBJECT(self).m_MagicSkill_204 := nil;//怒之烈火
    THEROOBJECT(self).m_MagicSkill_205 := nil;//静之烈火
    THEROOBJECT(self).m_MagicSkill_206 := nil;//怒之逐日
    THEROOBJECT(self).m_MagicSkill_207 := nil;//静之逐日
    THEROOBJECT(self).m_MagicSkill_208 := nil;//怒之火球
    THEROOBJECT(self).m_MagicSkill_209 := nil;//静之火球
    THEROOBJECT(self).m_MagicSkill_210 := nil;//怒之大火球
    THEROOBJECT(self).m_MagicSkill_211 := nil;//静之大火球
    THEROOBJECT(self).m_MagicSkill_212 := nil;//怒之火墙
    THEROOBJECT(self).m_MagicSkill_213 := nil;//静之火墙
    THEROOBJECT(self).m_MagicSkill_214 := nil;//怒之地狱火
    THEROOBJECT(self).m_MagicSkill_215 := nil;//静之地狱火
    THEROOBJECT(self).m_MagicSkill_216 := nil;//怒之疾光电影
    THEROOBJECT(self).m_MagicSkill_217 := nil;//静之疾光电影
    THEROOBJECT(self).m_MagicSkill_218 := nil;//怒之爆裂火焰
    THEROOBJECT(self).m_MagicSkill_219 := nil;//静之爆裂火焰
    THEROOBJECT(self).m_MagicSkill_220 := nil;//怒之冰咆哮
    THEROOBJECT(self).m_MagicSkill_221 := nil;//静之冰咆哮
    THEROOBJECT(self).m_MagicSkill_222 := nil;//怒之雷电
    THEROOBJECT(self).m_MagicSkill_223 := nil;//静之雷电
    THEROOBJECT(self).m_MagicSkill_224 := nil;//怒之地狱雷光
    THEROOBJECT(self).m_MagicSkill_225 := nil;//静之地狱雷光
    THEROOBJECT(self).m_MagicSkill_226 := nil;//怒之寒冰掌
    THEROOBJECT(self).m_MagicSkill_227 := nil;//静之寒冰掌
    THEROOBJECT(self).m_MagicSkill_228 := nil;//怒之灭天火
    THEROOBJECT(self).m_MagicSkill_229 := nil;//静之灭天火
    THEROOBJECT(self).m_MagicSkill_230 := nil;//怒之火符
    THEROOBJECT(self).m_MagicSkill_231 := nil;//静之火符
    THEROOBJECT(self).m_MagicSkill_232 := nil;//怒之噬血
    THEROOBJECT(self).m_MagicSkill_233 := nil;//静之噬血
    THEROOBJECT(self).m_MagicSkill_234 := nil;//怒之流星火雨
    THEROOBJECT(self).m_MagicSkill_235 := nil;//静之流星火雨
    THEROOBJECT(self).m_MagicSkill_236 := nil;//怒之内功剑法
    THEROOBJECT(self).m_MagicSkill_237 := nil;//静之内功剑法
  end;

  if m_MagicList.Count > 0 then begin//20080629
    for I := 0 to m_MagicList.Count - 1 do begin
      UserMagic := m_MagicList.Items[I];
      if UserMagic = nil then Continue;
      case UserMagic.wMagIdx of
        SKILL_ONESWORD: begin //基本剑术
            m_MagicOneSwordSkill := UserMagic;
            if UserMagic.btLevel > 0 then begin
              m_btHitPoint := m_btHitPoint + Round(9 / 3 * UserMagic.btLevel);
            end;
          end;
        SKILL_YEDO: begin //攻杀剑法
            m_MagicPowerHitSkill := UserMagic;
            if UserMagic.btLevel > 0 then begin
              m_btHitPoint := m_btHitPoint + Round(3 / 3 * UserMagic.btLevel);
            end;
            m_nHitPlus := DEFHIT + UserMagic.btLevel;
            m_btAttackSkillCount := 7 - UserMagic.btLevel;
            m_btAttackSkillPointCount := Random(m_btAttackSkillCount);
          end;
        SKILL_ERGUM: begin //刺杀剑法
            m_MagicErgumSkill := UserMagic;
          end;
        SKILL_BANWOL: begin //半月弯刀
            m_MagicBanwolSkill := UserMagic;
          end;
        SKILL_FIRESWORD: begin //烈火剑法
            m_MagicFireSwordSkill := UserMagic;
            m_nHitDouble := 4 + UserMagic.btLevel * 4;
          end;
        SKILL_74: begin //逐日剑法 20080511
            m_Magic74Skill := UserMagic;
          end;
        SKILL_ILKWANG: begin //精神力战法
            m_MagicOneSwordSkill := UserMagic;
            if UserMagic.btLevel > 0 then begin
              m_btHitPoint := m_btHitPoint + Round(8 / 3 * UserMagic.btLevel);
            end;
          end;
        SKILL_40: begin //抱月弯刀
            m_MagicCrsSkill := UserMagic;
          end;
        SKILL_41: begin //狮子吼
            m_Magic41Skill := UserMagic;
          end;
        SKILL_42: begin //开天斩
            m_Magic42Skill := UserMagic;
          end;
        SKILL_43: begin //龙影剑法
            m_Magic43Skill := UserMagic;
            //if m_Magic43Skill <>nil then SendMsg(self, RM_DRAGONPOINT, g_Config.nMaxDragonPoint, m_nDragonPoint, 0, 0, '');//只要学过龙影,就直接显示气槽 200804033  20080619 注释
          end;
        SKILL_46: begin//分身术 20081217
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_Magic46Skill:= UserMagic;
          end;
        SKILL_67: begin//先天元力 20080626
            m_Magic67Skill := UserMagic;
            m_Magic67Skill.nTranPoint:= m_Abil.MaxAlcohol;
          end;
        SKILL_68: begin//酒气护体 20080625
            m_Magic68Skill := UserMagic;
            if m_Magic68Skill <> nil then begin//20080702
              if m_btRaceServer = RC_PLAYOBJECT then begin
                 if TPlayObject(self).m_MaxExp68 <= 0 then TPlayObject(self).m_MaxExp68:= GetSkill68Exp(UserMagic.btLevel);//酒气护体升级经验 20080625
                 if m_Magic68Skill.btLevel < 100 then //20080830 增加
                   SendMsg(Self, RM_MAGIC68SKILLEXP, 0, 0, 0, 0, EncodeString(Inttostr(TPlayObject(self).m_Exp68)+'/'+Inttostr(TPlayObject(self).m_MaxExp68)));//发送酒气护体经验
              end;
              if m_btRaceServer = RC_HEROOBJECT then begin//英雄 20080925
                 if THEROOBJECT(self).m_MaxExp68 <= 0 then THEROOBJECT(self).m_MaxExp68:= GetSkill68Exp(UserMagic.btLevel);//酒气护体升级经验
                 if m_Magic68Skill.btLevel < 100 then
                   SendMsg(Self, RM_HEROMAGIC68SKILLEXP, 0, 0, 0, 0, EncodeString(Inttostr(THEROOBJECT(self).m_Exp68)+'/'+Inttostr(THEROOBJECT(self).m_MaxExp68)));//发送酒气护体经验
              end;
            end;
          end;
        SKILL_75:begin //护体神盾 20080218
            m_Magic75Skill := UserMagic;
          end;
        SKILL_200:begin//怒之攻杀
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_200 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_200 := UserMagic;
          end;
        SKILL_201:begin//静之攻杀
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_201 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_201 := UserMagic;
          end;
        Skill_202:begin//怒之半月
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_202 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_202 := UserMagic;
          end;
        Skill_203:begin//静之半月
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_203 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_203 := UserMagic;
          end;
        Skill_204:begin//怒之烈火
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_204 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_204 := UserMagic;
          end;
        Skill_205:begin//静之烈火
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_205 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_205 := UserMagic;
          end;
        Skill_206:begin//怒之逐日
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_206 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_206 := UserMagic;
          end;
        Skill_207:begin//静之逐日
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_207 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_207 := UserMagic;
          end;
        Skill_208:begin//怒之火球
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_208 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_208 := UserMagic;
          end;
        Skill_209:begin//静之火球
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_209 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_209 := UserMagic;
          end;
        Skill_210:begin//怒之大火球
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_210 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_210 := UserMagic;
          end;
        Skill_211:begin//静之大火球
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_211 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_211 := UserMagic;
          end;
        Skill_212:begin//怒之火墙
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_212 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_212 := UserMagic;
          end;
        Skill_213:begin//静之火墙
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_213 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_213 := UserMagic;
          end;
        Skill_214:begin//怒之地狱火
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_214 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_214 := UserMagic;
          end;
        Skill_215:begin//静之地狱火
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_215 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_215 := UserMagic;
          end;
        Skill_216:begin//怒之疾光电影
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_216 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_216 := UserMagic;
          end;
        Skill_217:begin//静之疾光电影
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_217 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_217 := UserMagic;
          end;
        Skill_218:begin//怒之爆裂火焰
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_218 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_218 := UserMagic;
          end;
        Skill_219:begin//静之爆裂火焰
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_219 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_219 := UserMagic;
          end;
        Skill_220:begin//怒之冰咆哮
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_220 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_220 := UserMagic;
          end;
        Skill_221:begin//静之冰咆哮
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_221 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_221 := UserMagic;
          end;
        Skill_222:begin//怒之雷电
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_222 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_222 := UserMagic;
          end;
        Skill_223:begin//静之雷电
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_223 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_223 := UserMagic;
          end;
        Skill_224:begin//怒之地狱雷光
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_224 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_224 := UserMagic;
          end;
        Skill_225:begin//静之地狱雷光
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_225 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_225 := UserMagic;
          end;
        Skill_226:begin//怒之寒冰掌
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_226 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_226 := UserMagic;
          end;
        Skill_227:begin//静之寒冰掌
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_227 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_227 := UserMagic;
          end;
        Skill_228:begin//怒之灭天火
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_228 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_228 := UserMagic;
          end;
        Skill_229:begin//静之灭天火
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_229 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_229 := UserMagic;
          end;
        Skill_230:begin//怒之火符
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_230 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_230 := UserMagic;
          end;
        Skill_231:begin//静之火符
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_231 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_231 := UserMagic;
          end;
        Skill_232:begin//怒之噬血
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_232 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_232 := UserMagic;
          end;
        Skill_233:begin//静之噬血
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_233 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_233 := UserMagic;
          end;
        Skill_234:begin//怒之流星火雨
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_234 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_234 := UserMagic;
          end;
        Skill_235:begin//静之流星火雨
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_235 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_235 := UserMagic;
          end;
        Skill_236:begin//怒之内功剑法(战+物理攻击)
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_236 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_236 := UserMagic;
          end;
        Skill_237:begin//静之内功剑法
            if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_237 := UserMagic
            else
            if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_237 := UserMagic;
          end;
      end;
    end;//for
  end;
end;

procedure TBaseObject.AddItemSkill(nIndex: Integer);
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
begin
  Magic := nil;
  case nIndex of
    1: Magic := UserEngine.FindMagic(g_Config.sFireBallSkill);
    2: Magic := UserEngine.FindMagic(g_Config.sHealSkill);
  end;
  if Magic <> nil then begin
    if not IsTrainingSkill(Magic.wMagicId) then begin
      New(UserMagic);
      UserMagic.MagicInfo := Magic;
      UserMagic.wMagIdx := Magic.wMagicId;
      UserMagic.btKey := 0;
      UserMagic.btLevel := 1;
      UserMagic.nTranPoint := 0;
      m_MagicList.Add(UserMagic);
      if m_btRaceServer = RC_PLAYOBJECT then begin
        TPlayObject(Self).SendAddMagic(UserMagic);
      end;
    end;
  end;
end;

function TBaseObject.AddToMap: Boolean;
var
  Point: Pointer;
begin
  Result := False;
  Point := m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  if Point <> nil then Result := True
  else Result := False;
  if not m_boFixedHideMode then
    SendRefMsg(RM_TURN, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TBaseObject.AttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word; nDir: Integer);
  function GetMagicSpell(UserMagic: pTUserMagic): Integer;
  begin
    Result := Round(UserMagic.MagicInfo.wSpell / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1));
  end;
  //武器升级设置
  procedure CheckWeaponUpgradeStatus(UserItem: pTUserItem);
  begin
    if (UserItem.btValue[0] + UserItem.btValue[1] + UserItem.btValue[2]) < g_Config.nUpgradeWeaponMaxPoint then begin
      case UserItem.btValue[10] of
        1: UserItem.wIndex := 0;
        10..12:begin
           UserItem.btValue[0] := UserItem.btValue[0] + UserItem.btValue[10] - 9;
           if UserItem.btValue[0] > g_Config.nUpgradeWeaponMaxPoint then UserItem.btValue[0] := g_Config.nUpgradeWeaponMaxPoint;//20080724 限制上限
         end;
        20..22:begin
           UserItem.btValue[1] := UserItem.btValue[1] + UserItem.btValue[10] - 19;
           if UserItem.btValue[1] > g_Config.nUpgradeWeaponMaxPoint then UserItem.btValue[1] := g_Config.nUpgradeWeaponMaxPoint;//20080724 限制上限
         end;
        30..32:begin
           UserItem.btValue[2] := UserItem.btValue[2] + UserItem.btValue[10] - 29;
           if UserItem.btValue[2] > g_Config.nUpgradeWeaponMaxPoint then UserItem.btValue[2]:= g_Config.nUpgradeWeaponMaxPoint;//20080724 限制上限
         end;
      end;
    end else UserItem.wIndex := 0;
    UserItem.btValue[10] := 0;
  end;
  procedure CheckWeaponUpgrade();//检查武器升级
  var
    UseItems: TUserItem;
    PlayObject: TPlayObject;
    StdItem: pTStdItem;
  begin
    if m_UseItems[U_WEAPON].btValue[10] > 0 then begin
      UseItems := m_UseItems[U_WEAPON];
      CheckWeaponUpgradeStatus(@m_UseItems[U_WEAPON]);
      if m_UseItems[U_WEAPON].wIndex = 0 then begin
        SysMsg(g_sTheWeaponBroke, c_Red, t_Hint);
        PlayObject := TPlayObject(Self);
        PlayObject.SendDelItems(@UseItems);
        //PlayObject.StatusChanged;
        SendRefMsg(RM_BREAKWEAPON, 0, 0, 0, 0, '');
        StdItem := UserEngine.GetStdItem(UseItems.wIndex);
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('21' + #9 +
            m_sMapName + #9 +IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UseItems.MakeIndex) + #9 +
            '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
            '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
            '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
            '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
            '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
            IntToStr(UseItems.btValue[0])+'/'+IntToStr(UseItems.btValue[1])+'/'+IntToStr(UseItems.btValue[2])+'/'+
            IntToStr(UseItems.btValue[3])+'/'+IntToStr(UseItems.btValue[4])+'/'+IntToStr(UseItems.btValue[5])+'/'+
            IntToStr(UseItems.btValue[6])+'/'+IntToStr(UseItems.btValue[7])+'/'+IntToStr(UseItems.btValue[8])+'/'+
            IntToStr(UseItems.btValue[14])+ #9 +'0');
        FeatureChanged();
      end else begin
        SysMsg(sTheWeaponRefineSuccessfull, c_Red, t_Hint);
        PlayObject := TPlayObject(Self);
        PlayObject.SendUpdateItem(@m_UseItems[U_WEAPON]);
        StdItem := UserEngine.GetStdItem(UseItems.wIndex);
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('20' + #9 + m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +StdItem.Name + #9 + IntToStr(UseItems.MakeIndex) + #9 +
            '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
            '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
            '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
            '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
            '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
            IntToStr(UseItems.btValue[0])+'/'+IntToStr(UseItems.btValue[1])+'/'+IntToStr(UseItems.btValue[2])+'/'+
            IntToStr(UseItems.btValue[3])+'/'+IntToStr(UseItems.btValue[4])+'/'+IntToStr(UseItems.btValue[5])+'/'+
            IntToStr(UseItems.btValue[6])+'/'+IntToStr(UseItems.btValue[7])+'/'+IntToStr(UseItems.btValue[8])+'/'+
            IntToStr(UseItems.btValue[14]) + #9 +'0');
        RecalcAbilitys();
        CompareSuitItem(False);//套装与身上装备对比 20080729
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
      end;
    end;
  end;
var
  AttackTarget: TBaseObject;
  boPowerHit: Boolean;
  boFireHit: Boolean;
  bo42: Boolean;
  bo43: Boolean;
  bo74: Boolean;
  wIdent: Word;
  nCheckCode: Integer;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::AttackDir Code: %d';
begin
  nCheckCode := 0;
  try
    if (wHitMode = 5) and (m_MagicBanwolSkill <> nil) then begin //半月
      if m_WAbil.MP > 0 then begin
        nCheckCode := 1;
        DamageSpell(m_MagicBanwolSkill.MagicInfo.btDefSpell + GetMagicSpell(m_MagicBanwolSkill));
        nCheckCode := 2;
        HealthSpellChanged();
        nCheckCode := 3;
      end else wHitMode := RM_HIT;
    end;
    nCheckCode := 4;
    m_btDirection := nDir;
    if TargeTBaseObject = nil then begin
      nCheckCode := 41;
      AttackTarget := GetPoseCreate();
    end else AttackTarget := TargeTBaseObject;
    if (AttackTarget <> nil) and (m_UseItems[U_WEAPON].wIndex > 0) then begin
      nCheckCode := 42;
      if m_btRaceServer = RC_PLAYOBJECT then CheckWeaponUpgrade();
    end;
    nCheckCode := 5;

    boPowerHit := m_boPowerHit; //控制攻杀剑术 20071217

    if (m_MagicPowerHitSkill <> nil) and (wHitMode = 3) and (m_btRaceServer = RC_HEROOBJECT) then boPowerHit :=True;//20071218

    boFireHit := m_boFireHitSkill;
    bo42 := m_bo42kill;
    bo43 := m_bo43kill;
    bo74 := m_boDailySkill;

    if m_btRaceServer = RC_PLAYOBJECT then begin//20081003 学过内功心法,每攻击一次减一点内力值
      if TPlayObject(self).m_boTrainingNG then begin//20081003 学过内功心法,每攻击一次减一点内力值
        TPlayObject(self).m_Skill69NH := _MAX(0, TPlayObject(self).m_Skill69NH - g_Config.nHitStruckDecNH);
        TPlayObject(self).SendRefMsg(RM_MAGIC69SKILLNH, 0, TPlayObject(self).m_Skill69NH, TPlayObject(self).m_Skill69MaxNH, 0, '');
      end;
    end else
    if m_btRaceServer = RC_HEROOBJECT then begin
       if THeroObject(self).m_boTrainingNG then begin//20081003 英雄学过内功心法,每攻击一次减一点内力值
         THeroObject(self).m_Skill69NH := _MAX(0, THeroObject(self).m_Skill69NH - g_Config.nHitStruckDecNH);
         THeroObject(self).SendRefMsg( RM_MAGIC69SKILLNH, 0, THeroObject(self).m_Skill69NH, THeroObject(self).m_Skill69MaxNH, 0, '');
       end;
    end;
    
    if _Attack(wHitMode, AttackTarget) then begin
      nCheckCode := 6;
      if m_btRaceServer = RC_HEROOBJECT then begin //20080531 修正英雄锁定后,不打锁定怪
        if not THeroObject(self).m_boTarget then SetTargetCreat(AttackTarget);
      end else SetTargetCreat(AttackTarget);
      nCheckCode := 7;
    end;
    wIdent := RM_HIT;
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin {增加分身魔法攻击}
      case wHitMode of
        0: wIdent := RM_HIT;
        1: wIdent := RM_HEAVYHIT;
        2: wIdent := RM_BIGHIT;
        3: if boPowerHit then wIdent := RM_SPELL2;
        4: if m_MagicErgumSkill <> nil then wIdent := RM_LONGHIT;
        5: if m_MagicBanwolSkill <> nil then wIdent := RM_WIDEHIT;
        7: if boFireHit and (m_MagicFireSwordSkill <> nil) then begin
           if (m_MagicFireSwordSkill.btLevel = 4) and (THeroObject(self).m_nLoyal >=g_Config.nGotoLV4) then begin // 英雄4级烈火20080113
             wIdent := RM_4FIREHIT;//发送4级烈火剑术消息  20080112
           end else
             wIdent := RM_FIREHIT;//发送烈火剑法消息 20080112
           end;
        8: if m_MagicCrsSkill <> nil then wIdent := RM_CRSHIT;
        9: if m_Magic42Skill <> nil then wIdent := RM_41;{开天斩}
        10: if bo42 then wIdent := RM_42;//这两句可能有错 20080202
        11: if bo43 then wIdent := RM_43;//这两句可能有错 20080202
        12: if bo43 and (m_Magic43Skill <> nil) then wIdent := RM_44;//龙影剑法 20080619 修改
        13: if bo74 and (m_Magic74Skill <> nil) then wIdent := RM_DAILY;//逐日剑法 20080511
      end;
    end;
    nCheckCode := 8;
    SendAttackMsg(wIdent, m_btDirection, m_nCurrX, m_nCurrY);
    nCheckCode := 9;
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg, [nCheckCode]));
    end;
  end;
end;
//检查PK状态
procedure TBaseObject.CheckPKStatus;
begin
  if m_boPKFlag and ((GetTickCount - m_dwPKTick) > g_Config.dwPKFlagTime {60 * 1000}) then begin
    m_boPKFlag := False;
    RefNameColor();
  end;
end;
//魔法损害
procedure TBaseObject.DamageSpell(nSpellPoint: Integer);
begin
  if nSpellPoint > 0 then begin
    if (m_WAbil.MP - nSpellPoint) > 0 then
      Dec(m_WAbil.MP, nSpellPoint)
    else m_WAbil.MP := 0;
  end else begin
    if (m_WAbil.MP - nSpellPoint) < m_WAbil.MaxMP then
      Dec(m_WAbil.MP, nSpellPoint)
    else m_WAbil.MP := m_WAbil.MaxMP;
  end;
end;
//减PK值
procedure TBaseObject.DecPKPoint(nPoint: Integer);
var
  nC: Integer;
begin
  nC := PKLevel();
  Dec(m_nPkPoint, nPoint);
  if m_nPkPoint < 0 then m_nPkPoint := 0;
  if (PKLevel <> nC) and (nC > 0) and (nC <= 2) then begin
    RefNameColor();
  end;
end;

procedure TBaseObject.DelItemSkill(nIndex: Integer);
  procedure DELETESKILL(sSkillName: string);
  var
    I: Integer;
    UserMagic: pTUserMagic;
    PlayObject: TPlayObject;
  begin
    for I := m_MagicList.Count - 1 downto 0 do begin//20080916 修改
      if m_MagicList.Count <= 0 then Break;//20080916
      UserMagic := m_MagicList.Items[I];
      if UserMagic.MagicInfo.sMagicName = sSkillName then begin
        PlayObject := TPlayObject(Self);
        PlayObject.SendDelMagic(UserMagic);
        Dispose(UserMagic);
        m_MagicList.Delete(I);
        Break;
      end;
    end;
  end;
begin
  if m_btRaceServer <> RC_PLAYOBJECT then Exit;
  case nIndex of
    1: if m_btJob <> 1 then DELETESKILL(g_Config.sFireBallSkill);
    2: if m_btJob <> 2 then DELETESKILL(g_Config.sHealSkill)
  end;
end;

procedure TPlayObject.DelMember(PlayObject: TPlayObject);
var
  I: Integer;
begin
  if m_GroupOwner <> PlayObject then begin
    for I := m_GroupMembers.Count - 1 downto 0 do begin
      if m_GroupMembers.Count <= 0 then Break;
      if (m_GroupMembers.Objects[I] <> nil) and (m_GroupMembers.Objects[I] = PlayObject) then begin
        PlayObject.LeaveGroup();
        m_GroupMembers.Delete(I);
        Break;
      end;
    end;//for
  end else begin
    for I := m_GroupMembers.Count - 1 downto 0 do begin
      if m_GroupMembers.Count <= 0 then Break;
      if TPlayObject(m_GroupMembers.Objects[I]) <> nil then begin
        TPlayObject(m_GroupMembers.Objects[I]).LeaveGroup;
        m_GroupMembers.Delete(I);
      end;
    end;
  end;
  if not CancelGroup then begin
    SendDefMessage(SM_GROUPCANCEL, 0, 0, 0, 0, '');
  end else SendGroupMembers();
end;

procedure TBaseObject.DoDamageWeapon(nWeaponDamage: Integer);
var
  nDura, nDuraPoint: Integer;
  PlayObject: TPlayObject;
  StdItem: pTStdItem;
begin
  if m_UseItems[U_WEAPON].wIndex <= 0 then Exit;
  nDura := m_UseItems[U_WEAPON].Dura;
  nDuraPoint := Round(nDura / 1.03);
  Dec(nDura, nWeaponDamage);
  if nDura <= 0 then begin
    nDura := 0;
    m_UseItems[U_WEAPON].Dura := nDura;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      PlayObject := TPlayObject(Self);
      PlayObject.SendDelItems(@m_UseItems[U_WEAPON]);
      StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
      if StdItem.NeedIdentify = 1 then
        AddGameDataLog('3' + #9 + m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 + StdItem.Name + #9 +
          IntToStr(m_UseItems[U_WEAPON].MakeIndex) + #9 +
          '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
          '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
          '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
          '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
          '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
          IntToStr(m_UseItems[U_WEAPON].btValue[0])+'/'+IntToStr(m_UseItems[U_WEAPON].btValue[1])+'/'+IntToStr(m_UseItems[U_WEAPON].btValue[2])+'/'+
          IntToStr(m_UseItems[U_WEAPON].btValue[3])+'/'+IntToStr(m_UseItems[U_WEAPON].btValue[4])+'/'+IntToStr(m_UseItems[U_WEAPON].btValue[5])+'/'+
          IntToStr(m_UseItems[U_WEAPON].btValue[6])+'/'+IntToStr(m_UseItems[U_WEAPON].btValue[7])+'/'+IntToStr(m_UseItems[U_WEAPON].btValue[8])+'/'+
          IntToStr(m_UseItems[U_WEAPON].btValue[14])+ #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) );
    end;
    m_UseItems[U_WEAPON].wIndex := 0;
    SendMsg(Self, RM_DURACHANGE, U_WEAPON, nDura, m_UseItems[U_WEAPON].DuraMax, 0, '');
  end else begin //004C199D
    m_UseItems[U_WEAPON].Dura := nDura;
  end;
  if (nDura / 1.03) <> nDuraPoint then begin
    SendMsg(Self, RM_DURACHANGE, U_WEAPON, m_UseItems[U_WEAPON].Dura, m_UseItems[U_WEAPON].DuraMax, 0, '');
  end;
end;

{procedure TBaseObject.DoDamageWeapon(nWeaponDamage: Integer);
var
  nDura, nDuraPoint: Integer;
  PlayObject: TPlayObject;
  HeroObject: THeroObject;
  StdItem: pTStdItem;
begin
  if m_UseItems[U_WEAPON].wIndex <= 0 then Exit;
  nDura := m_UseItems[U_WEAPON].Dura;
  nDuraPoint := Round(nDura / 1.03);
  Dec(nDura, nWeaponDamage);
  if nDura <= 0 then begin
    nDura := 0;
    m_UseItems[U_WEAPON].Dura := nDura;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      PlayObject := TPlayObject(Self);
      PlayObject.SendDelItems(@m_UseItems[U_WEAPON]);
      StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
      //004C195A
      if StdItem.NeedIdentify = 1 then
        AddGameDataLog('3' + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          //UserEngine.GetStdItemName(m_UseItems[U_WEAPON].wIndex) + #9 +
          StdItem.Name + #9 +
          IntToStr(m_UseItems[U_WEAPON].MakeIndex) + #9 +
          BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
          '0');
      m_UseItems[U_WEAPON].wIndex := 0;
      SendMsg(Self, RM_DURACHANGE, U_WEAPON, nDura, m_UseItems[U_WEAPON].DuraMax, 0, '');
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      HeroObject := THeroObject(Self);
      HeroObject.SendDelItems(@m_UseItems[U_WEAPON]);
      m_UseItems[U_WEAPON].wIndex := 0;
      SendMsg(Self, RM_HERODURACHANGE, U_WEAPON, nDura, m_UseItems[U_WEAPON].DuraMax, 0, '');
    end;
  end else begin
    m_UseItems[U_WEAPON].Dura := nDura;
  end;

  if (nDura / 1.03) <> nDuraPoint then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SendMsg(Self, RM_DURACHANGE, U_WEAPON, m_UseItems[U_WEAPON].Dura, m_UseItems[U_WEAPON].DuraMax, 0, '');
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      SendMsg(Self, RM_HERODURACHANGE, U_WEAPON, m_UseItems[U_WEAPON].Dura, m_UseItems[U_WEAPON].DuraMax, 0, '');
    end;
  end;
end; }
//取装备物品属性 20080325
procedure TBaseObject.GetAccessory(Item: TUserItem; var AddAbility: TAddAbility); //004C0EBC
var
  StdItem: pTStdItem;
  StdItemA: TStdItem;
begin
  StdItem := UserEngine.GetStdItem(Item.wIndex);
  if StdItem = nil then Exit;
  StdItemA := StdItem^;
  ItemUnit.GetItemAddValue(@Item, StdItemA);
  case StdItem.StdMode of
    5, 6: begin //004C0F63
        Inc(AddAbility.wHitPoint, HiWord(StdItemA.AC));
        if HiWord(StdItemA.MAC) > 10 then begin
          Inc(AddAbility.nHitSpeed, HiWord(StdItemA.MAC) - 10);
        end else begin
          Dec(AddAbility.nHitSpeed, HiWord(StdItemA.MAC));
        end;
        Inc(AddAbility.btLuck, LoWord(StdItemA.AC));
        Inc(AddAbility.btUnLuck, LoWord(StdItemA.MAC));
      end;
    19: begin //项链+幸运
        Inc(AddAbility.wAntiMagic, HiWord(StdItemA.AC));
        Inc(AddAbility.btUnLuck, LoWord(StdItemA.MAC));
        Inc(AddAbility.btLuck, HiWord(StdItemA.MAC));
      end;
    53: begin //新加物品属性
        if not g_Config.boAddUserItemNewValue then begin
          Inc(AddAbility.wAntiMagic, HiWord(StdItemA.AC));
          Inc(AddAbility.btUnLuck, LoWord(StdItemA.MAC));
          Inc(AddAbility.btLuck, HiWord(StdItemA.MAC));
        end else begin
          AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
          AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
        end;
      end;
    20, 24: begin //004C0FF0
        Inc(AddAbility.wHitPoint, HiWord(StdItemA.AC));
        Inc(AddAbility.wSpeedPoint, HiWord(StdItemA.MAC));
      end;
    52: begin //靴子(特殊型)
        if not g_Config.boAddUserItemNewValue then begin
          Inc(AddAbility.wHitPoint, HiWord(StdItemA.AC));
          Inc(AddAbility.wSpeedPoint, HiWord(StdItemA.MAC));
        end else begin
          AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
          AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
          AddAbility.wWearWeight := MakeLong(LoWord(AddAbility.wWearWeight) + LoWord(StdItemA.AniCount), HiWord(AddAbility.wWearWeight) + HiWord(StdItemA.AniCount));//20080325 加负重
        end;
      end;
    21: begin
        Inc(AddAbility.wHealthRecover, HiWord(StdItemA.AC));
        Inc(AddAbility.wSpellRecover, HiWord(StdItemA.MAC));
        Inc(AddAbility.nHitSpeed, LoWord(StdItemA.AC));
        Dec(AddAbility.nHitSpeed, LoWord(StdItemA.MAC));
      end;
    54: begin //腰带(特殊型)
        if not g_Config.boAddUserItemNewValue then begin
          Inc(AddAbility.wHealthRecover, HiWord(StdItemA.AC));
          Inc(AddAbility.wSpellRecover, HiWord(StdItemA.MAC));
          Inc(AddAbility.nHitSpeed, LoWord(StdItemA.AC));
          Dec(AddAbility.nHitSpeed, LoWord(StdItemA.MAC));
        end else begin
          AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
          AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
          AddAbility.wWearWeight := MakeLong(LoWord(AddAbility.wWearWeight) + LoWord(StdItemA.AniCount), HiWord(AddAbility.wWearWeight) + HiWord(StdItemA.AniCount));//20080325 加负重
        end;
      end;
    23: begin
        Inc(AddAbility.wAntiPoison, HiWord(StdItemA.AC));
        Inc(AddAbility.wPoisonRecover, HiWord(StdItemA.MAC));
        Inc(AddAbility.nHitSpeed, LoWord(StdItemA.AC));
        Dec(AddAbility.nHitSpeed, LoWord(StdItemA.MAC));
      end;
  else begin
      AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
      AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
    end;
  end;
  AddAbility.wDC := MakeLong(LoWord(AddAbility.wDC) + LoWord(StdItemA.DC), HiWord(AddAbility.wDC) + HiWord(StdItemA.DC));
  AddAbility.wMC := MakeLong(LoWord(AddAbility.wMC) + LoWord(StdItemA.MC), HiWord(AddAbility.wMC) + HiWord(StdItemA.MC));
  AddAbility.wSC := MakeLong(LoWord(AddAbility.wSC) + LoWord(StdItemA.SC), HiWord(AddAbility.wSC) + HiWord(StdItemA.SC));
end;
//取名字颜色值
function TBaseObject.GetCharColor(BaseObject: TBaseObject): Byte;
var
  n10: Integer;
  Castle: TUserCastle;
  nCode: Byte;
begin
  nCode:=0 ;
  try
    Result := BaseObject.GetNamecolor();
    nCode:= 1;
    if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
      nCode:= 2;
      if BaseObject.PKLevel < 2 then begin
        if BaseObject.m_boPKFlag then Result := g_Config.btPKFlagNameColor; //$2F
        nCode:= 3;
        n10 := GetGuildRelation(Self, BaseObject);
        nCode:= 4;
        case n10 of
          1, 3: Result := g_Config.btAllyAndGuildNameColor; //$B4;
          2: Result := g_Config.btWarGuildNameColor; //$45;
        end;
        nCode:= 5;
        if BaseObject.m_PEnvir.m_boFight3Zone then begin
          nCode:= 6;
          if m_MyGuild = BaseObject.m_MyGuild then Result := g_Config.btAllyAndGuildNameColor //$B4
          else Result := g_Config.btWarGuildNameColor //$45;
        end;
      end;
      nCode:= 7;
      Castle := g_CastleManager.InCastleWarArea(BaseObject);
      nCode:= 8;
      if (Castle <> nil) and Castle.m_boUnderWar and m_boInFreePKArea and BaseObject.m_boInFreePKArea then begin
        Result := g_Config.btInFreePKAreaNameColor; //$DD;
        m_boGuildWarArea := True;
        if (m_MyGuild = nil) then Exit;
        nCode:= 9;
        if Castle.IsMasterGuild(TGUild(m_MyGuild)) then begin
          nCode:= 10;
          if (m_MyGuild = BaseObject.m_MyGuild) or
            (TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild))) then begin
            nCode:= 11;
            Result := g_Config.btAllyAndGuildNameColor;
          end else begin
            nCode:= 12;
            if Castle.IsAttackGuild(TGUild(BaseObject.m_MyGuild)) then begin
              nCode:= 13;
              Result := g_Config.btWarGuildNameColor;
            end;
          end;
        end else begin
          nCode:= 14;
          if Castle.IsAttackGuild(TGUild(m_MyGuild)) then begin
            nCode:= 15;
            if (m_MyGuild = BaseObject.m_MyGuild) or
              (TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild))) then begin
              nCode:= 16;
              Result := g_Config.btAllyAndGuildNameColor;
            end else begin
              nCode:= 17;
              if Castle.IsMember(BaseObject) then begin
                nCode:= 18;
                Result := g_Config.btWarGuildNameColor;
              end;
            end;
          end;
        end;
      end;
    end else
    if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin
      nCode:= 19;
      if BaseObject.PKLevel < 2 then begin
        if BaseObject.m_boPKFlag then Result := g_Config.btPKFlagNameColor;
        if BaseObject.m_Master <> nil then begin//20080806 增加
          n10 := GetGuildRelation(Self, BaseObject.m_Master);
          nCode:= 26;
          case n10 of
            1, 3: Result := g_Config.btAllyAndGuildNameColor; //$B4;
            2: Result := g_Config.btWarGuildNameColor; //$45;
          end;
          if BaseObject.m_PEnvir.m_boFight3Zone then begin
            nCode:= 27;
            if m_MyGuild = BaseObject.m_Master.m_MyGuild then Result := g_Config.btAllyAndGuildNameColor //$B4
            else Result := g_Config.btWarGuildNameColor //$45;
          end;
        end;
      end;
      nCode:= 20;
      //攻城区域,英雄也一样变名 20080720
      Castle := g_CastleManager.InCastleWarArea(BaseObject);
      nCode:= 21;
      if BaseObject.m_Master <> nil then begin //20080803 增加
        if (Castle <> nil) and Castle.m_boUnderWar and BaseObject.m_Master.m_boInFreePKArea then begin
          nCode:= 22;
          Result := g_Config.btInFreePKAreaNameColor; //$DD;
          m_boGuildWarArea := True;
          if (m_MyGuild = nil) then Exit;
          nCode:= 26;
          if Castle.IsMasterGuild(TGUild(m_MyGuild)) then begin
            nCode:= 27;
            if (m_MyGuild = BaseObject.m_Master.m_MyGuild) or
              (TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild))) then begin
              nCode:= 28;
              Result := g_Config.btAllyAndGuildNameColor;
            end else begin
              nCode:= 29;
              if Castle.IsAttackGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then begin
                nCode:= 30;
                Result := g_Config.btWarGuildNameColor;
              end;
            end;
          end else begin
            nCode:= 31;
            if Castle.IsAttackGuild(TGUild(m_MyGuild)) then begin
              nCode:= 32;
              if (m_MyGuild = BaseObject.m_Master.m_MyGuild) or
                (TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild))) then begin
                nCode:= 33;
                Result := g_Config.btAllyAndGuildNameColor;
              end else begin
                nCode:= 34;
                if Castle.IsMember(BaseObject.m_Master) then begin
                  nCode:= 35;
                  Result := g_Config.btWarGuildNameColor;
                end;
              end;
            end;
          end;
        end;
      end;
    end else
    if BaseObject.m_btRaceServer = RC_NPC then begin//NPC名字颜色 20081218
      Result := g_Config.btNPCNameColor;
      if BaseObject.m_boCrazyMode then Result := $F9;//疯狂模式(红名)
      if BaseObject.m_boHolySeize then Result := $7D;//不能走动模式
    end else begin
      nCode:= 23;                                            //20080913 没有自定义名字颜色
      if (BaseObject.m_btSlaveExpLevel < SLAVEMAXLEVEL) and (not BaseObject.m_boSetNameColor) then begin
        nCode:= 24;
        Result := g_Config.SlaveColor[BaseObject.m_btSlaveExpLevel];
        if (BaseObject.m_Master <> nil) and (BaseObject.m_btRaceServer = RC_PLAYMOSTER) then begin//20080404 分身和主人名字颜色一样
          Result := BaseObject.m_btNameColor;//20081020
        end;
      end;
      if (BaseObject.PKLevel < 2) and (BaseObject.m_btRaceServer = RC_PLAYMOSTER) then begin//20081023 人形灰名显示
        if (BaseObject.m_boPKFlag) and (BaseObject.m_Master <> nil) then Result := g_Config.btPKFlagNameColor;
      end;  
      nCode:= 25;
      if BaseObject.m_boCrazyMode then Result := $F9;//疯狂模式(红名)
      if BaseObject.m_boHolySeize then Result := $7D;//不能走动模式
    end;
  except
    MainOutMessage('{异常} TBaseObject.GetCharColor Code:' + inttostr(nCode));
  end;
end;
//取等级所需经验值
function TBaseObject.GetLevelExp(nLevel: Integer): LongWord;
  function GetBaseExp(): Integer;
  var
    nInt64: Int64;
  begin
    nInt64 := (nLevel - 1000) * g_Config.nAddExp + g_Config.nBaseExp;
    if nInt64 > High(LongWord) then Result := High(LongWord) else Result := nInt64;
  end;
begin
  if nLevel <= MAXCHANGELEVEL {1000} then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      Result := g_Config.dwNeedExps[nLevel];
    end else begin
      Result := g_Config.dwHeroNeedExps[nLevel]; //英雄经验
    end;
    Exit;
  end;
  if g_Config.boUseFixExp then begin
    if nLevel <= MAXLEVEL then begin
      Result := 2000000000 + nLevel * 1500;
    end else begin
      Result := High(LongWord); //g_Config.dwNeedExps[High(g_Config.dwNeedExps)];
    end;
  end else begin
    if nLevel <= MAXLEVEL then begin
      Result := GetBaseExp();
    end else begin
      Result := High(LongWord);
    end;
  end;
end;
//取等级所需药力值 20080624
function TBaseObject.GetMedicineExp(nLevel: Integer): Word;
begin
  if nLevel <= MAXCHANGELEVEL {1000} then begin
    Result := g_Config.dwMedicineNeedExps[nLevel];
    Exit;
  end;
  if nLevel <= MAXLEVEL then Result := High(Word);
end;
//酒气护体 取等级所需经验值 20080625
function TBaseObject.GetSkill68Exp(nLevel: Byte): LongWord;
begin
  Result := 0;
  if nLevel = 0 then Exit;
  if nLevel < 100 then begin
    Result := g_Config.dwSkill68NeedExps[nLevel];
    Exit;
  end else Result := High(LongWord);
end;

//内功心法 取等级所需经验值,内力值上限 20080930
function TBaseObject.GetSkill69Exp(nLevel: Byte;var nMaxNH: Word): LongWord;
begin
  nMaxNH := 0;
  nMaxNH:= Round((2 + 2 * (nLevel - 1)) * nLevel / 2 + g_Config.nSkill69NG{10});
  if m_btRaceServer = RC_PLAYOBJECT then begin//主体
    Result := 200 * nLevel * nLevel * nLevel + 13940 * nLevel * nLevel + g_Config.nSkill69NGExp{55330};
  end else begin
    Result := 200 * nLevel * nLevel * nLevel + 14240 * nLevel * nLevel + 14240 * nLevel + g_Config.nHeroSkill69NGExp{62400};//英雄经验
  end;
end;
//取人物名字颜色
function TBaseObject.GetNamecolor(): Byte;
begin
  Result := m_btNameColor;
  if PKLevel = 1 then Result := g_Config.btPKLevel1NameColor; //$FB;
  if PKLevel >= 2 then Result := g_Config.btPKLevel2NameColor; //$F9;
end;
//查询在线人数即 who Total 命令返回 
procedure TBaseObject.HearMsg(sMsg: string);
begin
  if sMsg <> '' then SendMsg(nil, RM_HEAR, 0, g_Config.btHearMsgFColor, g_Config.btHearMsgBColor, 0, sMsg);
end;
//是否在安全区
function TBaseObject.InSafeArea(): Boolean;
var
  I: Integer;
  SC: string;
  n14, n18: Integer;
  StartPoint: pTStartPoint;
begin
  Result := False;
  if m_PEnvir = nil then Exit;
  Result := m_PEnvir.m_boSAFE;
  if Result then Exit;
  try
    g_StartPointList.Lock;
    if g_StartPointList.Count > 0 then begin//20080629
      for I := 0 to g_StartPointList.Count - 1 do begin
        SC := g_StartPointList.Strings[I];
        if SC = m_PEnvir.sMapName then begin
          StartPoint := pTStartPoint(g_StartPointList.Objects[I]);
          if StartPoint <> nil then begin
            //n1C := Integer(g_StartPointList.Objects[i]);
            n14 := StartPoint.m_nCurrX;
            n18 := StartPoint.m_nCurrY;    //20081006修改,使用安全区范围做判断
            if (abs(m_nCurrX - n14) <= {60}g_Config.nSafeZoneSize) and (abs(m_nCurrY - n18) <={60}g_Config.nSafeZoneSize) then begin
              Result := True;
              Break;
            end;
          end;
        end;
      end;//for
    end;
  finally
    g_StartPointList.UnLock;
  end;
end;

procedure TBaseObject.MonsterRecalcAbilitys;
var
  n8: Integer;
begin
  m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_Abil.DC));
  n8 := 0;
  if (m_btRaceServer = 100) or (m_btRaceServer = 113) or (m_btRaceServer = 114) then begin
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), Round((m_btSlaveExpLevel * {1.0e-1} 0.1 + {3.0000000000000000001e-1} 0.3) * {3.0} 3.0 * m_btSlaveExpLevel + HiWord(m_WAbil.DC)));
    n8 := n8 + Round((m_btSlaveExpLevel * {1.0e-1} 0.1 + {3.0000000000000000001e-1} 0.3) * m_Abil.MaxHP) * m_btSlaveExpLevel;
    n8 := n8 + m_Abil.MaxHP;
    if m_btSlaveExpLevel > 0 then m_WAbil.MaxHP := n8
    else m_WAbil.MaxHP := m_Abil.MaxHP;
  end else begin 
    n8 := m_Abil.MaxHP;
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), Round(m_btSlaveExpLevel * 2 + HiWord(m_WAbil.DC)));
    n8 := n8 + Round(m_Abil.MaxHP * {1.5000000000000000001e-1} 0.15) * m_btSlaveExpLevel;
    m_WAbil.MaxHP := _MIN(Round(m_Abil.MaxHP + m_btSlaveExpLevel * 60), n8);
    //m_WAbil.MAC:=0; 01/20 取消此行，防止怪物升级后魔防变0
  end;
  //m_btHitPoint:=15; 01/20 取消此行，防止怪物升级后准确率变15
end;

procedure TPlayObject.ShowMapInfo(sMAP, sX, sY: string);
var
  Map: TEnvirnoment;
  nX, nY: Integer;
  MapCellInfo: pTMapCellinfo;
begin
  nX := Str_ToInt(sX, 0);
  nY := Str_ToInt(sY, 0);
  if (sMAP <> '') and (nX >= 0) and (nY >= 0) then begin
    Map := g_MapManager.FindMap(sMAP);
    if Map <> nil then begin
      if Map.GetMapCellInfo(nX, nY, MapCellInfo) then begin
        SysMsg('标志: ' + IntToStr(MapCellInfo.chFlag), c_Green, t_Hint);
        if MapCellInfo.ObjList <> nil then begin
          SysMsg('对象数: ' + IntToStr(MapCellInfo.ObjList.Count), c_Green, t_Hint);
        end;
      end else begin
        SysMsg('取地图单元信息失败: ' + sMAP, c_Red, t_Hint);
      end;
    end;
  end else begin
    SysMsg('请按正确格式输入: ' + g_GameCommand.MAPINFO.sCmd + ' 地图号 X Y', c_Green, t_Hint);
  end;
end;

procedure TBaseObject.SendFirstMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string);
var
  SendMessage: pTSendMessage;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if not m_boGhost then begin
      New(SendMessage);
      SendMessage.wIdent := wIdent;
      SendMessage.wParam := wParam;
      SendMessage.nParam1 := lParam1;
      SendMessage.nParam2 := lParam2;
      SendMessage.nParam3 := lParam3;
      SendMessage.dwDeliveryTime := 0;
      SendMessage.BaseObject := BaseObject;
      if sMsg <> '' then begin
        try
          GetMem(SendMessage.Buff, Length(sMsg) + 1);
          Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
        except
          SendMessage.Buff := nil;
        end;
      end else begin
        SendMessage.Buff := nil;
      end;
      m_MsgList.Insert(0, SendMessage);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.SendMsg(BaseObject: TBaseObject; wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: string);
var
  SendMessage: pTSendMessage;
  nCode: Byte;//20080823
begin
  nCode:=0;
  try
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      nCode:=1;
      if Self = nil then Exit;//20080826 增加
      nCode:=7;
      if not m_boGhost then begin
        New(SendMessage);
        nCode:=2;
        SendMessage.wIdent := wIdent;
        SendMessage.wParam := wParam;
        SendMessage.nParam1 := nParam1;
        SendMessage.nParam2 := nParam2;
        SendMessage.nParam3 := nParam3;
        nCode:=3;
        SendMessage.dwDeliveryTime := 0;
        nCode:=4;
        SendMessage.BaseObject := BaseObject;
        SendMessage.boLateDelivery := False;
        if sMsg <> '' then begin
          try
            nCode:=5;
            GetMem(SendMessage.Buff, Length(sMsg) + 1);
            Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
          except
            SendMessage.Buff := nil;
          end;
        end else begin
          SendMessage.Buff := nil;
        end;
        nCode:=6;
        try
          m_MsgList.Add(SendMessage);
        except
          Dispose(SendMessage);
        end;
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('{异常} TBaseObject.SendMsg Code:'+inttostr(nCode)+'  Name:'+m_sCharName);
    KickException;//20080901 增加
  end;
end;
//------------------------------------------------------------------------------
//过程名：SendDelayMsg
//作用：延迟发送消息
//参数：dwDelay: LongWord  为延迟时间 单位：毫秒
procedure TBaseObject.SendDelayMsg(BaseObject: TBaseObject; wIdent,
  wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string;
  dwDelay: LongWord);
var
  SendMessage: pTSendMessage;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if not m_boGhost then begin
      New(SendMessage);
      SendMessage.wIdent := wIdent;
      SendMessage.wParam := wParam;
      SendMessage.nParam1 := lParam1;
      SendMessage.nParam2 := lParam2;
      SendMessage.nParam3 := lParam3;
      SendMessage.dwDeliveryTime := GetTickCount + dwDelay;
      SendMessage.BaseObject := BaseObject;
      SendMessage.boLateDelivery := True;
      if sMsg <> '' then begin
        try
          GetMem(SendMessage.Buff, Length(sMsg) + 1);
          Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
        except
          SendMessage.Buff := nil;
        end;
      end else begin
        SendMessage.Buff := nil;
      end;
      m_MsgList.Add(SendMessage);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.SendUpdateDelayMsg(BaseObject: TBaseObject; wIdent,
  wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string;
  dwDelay: LongWord);
var
  SendMessage: pTSendMessage;
  I: Integer;
begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    I := 0;
    while (True) do begin
      if m_MsgList.Count <= I then Break;
      SendMessage := m_MsgList.Items[I];
      if (SendMessage.wIdent = wIdent) and (SendMessage.nParam1 = lParam1) then begin
        m_MsgList.Delete(I);
        if SendMessage.Buff <> nil then FreeMem(SendMessage.Buff);
        Dispose(SendMessage);
        Continue;
      end;
      Inc(I);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendDelayMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg, dwDelay);
end;

procedure TBaseObject.SendUpdateMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string);
var
  SendMessage: pTSendMessage;
  I: Integer;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    I := 0;
    while (True) do begin
      if m_MsgList.Count <= I then Break;
      SendMessage := m_MsgList.Items[I];
      if SendMessage.wIdent = wIdent then begin
        m_MsgList.Delete(I);
        if SendMessage.Buff <> nil then FreeMem(SendMessage.Buff);
        Dispose(SendMessage);
        Continue;
      end;
      Inc(I);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg);
end;

procedure TBaseObject.SendActionMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string);
var
  SendMessage: pTSendMessage;
  I: Integer;
begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    I := 0;
    while (True) do begin
      if m_MsgList.Count <= I then Break;
      SendMessage := m_MsgList.Items[I];
      if (SendMessage.wIdent = CM_TURN) or
        (SendMessage.wIdent = CM_WALK) or
        (SendMessage.wIdent = CM_SITDOWN) or
        (SendMessage.wIdent = CM_HORSERUN) or
        (SendMessage.wIdent = CM_RUN) or
        (SendMessage.wIdent = CM_HIT) or
        (SendMessage.wIdent = CM_HEAVYHIT) or
        (SendMessage.wIdent = CM_BIGHIT) or
        (SendMessage.wIdent = CM_POWERHIT) or
        (SendMessage.wIdent = CM_LONGHIT) or
        (SendMessage.wIdent = CM_WIDEHIT) or
        (SendMessage.wIdent = CM_CRSHIT) or
        (SendMessage.wIdent = CM_DAILY) or //逐日剑法 20080511
        (SendMessage.wIdent = CM_FIREHIT){烈火} or
        (SendMessage.wIdent = CM_4FIREHIT){4级烈火 20080112} then begin
        m_MsgList.Delete(I);
        if SendMessage.Buff <> nil then FreeMem(SendMessage.Buff);
        Dispose(SendMessage);
        Continue;
      end;
      Inc(I);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg);
end;

function TBaseObject.MessageCount(): Integer;
begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    Result := m_MsgList.Count;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TBaseObject.GetMessage(Msg: pTProcessMessage): Boolean;
var
  I: Integer;
  SendMessage: pTSendMessage;
  nCode: Byte;
begin
  Result := False;
  nCode:= 0;
  if (self = nil) or (Msg = nil) then Exit;//20080801  20080810
try
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    I := 0;
    Msg.wIdent := 0;
    nCode:= 1;
    if m_MsgList <> nil then begin//20080912 增加
      while m_MsgList.Count > I do begin
        if m_MsgList.Count <= I then Break;//20080720 增加
        nCode:= 2;
        if m_MsgList.Items[I] = nil then begin//20080803 增加
          m_MsgList.Delete(I);
          Continue;
        end;
        nCode:= 21;
        SendMessage := m_MsgList.Items[I];
        nCode:= 3;
        if (SendMessage.dwDeliveryTime <> 0) and (GetTickCount < SendMessage.dwDeliveryTime) then begin
          Inc(I);
          Continue;
        end;
        nCode:= 5;
        m_MsgList.Delete(I);
        nCode:= 6;
        Msg.wIdent := SendMessage.wIdent;
        nCode:= 7;
        Msg.wParam := SendMessage.wParam;
        nCode:= 8;
        Msg.nParam1 := SendMessage.nParam1;
        nCode:= 9;
        Msg.nParam2 := SendMessage.nParam2;
        nCode:= 10;
        Msg.nParam3 := SendMessage.nParam3;
        nCode:= 11;
        Msg.BaseObject := SendMessage.BaseObject;
        nCode:= 12;
        Msg.dwDeliveryTime := SendMessage.dwDeliveryTime;
        nCode:= 13;
        Msg.boLateDelivery := SendMessage.boLateDelivery;
        nCode:= 14;
        if SendMessage.Buff <> nil then begin
          nCode:= 15;
          if Msg <> nil then//20080810 增加
            Msg.sMsg := StrPas(SendMessage.Buff);
          nCode:= 16;
          FreeMem(SendMessage.Buff);
        end else begin
          nCode:= 17;
          if Msg <> nil then//20080810 增加
            Msg.sMsg := '';
        end;
        nCode:= 18;
        if SendMessage <> nil then Dispose(SendMessage);//20080908 修改
        nCode:= 19;
        Result := True;
        Break;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  except
    MainOutMessage('{异常} TBaseObject.GetMessage Code:'+inttostr(nCode));
  end;
end;
//检查同个方向内一定范围里的怪(龙影)  20080405
function TBaseObject.GetDirectionBaseObjects_42(btDir, nRage: Integer; rList: TList): Boolean;
var
  I, III: Integer;
  X, Y: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::GetDirectionBaseObjects_42';
begin
  Result := False;
  if rList = nil then Exit;
  try
    case btDir of
      DR_UP: begin //北--OK
          for y := m_nCurrY downto m_nCurrY - nRage do begin
           for X:= m_nCurrX -1 to m_nCurrX + 1 do begin
            if m_PEnvir.GetMapCellInfo( X, Y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      rList.Add(BaseObject);
                    end;
                  end;
                end;//for
              end;
            end;
           end;//X
          end;//Y
        end;
      DR_UPRIGHT: begin//东北--OK
          for I := 0 to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY - I;
            for X := X -1 to X + 1 do begin
             for Y := Y -1 to Y + 1 do begin
              if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                if MapCellInfo.ObjList.Count > 0 then begin//20080629
                  for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                    OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                    if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        rList.Add(BaseObject);
                      end;
                    end;
                  end;//for
                end;
              end;
             end;//Y 
            end;//X
          end;
        end;
      DR_RIGHT: begin//东--OK
          for X := m_nCurrX to m_nCurrX + nRage do begin
           for Y:= m_nCurrY -1 to m_nCurrY + 1 do begin
            if m_PEnvir.GetMapCellInfo(X, Y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      rList.Add(BaseObject);
                    end;
                  end;
                end;//for
              end;
            end;
           end;//Y
          end;//X
        end;
      DR_DOWNRIGHT: begin//东南
          for I := 0 to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY + I;
            for X := X -1 to X + 1 do begin
             for Y := Y -1 to Y + 1 do begin
              if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                if MapCellInfo.ObjList.Count > 0 then begin//20080629
                  for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                    OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                    if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        rList.Add(BaseObject);
                      end;
                    end;
                  end;//for
                end;
              end;
             end;//Y
            end;//X
          end;
        end;
      DR_DOWN: begin //南--OK
          for y := m_nCurrY to m_nCurrY + nRage do begin
           for X:= m_nCurrX -1 to m_nCurrX + 1 do begin
            if m_PEnvir.GetMapCellInfo( X, Y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                  BaseObject := TBaseObject(OSObject.CellObj);
                  if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                    rList.Add(BaseObject);
                  end;
                end;
              end;
            end;
           end;//X
          end;//Y
        end;
      DR_DOWNLEFT: begin//西南向--OK
          for I := 0 to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY + I;
            for X := X -1 to X +1 do begin
             for Y := Y -1 to Y +1 do begin
              if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                if MapCellInfo.ObjList.Count > 0 then begin//20080629
                  for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                    OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                    if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        rList.Add(BaseObject);
                      end;
                    end;
                  end;//for
                end;
              end;
             end;//Y
            end;//X
          end;
        end;
      DR_LEFT: begin//西--OK
          for X := m_nCurrX downto m_nCurrX - nRage do begin
           for Y := m_nCurrY -1 to m_nCurrY + 1 do begin
            if m_PEnvir.GetMapCellInfo(X, Y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      rList.Add(BaseObject);
                    end;
                  end;
                end;//for
              end;
            end;
           end;//Y
          end;//X
        end;
      DR_UPLEFT: begin//西北
          for I := 0 to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY - I;
            for X := X -1 to X + 1 do begin
             for Y := Y -1 to Y + 1 do begin
              if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                if MapCellInfo.ObjList.Count > 0 then begin//20080629
                  for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                    OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                    if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        rList.Add(BaseObject);
                      end;
                    end;
                  end;//for
                end;
              end;
             end;//Y
            end;//X  
          end;
        end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
  Result := True;
end;

//取同方向的怪数 疾光电影使用判断怪的数量 20080421
function TBaseObject.GetDirBaseObjectsCount(btDir, nRage: Integer): Integer;
var
  I, III: Integer;
  X, Y: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::GetDirectionBaseObjects';
begin
  Result := 0;
  try
    case btDir of
      DR_UP: begin //北
          for y := m_nCurrY downto m_nCurrY - nRage{m_nCurrY to m_nCurrY + nRage} do begin //20080405
            if m_PEnvir.GetMapCellInfo(m_nCurrX , y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_UPRIGHT: begin//东北
          for I := 0 to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY -{+} I;//20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_RIGHT: begin//东
          for x := m_nCurrX to m_nCurrX + nRage do begin
            if m_PEnvir.GetMapCellInfo(x, m_nCurrY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_DOWNRIGHT: begin//东南
          for I := 0 to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY +{-} I;//20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_DOWN: begin //南
          for y := m_nCurrY to m_nCurrY + nRage{m_nCurrY downto m_nCurrY - nRage} do begin//20080405
            if m_PEnvir.GetMapCellInfo(m_nCurrX, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_DOWNLEFT: begin//西南向
          for I := 0 to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY +{-} I;//20080405
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_LEFT: begin//西
          for x := m_nCurrX downto m_nCurrX - nRage do begin
            if m_PEnvir.GetMapCellInfo(x, m_nCurrY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_UPLEFT: begin//西北
          for I := 0 to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY {+}- I;//20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

//检查同个方向内一定范围里的怪
function TBaseObject.GetDirectionBaseObjects(btDir, nRage: Integer; rList: TList): Boolean;
var
  I, III: Integer;
  X, Y: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::GetDirectionBaseObjects';
begin
  Result := False;
  if rList = nil then Exit;
  try
    case btDir of
      DR_UP: begin //北
          for y := m_nCurrY -1  downto m_nCurrY - nRage do begin //20080405
            if m_PEnvir.GetMapCellInfo(m_nCurrX , Y , MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      rList.Add(BaseObject);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_UPRIGHT: begin//东北
          for I := 1{0} to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY - I;//20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if  MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      rList.Add(BaseObject);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_RIGHT: begin//东
          for x := m_nCurrX+1  to m_nCurrX + nRage do begin
            if m_PEnvir.GetMapCellInfo(x , m_nCurrY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      rList.Add(BaseObject);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_DOWNRIGHT: begin//东南
          for I := 1{0} to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY + I;//20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      rList.Add(BaseObject);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_DOWN: begin //南
          for y := m_nCurrY+1 to m_nCurrY + nRage do begin//20080405
            if m_PEnvir.GetMapCellInfo(m_nCurrX, y , MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      rList.Add(BaseObject);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_DOWNLEFT: begin//西南向
          for I := 1{0} to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY + I;//20080405
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      rList.Add(BaseObject);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_LEFT: begin//西
          for x := m_nCurrX-1 downto m_nCurrX - nRage do begin
            if m_PEnvir.GetMapCellInfo(x , m_nCurrY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      rList.Add(BaseObject);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_UPLEFT: begin//西北
          for I := 1{0} to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY - I;//20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      rList.Add(BaseObject);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
  Result := True;
end;

//取地图坐标范围内的怪
function TBaseObject.GetMapBaseObjects(tEnvir: TEnvirnoment; nX, nY, nRage: Integer; rList: TList): Boolean; //004B8D2C
var
  III: Integer;
  x, y: Integer;
  nStartX, nStartY, nEndX, nEndY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::GetMapBaseObjects';
begin
  Result := False;
  if rList = nil then Exit;
  try
    nStartX := nX - nRage;
    nEndX := nX + nRage;
    nStartY := nY - nRage;
    nEndY := nY + nRage;
    for x := nStartX to nEndX do begin
      for y := nStartY to nEndY do begin
        if tEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
          if MapCellInfo.ObjList.Count > 0 then begin//20080629
            for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
              OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
              if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                BaseObject := TBaseObject(OSObject.CellObj);
                if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                  rList.Add(BaseObject);
                end;
              end;
            end;//for
          end;
        end;
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
  Result := True;
end;

procedure TBaseObject.SendRefMsg(wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: string);
var
  II, nC: Integer;
  nCX, nCY, nLX, nLY, nHX, nHY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  btType: Byte;
  nCode: Byte;
  boIsClear: Boolean;//20080915
resourcestring
  sExceptionMsg = '{异常} TBaseObject::SendRefMsg Name:%s Code:%d';
begin
  nCode:=0;
  boIsClear:= False;//20080915
  try
    //if (m_btRaceServer = RC_PLAYOBJECT) and (TPlayObject(Self).m_boNotOnlineAddExp) then Exit; //10-28 修改 离线挂机人物不刷新
    if (m_PEnvir = nil) then Exit;
    nCode:=1;
    //if m_boObMode or m_boFixedHideMode then exit;
    //01/21 增加，原来直接不发信息，如果隐身模式则只发送信息给自己
    if m_boObMode or m_boFixedHideMode then begin
      nCode:=2;
      SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
      Exit;
    end;
    nCode:=3;
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_VisibleHumanList <> nil then begin
      if m_VisibleHumanList.Count = 0 then boIsClear:= True;//20080915
    end;
    nCode:=4;
    try
      if ((GetTickCount - m_SendRefMsgTick) >= 500) or boIsClear{(m_VisibleHumanList.Count = 0)} then begin
        m_SendRefMsgTick := GetTickCount();
        nCode:=5;
        try
          m_VisibleHumanList.Clear;//20080819 修改
        except
        end;
        nCode:=6;
        nLX := m_nCurrX - g_Config.nSendRefMsgRange {12};
        nHX := m_nCurrX + g_Config.nSendRefMsgRange {12};
        nLY := m_nCurrY - g_Config.nSendRefMsgRange {12};
        nHY := m_nCurrY + g_Config.nSendRefMsgRange {12};
        nCode:=7;
        for nCX := nLX to nHX do begin
          for nCY := nLY to nHY do begin
            nCode:=8;
            if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) then begin
              nCode:=9;
              if MapCellInfo <> nil then begin
                if (MapCellInfo.ObjList <> nil) then begin//20080903 增加
                  if MapCellInfo.ObjList.Count > 0 then begin//20080525 增加
                    nCode:= 200;
                    for II := MapCellInfo.ObjList.Count - 1 downto 0 do begin
                      nCode:= 201;
                      if MapCellInfo.ObjList.Count <= 0 then Break;//20080803 增加
                      nCode:= 202;
                      OSObject := MapCellInfo.ObjList.Items[II];
                      nCode:=11;
                      if OSObject = nil then begin//传世处理代码 20080916
                        MapCellInfo.ObjList.Delete(II);
                        if MapCellInfo.ObjList.Count > 0 then Continue;
                        FreeAndNil(MapCellInfo.ObjList);
                        break;
                      end;
                      if OSObject <> nil then begin
                        nCode:=111;
                        try  //20080923
                          btType := OSObject.btType;
                        except
                          MapCellInfo.ObjList.Delete(II);
                          if MapCellInfo.ObjList.Count > 0 then Continue;
                          FreeAndNil(MapCellInfo.ObjList);
                          break;
                        end;

                        if {OSObject.btType}btType = OS_MOVINGOBJECT then begin //20080923 修改
                          if (GetTickCount - OSObject.dwAddTime) >= 60000{60 * 1000} then begin
                            nCode:=12;
                            if MapCellInfo.ObjList <> nil then MapCellInfo.ObjList.Delete(II);//20080910 修改
                            DisPoseAndNil(OSObject);
                            nCode:=121;
                            if MapCellInfo.ObjList.Count <= 0 then begin
                              FreeAndNil(MapCellInfo.ObjList);
                              Break;
                            end;
                          end else begin
                            nCode:=122;
                            try
                              BaseObject := TBaseObject(OSObject.CellObj);
                              if (BaseObject <> nil) then begin
                                nCode:=123;
                                 if (BaseObject.m_PEnvir = m_PEnvir) and (not BaseObject.m_boGhost) then begin
                                  if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                                    nCode:=124;
                                    if not TPLAYOBJECT(BaseObject).m_boNotOnlineAddExp then begin//20080717 非挂机才增加消息   
                                      nCode:=125;
                                      BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
                                      nCode:=126;
                                      if (m_VisibleHumanList <> nil) and (BaseObject <> nil) then m_VisibleHumanList.Add(BaseObject);//20081223 修改
                                      nCode:=130;
                                    end;
                                  end else
                                    if BaseObject.m_boWantRefMsg then begin
                                    nCode:=127;
                                    if (wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent = RM_DEATH) or (wIdent = RM_CHARSTATUSCHANGED) then begin //增加分身的魔法盾效果
                                      nCode:=128;
                                      BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
                                      nCode:=129;
                                      if (m_VisibleHumanList <> nil) and (BaseObject <> nil) then m_VisibleHumanList.Add(BaseObject);//20081223 修改
                                      nCode:=130;
                                    end;
                                  end;
                                end;
                              end;
                            except
                              on E: Exception do begin
                                MapCellInfo.ObjList.Delete(II);
                                if MapCellInfo.ObjList.Count <= 0 then begin
                                  FreeAndNil(MapCellInfo.ObjList);
                                end;
                                MainOutMessage(Format(sExceptionMsg, [m_sCharName, nCode]));
                              end;
                            end;
                          end;
                        end;
                      end;
                    end; //for II := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  end;//if MapCellInfo.ObjList.Count > 0 then begin//200080525 增加
                end;//if MapCellInfo.ObjList <> nil then begin
              end; //if MapCellInfo <> nil then begin
            end; //if PEnvir.GetMapCellInfo(nC,n10,MapCellInfo) then begin
          end;
        end;
      end else begin
        nCode:=13;
        if m_VisibleHumanList <> nil then begin//20081201 增加
          if m_VisibleHumanList.Count > 0 then begin//20080627 增加
            nCode:=14;
            for nC := 0 to m_VisibleHumanList.Count - 1 do begin
              nCode:=15;
              try
                BaseObject := TBaseObject(m_VisibleHumanList.Items[nC]);
              except
                //MainOutMessage(format(sExceptionMsg,[m_sCharName]));
                //MainOutMessage('Please contact thedeath and tell him you saw msg number 4');
              end;
              nCode:=151;
              if (BaseObject <> nil) then begin
                if (not BaseObject.m_boGhost) and
                   (BaseObject.m_PEnvir = m_PEnvir) and
                   (abs(BaseObject.m_nCurrX - m_nCurrX) < 11) and
                   (abs(BaseObject.m_nCurrY - m_nCurrY) < 11) then begin
                  if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                    nCode:=16;
                    if not TPLAYOBJECT(BaseObject).m_boNotOnlineAddExp then//20080717 非挂机才增加消息
                      BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
                  end else
                    if BaseObject.m_boWantRefMsg then begin
                    nCode:=17;
                    if (wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent = RM_DEATH) or (wIdent = RM_CHARSTATUSCHANGED) then begin
                      BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
                    end;
                  end; //if BaseObject.m_boWantRefMsg then begin
                end; //if (BaseObject.m_PEnvir = m_PEnvir) and
              end;//if (BaseObject <> nil) then begin
            end; //for nC:= 0 to m_VisibleHumanList.Count - 1 do begin
          end;
        end;
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('{异常} TBaseObject::SendRefMsg Code:'+Inttostr(nCode)+' Name:'+m_sCharName);
  end;
end;

procedure TBaseObject.UpdateVisibleGay(BaseObject: TBaseObject);
var
  I: Integer;
  //boIsVisible: Boolean;
  VisibleBaseObject: pTVisibleBaseObject;
begin
  //boIsVisible := False;
  if BaseObject = nil then Exit;//20081216
  if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_Master <> nil) then
    m_boIsVisibleActive := True; //如果是人物或宝宝则置TRUE
  for I := 0 to m_VisibleActors.Count - 1 do begin
    VisibleBaseObject := m_VisibleActors.Items[I];
    if VisibleBaseObject <> nil then begin
      if VisibleBaseObject.BaseObject = BaseObject then begin
        VisibleBaseObject.nVisibleFlag := 1;
        //boIsVisible := True;
        //Break;
        Exit;//20080815 增加
      end;
    end;
  end;
  //if boIsVisible then Exit;
  New(VisibleBaseObject);
  VisibleBaseObject.nVisibleFlag := 2;
  VisibleBaseObject.BaseObject := BaseObject;
  m_VisibleActors.Add(VisibleBaseObject);
end;

procedure TBaseObject.UpdateVisibleItem(wX, wY: Integer; MapItem: PTMapItem);
var
  I: Integer;
  //boIsVisible: Boolean;
  VisibleMapItem: pTVisibleMapItem;
begin
  //boIsVisible := False;
  if m_VisibleItems.Count > 0 then begin//20080629
    for I := 0 to m_VisibleItems.Count - 1 do begin
      VisibleMapItem := m_VisibleItems.Items[I];
      if VisibleMapItem <> nil then begin
        if (VisibleMapItem.MapItem <> nil) and (VisibleMapItem.MapItem = MapItem) then begin
          VisibleMapItem.nVisibleFlag := 1;
          //boIsVisible := True;
          //Break;
          Exit;//20080815 增加
        end;
      end;
    end;
  end;
  //if boIsVisible then Exit;
  New(VisibleMapItem);
  VisibleMapItem.nVisibleFlag := 2;
  VisibleMapItem.nX := wX;
  VisibleMapItem.nY := wY;
  VisibleMapItem.MapItem := MapItem;
  VisibleMapItem.sName := MapItem.Name;
  VisibleMapItem.wLooks := MapItem.Looks;
  m_VisibleItems.Add(VisibleMapItem);
end;

procedure TBaseObject.UpdateVisibleEvent(wX, wY: Integer; MapEvent: TObject);
var
  I: Integer;
  boIsVisible: Boolean;
  VisibleMapEvent: pTVisibleMapEvent;
begin
  boIsVisible := False;
  if m_VisibleEvents.Count > 0 then begin//20080629
    for I := 0 to m_VisibleEvents.Count - 1 do begin
      VisibleMapEvent := m_VisibleEvents.Items[I];
      if VisibleMapEvent <> nil then begin
        if VisibleMapEvent.MapEvent = MapEvent then begin
          VisibleMapEvent.nVisibleFlag := 1;
          boIsVisible := True;
          Break;
        end;
      end;
    end;
  end;
  if boIsVisible then Exit;
  New(VisibleMapEvent);
  VisibleMapEvent.MapEvent := MapEvent;
  VisibleMapEvent.nVisibleFlag := 2;
  VisibleMapEvent.nX := wX;
  VisibleMapEvent.nY := wY;
  m_VisibleEvents.Add(VisibleMapEvent);
end;

{function TBaseObject.IsVisibleHuman: Boolean;//未使用 20080329
var
  I: Integer;
  VisibleBaseObject: pTVisibleBaseObject;
begin
  Result := False;
  for I := 0 to m_VisibleActors.Count - 1 do begin
    VisibleBaseObject := m_VisibleActors.Items[I];
    if VisibleBaseObject <> nil then begin
      if (TBaseObject(VisibleBaseObject.BaseObject).m_btRaceServer = RC_PLAYOBJECT) or (TBaseObject(VisibleBaseObject.BaseObject).m_Master <> nil) then begin
        Result := True;
        Break;
      end;
    end;
  end;
end; }
//搜索查看范围
procedure TBaseObject.SearchViewRange;
var
  I: Integer;
  nStartX: Integer;
  nEndX: Integer;
  nStartY: Integer;
  nEndY: Integer;
  n18: Integer;
  n1C: Integer;
  nIdx: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  MapItem: PTMapItem;
  MapEvent: TEvent;
  VisibleBaseObject: pTVisibleBaseObject;
  VisibleMapItem: pTVisibleMapItem;
  nCheckCode: Byte;
  btType: Byte;
  nVisibleFlag: Integer;
begin
  //if m_btRaceServer = RC_PLAYOBJECT then Exit;
  if self = nil then Exit;//20080803 增加
  if m_PEnvir = nil then begin
    MainOutMessage('SearchViewRange nil PEnvir Name:'+ m_sCharName);
    KickException();//20081226 地图不存在，则踢出角色
    Exit;
  end;
  nCheckCode := 1;
  m_boIsVisibleActive := False; //先置为FALSE
  try
    if m_VisibleItems.Count > 0 then begin//20080629
      for I := 0 to m_VisibleItems.Count - 1 do begin
        //pTVisibleMapItem(m_VisibleItems.Items[I]).nVisibleFlag := 0;
        VisibleMapItem:= pTVisibleMapItem(m_VisibleItems.Items[I]);//20080526 增加
        if VisibleMapItem <> nil then VisibleMapItem.nVisibleFlag := 0;//20080526 增加
      end;
    end;
  except
    MainOutMessage(Format('{异常} TBaseObject::SearchViewRange Code:%d', [nCheckCode]));
    KickException();
  end;
  nCheckCode := 2;
  try
    if m_VisibleActors.Count > 0 then begin//20080629
      for I := 0 to m_VisibleActors.Count - 1 do begin
        //pTVisibleBaseObject(m_VisibleActors.Items[I]).nVisibleFlag := 0;
        VisibleBaseObject:= pTVisibleBaseObject(m_VisibleActors.Items[I]); //20080526 增加
        if VisibleBaseObject <> nil then VisibleBaseObject.nVisibleFlag := 0;//20080526 增加
      end;
    end;
  except
    MainOutMessage(Format('{异常} TBaseObject::SearchViewRange Code:%d', [nCheckCode]));
    KickException();
  end;
  nStartX := m_nCurrX - m_nViewRange;
  nEndX := m_nCurrX + m_nViewRange;
  nStartY := m_nCurrY - m_nViewRange;
  nEndY := m_nCurrY + m_nViewRange;
  try
    nCheckCode := 3;
    for n18 := nStartX to nEndX do begin
      for n1C := nStartY to nEndY do begin
        nCheckCode := 4;
        if m_PEnvir.GetMapCellInfo(n18, n1C, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
          nCheckCode := 5;
          nIdx := 0;
          while (True) do begin
            if MapCellInfo.ObjList.Count <= nIdx then Break;
            OSObject := MapCellInfo.ObjList.Items[nIdx];
            nCheckCode := 51;
            if OSObject = nil then begin//处理异常 传奇代码 20080916
              MapCellInfo.ObjList.Delete(nIdx);
              nCheckCode := 52;
              if MapCellInfo.ObjList.Count > 0 then Continue;
              nCheckCode := 53;
              FreeAndNil(MapCellInfo.ObjList);
              break;
            end;
            if OSObject <> nil then begin
              nCheckCode := 61; //20081017
              try
                btType := OSObject.btType; //2006-10-14 防止内存出错
              except
                nCheckCode := 62;
                MapCellInfo.ObjList.Delete(nIdx); //20080916
                if MapCellInfo.ObjList.Count > 0 then Continue;
                nCheckCode := 63;
                FreeAndNil(MapCellInfo.ObjList);
                break;
              end;
              nCheckCode := 6;
              if {OSObject.btType}btType = OS_MOVINGOBJECT then begin//20081017 修改
                if (GetTickCount - OSObject.dwAddTime) >= 60000{60 * 1000} then begin
                  nCheckCode := 7;
                  MapCellInfo.ObjList.Delete(nIdx);//20080916 修改
                  DisPoseAndNil(OSObject);
                  if MapCellInfo.ObjList.Count > 0 then Continue;//20080916 修改
                  FreeAndNil(MapCellInfo.ObjList);
                  Break;
                end;
                nCheckCode := 8;
                BaseObject := TBaseObject(OSObject.CellObj);
                if BaseObject <> nil then begin
                  if (not BaseObject.m_boGhost) and (not BaseObject.m_boFixedHideMode) and (not BaseObject.m_boObMode) then begin
                    if (m_btRaceServer < RC_ANIMAL) or (m_Master <> nil) or m_boCrazyMode or m_boWantRefMsg or
                      ((BaseObject.m_Master <> nil) and (abs(BaseObject.m_nCurrX - m_nCurrX) <= {3}6) and (abs(BaseObject.m_nCurrY - m_nCurrY) <=  {3}6)) or//20080815 由3格变6格(修正,赤月恶魔3格后,就不能攻击英雄)
                      (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
                      nCheckCode := 9;
                      UpdateVisibleGay(BaseObject);
                    end;
                  end;
                end;
              end; //if OSObject.btType = OS_MOVINGOBJECT then begin

              //增加分身人搜索地面物品  20080707 注释
              nCheckCode := 10;
              if ((m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT)) and (m_Master <> nil) and (m_nCopyHumanLevel > 0) then begin //20080729 修改
                if (OSObject <> nil) and (OSObject.btType = OS_ITEMOBJECT) then begin
                  nCheckCode := 11;
                  if (GetTickCount - OSObject.dwAddTime) > g_Config.dwClearDropOnFloorItemTime {60 * 60 * 1000} then begin
                    if PTMapItem(OSObject.CellObj) <> nil then DisPoseAndNil(PTMapItem(OSObject.CellObj)); //防止占用内存不释放现象 20080702 修改
                    DisPoseAndNil(OSObject);
                    MapCellInfo.ObjList.Delete(nIdx);
                    if MapCellInfo.ObjList.Count > 0 then Continue;//20080916 增加
                    FreeAndNil(MapCellInfo.ObjList);
                    Break;
                  end;
                  MapItem := PTMapItem(OSObject.CellObj);
                  nCheckCode := 12;
                  UpdateVisibleItem(n18, n1C, MapItem);
                  nCheckCode := 13;
                  if (MapItem.OfBaseObject <> nil) or (MapItem.DropBaseObject <> nil) then begin
                    if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then begin
                      MapItem.OfBaseObject := nil;
                      MapItem.DropBaseObject := nil;
                    end else begin
                      nCheckCode := 14;
                      if TBaseObject(MapItem.OfBaseObject) <> nil then begin
                        if TBaseObject(MapItem.OfBaseObject).m_boGhost then MapItem.OfBaseObject := nil;
                      end;
                      if TBaseObject(MapItem.DropBaseObject) <> nil then begin
                        if TBaseObject(MapItem.DropBaseObject).m_boGhost then MapItem.DropBaseObject := nil;
                      end;
                    end;
                  end;
                end; //if OSObject.btType = OS_ITEMOBJECT then begin
              end;//增加分身人搜索地面物品
            end;
            Inc(nIdx);
          end;
        end;
      end;
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format('{异常} TBaseObject::SearchViewRange %s %s %d %d %d', [m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      KickException();
    end;
  end;

  try
   nCheckCode := 15;
   n18 := 0;
    while (True) do begin
      if m_VisibleItems.Count <= n18 then Break;
      nCheckCode := 16;
      VisibleMapItem := m_VisibleItems.Items[n18];
      nCheckCode := 17;
      if VisibleMapItem = nil then begin//20080526 增加
        m_VisibleItems.Delete(n18);//20080901
        Continue;
      end;
      
      try //20080901
        nCheckCode := 18;
        nVisibleFlag := VisibleMapItem.nVisibleFlag;
      except
        m_VisibleItems.Delete(n18);
        Continue;
      end;

      if {VisibleMapItem.nVisibleFlag}nVisibleFlag = 0 then begin//20080901 修改
        nCheckCode := 19;
        m_VisibleItems.Delete(n18);
        nCheckCode := 20;
        DisPoseAndNil(VisibleMapItem);
        Continue;
      end;
      Inc(n18);
    end;

    nCheckCode := 21;
    n18 := 0;
    while (True) do begin
      if m_VisibleActors.Count <= n18 then Break;
      nCheckCode := 22;
      VisibleBaseObject := m_VisibleActors.Items[n18];
      nCheckCode := 23;
      if VisibleBaseObject = nil then begin //20080526 增加
        m_VisibleActors.Delete(n18);//20080901
        Continue;
      end;

      try   //20080901
        nCheckCode := 24;
        nVisibleFlag := VisibleBaseObject.nVisibleFlag;
      except
        m_VisibleActors.Delete(n18);
        Continue;
      end;

      if {VisibleBaseObject.nVisibleFlag}nVisibleFlag = 0 then begin//20080901 修改
        nCheckCode := 25;
        m_VisibleActors.Delete(n18);
        nCheckCode := 26;
        DisPoseAndNil(VisibleBaseObject);
        Continue;
      end;
      Inc(n18);
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format('{异常} TBaseObject::SearchViewRange %s %s %d %d %d', [m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      KickException();
    end;
  end;
end;

function TBaseObject.GetFeatureToLong: Integer;
begin
  Result := GetFeature(nil);
end;
//取着装效果
function TBaseObject.GetFeatureEx(): Word;
begin
  if m_boOnHorse then begin//骑马
    Result := MakeWord(m_btHorseType, m_btDressEffType);
  end else begin
    Result := MakeWord(0, m_btDressEffType);
  end;
end;
//取外观
function TBaseObject.GetFeature(BaseObject: TBaseObject): Integer;
var
  nDress, nWeapon, nHair, nRaceImg, nAppr: Integer;
  StdItem: pTStdItem;
  bo25: Boolean;
begin
  {if Assigned(zPlugOfEngine.GetFeature) then begin //20080813 注释
    Result := zPlugOfEngine.GetFeature(Self, BaseObject);
  end else begin }
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin
      nDress := 0;
      //衣服
      if m_UseItems[U_DRESS].wIndex > 0 then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_DRESS].wIndex);
        if StdItem <> nil then begin
          nDress := StdItem.Shape * 2;
        end;
      end;
      Inc(nDress, m_btGender);
      nWeapon := 0;
      //武器
      if m_UseItems[U_WEAPON].wIndex > 0 then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
        if StdItem <> nil then begin
          nWeapon := StdItem.Shape * 2;
        end;
      end;
      Inc(nWeapon, m_btGender);
      
      //斗笠 20080417
      if m_UseItems[U_ZHULI].wIndex > 0 then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_ZHULI].wIndex);
        if StdItem <> nil then begin
          case StdItem.Shape of
            0:nHair := High(Byte);//普通斗笠
            1:nHair := 254;//金斗笠 20080807
          end;
        end else nHair := m_btHair * 2 + m_btGender;
      end else nHair := m_btHair * 2 + m_btGender;
      if m_btRaceServer = RC_PLAYOBJECT then Result := MakeHumanFeature(RC_PLAYOBJECT, nDress, nWeapon, nHair);
      if m_btRaceServer = RC_PLAYMOSTER then Result := MakeHumanFeature(RC_PLAYMOSTER, nDress, nWeapon, nHair);
      if m_btRaceServer = RC_HEROOBJECT then Result := MakeHumanFeature(1, nDress, nWeapon, nHair);
      Exit;
    end;
    bo25 := False;
    if (BaseObject <> nil) and (BaseObject.bo245) then bo25 := True;
    if bo25 then begin
      nRaceImg := m_btRaceImg;
      nAppr := m_wAppr;
      case nAppr of
        0: begin
            nRaceImg := 12;
            nAppr := 5;
          end;
        1: begin
            nRaceImg := 11;
            nAppr := 9;
          end;
        160: begin
            nRaceImg := 10;
            nAppr := 0;
          end;
        161: begin
            nRaceImg := 10;
            nAppr := 1;
          end;
        162: begin
            nRaceImg := 11;
            nAppr := 6;
          end;
        163: begin
            nRaceImg := 11;
            nAppr := 3;
          end;
      end;//case
      Result := MakeMonsterFeature(nRaceImg, m_btMonsterWeapon, nAppr);
      Exit;
    end;
    Result := MakeMonsterFeature(m_btRaceImg, m_btMonsterWeapon, m_wAppr);
  //end;//20080813 注释
end;
//取当前状态值
function TBaseObject.GetCharStatus(): Integer;
var
  I: Integer;
  nStatus: Integer;
begin
  nStatus := 0;
  for I := Low(TStatusTime) to High(TStatusTime) do begin
    if m_wStatusTimeArr[I] > 0 then begin
      nStatus := ($80000000 shr I) or nStatus;
(* $80000000 指十六进制值，转成二进制则为10000000000000000000000000000000  然后Shr右移
   例：I为3,右移3位，得到二进制值：10000000000000000000000000000
   or 代表运算, 需要两个运算数，即两个数的位运算，只有其中一个是1就返回1; 都是0才返回0
   从上面算法得到，最终 nStatus得到是1,*)
    end;
  end;
  Result := (m_nCharStatusEx and $FFFFF) or nStatus; //and or 都为二进制的位运算
end;

procedure TBaseObject.AbilCopyToWAbil;
begin
  m_WAbil := m_Abil;
end;
//始化化魔法
procedure TBaseObject.Initialize;
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  AbilCopyToWAbil();
  if (m_btRaceServer = RC_PLAYOBJECT) then begin
    if m_MagicList.Count > 0 then begin//20080629
      for I := 0 to m_MagicList.Count - 1 do begin
        UserMagic := m_MagicList.Items[I];
        if (UserMagic.btLevel > 3) and (UserMagic.wMagIdx <> 66) and (UserMagic.wMagIdx <> 68) then UserMagic.btLevel := 0;//除4级魔法盾外 20080624
      end;
    end;
  end else
  if (m_btRaceServer = RC_PLAYMOSTER) then begin //20080417 英雄分身可以有4级技能
    if m_MagicList.Count > 0 then begin//20080629
      for I := 0 to m_MagicList.Count - 1 do begin
        UserMagic := m_MagicList.Items[I];
        if (m_Master <> nil) and (m_Master.m_btRaceServer = RC_HEROOBJECT) then
           if UserMagic.btLevel > 4 then UserMagic.btLevel := 0
        else
           if UserMagic.btLevel > 3 then UserMagic.btLevel := 0;
      end;//for
    end;
  end else
  if (m_btRaceServer = RC_HEROOBJECT) then begin //20080320 英雄可以有4级技能
    if m_MagicList.Count > 0 then begin//20080629
      for I := 0 to m_MagicList.Count - 1 do begin
        UserMagic := m_MagicList.Items[I];
        if (UserMagic.btLevel > 4) and (UserMagic.wMagIdx <> 68) then UserMagic.btLevel := 0;//除酒气护体外 20080625
      end;
    end;
  end;
  m_boAddtoMapSuccess := True;
  if m_PEnvir.CanWalk(m_nCurrX, m_nCurrY, True) and AddToMap() then m_boAddtoMapSuccess := False;
  m_nCharStatus := GetCharStatus();
  AddBodyLuck(0);
  LoadSayMsg();
  if g_Config.boMonSayMsg then MonsterSayMsg(nil, s_MonGen);
end;
//==============================
//取得怪物说话信息列表
procedure TBaseObject.LoadSayMsg();
var
  I: Integer;
begin
  if g_MonSayMsgList.Count > 0 then begin//20080629
    for I := 0 to g_MonSayMsgList.Count - 1 do begin
      if CompareText(g_MonSayMsgList.Strings[I], m_sCharName) = 0 then begin
        m_SayMsgList := TList(g_MonSayMsgList.Objects[I]);
        Break;
      end;
    end;
  end;
end;

procedure TBaseObject.Disappear();
begin

end;
//着装效果改变
procedure TBaseObject.FeatureChanged;
begin
  SendRefMsg(RM_FEATURECHANGED, GetFeatureEx, GetFeatureToLong, 0, 0, '');
end;
//状态改变 20080811 修改
procedure TBaseObject.StatusChanged(Str: String);
begin
  SendRefMsg(RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0, 0, Str);
end;

procedure TBaseObject.DisappearA();
var
  FlowerEvent: TFlowerEvent;
begin
  if (m_btRaceServer = RC_HEROOBJECT) and (m_Master <> nil) then begin //20080403 英雄尸体消失后,左上角英雄窗口才消失
    if (not TPlayObject(m_Master).m_boReconnection) and (not TPlayObject(m_Master).m_boSoftClose) and (not THeroObject(self).boCallLogOut) then begin//20080425 主人不是小退时才显示动画
      TPlayObject(m_Master).m_nRecallHeroTime:= GetTickCount();//召唤英雄间隔 20080606
      FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, SM_HEROLOGOUT, 3000); //英雄退出动画显示
      g_EventManager.AddEvent(FlowerEvent);
    end;
    m_Master.SendMsg(m_Master, RM_HERODEATH, 0, 0, 0, 0, '');
    m_Master := nil;
  end;
  m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
end;
//踢除异常角色
procedure TBaseObject.KickException;
var
  PlayObject: TPlayObject;
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    m_sMapName := g_Config.sHomeMap;
    m_nCurrX := g_Config.nHomeX;
    m_nCurrY := g_Config.nHomeY;
    PlayObject := TPlayObject(Self);
    PlayObject.m_boEmergencyClose := True;
    PlayObject.m_boNotOnlineAddExp := False;
    PlayObject.m_boPlayOffLine := False; //关闭下线触发
  end else begin
    m_boDeath := True;
    m_dwDeathTick := GetTickCount;
    MakeGhost;
  end;
end;

function TBaseObject.Walk(nIdent: Integer): Boolean;
var
  I: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  GateObj: pTGateObj;
  bo1D: Boolean;
  Event: TEvent;
  PlayObject: TPlayObject;
  nCheckCode: Integer;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::Walk  CheckCode:%d %s %s %d:%d';
begin
  Result := True;
  nCheckCode := -1;
  if m_PEnvir = nil then begin
    MainOutMessage('Walk nil PEnvir');
    Exit;
  end;
  try
    nCheckCode := 1;
    bo1D := m_PEnvir.GetMapCellInfo(m_nCurrX, m_nCurrY, MapCellInfo);
    GateObj := nil;
    Event := nil;
    nCheckCode := 2;
    if bo1D and (MapCellInfo.ObjList <> nil) then begin
      if MapCellInfo.ObjList.Count > 0 then begin//20080629
        for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
          OSObject := MapCellInfo.ObjList.Items[I];
          if OSObject <> nil then begin
            if OSObject.btType = OS_GATEOBJECT then begin
              GateObj := pTGateObj(OSObject.CellObj);
            end;
            if OSObject.btType = OS_EVENTOBJECT then begin
              if TEvent(OSObject.CellObj).m_OwnBaseObject <> nil then
                Event := TEvent(OSObject.CellObj);
            end;
            if OSObject.btType = OS_MAPEVENT then begin

            end;
            if OSObject.btType = OS_DOOR then begin

            end;
            if OSObject.btType = OS_ROON then begin

            end;
          end;
        end;//for
      end;
    end;
    nCheckCode := 3;
    if Event <> nil then begin
      nCheckCode := 31;
      if Event.m_OwnBaseObject <> nil then begin
        nCheckCode := 32;
        if Event.m_OwnBaseObject.IsProperTarget(Self) then begin
          nCheckCode := 33;
          SendMsg(Event.m_OwnBaseObject, RM_MAGSTRUCK_MINE, 0, Event.m_nDamage, 0, 0, '');
          nCheckCode := 34;
        end;
      end;
    end;
    nCheckCode := 4;
    if Result and (GateObj <> nil) then begin
      if m_btRaceServer = RC_PLAYOBJECT then begin
        if m_PEnvir.ArroundDoorOpened(m_nCurrX, m_nCurrY) then begin
          if (not TEnvirnoment(GateObj.DEnvir).m_boNEEDHOLE) or (g_EventManager.GetEvent(m_PEnvir, m_nCurrX, m_nCurrY, ET_DIGOUTZOMBI) <> nil) then begin
            if nServerIndex = TEnvirnoment(GateObj.DEnvir).nServerIndex then begin
              if not TEnvirnoment(GateObj.DEnvir).m_boNEEDLEVELTIME then begin//进入地图不需要等级 20081228
                if not EnterAnotherMap(TEnvirnoment(GateObj.DEnvir), GateObj.nDMapX, GateObj.nDMapY) then begin
                  Result := False;
                end;
              end else begin//雪域地图 20081228
                if m_Abil.Level >= TEnvirnoment(GateObj.DEnvir).m_nNEEDLEVELPOINT then begin//等级达到时才可进入地图
                  if not EnterAnotherMap(TEnvirnoment(GateObj.DEnvir), GateObj.nDMapX, GateObj.nDMapY) then begin
                    Result := False;
                  end;
                end else begin
                  TPlayObject(Self).MoveToHome();//移动到回城点
                  SysMsg(Format(sNEEDLEVELToXYErrorMsg ,[TEnvirnoment(GateObj.DEnvir).m_nNEEDLEVELPOINT]), c_Red, t_Hint);
                end;
              end;
            end else begin
              DisappearA();
              m_bo316 := True;
              PlayObject := TPlayObject(Self);
              PlayObject.m_sSwitchMapName := TEnvirnoment(GateObj.DEnvir).sMapName;
              PlayObject.m_nSwitchMapX := GateObj.nDMapX;
              PlayObject.m_nSwitchMapY := GateObj.nDMapY;
              PlayObject.m_boSwitchData := True;
              PlayObject.m_nServerIndex := TEnvirnoment(GateObj.DEnvir).nServerIndex;
              PlayObject.m_boEmergencyClose := True;
              PlayObject.m_boReconnection := True;
              PlayObject.m_boPlayOffLine := False;
            end;
          end;
        end;
      end else Result := False;
    end else begin
      nCheckCode := 5;
      if Result then begin
        nCheckCode := 6;
        SendRefMsg(nIdent, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
      end;
    end;
  except
    //on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg, [nCheckCode, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY]));
      //MainOutMessage(E.Message);
   //end;
  end;
end;
//进入另外的地图
function TBaseObject.EnterAnotherMap(Envir: TEnvirnoment; nDMapX,
  nDMapY: Integer): Boolean;
var
  I: Integer;
  MapCellInfo: pTMapCellinfo;
  OldEnvir: TEnvirnoment;
  nOldX: Integer;
  nOldY: Integer;
  Castle: TUserCastle;
  nCode:Byte;//20080901
resourcestring
  sExceptionMsg1 = '{异常} TBaseObject::EnterAnotherMap -> MsgTargetList Clear';
  sExceptionMsg2 = '{异常} TBaseObject::EnterAnotherMap -> VisbleItems Dispose';
  sExceptionMsg3 = '{异常} TBaseObject::EnterAnotherMap -> VisbleItems Clear';
  sExceptionMsg4 = '{异常} TBaseObject::EnterAnotherMap -> VisbleEvents Clear';
  sExceptionMsg5 = '{异常} TBaseObject::EnterAnotherMap -> VisbleActors Dispose';
  sExceptionMsg6 = '{异常} TBaseObject::EnterAnotherMap -> VisbleActors Clear';
  sExceptionMsg7 = '{异常} TBaseObject::EnterAnotherMap';
begin
  {if Assigned(zPlugOfEngine.ObjectEnterAnotherMap) then begin//20080813 注释
    Result := zPlugOfEngine.ObjectEnterAnotherMap(Self, Envir, nDMapX, nDMapY);
  end else begin }
    Result := False;
    nCode:= 0;
    try
      if Envir = nil then Exit;//20081014
      if m_Abil.Level < Envir.nRequestLevel then Exit;
      nCode:= 1;
      if Envir <> nil then begin
        nCode:= 15;
        if Envir.QuestNPC <> nil then begin
          nCode:= 16; //20081223 增加 Self <> nil 
          if Self <> nil then TMerchant(Envir.QuestNPC).Click(TPlayObject(Self));
        end;
      end;
      nCode:= 2;
      if Envir.nNEEDSETONFlag >= 0 then begin
        nCode:= 3;
        if GetQuestFalgStatus(Envir.nNEEDSETONFlag) <> Envir.nNeedONOFF then Exit;
      end;
      nCode:= 4;
      if not Envir.GetMapCellInfo(nDMapX, nDMapY, MapCellInfo) then Exit;
      nCode:= 5;
      Castle := g_CastleManager.IsCastlePalaceEnvir(Envir);
      if (Castle <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin
        nCode:= 6;
        if not Castle.CheckInPalace(m_nCurrX, m_nCurrY, Self) then Exit;
      end;
      
      {if (UserCastle.m_MapPalace = Envir) and (m_btRaceServer = RC_PLAYOBJECT) then begin
        if not UserCastle.CheckInPalace(m_nCurrX,m_nCurrY,Self) then exit;
      end;}
      
      OldEnvir := m_PEnvir;
      nOldX := m_nCurrX;
      nOldY := m_nCurrY;
      nCode:= 7;
      DisappearA();
      nCode:= 8;
      try
        m_VisibleHumanList.Clear;
      except
        MainOutMessage(sExceptionMsg1);
      end;
      try
        if m_VisibleItems.Count > 0 then begin//20080629
          for I := 0 to m_VisibleItems.Count - 1 do begin
            if pTVisibleMapItem(m_VisibleItems.Items[I]) <> nil then
               Dispose(pTVisibleMapItem(m_VisibleItems.Items[I]));
          end;
        end;
      except
        MainOutMessage(sExceptionMsg2);
      end;
      try
        m_VisibleItems.Clear;
      except
        MainOutMessage(sExceptionMsg3);
      end;

      try
        if m_VisibleEvents.Count > 0 then begin//20080629
          for I := 0 to m_VisibleEvents.Count - 1 do begin
            if pTVisibleMapEvent(m_VisibleEvents.Items[I]) <> nil then
               Dispose(pTVisibleMapEvent(m_VisibleEvents.Items[I]));
          end;
        end;
        m_VisibleEvents.Clear;
      except
        MainOutMessage(sExceptionMsg4);
      end;
      try
        if m_VisibleActors.Count > 0 then begin//20080629
          for I := 0 to m_VisibleActors.Count - 1 do begin
            if pTVisibleBaseObject(m_VisibleActors.Items[I]) <> nil then
               Dispose(pTVisibleBaseObject(m_VisibleActors.Items[I]));
          end;
        end;
      except
        MainOutMessage(sExceptionMsg5);
      end;
      try
        m_VisibleActors.Clear;
      except
        MainOutMessage(sExceptionMsg6);
      end;
      nCode:= 9;
      SendMsg(Self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');
      m_PEnvir := Envir;
      m_sMapName := Envir.sMapName;
      m_nCurrX := nDMapX;
      m_nCurrY := nDMapY;
      SendMsg(Self, RM_CHANGEMAP, 0, 0, 0, 0, g_MapManager.GetMainMap(Envir));
      nCode:= 10;
      if AddToMap() then begin
        m_dwMapMoveTick := GetTickCount();
        m_bo316 := True;
        Result := True;
      end else begin
        m_PEnvir := OldEnvir;
        m_nCurrX := nOldX;
        m_nCurrY := nOldY;
        nCode:= 11;
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
      end;
      nCode:= 12;
      if m_btRaceServer = RC_PLAYOBJECT then begin //复位泡点，及金币，时间
        nCode:= 13;
        TPlayObject(Self).m_dwIncGamePointTick := GetTickCount();
        TPlayObject(Self).m_dwIncGameGoldTick := GetTickCount();
        TPlayObject(Self).m_dwAutoGetExpTick := GetTickCount();
      end;
      nCode:= 14;
      if m_PEnvir.m_boFight3Zone and (m_PEnvir.m_boFight3Zone <> OldEnvir.m_boFight3Zone) then
        RefShowName();
    except
      MainOutMessage(sExceptionMsg7+'  Code:'+inttostr(nCode));
    end;
  //end;//20080813 注释
end;

procedure TBaseObject.TurnTo(nDir: Integer);
begin
  m_btDirection := nDir;
  SendRefMsg(RM_TURN, nDir, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TBaseObject.ProcessSayMsg(sMsg: string);
var
  sCharName: string;
begin
  if m_btRaceServer = RC_PLAYOBJECT then Exit; //修改
  sCharName := FilterShowName(m_sCharName);
  SendRefMsg(RM_HEAR, 0, g_Config.btHearMsgFColor, g_Config.btHearMsgBColor, 0, sCharName + ':' + sMsg);
end;

//加强版文件信息发送函数(供NPC命令-SendMsg使用) 20081214
procedure TBaseObject.ProcessSayMsg1(sMsg: string; FColor, BColor: Byte);
var
  sCharName: string;
begin
  if m_btRaceServer = RC_PLAYOBJECT then Exit; //修改
  sCharName := FilterShowName(m_sCharName);
  SendRefMsg(RM_HEAR, 0, FColor, BColor, 0, sCharName + ':' + sMsg);
end;
//发送文件信息 20080211
procedure TBaseObject.SysMsg(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType);
var
  str,FColor,BColor,nTime:string;//20080106 特殊公告
begin
  if (m_btRaceServer = RC_PLAYOBJECT) and (TPlayObject(Self).m_boNotOnlineAddExp) then Exit; //修改离线人物不发送
  
  if g_Config.boShowPreFixMsg then begin
    case MsgType of
      t_Mon: sMsg := g_Config.sMonSayMsgpreFix + sMsg;
      t_Hint: sMsg := g_Config.sHintMsgPreFix + sMsg;
     { s_GroupMsg: sMsg:=g_Config.sGroupMsgPreFix + sMsg;
      s_GuildMsg: sMsg:=g_Config.sGuildMsgPreFix + sMsg;  }
      t_GM: sMsg := g_Config.sGMRedMsgpreFix + sMsg;
      t_System: sMsg := g_Config.sSysMsgPreFix + sMsg;
      //t_Notice: sMsg := g_Config.sLineNoticePreFix + sMsg;
      t_Cust: sMsg := g_Config.sCustMsgpreFix + sMsg;
      t_Castle: sMsg := g_Config.sCastleMsgpreFix + sMsg;
    end;
  end;
 { case MsgColor of
    c_Green: SendMsg(Self,RM_SYSMESSAGE2,0,0,0,0,sMsg);
    c_Blue: SendMsg(Self,RM_SYSMESSAGE3,0,0,0,0,sMsg);
    else SendMsg(Self,RM_SYSMESSAGE,0,0,0,0,sMsg);
  end; }

  //增加滚动公告  清清 2007.11.13 (此处处理各种特殊的公告 20080106)
  if MsgType = t_Notice then begin //如果发的是公告
    if (sMsg[1] = '[') then begin //顶部滚动公告
      sMsg:= ArrestStringEx(sMsg, '[', ']', str);
      BColor:= GetValidStrCap(str, FColor, [',']);
      if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg;//20080504 增加
      SendMsg(Self, RM_MOVEMESSAGE, 0, Str_ToInt(FColor, 255), Str_ToInt(BColor, 255), 0, sMsg);
    end else
   { if (sMsg[1] = '<') then begin //聊天框彩色公告
      sMsg:= ArrestStringEx(sMsg, '<', '>', str);
      BColor:= GetValidStrCap(str, FColor, [',']);
      if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg;//20080504 增加
    end else      }
    if (sMsg[1] = '{') then begin //屏幕居中公告
      sMsg:= ArrestStringEx(sMsg, '{', '}', str);
      str:= GetValidStrCap(str, FColor, [',']);
      str:= GetValidStrCap(str, BColor, [',']);
      str:= GetValidStrCap(str, nTime, [',']);//20081226
      if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg;//20080504 增加
      SendMsg(Self, RM_MOVEMESSAGE, 1, Str_ToInt(FColor, 255), Str_ToInt(BColor, 255), Str_ToInt(nTime ,0), sMsg);//20081226
    end else
  {  if (sMsg[1] = '(') then begin //聊天框顶部公告
      sMsg:= ArrestStringEx(sMsg, '(', ')', str);
      BColor:= GetValidStrCap(str, FColor, [',']);
      if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg;//20080504 增加
    end else     }
    begin
      case MsgColor of //控制公告的颜色 20080503
        c_Red: begin
             if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg;//20080504 增加
             SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btRedMsgFColor, g_Config.btRedMsgBColor , 0, sMsg);
           end;
        c_Green: begin
            if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg;//20080504 增加
            SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btGreenMsgFColor, g_Config.btGreenMsgBColor, 0, sMsg);
           end;
        c_Blue: begin
            if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg;//20080504 增加
            SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btBlueMsgFColor, g_Config.btBlueMsgBColor, 0, sMsg);
           end;
      end;
    end;
  end else begin
    case MsgColor of
      c_Green: SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btGreenMsgFColor, g_Config.btGreenMsgBColor, 0, sMsg);
      c_Blue: SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btBlueMsgFColor, g_Config.btBlueMsgBColor, 0, sMsg);
      c_Fuchsia: SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btSayMsgFColor , g_Config.btSayeMsgBColor , 0, sMsg);//千里传音颜色 20080309
      BB_Fuchsia: SendMsg(Self, RM_SYSMESSAGE, 0, 241, 255, 0, sMsg);//宝宝提示颜色 20080328
      C_HeroHint: SendMsg(Self, RM_SYSMESSAGE, 0, 255, 252, 0, sMsg);//英雄状态提示(兰底白字) 20080329
      else begin
        if MsgType = t_Cust then begin //祝福语
         SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btCustMsgFColor, g_Config.btCustMsgBColor, 0, sMsg);
        end else begin
         SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btRedMsgFColor, g_Config.btRedMsgBColor, 0, sMsg);
        end;
      end;
    end;
  end;
end;
//加强版文件信息发送函数(供NPC命令-SendMsg使用) 20081214
procedure TBaseObject.SysMsg1(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType; FColor, BColor: Byte);
begin
  if (m_btRaceServer = RC_PLAYOBJECT) and (TPlayObject(Self).m_boNotOnlineAddExp) then Exit; //修改离线人物不发送
  
  if g_Config.boShowPreFixMsg then begin
    case MsgType of
      t_System: sMsg := g_Config.sSysMsgPreFix + sMsg;
    end;
  end;

  case MsgColor of
    c_Green: SendMsg(Self, RM_SYSMESSAGE, 0, FColor, BColor, 0, sMsg);
    c_Blue: SendMsg(Self, RM_SYSMESSAGE, 0, FColor, BColor, 0, sMsg);
    else SendMsg(Self, RM_SYSMESSAGE, 0, FColor, BColor, 0, sMsg);
  end;
end;

procedure TBaseObject.MonsterSayMsg(AttackBaseObject: TBaseObject; MonStatus: TMonStatus);
var
  I: Integer;
//  nMsgColor: Integer;
  sMsg: string;
  MonSayMsg: pTMonSayMsg;
  sAttackName: string;
begin
  if m_SayMsgList = nil then Exit;
  if (AttackBaseObject <> nil) then begin
    if (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT) and (AttackBaseObject.m_Master = nil) then begin
      Exit;
    end;
    if AttackBaseObject.m_Master <> nil then sAttackName := AttackBaseObject.m_Master.m_sCharName
    else sAttackName := AttackBaseObject.m_sCharName;
  end;
  if m_SayMsgList.Count > 0 then begin//20080629
    for I := 0 to m_SayMsgList.Count - 1 do begin
      MonSayMsg := m_SayMsgList.Items[I];
      if MonSayMsg = nil then Continue;
      sMsg := AnsiReplaceText(MonSayMsg.sSayMsg, '%s', FilterShowName(m_sCharName));
      sMsg := AnsiReplaceText(sMsg, '%d', sAttackName);
      if (MonSayMsg.State = MonStatus) and (Random(MonSayMsg.nRate) = 0) then begin
        if MonStatus = s_MonGen then begin
          UserEngine.SendBroadCastMsg(sMsg, t_Mon);
          Break;
        end;
        if MonSayMsg.Color = c_White then begin
          ProcessSayMsg(sMsg);
        end else begin
          AttackBaseObject.SysMsg(sMsg, MonSayMsg.Color, t_Mon);
        end;
        Break;
      end;
    end;//for
  end;
end;
//发送组队聊天
procedure TPlayObject.SendGroupText(sMsg: string);
var
  I: Integer;
  PlayObject: TPlayObject;
begin
  sMsg := g_Config.sGroupMsgPreFix + sMsg;
  if m_GroupOwner <> nil then begin
    if m_GroupOwner.m_GroupMembers.Count > 0 then begin//20080629
      for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
        PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[I]);
        if PlayObject = nil then Continue;
        PlayObject.SendMsg(Self, RM_GROUPMESSAGE, 0, g_Config.btGroupMsgFColor, g_Config.btGroupMsgBColor, 0, sMsg);
      end;
    end;
  end;
end;

procedure TBaseObject.MakeGhost();
begin
  m_boGhost := True;
  m_dwGhostTick := GetTickCount();
  DisappearA();
end;
//设置肉的品质
procedure TBaseObject.ApplyMeatQuality;
var
  I: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
begin
  if m_ItemList.Count > 0 then begin//20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        if StdItem.StdMode = 40 then begin //肉
          UserItem.Dura := m_nMeatQuality;
        end;
      end;
    end;
  end;
end;

function TBaseObject.TakeBagItems(BaseObject: TBaseObject): Boolean;
var
  UserItem: pTUserItem;
  PlayObject: TPlayObject;
begin
  Result := False;
  while (True) do begin
    if BaseObject.m_ItemList.Count <= 0 then Break;
    UserItem := BaseObject.m_ItemList.Items[0];
    if not AddItemToBag(UserItem) then Break;
    if Self is TPlayObject then begin
      PlayObject := TPlayObject(Self);
      PlayObject.SendAddItem(UserItem);
      Result := True;
    end;
    BaseObject.m_ItemList.Delete(0);
  end;
end;

//怪物掉物品 20080127
procedure TBaseObject.ScatterBagItems(ItemOfCreat: TBaseObject);
var
  I, II, DropWide: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  boCanNotDrop: Boolean;
  MonDrop: pTMonDrop;
  pu: pTUserItem;
  DelList: TStringList;
  boDropall: Boolean;
  sCheckItemName: string;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::ScatterBagItems';
begin
  if m_btRaceServer = RC_HEROOBJECT then begin //英雄死后爆包裹
    TPlayObject(m_Master).m_boCanQueryBag:= True;//掉落装备物品时,不能刷新包裹 20080917
    Try
      DelList := nil;
      if m_PEnvir.m_boNODROPITEM then Exit;//地图禁止死亡掉物品则退出 20080503
      if m_boAngryRing or m_boNoDropItem then Exit; //不死戒指
      boDropall := False;
      DropWide := 2;
      if g_Config.boHeroDieRedScatterBagAll and (PKLevel >= 2) then begin
        boDropall := True;
      end;
      //非红名掉1/3 //红名全掉
      try
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          if boDropall or (Random(g_Config.nHeroDieScatterBagRate {3}) = 0) then begin
            if m_ItemList[I] <> nil then begin
              pu := pTUserItem(m_ItemList[I]);
              sCheckItemName:=UserEngine.GetStdItemName(pu.wIndex);
              if PlugOfCheckCanItem(6, sCheckItemName, False, 0, 0) then Continue;//禁止物品规则(永不爆出) 20080729
              if THEROOBJECT(self).CheckItemBindDieNoDrop(m_ItemList[I]) then Continue;//人物装备绑定死亡不爆 20081127

              StdItem := UserEngine.GetStdItem(pu.wIndex);
              if StdItem <> nil then begin
                if (StdItem.StdMode = 51) and (StdItem.Shape = 0) and (pu.Dura > 0) and (pu.btValue[20]= 1) then begin//是聚灵珠 20080611
                  TPlayObject(m_Master).n_UsesItemTick:= 0;//时间初始
                  pu.btValue[12]:= 2;//不能聚集的标识
                end;
              end;
              if DropItemDown(pTUserItem(m_ItemList[I]), DropWide, True, True, ItemOfCreat, Self) then begin
                if m_btRaceServer = RC_HEROOBJECT then begin
                  if DelList = nil then DelList := TStringList.Create;
                  DelList.AddObject(UserEngine.GetStdItemName(pu.wIndex), TObject(pu.MakeIndex));
                end;
                Dispose(pTUserItem(m_ItemList[I])); //修改
                m_ItemList.Delete(I);
              end;
            end;
          end;
        end;//for
        if DelList <> nil then begin
          SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
        end;
      except
        MainOutMessage(sExceptionMsg);
      end;
    finally
      TPlayObject(m_Master).m_boCanQueryBag:= False;//掉落装备物品时,不能刷新包裹 20080917
    end;
  end else begin
    DropWide := 3;
    try
      g_MonDropLimitLIst.Lock;
      try
        if m_ItemList <> nil then begin
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem := m_ItemList.Items[I];
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            boCanNotDrop := False;
            if (StdItem <> nil) and (g_MonDropLimitLIst.Count > 0) then begin
              for II := 0 to g_MonDropLimitLIst.Count - 1 do begin
                if CompareText(StdItem.Name, g_MonDropLimitLIst.Strings[II]) = 0 then begin
                  MonDrop := pTMonDrop(g_MonDropLimitLIst.Objects[II]);
                  if MonDrop <> nil then begin
                    if MonDrop.nDropCount < MonDrop.nCountLimit then begin
                      Inc(MonDrop.nDropCount);
                      g_MonDropLimitLIst.Objects[II] := TObject(MonDrop);
                    end else begin
                      Inc(MonDrop.nNoDropCount);
                      boCanNotDrop := True;
                    end;
                  end;
                  Break;
                end;
              end;//for
            end;
            if boCanNotDrop then Continue;
            if DropItemDown(UserItem, DropWide, True, True, ItemOfCreat, Self) then begin
              Dispose(UserItem);
              m_ItemList.Delete(I);
            end;
          end;//for
        end;
      finally
        g_MonDropLimitLIst.UnLock;
      end;
    except
      MainOutMessage(sExceptionMsg + ' ' + m_sCharName);
    end;
  end;
end;
//分散金币
procedure TBaseObject.ScatterGolds(GoldOfCreat: TBaseObject);
var
  I, nGold: Integer;
begin
  if m_nGold > 0 then begin
    I := 0;
    while (True) do begin
      //      for i:=0 to 18 do begin
      if m_nGold > g_Config.nMonOneDropGoldCount then begin
        nGold := g_Config.nMonOneDropGoldCount;
        m_nGold := m_nGold - g_Config.nMonOneDropGoldCount;
      end else begin
        nGold := m_nGold;
        m_nGold := 0;
      end;
      if nGold > 0 then begin
        if not DropGoldDown(nGold, True, GoldOfCreat, Self) then begin
          m_nGold := m_nGold + nGold;
          Break;
        end;
      end else Break;
      Inc(I);
      if I >= 17 then Break;
    end;
    GoldChanged;
  end;
end;
//掉装备 20080120
procedure TBaseObject.DropUseItems(BaseObject: TBaseObject);
var
  I, nRate: Integer;
  StdItem: pTStdItem;
  DropItemList: TStringList;
  sCheckItemName: string;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::DropUseItems';
begin
  DropItemList := nil;
  try
    if m_boNoDropUseItem then Exit;
    if m_PEnvir.m_boNODROPITEM then Exit;//地图禁止死亡掉物品则退出 20080503
    if m_Master <> nil then begin
      //if (m_btRaceServer <> RC_HEROOBJECT) or (m_btRaceServer <> RC_PLAYMOSTER) then Exit;
      if m_btRaceServer <> RC_HEROOBJECT then begin //如果不是人形怪或者英雄，装备不掉 20080602
         if m_btRaceServer <> RC_PLAYMOSTER then Exit;
      end;
    end;

    for I := Low(THumanUseItems) to High(THumanUseItems) do begin
      StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
      if StdItem <> nil then begin
        if CheckItemValue(@m_UseItems[I],5) then Continue;//20080314 禁止爆出
        if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Continue;//禁止物品规则(永不爆出) 20080729
        if m_btRaceServer = RC_HEROOBJECT then
          if THEROOBJECT(self).CheckItemBindDieNoDrop(@m_UseItems[I]) then Continue;//人物装备绑定死亡不爆 20081127

        if StdItem.Reserved and 8 <> 0 then begin
          if m_btRaceServer = RC_HEROOBJECT then begin
            if DropItemList = nil then DropItemList := TStringList.Create;
            DropItemList.AddObject('', TObject(m_UseItems[I].MakeIndex));
          end;
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('16' + #9 +
              m_sMapName +'('+IntToStr(m_btRaceServer)+')'+ #9 +
              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 + StdItem.Name + #9 + IntToStr(m_UseItems[I].MakeIndex) + #9 +
              '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
              '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
              '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
              '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
              '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
              IntToStr(m_UseItems[I].btValue[0])+'/'+IntToStr(m_UseItems[I].btValue[1])+'/'+IntToStr(m_UseItems[I].btValue[2])+'/'+
              IntToStr(m_UseItems[I].btValue[3])+'/'+IntToStr(m_UseItems[I].btValue[4])+'/'+IntToStr(m_UseItems[I].btValue[5])+'/'+
              IntToStr(m_UseItems[I].btValue[6])+'/'+IntToStr(m_UseItems[I].btValue[7])+'/'+IntToStr(m_UseItems[I].btValue[8])+'/'+
              IntToStr(m_UseItems[I].btValue[14]) + #9 +'1');
          m_UseItems[I].wIndex := 0;
        end;
      end;
    end;

    if m_btRaceServer = RC_HEROOBJECT then begin //如果是英雄
      if PKLevel > 2 then nRate := g_Config.nHeroDieRedDropUseItemRate {15}
      else nRate := g_Config.nHeroDieDropUseItemRate {30};
    end else
    if m_btRaceServer = RC_PLAYMOSTER then begin //如果是人形怪,掉装备的几率 20080120 修改
      if not TPlayMonster(Self).m_boDropUseItem then Exit;//如果设置不掉装备 20080523
      nRate := TPlayMonster(Self).m_nDieDropUseItemRate;//掉装备的几率
    end;

    for I := Low(THumanUseItems) to High(THumanUseItems) do begin
      if Random(nRate) <> 0 then Continue;
      if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then begin
        if InDisableTakeOffList(m_UseItems[I].wIndex) then Continue; //检查是否在禁止取下列表,如果在列表中则不掉此物品
      end;
      StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
      if CheckItemValue(@m_UseItems[I],5) then Continue;//20080314 禁止爆出
      if StdItem <> nil then
        if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Continue;//禁止物品规则(永不爆出) 20080729
      if m_btRaceServer = RC_HEROOBJECT then
        if THEROOBJECT(self).CheckItemBindDieNoDrop(@m_UseItems[I]) then Continue;//人物装备绑定死亡不爆 20081127

      if DropItemDown(@m_UseItems[I], 3, True, True, BaseObject, Self) then begin
        if StdItem <> nil then begin
          if StdItem.Reserved and 10 = 0 then begin
            if m_btRaceServer = RC_HEROOBJECT then begin
              //if StdItem.Reserved = 10 then Continue; //增加不允许掉落装备
              if DropItemList = nil then DropItemList := TStringList.Create;
              DropItemList.AddObject(UserEngine.GetStdItemName(m_UseItems[I].wIndex), TObject(m_UseItems[I].MakeIndex));
            end;
            m_UseItems[I].wIndex := 0;
          end;
        end; 
      end;
    end;
    if DropItemList <> nil then begin
      SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DropItemList), 0, 0, '');
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

//执行杀怪触发
function TPlayObject.KillMonsterFunc(BaseObject: TBaseObject): Boolean;
  function GotoKillMonsterFunc(): Boolean;
  begin
    Result := False;
    if g_FunctionNPC <> nil then begin
      //20080415 地图杀怪触发
      if m_PEnvir <> nil then begin//20090101
        if m_PEnvir.m_boKILLFUNC then g_FunctionNPC.GotoLable(Self, '@KillMonster'+ Inttostr(m_PEnvir.m_nKILLFUNC), False);
      end;
      g_FunctionNPC.GotoLable(Self, '@KillMonster', False);
      Result := True;
    end;
  end;
begin
  Result := False;
  Try
    if BaseObject <> nil then begin
      if BaseObject.m_btRaceServer >= RC_ANIMAL then begin
        m_sString[0] := BaseObject.m_sCharName;
        m_nInteger[0] := BaseObject.m_Abil.Level;
        Result := GotoKillMonsterFunc;
      end;
    end;
  except
    MainOutMessage('{异常} TPlayObject.KillMonsterFunc');
  end;
end;
//死亡必掉物品 20080614
procedure TBaseObject.DieDropItems;
var
  I: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  ItemName:string;
  DelList: TStringList;
begin
  DelList := nil;
  try
    if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYOBJECT) then begin
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if StdItem <> nil then begin
          ItemName:= StdItem.Name;
          if PlugOfCheckCanItem(6, ItemName, False, 0, 0) then Continue;//禁止物品规则(永不爆出) 20080729
          if (m_btRaceServer = RC_PLAYOBJECT) then begin
            if TPLAYOBJECT(self).CheckItemBindDieNoDrop(@m_UseItems[I]) then Continue;//人物装备绑定死亡不爆 20081127
          end else
          if (m_btRaceServer = RC_HEROOBJECT) then begin
            if THEROOBJECT(self).CheckItemBindDieNoDrop(@m_UseItems[I]) then Continue;//英雄装备绑定死亡不爆 20081127
          end;
          if PlugOfCheckCanItem(10, ItemName, False, 0, 0) then begin//禁止物品规则(死亡必爆) 20080729
            if DropItemDown(@m_UseItems[I], 3, True, True, nil, Self) then begin
              if DelList = nil then DelList := TStringList.Create;
              DelList.AddObject(UserEngine.GetStdItemName(m_UseItems[I].wIndex), TObject(m_UseItems[I].MakeIndex));
              m_UseItems[I].wIndex := 0;
            end;
          end;
        end;
      end;

      for I := m_ItemList.Count - 1 downto 0 do begin //包裹不为空
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem <> nil then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            ItemName:= StdItem.Name;
            if PlugOfCheckCanItem(6, ItemName, False, 0, 0) then Continue;//禁止物品规则(永不爆出) 20080729
            if (m_btRaceServer = RC_PLAYOBJECT) then begin
              if TPLAYOBJECT(self).CheckItemBindDieNoDrop(UserItem) then Continue;//人物装备绑定死亡不爆 20081127
            end else
            if (m_btRaceServer = RC_HEROOBJECT) then begin
              if THEROOBJECT(self).CheckItemBindDieNoDrop(UserItem) then Continue;//英雄装备绑定死亡不爆 20081127
            end;
            if PlugOfCheckCanItem(10, ItemName, False, 0, 0) then begin//禁止物品规则(死亡必爆) 20080729
              //if DropItemDown(pTUserItem(m_ItemList[I]), 3, True, True, nil, Self) then begin
              if DropItemDown(UserItem, 3, True, True, nil, Self) then begin//20081006 修改
                if DelList = nil then DelList := TStringList.Create;
                DelList.AddObject(UserEngine.GetStdItemName(UserItem.wIndex), TObject(UserItem.MakeIndex));
                Dispose(pTUserItem(m_ItemList[I])); //20080618
                m_ItemList.Delete(I);//20080618
              end;
            end;
          end;
        end;//if m_ItemList[I] <> nil then begin
      end;//for
    end;
    if DelList <> nil then
       SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
  except
    on E: Exception do begin
      MainOutMessage('{异常} procedure TBaseObject.DieDropItems');
    end;
  end;
end;

procedure TBaseObject.Die;
var
  boPK, guildwarkill: Boolean;
  tStr: string;
  tExp: LongWord;
  I: Integer;
  GroupHuman: TPlayObject;
  QuestNPC: TMerchant;
  tCheck, boCheck: Boolean;
  AttackBaseObject: TBaseObject;
  BaseObject: TBaseObject;
  HeroObject: THeroObject;
  Castle: TUserCastle;
  n10: Integer;
  nCheckCode: Byte;
resourcestring
  sExceptionMsg1 = '{异常} TBaseObject::Die 1 CheckCode:';
  sExceptionMsg2 = '{异常} TBaseObject::Die 2 CheckCode:';
  sExceptionMsg3 = '{异常} TBaseObject::Die 3 CheckCode:';
begin
  try
    if m_boSuperMan then Exit;
    if m_boSupermanItem then Exit;
    m_boDeath := True;
    m_dwDeathTick := GetTickCount();
    nCheckCode:= 0;
    if (m_Master <> nil) and (m_btRaceServer <> RC_HEROOBJECT) then begin//20080716 除英雄外
      m_ExpHitter := nil;
      m_LastHiter := nil;
    end;
    if (m_Master <> nil) and (m_btRaceServer = RC_HEROOBJECT) and (m_LastHiter <> nil) then begin//20080724 杀自己英雄
      if m_LastHiter = m_Master then begin
        m_ExpHitter := nil;
        m_LastHiter := nil;
      end;
    end;
    m_nIncSpell := 0;
    m_nIncHealth := 0;
    m_nIncHealing := 0;
 
    {if Assigned(zPlugOfEngine.ObjectDie) then begin//20080813 注释
      nCheckCode:= 1;
      if zPlugOfEngine.ObjectDie(Self) then Exit;
    end;}
    if (m_btRaceServer <> RC_PLAYOBJECT) and (m_LastHiter <> nil) then begin
      nCheckCode:= 2;
      if g_Config.boMonSayMsg then MonsterSayMsg(m_LastHiter, s_Die);
      if (m_ExpHitter <> nil) then begin
        if m_ExpHitter.m_btRaceServer = RC_PLAYOBJECT then begin
          nCheckCode:= 3;
          tExp := m_ExpHitter.CalcGetExp(m_Abil.Level, m_dwFightExp);
          if not g_Config.boVentureServer then begin
            nCheckCode:= 4;
            if m_boIsNGMonster then//20081224
              TPlayObject(m_ExpHitter).GainExp(tExp,1)
            else TPlayObject(m_ExpHitter).GainExp(tExp,0);
            //if m_boIsNGMonster then TPlayObject(m_ExpHitter).GetNGExp(tExp, 0);//取得内力经验 20081001
          end;
          nCheckCode:= 5;
          //是否执行任务脚本
          if (m_PEnvir.IsCheapStuff) and (m_ExpHitter <> nil) then begin//20080827 修改
            boCheck := False;
            if (TPlayObject(m_ExpHitter).m_GroupOwner <> nil) and (TPlayObject(m_ExpHitter).m_GroupOwner.m_GroupMembers <> nil) and (TPlayObject(m_ExpHitter).m_GroupOwner.m_GroupMembers.Count > 0) then begin
              nCheckCode:= 6;
              for I := 0 to TPlayObject(m_ExpHitter).m_GroupOwner.m_GroupMembers.Count - 1 do begin
                GroupHuman := TPlayObject(TPlayObject(m_ExpHitter).m_GroupOwner.m_GroupMembers.Objects[I]);
                nCheckCode:= 61;
                if GroupHuman <> nil then begin
                  if not GroupHuman.m_boDeath and (m_ExpHitter = GroupHuman) then begin
                    nCheckCode:= 62;
                    boCheck := True;
                    if m_PEnvir <> nil then begin
                      nCheckCode:= 63;
                      QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(GroupHuman, m_sCharName, '', False));
                      nCheckCode:= 64;
                      if (QuestNPC <> nil) and (GroupHuman <> nil) then begin
                        nCheckCode:= 65;
                        if not GroupHuman.m_boGhost then QuestNPC.Click(GroupHuman);//20081228 
                      end;
                    end;
                  end else
                  if not GroupHuman.m_boDeath and (m_ExpHitter.m_PEnvir = GroupHuman.m_PEnvir) and (abs(m_ExpHitter.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and (abs(m_ExpHitter.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and (m_ExpHitter <> GroupHuman) then begin
                    tCheck := True;
                    nCheckCode:= 66;
                    QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(GroupHuman, m_sCharName, '', tCheck));
                    if (QuestNPC <> nil) and (GroupHuman <> nil) then begin
                      if GroupHuman = m_ExpHitter then boCheck := True;
                      nCheckCode:= 67;
                      if not GroupHuman.m_boGhost then QuestNPC.Click(GroupHuman);//20081228
                    end;
                  end;
                end;
              end;//for
            end;
            if not boCheck then begin
              nCheckCode:= 7;
              if (m_ExpHitter <> nil) and (m_PEnvir <> nil) then begin//20081029
                nCheckCode:= 71;
                QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(m_ExpHitter, m_sCharName, '', False));
                if (QuestNPC <> nil) and (m_ExpHitter <> nil) then begin
                  nCheckCode:= 73;
                  if not m_ExpHitter.m_boGhost then QuestNPC.Click(TPlayObject(m_ExpHitter));//20081228
                end;
              end;
            end;
          end;
        end else begin//if m_ExpHitter.m_btRaceServer = RC_PLAYOBJECT then begin
          if m_ExpHitter.m_Master <> nil then begin
            nCheckCode:= 8;
            if m_ExpHitter.m_Master.m_btRaceServer = RC_HEROOBJECT then begin //英雄宝宝杀死怪,英雄获取经验  20080229
              m_ExpHitter.GainSlaveExp(m_Abil.Level);//宝宝升级 20080521
              tExp := m_ExpHitter.CalcGetExp(m_Abil.Level, m_dwFightExp);
              if not g_Config.boVentureServer then begin
                if m_ExpHitter.m_Master <> nil then begin//20080623 增加
                   if m_ExpHitter.m_Master.m_Master <> nil then begin//20080703
                     nCheckCode:= 95;
                     if m_boIsNGMonster then//20081224
                       TPlayObject(m_ExpHitter.m_Master.m_Master).GainExp(tExp,1)
                     else TPlayObject(m_ExpHitter.m_Master.m_Master).GainExp(tExp,0);
                     //nCheckCode:= 96;
                     //if m_boIsNGMonster then TPlayObject(m_ExpHitter.m_Master.m_Master).GetNGExp(tExp, 0);//取得内力经验 20081001
                     nCheckCode:= 97;
                     if m_PEnvir <> nil then begin
                       if m_PEnvir.IsCheapStuff then begin//是否执行任务脚本 20080628
                          nCheckCode:= 99;
                          QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(m_ExpHitter.m_Master.m_Master, m_sCharName, '', False));
                          if (QuestNPC <> nil) and (m_ExpHitter <> nil) then begin
                            nCheckCode:= 98;
                            if (m_ExpHitter.m_Master <> nil) then begin
                               nCheckCode:= 100;
                               if (m_ExpHitter.m_Master.m_Master <> nil) then begin
                                 nCheckCode:= 201;
                                 if not m_ExpHitter.m_Master.m_Master.m_boGhost then QuestNPC.Click(TPlayObject(m_ExpHitter.m_Master.m_Master));//20081228
                               end;
                            end;
                          end;
                       end;
                     end;
                   end;
                end else begin
                  nCheckCode:= 202;
                  THeroObject(m_ExpHitter.m_Master).GainExp(tExp);
                  nCheckCode:= 203;
                  if m_boIsNGMonster then THeroObject(m_ExpHitter.m_Master).GetNGExp(tExp,0);//取得内力经验 20081001
                end;
              end;
            end else
            if m_ExpHitter.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin //人物宝宝杀死怪,英雄获取经验  20080402
              nCheckCode:= 10;
              m_ExpHitter.GainSlaveExp(m_Abil.Level);//宝宝升级 20080521
              tExp := m_ExpHitter.CalcGetExp(m_Abil.Level, m_dwFightExp);
              if not g_Config.boVentureServer then begin
                if m_ExpHitter.m_Master <> nil then begin
                   nCheckCode:= 101;
                   if m_boIsNGMonster then//20081224
                     TPlayObject(m_ExpHitter.m_Master).GainExp(tExp, 1)
                   else TPlayObject(m_ExpHitter.m_Master).GainExp(tExp, 0);//20080531
                   nCheckCode:= 102;
                   //if m_boIsNGMonster then TPlayObject(m_ExpHitter.m_Master).GetNGExp(tExp, 0);//取得内力经验 20081001
                   nCheckCode:= 103;
                   if m_PEnvir <> nil then begin
                     if m_PEnvir.IsCheapStuff then begin//是否执行任务脚本 20080628
                       nCheckCode:= 104;
                       QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(m_ExpHitter.m_Master, m_sCharName, '', False));
                       if (QuestNPC <> nil) and (m_ExpHitter <> nil) then begin
                         nCheckCode:= 106;
                         if m_ExpHitter.m_Master <> nil then begin
                           nCheckCode:= 107;
                           if not m_ExpHitter.m_Master.m_boGhost then QuestNPC.Click(TPlayObject(m_ExpHitter.m_Master));//20081228
                         end;
                       end;
                     end;
                   end;
                end;
              end;
            end else
            if m_ExpHitter.m_btRaceServer = RC_HEROOBJECT then begin //英雄获取经验
              nCheckCode:= 11;
              tExp := m_ExpHitter.CalcGetExp(m_Abil.Level, m_dwFightExp);
              nCheckCode:= 110;
              if not g_Config.boVentureServer then begin
                if m_ExpHitter.m_Master <> nil then begin
                  nCheckCode:= 111;
                  if m_boIsNGMonster then//20081224
                    TPlayObject(m_ExpHitter.m_Master).GainExp(tExp, 1)
                  else TPlayObject(m_ExpHitter.m_Master).GainExp(tExp, 0);//20080531
                  nCheckCode:= 112;
                  //if m_boIsNGMonster then TPlayObject(m_ExpHitter.m_Master).GetNGExp(tExp, 0);//取得内力经验 20081001
                  nCheckCode:= 113;
                  if m_PEnvir <> nil then begin
                    if m_PEnvir.IsCheapStuff then begin//是否执行任务脚本 20080628
                      nCheckCode:= 114;
                      QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(m_ExpHitter.m_Master, m_sCharName, '', False));
                      if (QuestNPC <> nil) and (m_ExpHitter <> nil) then begin
                        nCheckCode:= 115;
                        if (m_ExpHitter.m_Master <> nil) then begin
                          nCheckCode:= 116;
                          if not m_ExpHitter.m_Master.m_boGhost then QuestNPC.Click(TPlayObject(m_ExpHitter.m_Master));//20081228
                        end;
                      end;
                    end;
                  end;
                end;
              end;
            end else begin
              nCheckCode:= 12;
              m_ExpHitter.GainSlaveExp(m_Abil.Level);//宝宝升级
              nCheckCode:= 121;
              tExp := m_ExpHitter.m_Master.CalcGetExp(m_Abil.Level, m_dwFightExp);
              nCheckCode:= 122;
              if not g_Config.boVentureServer then begin
                if m_ExpHitter.m_Master <> nil then begin
                  nCheckCode:= 123;
                  if m_boIsNGMonster then//20081224
                    TPlayObject(m_ExpHitter.m_Master).GainExp(tExp, 1)
                  else TPlayObject(m_ExpHitter.m_Master).GainExp(tExp, 0);//20080531
                  nCheckCode:= 124;
                  //if m_boIsNGMonster then TPlayObject(m_ExpHitter.m_Master).GetNGExp(tExp, 0);//取得内力经验 20081001
                  if m_PEnvir <> nil then begin
                    nCheckCode:= 125;
                    if m_PEnvir.IsCheapStuff then begin//是否执行任务脚本 20080629
                      nCheckCode:= 126;
                      QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(m_ExpHitter.m_Master, m_sCharName, '', False));
                       nCheckCode:= 127;
                      if (QuestNPC <> nil) and (m_ExpHitter <> nil) then begin
                        nCheckCode:= 128;
                        if (m_ExpHitter.m_Master <> nil) then begin
                          nCheckCode:= 129;
                          if not m_ExpHitter.m_Master.m_boGhost then QuestNPC.Click(TPlayObject(m_ExpHitter.m_Master));//20081228
                        end;
                      end;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
      end else begin
        if m_LastHiter <> nil then begin//20080531  
          if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then begin
            nCheckCode:= 13;
            tExp := m_LastHiter.CalcGetExp(m_Abil.Level, m_dwFightExp);
            if not g_Config.boVentureServer then begin
              if m_boIsNGMonster then//20081224
                TPlayObject(m_LastHiter).GainExp(tExp, 1)
              else TPlayObject(m_LastHiter).GainExp(tExp, 0);
              //if m_boIsNGMonster then TPlayObject(m_LastHiter).GetNGExp(tExp, 0);//取得内力经验 20081001
            end;
          end;
        end;//20080531
      end;
    end;
    if (g_Config.boMonSayMsg) and (m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter <> nil) then begin
      nCheckCode:= 14;
      m_LastHiter.MonsterSayMsg(Self, s_KillHuman);
    end;
    nCheckCode:= 15;
    //宝宝杀死怪触发    魔王岭,135宝宝杀怪主人记数, 
    if (m_LastHiter <> nil) and (m_LastHiter.m_Master <> nil) and
       (m_LastHiter.m_Master.m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter.m_btRaceServer = 135) then  {20080208 增加条件}
          TPlayObject(m_LastHiter.m_Master).KillMissionMob;
    nCheckCode:= 16;
    //执行杀怪触发
    if (m_LastHiter <> nil) then begin
      nCheckCode:= 161;
      if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then TPlayObject(m_LastHiter).KillMonsterFunc(self)
      else if (m_LastHiter.m_btRaceServer = RC_HEROOBJECT) and (m_LastHiter.m_Master <> nil) then TPlayObject(m_LastHiter.m_Master).KillMonsterFunc(self)//20081108 英雄杀怪,触发
      else if (m_LastHiter.m_Master <> nil) then begin
        nCheckCode:= 162;
        if (m_LastHiter.m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
          nCheckCode:= 163;
          TPlayObject(m_LastHiter.m_Master).KillMonsterFunc(self);
        end else
          if (m_LastHiter.m_Master.m_btRaceServer = RC_HEROOBJECT) then begin
            nCheckCode:= 164;
            if m_LastHiter.m_Master.m_Master <> nil then TPlayObject(m_LastHiter.m_Master.m_Master).KillMonsterFunc(self);
        end;
      end;
    end;
    nCheckCode:= 17;
    if m_btRaceServer <> RC_HEROOBJECT then m_Master := nil;
  except
    on E: Exception do begin
      MainOutMessage(sExceptionMsg1+inttostr(nCheckCode)+'  Name:'+ m_sCharName);//20081226 增加显示名字
    end;
  end;
  
  try
    nCheckCode:= 18;
    {执行杀人和死亡触发}
    if (m_LastHiter <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then TPlayObject(Self).DieGotoLable();

    boPK := False;
    if (not g_Config.boVentureServer) and (not m_PEnvir.m_boFightZone) and (not m_PEnvir.m_boFight3Zone) and (not m_PEnvir.m_boFight2Zone) and (not m_PEnvir.m_boFight4Zone) then begin//20080525
      nCheckCode:= 19;
      //20080716 增加杀英雄
      if ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and (m_LastHiter <> nil) and (PKLevel < 2) then begin             //英雄除行会战外 20080726
        if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or (m_LastHiter.m_btRaceServer = RC_NPC) or ((m_LastHiter.m_btRaceServer = RC_HEROOBJECT) and (not m_boInFreePKArea)) then begin//允许NPC杀死人物 20080721
          boPK := True;
        end;
        if (m_LastHiter.m_Master <> nil) and (m_LastHiter.m_btRaceServer <> RC_HEROOBJECT)then//20080721
          if (m_LastHiter.m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
            nCheckCode:= 20;
            m_LastHiter := m_LastHiter.m_Master;
            boPK := True;
          end;
      end;
    end;
    nCheckCode:= 21;
    if (m_LastHiter <> nil) and boPK then begin //PK不红名
      if m_LastHiter.m_PEnvir.m_boFIGHTPK then m_LastHiter.m_boPKFlag := True; //m_boPKFlag = True 属于正当防卫
    end;
    nCheckCode:= 210;
    if m_PEnvir.m_boFight4Zone and (m_btRaceServer = RC_PLAYOBJECT) then begin//挑战地图 20080706
      nCheckCode:= 211;
      if TPLAYOBJECT(Self).m_boChallengeing and (TPLAYOBJECT(Self).m_ChallengeCreat <> nil) then begin
        if TPLAYOBJECT(Self).m_ChallengeCreat.m_PEnvir.m_boFight4Zone then
           TPLAYOBJECT(Self).m_ChallengeCreat.MapRandomMove(TPLAYOBJECT(Self).m_ChallengeCreat.m_sLastMapName, 0);
        SysMsg(g_sChallengeLoseMsg{'您挑战输了!'}, c_Blue, t_Hint);
        nCheckCode:= 212;
        TPLAYOBJECT(Self).m_ChallengeCreat.SysMsg(g_sChallengeWinMsg{'您挑战获胜!'}, c_Blue, t_Hint);
        nCheckCode:= 213;
        TPLAYOBJECT(Self).m_ChallengeCreat.WinGetChallengeItems;//取胜后得到挑战的抵押物品
      end;
    end;
    nCheckCode:= 22;
    if boPK and (m_LastHiter <> nil) then begin
      guildwarkill := False;
      if (m_MyGuild <> nil) and (m_LastHiter.m_MyGuild <> nil) then begin
        if GetGuildRelation(Self, m_LastHiter) = 2 then guildwarkill := True;
      end;
      nCheckCode:= 23;
      Castle := g_CastleManager.InCastleWarArea(Self);
      if ((Castle <> nil) and Castle.m_boUnderWar) or (m_boInFreePKArea) then guildwarkill := True;//攻城或行会战
      if (m_LastHiter.m_btRaceServer = RC_HEROOBJECT) and (not guildwarkill) then begin//20080928 英雄攻城或行会战杀人不加PK值
         if (m_LastHiter.m_Master <> nil) then begin
           if m_LastHiter.m_Master.m_boInFreePKArea then guildwarkill := True;
           if (m_MyGuild <> nil) and (m_LastHiter.m_Master.m_MyGuild <> nil) and (not guildwarkill) then begin//检查主人是否是在行会战 20080928
             if GetGuildRelation(Self, m_LastHiter.m_Master) = 2 then guildwarkill := True;
           end;
         end;
      end;
      if (m_btRaceServer = RC_HEROOBJECT) and (not guildwarkill) then begin
        if (m_Master <> nil) then begin
          if m_Master.m_boInFreePKArea then guildwarkill := True;//20081209
          if (m_Master.m_MyGuild <> nil) and (m_LastHiter.m_MyGuild <> nil) and (not guildwarkill) then begin//检查主人是否是在行会战 20080928
            if GetGuildRelation(m_Master, m_LastHiter) = 2 then guildwarkill := True;
          end;
          if (m_LastHiter.m_Master <> nil) then begin//20081209 行会战,英雄杀英雄不加PK值
            if (m_Master.m_MyGuild <> nil) and (m_LastHiter.m_Master.m_MyGuild <> nil) and (not guildwarkill) then begin
              if GetGuildRelation(m_Master, m_LastHiter.m_Master) = 2 then guildwarkill := True;
            end;
          end;
        end;
      end;

      //=================================================================
      if (not guildwarkill) and (not m_PEnvir.m_boFight4Zone) then begin//20080706
        nCheckCode:= 24;
        if (g_Config.boKillHumanWinLevel or g_Config.boKillHumanWinExp or m_PEnvir.m_boPKWINLEVEL or m_PEnvir.m_boFIGHTPK or m_PEnvir.m_boPKWINEXP) and (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then begin
          TPlayObject(Self).PKDie(TPlayObject(m_LastHiter));
        end else begin
          if not m_LastHiter.IsGoodKilling(Self) then begin
            nCheckCode:= 25;
            m_LastHiter.IncPkPoint(g_Config.nKillHumanAddPKPoint {100});//PK值增加

            if m_LastHiter.m_btRaceServer <> RC_HEROOBJECT then begin//20080721
               m_LastHiter.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
               m_LastHiter.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
              if PKLevel < 1 then
                if Random(g_Config.nKillHumanWeaponUnlockRate{5}) = 0 then m_LastHiter.MakeWeaponUnlock;
            end else begin
               //THEROOBJECT(m_LastHiter).SysMsg('(英雄)犯了谋杀罪！！！' , c_Red, t_Hint);
               if (m_LastHiter.m_Master <> nil) then begin
                  m_LastHiter.m_Master.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint);//英雄杀人,提示主人杀人 20080910
                  m_LastHiter.m_Master.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
                  if PKLevel < 1 then
                    if Random(g_Config.nKillHumanWeaponUnlockRate{5}) = 0 then m_LastHiter.m_Master.MakeWeaponUnlock;
               end;
            end;

            if g_Config.boUnKnowHum and m_LastHiter.IsUsesZhuLi then //20080424 带上斗笠,不显示人的真正名字
              SysMsg(Format(g_sYouKilledByMsg, ['神秘人']), c_Red, t_Hint)
            else begin
              if m_LastHiter.m_btRaceServer <> RC_HEROOBJECT then
                SysMsg(Format(g_sYouKilledByMsg, [m_LastHiter.m_sCharName]), c_Red, t_Hint)
              else begin//20080915 英雄杀人,提示主人杀的
                if (m_LastHiter.m_Master <> nil) then begin
                  if m_btRaceServer <> RC_HEROOBJECT then
                     SysMsg(Format(g_sYouKilledByMsg, [m_LastHiter.m_Master.m_sCharName]), c_Red, t_Hint)
                  else THEROOBJECT(Self).SysMsg(Format('(英雄)' +g_sYouKilledByMsg, [m_LastHiter.m_Master.m_sCharName]), c_Red, t_Hint)
                end;
              end;
            end;
          end else
            m_LastHiter.SysMsg(g_sYouProtectedByLawOfDefense {'[你受到正当规则保护。]'}, c_Green, t_Hint);
        end;
        nCheckCode:= 26;
        //检查攻击人是否用了着经验或等级装备
        if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then begin
          if m_LastHiter.m_dwPKDieLostExp > 0 then begin
            if m_Abil.Exp >= m_LastHiter.m_dwPKDieLostExp then begin
              Dec(m_Abil.Exp, m_LastHiter.m_dwPKDieLostExp);
            end else m_Abil.Exp := 0;
          end;
          nCheckCode:= 27;
          if m_LastHiter.m_nPKDieLostLevel > 0 then begin
            if m_Abil.Level >= m_LastHiter.m_nPKDieLostLevel then begin
              Dec(m_Abil.Level, m_LastHiter.m_nPKDieLostLevel);
            end else m_Abil.Level := 0;
          end;
        end;
      end;
      //=================================================================
    end;
  except
    MainOutMessage(sExceptionMsg2+inttostr(nCheckCode));
  end;

  try
    nCheckCode:= 28;
    DieDropItems;//死亡必掉物品 20080614
    if (not m_PEnvir.m_boFightZone) and
      (not m_PEnvir.m_boFight3Zone) and
      (not m_boAnimal) then begin
      nCheckCode:= 39;
      AttackBaseObject := m_ExpHitter;
      if (m_ExpHitter <> nil) and (m_ExpHitter.m_Master <> nil) then begin
        AttackBaseObject := m_ExpHitter.m_Master;
        if (m_ExpHitter.m_Master.m_btRaceServer = RC_HEROOBJECT) and
         (m_ExpHitter.m_Master.m_Master <> nil) then AttackBaseObject := m_ExpHitter.m_Master.m_Master;//20080309 英雄宝宝打到的物品,英雄主人可以捡
      end;
      nCheckCode:= 29;
      if m_btRaceServer = RC_HEROOBJECT then begin //英雄死亡
        if not m_boNoItem then begin {修改日期2004/07/21，增加此行，允许设置 m_boNoItem 后人物死亡不掉物品}
          nCheckCode:= 47;
          if AttackBaseObject <> nil then begin                                                                           //20080602  英雄打死英雄也能掉装备
            nCheckCode:= 48;
            if (g_Config.boHeroKillByHumanDropUseItem and ((AttackBaseObject.m_btRaceServer = RC_PLAYOBJECT) or (AttackBaseObject.m_btRaceServer =RC_HEROOBJECT)))
               or (g_Config.boHeroKillByMonstDropUseItem and (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT)) then
              DropUseItems(nil);
          end else begin
            nCheckCode:= 49;
            DropUseItems(nil);
          end;
          if g_Config.boHeroDieScatterBag then ScatterBagItems(nil);
        end;
      end else
        if m_btRaceServer <> RC_PLAYOBJECT then begin
        nCheckCode:= 30;
        if AttackBaseObject <> nil then  DropUseItems(AttackBaseObject);//掉装备
        nCheckCode:= 31;
        if m_btRaceServer = 136 then begin  //20080127 魔王岭
          nCheckCode:= 32;
          if (m_Master = nil) and (not m_boNoItem)  then begin
           if m_LastHiter.m_Master<> nil then  ScatterBagItems(m_LastHiter.m_Master)//掉物品
           else ScatterBagItems(m_LastHiter);
          end;
        end else begin
          nCheckCode:= 33;
          if (m_Master = nil) and (not m_boNoItem) then begin
            nCheckCode:= 47;
            if AttackBaseObject <> nil then ScatterBagItems(AttackBaseObject);//掉物品
          end;
        end;
        nCheckCode:= 34;
        if (m_btRaceServer >= RC_ANIMAL) and (m_Master = nil) and (not m_boNoItem) and (AttackBaseObject <> nil) then begin//20080812 修改
          nCheckCode:= 39;
          if (AttackBaseObject.m_btRaceServer = RC_PLAYOBJECT) and (g_Config.boDropGoldToPlayBag) then begin
            nCheckCode:= 40;
            if TPlayObject(AttackBaseObject).IncGold(m_nGold) then begin
              nCheckCode:= 41;
              TPlayObject(AttackBaseObject).GoldChanged();
            end else begin
              nCheckCode:= 42;
              ScatterGolds(AttackBaseObject);
            end;
          end else begin//如果是宝宝打到的金币,直接进入主人包裹 20080615
            nCheckCode:= 43;
            if (AttackBaseObject.m_Master <> nil) and (AttackBaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) and (g_Config.boDropGoldToPlayBag) then begin
                nCheckCode:= 44;
                if TPlayObject(AttackBaseObject.m_Master).IncGold(m_nGold) then begin
                  nCheckCode:= 45;
                  TPlayObject(AttackBaseObject.m_Master).GoldChanged();
                end else begin
                  nCheckCode:= 46;
                  ScatterGolds(AttackBaseObject);//将金币分散到地上
                end;
            end else ScatterGolds(AttackBaseObject);
          end;
        end;  
      end else begin
        if not m_boNoItem then begin {修改日期2004/07/21，增加此行，允许设置 m_boNoItem 后人物死亡不掉物品}
          nCheckCode:= 35;
          if AttackBaseObject <> nil then begin
            if (g_Config.boKillByHumanDropUseItem and (AttackBaseObject.m_btRaceServer = RC_PLAYOBJECT)) or (g_Config.boKillByMonstDropUseItem and (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT)) then
             DropUseItems(nil);
          end else begin
             DropUseItems(nil);
          end;  
          if g_Config.boDieScatterBag then ScatterBagItems(nil);
          if g_Config.boDieDropGold then ScatterGolds(nil);
        end;
        AddBodyLuck(-(50 - (50 - m_Abil.Level * 5)));
      end;
    end;
    nCheckCode:= 36;
    if m_PEnvir.m_boFight3Zone then begin //行会战争地图
      Inc(m_nFightZoneDieCount);//在行会战争地图中死亡次数
      if m_MyGuild <> nil then begin
        TGUild(m_MyGuild).TeamFightWhoDead(m_sCharName);
      end;
      if (m_LastHiter <> nil) then begin
        if m_LastHiter.m_btRaceServer = RC_HEROOBJECT then begin //行会战杀人增加英雄忠诚度 20080214
           THeroObject(m_LastHiter).m_nLoyal:= THeroObject(m_LastHiter).m_nLoyal + g_Config.nGuildIncLoyal;
           if THeroObject(m_LastHiter).m_nLoyal > 10000 then THeroObject(m_LastHiter).m_nLoyal:=10000;
        end;
        if (m_LastHiter.m_MyGuild <> nil) and (m_MyGuild <> nil) then begin
          TGUild(m_LastHiter.m_MyGuild).TeamFightWhoWinPoint(m_LastHiter.m_sCharName, 100); 
          tStr := TGUild(m_LastHiter.m_MyGuild).sGuildName + ':' +
            IntToStr(TGUild(m_LastHiter.m_MyGuild).nContestPoint) + '  ' +
            TGUild(m_MyGuild).sGuildName + ':' +
            IntToStr(TGUild(m_MyGuild).nContestPoint);
          UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, '- ' + tStr);
        end;
      end;
    end;
    nCheckCode:= 37;
    if m_btRaceServer = RC_HEROOBJECT then m_btLastOutStatus:= 1;//20080404 增加英雄退出状态 1为死亡退出
    if m_btRaceServer = RC_PLAYOBJECT then begin
      m_btLastOutStatus := 1; //2006-01-12 增加人物最后退出状态 1为死亡退出
      //人物死亡立即退组，以防止组队刷经验
      if TPlayObject(Self).m_GroupOwner <> nil then TPlayObject(Self).m_GroupOwner.DelMember(TPlayObject(Self));
      if m_LastHiter <> nil then begin
        if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then tStr := m_LastHiter.m_sCharName
        else tStr := '#' + m_LastHiter.m_sCharName;
      end else tStr := '####';
      AddGameDataLog('19' + #9 + m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 + 'FZ-' + BoolToIntStr(m_PEnvir.m_boFightZone) +
        '_F3-' + BoolToIntStr(m_PEnvir.m_boFight3Zone) + #9 +
        '0' + #9 + '1' + #9 + tStr);
    end;
    nCheckCode:= 38;
    //减少地图上怪物计数
    if (m_Master = nil) and (not m_boDelFormMaped) then begin
      m_PEnvir.DelObjectCount(Self);
      m_boDelFormMaped := True;
    end;
    SendRefMsg(RM_DEATH, m_btDirection, m_nCurrX, m_nCurrY, 1, '');
  except
    MainOutMessage(sExceptionMsg3+inttostr(nCheckCode));
  end;
end;

procedure TPlayObject.PKDie(PlayObject: TPlayObject);
var
  nWinLevel, nLostLevel, nWinExp, nLostExp: Integer;
  boWinLEvel, boLostLevel, boWinExp, boLostExp: Boolean;
begin
  nWinLevel := g_Config.nKillHumanWinLevel;
  nLostLevel := g_Config.nKilledLostLevel;
  nWinExp := g_Config.nKillHumanWinExp;
  nLostExp := g_Config.nKillHumanLostExp;

  boWinLEvel := g_Config.boKillHumanWinLevel;
  boLostLevel := g_Config.boKilledLostLevel;
  boWinExp := g_Config.boKillHumanWinExp;
  boLostExp := g_Config.boKilledLostExp;

  if m_PEnvir.m_boPKWINLEVEL then begin
    boWinLEvel := True;
    nWinLevel := m_PEnvir.m_nPKWINLEVEL;
  end;
  if m_PEnvir.m_boPKLOSTLEVEL then begin
    boLostLevel := True;
    nLostLevel := m_PEnvir.m_nPKLOSTLEVEL;
  end;
  if m_PEnvir.m_boPKWINEXP then begin
    boWinExp := True;
    nWinExp := m_PEnvir.m_nPKWINEXP;
  end;
  if m_PEnvir.m_boPKLOSTEXP then begin
    boLostExp := True;
    nLostExp := m_PEnvir.m_nPKLOSTEXP;
  end;

  if PlayObject.m_Abil.Level - m_Abil.Level > g_Config.nHumanLevelDiffer then begin
    if not PlayObject.IsGoodKilling(Self) then begin
      PlayObject.IncPkPoint(g_Config.nKillHumanAddPKPoint {100});
      PlayObject.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
      if g_Config.boUnKnowHum and m_LastHiter.IsUsesZhuLi then //20080424 带上斗笠,不显示人的真正名字
         SysMsg(Format(g_sYouKilledByMsg, ['神秘人']), c_Red, t_Hint)
      else SysMsg(Format(g_sYouKilledByMsg, [m_LastHiter.m_sCharName]), c_Red, t_Hint);
      PlayObject.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
      if PKLevel < 1 then
        if Random(g_Config.nKillHumanWeaponUnlockRate{5}) = 0 then PlayObject.MakeWeaponUnlock;
    end else begin
      PlayObject.SysMsg(g_sYouProtectedByLawOfDefense {'[你受到正当规则保护。]'}, c_Green, t_Hint);
    end;
    Exit;
  end;
  if boWinLEvel then begin
    if PlayObject.m_Abil.Level + nWinLevel <= MAXUPLEVEL then begin
      Inc(PlayObject.m_Abil.Level, nWinLevel);
      AddGameDataLog('12' + #9 + PlayObject.m_sMapName + #9 + //人物升级记录日志
        IntToStr(PlayObject.m_Abil.Level) + #9 +
        IntToStr(PlayObject.m_Abil.Exp)+'/'+IntToStr(PlayObject.m_Abil.MaxExp) + #9 +
        m_sCharName + #9 +
        '0' + #9 +
        '0' + #9 +
        '1' + #9 +
        'PK+');
    end else begin
      PlayObject.m_Abil.Level := MAXUPLEVEL;
      AddGameDataLog('12' + #9 + PlayObject.m_sMapName + #9 + //人物升级记录日志
        IntToStr(PlayObject.m_Abil.Level) + #9 +
        IntToStr(PlayObject.m_Abil.Exp)+'/'+IntToStr(PlayObject.m_Abil.MaxExp) + #9 +
        m_sCharName + #9 +
        '0' + #9 +
        '0' + #9 +
        '1' + #9 +
        'PK+');      
    end;
    PlayObject.HasLevelUp(PlayObject.m_Abil.Level - nWinLevel);

    if boLostLevel then begin
      if PKLevel >= 2 then begin
        if m_Abil.Level >= nLostLevel * 2 then Dec(m_Abil.Level, nLostLevel * 2);
      end else begin
        if m_Abil.Level >= nLostLevel then Dec(m_Abil.Level, nLostLevel);
      end;
    end;
  end;

  if boWinExp then begin
    PlayObject.WinExp(nWinExp);
    if boLostExp then begin
      if m_Abil.Exp >= LongWord(nLostExp) then begin
        if m_Abil.Exp >= LongWord(nLostExp) then begin
          Dec(m_Abil.Exp, LongWord(nLostExp));
        end else begin
          m_Abil.Exp := 0;
        end;
      end else begin
        if m_Abil.Level >= 1 then begin
          Dec(m_Abil.Level);
          Inc(m_Abil.Exp, GetLevelExp(m_Abil.Level));
          if m_Abil.Exp >= LongWord(nLostExp) then begin
            Dec(m_Abil.Exp, LongWord(nLostExp));
          end else begin
            m_Abil.Exp := 0;
          end;
        end else begin
          m_Abil.Level := 0;
          m_Abil.Exp := 0;
        end;
        //HasLevelUp(m_Abil.Level + 1);
      end;
    end;
  end;
end;
//复活
procedure TBaseObject.ReAlive;
begin
  m_boDeath := False;
  SendRefMsg(RM_ALIVE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;
//设置最后打自己的人
procedure TBaseObject.SetLastHiter(BaseObject: TBaseObject);
begin
  if BaseObject = nil then Exit;//20080726 增加
  m_LastHiter := BaseObject;
  m_LastHiterTick := GetTickCount();
  if m_ExpHitter = nil then begin
    m_ExpHitter := BaseObject;
    m_ExpHitterTick := GetTickCount();
  end else begin
    if m_ExpHitter = BaseObject then
      m_ExpHitterTick := GetTickCount();
  end;
end;
//设置人物名字变色,即灰名
procedure TBaseObject.SetPKFlag(BaseObject: TBaseObject);
var
  nCode: byte;
  I: Integer;
  Slave: TBaseObject;
begin
  nCode:= 0;
  if BaseObject = nil then Exit;//20080726 增加
  try
    if (PKLevel < 2) and (BaseObject.PKLevel < 2) and
      (not m_PEnvir.m_boFightZone) and
      (not m_PEnvir.m_boFight2Zone) and //PK掉装备地图 20080525
      (not m_PEnvir.m_boFight3Zone) and
      (not m_PEnvir.m_boFight4Zone) and//挑战地图 20080711
      (not m_boPKFlag) then begin
      nCode:= 1;
      BaseObject.m_dwPKTick := GetTickCount();
      if not BaseObject.m_boPKFlag then begin
        nCode:= 2;
        BaseObject.m_boPKFlag := True;
        nCode:= 3;
        BaseObject.RefNameColor();
        nCode:= 4;
        if BaseObject <> nil then begin
          nCode:= 10;
          if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_btRaceServer = RC_HEROOBJECT) then begin//20081222
            nCode:= 11;
            if BaseObject.m_SlaveList <> nil then begin//20081216
              nCode:= 12;
              if BaseObject.m_SlaveList.Count > 0 then begin//下属为分身则一样变名 20081023
                nCode:= 6;
                for I := 0 to BaseObject.m_SlaveList.Count - 1 do begin
                  Slave := TBaseObject(BaseObject.m_SlaveList.Items[I]);
                  nCode:= 7;
                  if Slave <> nil then begin
                    if Slave.m_btRaceServer = RC_PLAYMOSTER then begin
                      nCode:= 8;
                      Slave.m_dwPKTick := GetTickCount();
                      Slave.m_boPKFlag := True;
                      nCode:= 9;
                      Slave.RefNameColor();
                      Break;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage('{异常} TBaseObject.SetPKFlag  Code:'+inttostr(nCode));
  end;
end;

function TBaseObject.IsGoodKilling(Cert: TBaseObject): Boolean;
begin
  Result := False;
  if Cert.m_boPKFlag then Result := True;
end;

function TBaseObject.IsProtectTarget(BaseObject: TBaseObject): Boolean;
begin
  Result := True;
  if BaseObject = nil then Exit;
  if (InSafeZone) or (BaseObject.InSafeZone) then Result := False;//安全区
  if not BaseObject.m_boInFreePKArea then begin
    //新人保护
    if g_Config.boPKLevelProtect then begin
      if (m_Abil.Level > g_Config.nPKProtectLevel) then begin //如果大于指定等级
        if not BaseObject.m_boPKFlag and (BaseObject.m_Abil.Level <= g_Config.nPKProtectLevel) and (BaseObject.PKLevel < 2) then begin
          //被攻击的人物小指定等级没有红名，则不可以攻击。
          Result := False;
          Exit;
        end;
      end;
      if (m_Abil.Level <= g_Config.nPKProtectLevel) then begin //如果小于指定等级
        if not BaseObject.m_boPKFlag and (BaseObject.m_Abil.Level > g_Config.nPKProtectLevel) and (BaseObject.PKLevel < 2) then begin
          Result := False;
          Exit;
        end;
      end;
    end;

    {
    //大于指定级别的红名人物不可以杀指定级别未红名的人物。
    if (PKLevel >= 2) and (m_Abil.Level > 10) then begin
      if (BaseObject.m_Abil.Level <= 10) and (BaseObject.PKLevel < 2) then begin
        Result:=False;
        exit;
      end;
    end;

    //小于指定级别的非红名人物不可以杀指定级别红名人物。
    if (m_Abil.Level <= 10) and (PKLevel < 2) then begin
      if (BaseObject.PKLevel >= 2) and (BaseObject.m_Abil.Level > 10) then begin
        Result:=False;
        exit;
      end;
    end;
    }
    //大于指定级别的红名人物不可以杀指定级别未红名的人物。
    if (PKLevel >= 2) and (m_Abil.Level > g_Config.nRedPKProtectLevel) then begin
      if (BaseObject.m_Abil.Level <= g_Config.nRedPKProtectLevel) and (BaseObject.PKLevel < 2) then begin
        Result := False;
        Exit;
      end;
    end;

    //小于指定级别的非红名人物不可以杀指定级别红名人物。
    if (m_Abil.Level <= g_Config.nRedPKProtectLevel) and (PKLevel < 2) then begin
      if (BaseObject.PKLevel >= 2) and (BaseObject.m_Abil.Level > g_Config.nRedPKProtectLevel) then begin
        Result := False;
        Exit;
      end;
    end;

    if (GetTickCount - m_dwMapMoveTick < 3000) or (GetTickCount - BaseObject.m_dwMapMoveTick < 3000) then
      Result := False;
  end;
end;
//是否是攻击目标
function TBaseObject.IsAttackTarget(BaseObject: TBaseObject): Boolean;
var
  I: Integer;
  nCode: Byte;
begin
  Result := False;
  nCode:= 0;
  try
    if (BaseObject = nil) or ((BaseObject <> nil) and (BaseObject = Self)) then Exit;
    nCode:= 1;
    if BaseObject.m_btRaceServer = 135 then Exit;//20080122 135新型怪 让角色或英雄、宝宝不攻击
    nCode:= 2;
    if m_btRaceServer >= RC_ANIMAL {50} then begin //
      nCode:= 3;
      if m_Master <> nil then begin
        if m_Master.m_LastHiter <> nil then begin
          if m_Master.m_LastHiter = BaseObject then Result := True;
        end;
        if m_Master.m_ExpHitter <> nil then begin
          if m_Master.m_ExpHitter = BaseObject then Result := True;
        end;
        if m_Master.m_TargetCret <> nil then begin
          if m_Master.m_TargetCret = BaseObject then  Result := True;
        end;
       { if (m_Master.m_LastHiter = BaseObject) or
           (m_Master.m_ExpHitter = BaseObject) or
           (m_Master.m_TargetCret = BaseObject) then  Result := True; //宝宝攻击 }
        nCode:= 4;
        if (m_btRaceServer = RC_HEROOBJECT) and (not Result) then begin
           if (m_TargetCret = BaseObject) or (m_LastHiter = BaseObject) or (m_ExpHitter = BaseObject) then  Result := True;
           if (m_SlaveList.Count > 0) and (not Result) then begin
             for I := 0 to m_SlaveList.Count - 1 do begin
               if TBaseObject(m_SlaveList.Items[I]).m_TargetCret <> nil then begin//20080803 攻击下属的目标
                 nCode:= 121;
                 if TBaseObject(m_SlaveList.Items[I]).m_TargetCret =  BaseObject then begin
                   nCode:= 122;
                   Result := True;
                   Break;
                 end;
               end;
             end;
           end;
          if (m_Master <> nil) and (not Result) then begin
            if (m_Master.m_SlaveList.Count > 0) then begin
              for I := 0 to m_Master.m_SlaveList.Count - 1 do begin
                if TBaseObject(m_Master.m_SlaveList.Items[I]).m_TargetCret <> nil then begin
                   nCode:= 123;
                   if TBaseObject(m_Master.m_SlaveList.Items[I]).m_TargetCret = BaseObject then begin
                     nCode:= 124;
                     Result := True;
                     Break;
                   end;
                end;
              end;
            end;
          end;
        end;
        nCode:= 5;
        if BaseObject.m_TargetCret <> nil then begin
          if (BaseObject.m_TargetCret = m_Master)  and (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) then Result := True;
         { nCode:= 111;
          if BaseObject.m_TargetCret.m_Master <> nil then begin
            nCode:= 112;
            if (BaseObject.m_TargetCret.m_Master = m_Master) and (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) then Result := True;
          end;}
          nCode:= 6;
          if (BaseObject.m_TargetCret = Self) and (BaseObject.m_btRaceServer >{=} RC_ANIMAL) then Result := True;
        end;
        nCode:= 7;
        if (BaseObject.m_Master <> nil) and (not Result) then begin
          nCode:= 107;
          if (m_Master.m_LastHiter <> nil) then
            if (BaseObject.m_Master = m_Master.m_LastHiter) then Result := True;
          nCode:= 108;
          if (m_Master.m_TargetCret <> nil) then
            if (BaseObject.m_Master = m_Master.m_TargetCret) then Result := True;

          if (BaseObject.m_Master <> nil) and Result then begin
            nCode:= 109;
            if (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) then begin//20080812 不打英雄下属
               nCode:= 110;
               if BaseObject.m_Master.m_Master <> nil then begin
                 nCode:= 111;
                 if BaseObject.m_Master.m_Master = m_Master then Result := False;
               end;
            end;
          end;
        end;

        nCode:= 20;
        if ((m_Master.m_btRaceServer = RC_PLAYOBJECT) or (m_Master.m_btRaceServer = RC_HEROOBJECT)) and Result then begin
          case m_Master.m_btAttatckMode of //20080510
           (*HAM_ALL {0}: begin //全体攻击
              if (BaseObject.m_btRaceServer < RC_NPC {10}) or (BaseObject.m_btRaceServer > RC_PEACENPC {15}) then Result := True;
            end;*)
            HAM_PEACE {1}: begin//和平攻击
                nCode:= 21;
                if BaseObject.m_btRaceServer < RC_ANIMAL then Result := False;
                nCode:= 22;
                if BaseObject.m_Master <> nil then Result := False;
              end;
            HAM_DEAR: begin //夫妻攻击
                nCode:= 23;
                if m_Master <> nil then begin
                  nCode:= 28;
                  if (TPlayObject(m_Master).m_DearHuman <> nil) and (BaseObject <> nil) then begin//20080713 增加
                    nCode:= 112;
                    if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (BaseObject = TPlayObject(m_Master).m_DearHuman) then Result := False;
                    nCode:= 24;
                    if BaseObject <> nil then begin
                      if BaseObject.m_Master <> nil then begin//20080521 增加
                        nCode:= 25;
                        if BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT then begin
                          nCode:= 26;
                          if BaseObject.m_Master.m_Master = TPlayObject(m_Master).m_DearHuman then Result := False;
                        end else if BaseObject.m_Master = TPlayObject(m_Master).m_DearHuman then Result := False;
                        nCode:= 27;
                      end;
                    end;
                  end;
                end;
              end;
            HAM_MASTER: begin//师徒攻击
                if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                  nCode:= 29;
                  if (m_Master <> nil) and (BaseObject <> nil) then begin
                    nCode:= 30;
                    if (TPlayObject(m_Master).m_boMaster) then
                      if TPlayObject(BaseObject).m_sMasterName = m_Master.m_sCharName then Result := False;
                  end;
                  nCode:= 31;
                  if TPlayObject(BaseObject).m_boMaster then begin
                    nCode:= 32;
                    if m_Master.m_btRaceServer = RC_PLAYOBJECT then//主人是人
                       if BaseObject.m_sCharName = TPlayObject(m_Master).m_sMasterName then Result := False;
                    nCode:= 33;
                    if (m_Master.m_btRaceServer = RC_HEROOBJECT) and (m_Master.m_Master <> nil) then//主人是英雄
                       if BaseObject.m_sCharName = TPlayObject(m_Master.m_Master).m_sMasterName then Result := False;
                  end;
                end else begin
                  if BaseObject.m_Master <> nil then begin
                    nCode:= 38;
                    if (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) and (BaseObject.m_Master.m_Master <> nil) then begin
                      nCode:= 39;
                      if (m_Master <> nil) then begin
                        nCode:= 40;
                        if (TPlayObject(m_Master).m_boMaster) then
                          if TPlayObject(BaseObject.m_Master.m_Master).m_sMasterName = m_Master.m_sCharName then Result := False;
                      end;
                      nCode:= 41;
                      if TPlayObject(BaseObject.m_Master.m_Master).m_boMaster then begin
                        nCode:= 42;
                        if m_Master.m_btRaceServer = RC_PLAYOBJECT then//主人是人
                           if BaseObject.m_Master.m_Master.m_sCharName = TPlayObject(m_Master).m_sMasterName then Result := False;
                        nCode:= 43;
                        if (m_Master.m_btRaceServer = RC_HEROOBJECT) and (m_Master.m_Master <> nil) then//主人是英雄
                           if BaseObject.m_Master.m_Master.m_sCharName = TPlayObject(m_Master.m_Master).m_sMasterName then Result := False;
                      end;
                    end else begin//主人不是英雄
                      if (BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                        nCode:= 45;
                        if (m_Master <> nil) then begin
                          nCode:= 125; 
                          if (TPlayObject(m_Master).m_boMaster) then
                            if TPlayObject(BaseObject.m_Master).m_sMasterName = m_Master.m_sCharName then Result := False;
                        end;
                        nCode:= 48;
                        if TPlayObject(BaseObject.m_Master).m_boMaster then begin
                          nCode:= 46;
                          if m_Master.m_btRaceServer = RC_PLAYOBJECT then//主人是人
                             if BaseObject.m_Master.m_sCharName = TPlayObject(m_Master).m_sMasterName then Result := False;
                          nCode:= 47;
                          if (m_Master.m_btRaceServer = RC_HEROOBJECT) and (m_Master.m_Master <> nil) then//主人是英雄
                             if BaseObject.m_Master.m_sCharName = TPlayObject(m_Master.m_Master).m_sMasterName then Result := False;
                        end;
                      end;
                    end;
                  end;//if BaseObject.m_Master <> nil then begin
                end;//
              end;
            HAM_GROUP {2}: begin //编组攻击
                nCode:= 55;
                if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                  if TPlayObject(m_Master).IsGroupMember(BaseObject) then begin
                    Result := False;
                    BreakCrazyMode();
                    Exit;
                  end;
                nCode:= 56;
                if m_Master.m_btRaceServer = RC_HEROOBJECT then begin//20080707
                  nCode:= 57;
                  if (m_Master.m_Master <> nil) then
                     if TPlayObject(m_Master.m_Master).IsGroupMember(BaseObject) then begin
                       Result := False;
                       BreakCrazyMode();
                       Exit;
                     end;
                  nCode:= 58;
                  if (BaseObject <> nil) and (BaseObject.m_Master <> nil) and (m_Master.m_Master <> nil) and (m_Master.m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                     nCode:= 72;
                     if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                       nCode:= 96;
                       if TPlayObject(m_Master.m_Master).IsGroupMember(BaseObject.m_Master) then begin
                          Result := False;
                          BreakCrazyMode();
                          Exit;
                       end;
                     end;
                     nCode:= 73;
                     if (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) and (BaseObject.m_Master.m_Master<> nil) then begin
                       nCode:= 97;
                       if TPlayObject(m_Master.m_Master).IsGroupMember(BaseObject.m_Master.m_Master) then begin
                         Result := False;
                         BreakCrazyMode();
                         Exit;
                       end;
                     end;
                  end;
                end;
                if m_Master.m_btRaceServer = RC_PLAYOBJECT then begin//20080721
                  nCode:= 59;
                  if TPlayObject(m_Master).IsGroupMember(BaseObject) then begin
                     Result := False;
                     BreakCrazyMode();
                     Exit;
                  end;
                  nCode:= 71;
                  if (BaseObject <> nil) and Result then begin //20080916 修改
                    if (BaseObject.m_Master <> nil) and (m_Master <> nil) then begin//20080812 
                       nCode:= 82;
                       if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                         nCode:= 126;
                         if TPlayObject(m_Master).IsGroupMember(BaseObject.m_Master) then Result := False;
                       end;
                       nCode:= 95;
                       if (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) and (BaseObject.m_Master.m_Master<> nil) and Result then begin
                         nCode:= 127;
                         if TPlayObject(m_Master).IsGroupMember(BaseObject.m_Master.m_Master) then Result := False;
                       end;
                    end;
                  end;
                end;
              end;
            HAM_GUILD {3}: begin //行会攻击 20080512
                nCode:= 60;
                if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                  if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                    if (m_Master.m_MyGuild <> nil) then begin
                      nCode:= 61;
                      if TGUild(m_Master.m_MyGuild).IsMember(BaseObject.m_sCharName) then Result := False;
                      nCode:= 62;
                      if m_boGuildWarArea and (BaseObject.m_MyGuild <> nil) then begin
                        nCode:= 63;
                        if TGUild(m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild)) then Result := False;
                      end;
                    end;
                  end else begin
                    nCode:= 161;
                    if m_Master.m_Master <> nil then begin
                      nCode:= 162;
                      if (m_Master.m_Master.m_MyGuild <> nil) then begin
                        nCode:= 163;
                        if TGUild(m_Master.m_Master.m_MyGuild).IsMember(BaseObject.m_sCharName) then Result := False;
                        nCode:= 164;
                        if m_boGuildWarArea and (BaseObject.m_MyGuild <> nil) then begin
                          nCode:= 165;
                          if TGUild(m_Master.m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild)) then Result := False;
                        end;
                      end;
                    end;
                  end;
                end;
                nCode:= 64;
                if (BaseObject.m_btRaceServer = RC_HEROOBJECT) and (BaseObject.m_Master <> nil) then begin
                  nCode:= 65;
                  if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                    if (m_Master.m_MyGuild <> nil) then begin
                      nCode:= 66;
                      if TGUild(m_Master.m_MyGuild).IsMember(BaseObject.m_Master.m_sCharName) then Result := False;
                      nCode:= 67;
                      if m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin
                        nCode:= 68;
                        if TGUild(m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then Result := False;
                      end;
                    end;
                  end else begin
                    nCode:= 166;
                    if m_Master.m_Master <> nil then begin
                      nCode:= 167;
                      if (m_Master.m_Master.m_MyGuild <> nil) then begin
                        nCode:= 168;
                        if TGUild(m_Master.m_Master.m_MyGuild).IsMember(BaseObject.m_Master.m_sCharName) then Result := False;
                        nCode:= 169;
                        if m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin
                          nCode:= 170;
                          if TGUild(m_Master.m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then Result := False;
                        end;
                      end;
                    end;
                  end;
                end;//if BaseObject.m_Master <> nil
              end;
          end;//Case
        end;

        nCode:= 8;                                               {20080211}
        if (BaseObject.m_Master = m_Master) or (BaseObject = m_Master) then Result := False; {检测是主人不攻击主人}
        nCode:= 9;
        if (m_Master.m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_Master <> nil) then
          if (TPlayObject(m_Master).m_MyHero <> nil) and (BaseObject.m_Master = TPlayObject(m_Master).m_MyHero) then Result := False;//20080614 主人下属不打英雄下属
        nCode:= 10;
        if (m_Master.m_btRaceServer = RC_HEROOBJECT) then begin
          nCode:= 11;
          if m_Master.m_Master <> nil then begin //20080213
            nCode:= 12;
            if BaseObject = m_Master.m_Master then Result := False; {如果主人是英雄,不攻击英雄的主人}
            nCode:= 13;
            if (m_Master.m_Master.m_SlaveList.Count > 0) {and (m_btAttatckMode <> HAM_ALL)} then begin//英雄的下属不打主人下属
              nCode:= 14;
              for I := 0 to m_Master.m_Master.m_SlaveList.Count - 1 do begin  //20080406
                nCode:= 15;
                if TBaseObject(m_Master.m_Master.m_SlaveList.Items[I]) = BaseObject then begin
                  nCode:= 16;
                  Result := False;
                  Break;
                end;
              end;
            end;
          end;
        end;
        nCode:= 17;
        if (m_SlaveList.Count > 0) and (m_btAttatckMode <> HAM_ALL) then begin//20080212 不能锁定自己的下属
          nCode:= 18;
          for I := 0 to m_SlaveList.Count - 1 do begin
            nCode:= 19;
            if TBaseObject(m_SlaveList.Items[I]) = BaseObject then begin
              nCode:= 20;
              Result := False;
              Break;
            end;
          end;
        end;

      {  if (m_Master.m_SlaveList.Count > 0) and (m_btAttatckMode <> HAM_ALL) then begin
          for I := 0 to m_Master.m_SlaveList.Count - 1 do begin  //20080212
            if TBaseObject(m_Master.m_SlaveList.Items[I]) = BaseObject then begin
              Result := False;
              Break;
            end;
          end;
        end; }

        nCode:= 74;
        if BaseObject.m_boHolySeize then  Result := False;
        nCode:= 75;
        if (m_Master.m_boSlaveRelax) and (m_btRaceServer <> RC_HEROOBJECT) then Result := False; {检测宝宝是否处于休息状态,英雄除外}
        nCode:= 76;
        if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_btRaceServer = RC_HEROOBJECT) or (BaseObject.m_Master <> nil) then begin //安全区不能打人物和英雄
          nCode:= 77;
          //if (m_Master.InSafeZone) or (BaseObject.InSafeZone) then begin
          if BaseObject.InSafeZone or InSafeZone then  Result := False;//20080721 修改
        end;
        nCode:= 78;
        BreakCrazyMode();
      end else begin
        nCode:= 79;
        if BaseObject.m_btRaceServer = RC_PLAYOBJECT then  Result := True;
        nCode:= 80;
        if (m_btRaceServer > RC_PEACENPC {15}) and (m_btRaceServer < RC_ANIMAL {50}) then  Result := True;
        nCode:= 81;
        if BaseObject.m_Master <> nil then Result := True;
      end; //if m_Master <> nil then begin
      nCode:= 96;
      if ((BaseObject.m_btRaceServer = 10) or (BaseObject.m_btRaceServer = 11) or (BaseObject.m_btRaceServer = RC_GUARD))
      and ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_Master <> nil)) then  Result := False;//20080408 英雄不打卫士(10-12分类的怪) 20080409
      nCode:= 83;
      if m_boCrazyMode then  Result := True;
    end else begin
      nCode:= 84;
      if m_btRaceServer = RC_PLAYOBJECT then begin {增加分身检测}
        case m_btAttatckMode of //攻击状态
          HAM_ALL {0}: begin //全体攻击
              nCode:= 85;
              if (BaseObject.m_btRaceServer < RC_NPC {10}) or (BaseObject.m_btRaceServer > RC_PEACENPC {15}) then Result := True;
              if g_Config.boNonPKServer then Result := True;//没有禁止PK
            end;
          HAM_PEACE {1}: begin//和平攻击
              nCode:= 86;
              if BaseObject.m_btRaceServer >= RC_ANIMAL then Result := True;
              if BaseObject.m_Master <> nil then Result := False;//20080521
            end;
          HAM_DEAR: begin //夫妻攻击
              nCode:= 87;
              if BaseObject <> TPlayObject(Self).m_DearHuman then Result := True;
              if BaseObject.m_Master <> nil then begin//20080521
                 if BaseObject.m_Master <> TPlayObject(Self).m_DearHuman then Result := True;
              end;
            end;
          HAM_MASTER: begin//师徒攻击
              nCode:= 88;
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                nCode:= 89;
                Result := True;
                if TPlayObject(Self).m_boMaster then begin
                  if TPlayObject(Self).m_MasterList.Count > 0 then begin//20080629
                    for I := 0 to TPlayObject(Self).m_MasterList.Count - 1 do begin
                      if TPlayObject(Self).m_MasterList.Items[I] = BaseObject then begin
                        Result := False;
                        Break;
                      end;
                    end;
                  end;
                end;
                if TPlayObject(BaseObject).m_boMaster then begin
                  if TPlayObject(BaseObject).m_MasterList.Count > 0 then begin//20080629
                    for I := 0 to TPlayObject(BaseObject).m_MasterList.Count - 1 do begin
                      if TPlayObject(BaseObject).m_MasterList.Items[I] = Self then begin
                        Result := False;
                        Break;
                      end;
                    end;//for
                  end;
                end;
              end else  Result := True;
            end;
          HAM_GROUP {2}: begin //编组攻击
              nCode:= 90;
              if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then
                Result := True;
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                if TPlayObject(Self).IsGroupMember(BaseObject) then Result := False;
              
              if BaseObject.m_Master <> nil then begin//20080611 修改
                if BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT then begin
                   if BaseObject.m_Master.m_Master <> nil then
                      if TPlayObject(Self).IsGroupMember(BaseObject.m_Master.m_Master) then Result := False;
                end else
                if TPlayObject(Self).IsGroupMember(BaseObject.m_Master) then Result := False;
              end;

              if g_Config.boNonPKServer then Result := True;
            end;
          HAM_GUILD {3}: begin //行会攻击
              nCode:= 91;
              if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then
                Result := True;
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                if m_MyGuild <> nil then begin
                  if TGUild(m_MyGuild).IsMember(BaseObject.m_sCharName) then
                    Result := False;
                  if m_boGuildWarArea and (BaseObject.m_MyGuild <> nil) then begin
                    if TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild)) then
                      Result := False;
                  end;
                end;
              end else begin//20080611 不打同行会的宝宝
                nCode:= 92;
                if BaseObject.m_Master <> nil then begin
                  if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                    if m_MyGuild <> nil then begin
                      if TGUild(m_MyGuild).IsMember(BaseObject.m_Master.m_sCharName) then
                        Result := False;
                      if m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin
                        if TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then
                          Result := False;
                      end;
                    end;
                  end else
                  if BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT then begin
                    nCode:= 93;
                    if (m_MyGuild <> nil) and (BaseObject.m_Master.m_Master <> nil) then begin
                      if TGUild(m_MyGuild).IsMember(BaseObject.m_Master.m_Master.m_sCharName) then
                        Result := False;
                      if m_boGuildWarArea and (BaseObject.m_Master.m_Master.m_MyGuild <> nil) then begin
                        if TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_Master.m_MyGuild)) then
                          Result := False;
                      end;
                    end;
                   end;
                end;//if BaseObject.m_Master <> nil
              end;
              if g_Config.boNonPKServer then Result := True;
            end;
          HAM_PKATTACK {4}: begin//红名攻击
              nCode:= 94;
              if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then
                Result := True;
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                if PKLevel >= 2 then begin
                  if BaseObject.PKLevel < 2 then
                    Result := True
                  else Result := False;
                end else begin
                  if BaseObject.PKLevel >= 2 then
                    Result := True
                  else Result := False;
                end;
              if g_Config.boNonPKServer then Result := True;
            end;
        end;
        //if BaseObject = m_MyHero then Result := False;//是自己的英雄不攻击  2007-3-25
      end else Result := True;
    end;
    if BaseObject.m_boAdminMode or BaseObject.m_boStoneMode then Result := False;
  except
    //MainOutMessage('{异常} TBaseObject.IsAttackTarget Code:'+inttostr(nCode));
  end;
end;
//是否是适当的目标
function TBaseObject.IsProperTarget(BaseObject: TBaseObject): Boolean;
var I:integer;
    nCode: Byte;
begin
  nCode:= 0;
  try
    Result := IsAttackTarget(BaseObject);
    nCode:= 1;
    if Result then begin
      nCode:= 2;
      if (m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
        nCode:= 3;
        Result := IsProtectTarget(BaseObject); {检测人物是否符合攻击要求}
      end;
    end;
    nCode:= 4;
    if (BaseObject <> nil) and
     (m_btRaceServer = RC_PLAYOBJECT) and
     (BaseObject.m_Master <> nil) and
     (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) then begin
      nCode:= 5;
      if BaseObject.m_Master = Self then begin
        nCode:= 6;
        if (m_btAttatckMode <> HAM_ALL) {or 20080402换成and}and (BaseObject = TPlayObject(Self).m_MyHero) then Result := False; {检测是否是自己的宝宝}
        nCode:= 7;
        if (m_SlaveList.Count > 0) and (m_btAttatckMode <> HAM_ALL) then begin    //20080322 不能锁定主人的下属
          nCode:= 8;
          for I := 0 to m_SlaveList.Count - 1 do begin
            nCode:= 9;
            if TBaseObject(m_SlaveList.Items[I]) = BaseObject then begin
              nCode:= 10;
              Result := False;
              Break;
            end;
          end;
        end;
      end else begin
        nCode:= 11;
        Result := IsAttackTarget(BaseObject.m_Master);//20080522
        nCode:= 12;
        if InSafeZone or BaseObject.InSafeZone then Result := False; {检测是否是在安全区}
        nCode:= 13;
        if (m_btRaceServer = RC_HEROOBJECT) and (InSafeZone or BaseObject.InSafeZone)and (BaseObject.m_Master <> nil) then Result := False;//20080404 英雄不能在安全区PK
        nCode:= 14;
        if (TPlayObject(self).m_MyHero <> nil)  and (m_btAttatckMode <> HAM_ALL) then begin   //20080323 不能锁定英雄的下属
          nCode:= 15;
          if (TPlayObject(self).m_MyHero.m_SlaveList.Count > 0) and (m_btAttatckMode <> HAM_ALL) then begin
            nCode:= 16;
            for I := 0 to TPlayObject(self).m_MyHero.m_SlaveList.Count - 1 do begin
              nCode:= 17;
              if TBaseObject(TPlayObject(self).m_MyHero.m_SlaveList.Items[I]) = BaseObject then begin
                nCode:= 18;
                Result := False;
                Break;
              end;
            end;
          end;
        end;// if (m_Master <> nil) then begin
      end;
    end;// else
  except
    MainOutMessage('{异常} TBaseObject.IsProperTarget Code:'+inttostr(nCode));
  end;   
end;

//擒龙手目标检测
function TBaseObject.IsProperTargetSKILL_55(nLevel: Integer; BaseObject: TBaseObject): Boolean;
begin
  Result := False;
  if (BaseObject = nil) or (BaseObject = Self) then Exit;
  if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then begin
    if (BaseObject.m_btRaceServer <> RC_GUARD) and
      (BaseObject.m_btRaceServer <> RC_ARCHERGUARD) and
      (BaseObject.m_btRaceServer <> 110) and
      (BaseObject.m_btRaceServer <> 111) and
      (nLevel >= BaseObject.m_Abil.Level) and
      (not BaseObject.m_boGhost) and
      (not BaseObject.m_boDeath) then begin
      if ((not g_Config.boPullPlayObject) or (nLevel < BaseObject.m_Abil.Level)) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then Exit;
      if g_Config.boPullCrossInSafeZone and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and BaseObject.InSafeZone then Exit;
      if g_Config.boPullCrossInSafeZone and (BaseObject.m_Master <> nil) and BaseObject.InSafeZone then Exit; //不允许抓安全区的宝宝
      Result := True;
    end;
  end;
end;

//骷髅咒
function TBaseObject.IsProperTargetSKILL_54(BaseObject: TBaseObject): Boolean;
begin
  Result := False;
  if (BaseObject = nil) or (BaseObject = Self) then Exit;
  if BaseObject.m_boDeath and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
    if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then begin
      if (BaseObject.m_btRaceServer <> RC_GUARD) and
        (BaseObject.m_btRaceServer <> RC_ARCHERGUARD) and
        (BaseObject.m_btRaceServer <> 110) and
        (BaseObject.m_btRaceServer <> 111) then Result := True;
    end;
  end;
end;

//复活术
function TBaseObject.IsProperTargetSKILL_57(BaseObject: TBaseObject): Boolean;
begin
  Result := False;
  if (BaseObject = nil) or (BaseObject = Self) then Exit;
  if BaseObject.m_boDeath and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
    if TPlayObject(BaseObject).m_boAllowReAlive then Result := True
    else SysMsg('对方禁止复活！！！', c_Green, t_Hint);
  end;
end;

{//召唤NPC  未使用 20080329
function TBaseObject.IsProperTargetSKILL_70(PlayObject: TBaseObject): Boolean;
begin
  Result := False;
  if (g_FunctionNPC <> nil) and (PlayObject <> nil) then begin
    if PlayObject.m_btRaceServer = RC_PLAYOBJECT then begin
      g_FunctionNPC.GotoLable(TPlayObject(PlayObject), '@Magic', False);
      Result := True;
    end;
  end;
end; }

//死亡触发函数
function TPlayObject.DieGotoLable(): Boolean;
begin
  Result := False;
  if (m_LastHiter <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin
    if m_LastHiter.m_Master <> nil then begin
      if m_LastHiter.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
        m_sString[0] := TPlayObject(m_LastHiter.m_Master).m_sCharName;
        m_nInteger[0] := TPlayObject(m_LastHiter.m_Master).m_WAbil.Level;
        TPlayObject(m_LastHiter.m_Master).m_sString[0] := m_sCharName;
        TPlayObject(m_LastHiter.m_Master).m_nInteger[0] := m_WAbil.Level;
        TPlayObject(m_LastHiter.m_Master).KillPlayFunc;
      end else
      if m_LastHiter.m_Master.m_btRaceServer = RC_HEROOBJECT then begin//20081102 英雄下属杀人
        if m_LastHiter.m_Master.m_Master <> nil then begin
          m_sString[0] := TPlayObject(m_LastHiter.m_Master.m_Master).m_sCharName;
          m_nInteger[0] := TPlayObject(m_LastHiter.m_Master.m_Master).m_WAbil.Level;
          TPlayObject(m_LastHiter.m_Master.m_Master).m_sString[0] := m_sCharName;
          TPlayObject(m_LastHiter.m_Master.m_Master).m_nInteger[0] := m_WAbil.Level;
          TPlayObject(m_LastHiter.m_Master.m_Master).KillPlayFunc;
        end;
      end;
    end else
      if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then begin
      m_sString[0] := TPlayObject(m_LastHiter).m_sCharName;
      m_nInteger[0] := TPlayObject(m_LastHiter).m_WAbil.Level;
      TPlayObject(m_LastHiter).m_sString[0] := m_sCharName;
      TPlayObject(m_LastHiter).m_nInteger[0] := m_WAbil.Level;
      TPlayObject(m_LastHiter).KillPlayFunc;
    end;
    if m_LastHiter.m_btRaceServer <> RC_PLAYOBJECT then begin
      m_sString[0] := m_LastHiter.m_sCharName;
      m_nInteger[0] := m_LastHiter.m_WAbil.Level;
    end;
    Result := DieFunc(); //死亡触发
  end;
end;
//负重改变
procedure TBaseObject.WeightChanged;
begin
  m_WAbil.Weight := RecalcBagWeight();
  SendUpdateMsg(Self, RM_WEIGHTCHANGED, 0, 0, 0, 0, '');
end;

function TBaseObject.InSafeZone: Boolean;
var
  I , nSafeX, nSafeY: Integer;
  sMapName: string;
  StartPoint: pTStartPoint;
  nCode: Byte;//20081030
begin
  Result := False;//20080818 增加
  nCode:= 0;
  if self = nil then Exit;//20080801
  if m_boGhost then Exit;//20081228
  try
    nCode:= 1;
    if m_PEnvir = nil then begin //修正机器人刷火墙的错误
      Result := True;
      Exit;
    end;
    nCode:= 2;
    if (m_PEnvir <> nil) and (not m_boGhost) then begin//20081228
      nCode:= 21;
      try
        Result := m_PEnvir.m_boSAFE;
        nCode:= 22;
        if Result then Exit;
        nCode:= 3;
        if (m_PEnvir.sMapName <> g_Config.sRedHomeMap) or
          (abs(m_nCurrX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
          (abs(m_nCurrY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then begin
          Result := False;
        end else begin
          Result := True;
        end;
      except
      end;
    end;
    nCode:= 4;
    if Result then Exit;
    try
      g_StartPointList.Lock;
      nCode:= 5;
      if g_StartPointList.Count > 0 then begin//20080629
        for I := 0 to g_StartPointList.Count - 1 do begin
          nCode:= 6;
          sMapName := g_StartPointList.Strings[I];
          if m_boGhost then Break;//20081228
          {nSafePoint := Integer(g_StartPointList.Objects[i]);
          nSafeX := LoWord(nSafePoint);
          nSafeY := HiWord(nSafePoint); }
          nCode:= 12;
          try
            if (m_PEnvir <> nil) and (sMapName <>'') and (not m_boGhost) then begin//20081228
              nCode:= 11;
              if (sMapName = m_PEnvir.sMapName) then begin
                nCode:= 8;
                StartPoint := pTStartPoint(g_StartPointList.Objects[I]);
                if StartPoint <> nil then begin
                  nCode:= 9;
                  nSafeX := StartPoint.m_nCurrX;
                  nSafeY := StartPoint.m_nCurrY;
                  nCode:= 10;
                  if (abs(m_nCurrX - nSafeX) <= g_Config.nSafeZoneSize) and
                    (abs(m_nCurrY - nSafeY) <= g_Config.nSafeZoneSize) then begin
                    Result := True;
                    Break;
                  end;
                end;
              end;
            end;
          except
            Break;
          end;
        end;//for
      end;
    finally
      g_StartPointList.UnLock;
    end;
  except
    MainOutMessage('{异常} TBaseObject.InSafeZone Code:'+ IntToStr(nCode));
  end;
end;

function TBaseObject.InSafeZone(Envir: TEnvirnoment; nX, nY: Integer): Boolean;
var
  I, nSafeX, nSafeY: Integer;
  sMapName: string;
  StartPoint: pTStartPoint;
begin
  if m_PEnvir = nil then begin //修正机器人刷火墙的错误 叶随风飘
    Result := True;
    Exit;
  end;
  Result := Envir.m_boSAFE;
  if Result then Exit;
  if (Envir.sMapName <> g_Config.sRedHomeMap) or
    (abs(nX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
    (abs(nY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then begin
    Result := False;
  end else begin
    Result := True;
  end;
  if Result then Exit;
  try
    g_StartPointList.Lock;
    if g_StartPointList.Count > 0 then begin//20080629
      for I := 0 to g_StartPointList.Count - 1 do begin
        sMapName := g_StartPointList.Strings[I];
        if (sMapName = Envir.sMapName) then begin
          StartPoint := pTStartPoint(g_StartPointList.Objects[I]);
          if StartPoint <> nil then begin
            nSafeX := StartPoint.m_nCurrX;
            nSafeY := StartPoint.m_nCurrY;
            if (abs(nX - nSafeX) <= g_Config.nSafeZoneSize) and
              (abs(nY - nSafeY) <= g_Config.nSafeZoneSize) then begin
              Result := True;
              Break;
            end;
          end;
        end;
      end;//for
    end;
  finally
    g_StartPointList.UnLock;
  end;
end;

//不能走动模式
procedure TBaseObject.OpenHolySeizeMode(dwInterval: LongWord);
begin
  m_boHolySeize := True;
  m_dwHolySeizeTick := GetTickCount();
  m_dwHolySeizeInterval := dwInterval;
  RefNameColor();
end;

procedure TBaseObject.BreakHolySeizeMode;
begin
  m_boHolySeize := False;
  RefNameColor();
end;
//开启怪物狂化模式
procedure TBaseObject.OpenCrazyMode(nTime: Integer);
begin
  m_boCrazyMode := True;
  m_dwCrazyModeTick := GetTickCount();
  m_dwCrazyModeInterval := nTime * 1000;
  RefNameColor();
end;
//关闭怪物狂化模式
procedure TBaseObject.BreakCrazyMode;
begin
  if m_boCrazyMode then begin
    m_boCrazyMode := False;
    RefNameColor();
  end;
end;

procedure TPlayObject.LeaveGroup;
resourcestring
  sExitGropMsg = '%s 已经退出了本组....';
begin
  SendGroupText(Format(sExitGropMsg, [m_sCharName]));
  m_GroupOwner := nil;
  SendMsg(Self, RM_GROUPCANCEL, 0, 0, 0, 0, '');
end;

function TPlayObject.CancelGroup: Boolean;
resourcestring
  sCanceGrop = '您的小组被解散了...';
begin
  Result := True;
  if m_GroupMembers.Count <= 1 then begin
    SendGroupText(sCanceGrop);
    m_GroupMembers.Clear;
    m_GroupOwner := nil;
    Result := False;
  end;
end;

procedure TPlayObject.SendGroupMembers;
var
  I: Integer;
  PlayObject: TPlayObject;
  sSENDMSG: string;
begin
  sSENDMSG := '';
  if m_GroupMembers.Count > 0 then begin//20080629
    for I := 0 to m_GroupMembers.Count - 1 do begin
      PlayObject := TPlayObject(m_GroupMembers.Objects[I]);
      if PlayObject <> nil then sSENDMSG := sSENDMSG + PlayObject.m_sCharName + '/';
    end;
    for I := 0 to m_GroupMembers.Count - 1 do begin
      PlayObject := TPlayObject(m_GroupMembers.Objects[I]);
      if PlayObject <> nil then PlayObject.SendDefMessage(SM_GROUPMEMBERS, 0, 0, 0, 0, sSENDMSG);
    end;
  end;
end;
//根据魔法ID,取魔法数据
function TPlayObject.GetMagicInfo(nMagicID: Integer): pTUserMagic;
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  Result := nil;
  if nMagicID in [60..65] then begin
    if m_MyHero <> nil then begin
      Result := THeroObject(m_MyHero).FindTogetherMagic;
      Exit;
    end;
  end;
  if m_MagicList.Count > 0 then begin//20080629
    for I := 0 to m_MagicList.Count - 1 do begin
      UserMagic := m_MagicList.Items[I];
      if UserMagic.MagicInfo.wMagicId = nMagicID then begin
        Result := UserMagic;
        Break;
      end;
    end;
  end;
end;

function TPlayObject.GetMagicInfo(sMagicName: string): pTUserMagic;
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  Result := nil;
  if m_MagicList.Count > 0 then begin//20080629
    for I := 0 to m_MagicList.Count - 1 do begin
      UserMagic := m_MagicList.Items[I];
      if CompareText(UserMagic.MagicInfo.sMagicName, sMagicName) = 0 then begin
        Result := UserMagic;
        Break;
      end;
    end;
  end;
end;
//取技能消耗的MP值
function TPlayObject.GetSpellPoint(UserMagic: pTUserMagic): Integer;
begin                       //spell-魔法消耗                        //修炼等级        //魔法等级                        //升级魔法
  Result := Round(UserMagic.MagicInfo.wSpell / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + UserMagic.MagicInfo.btDefSpell;
end;
//野蛮冲撞
function TPlayObject.DoMotaebo(nDir: Byte; nMagicLevel: Integer): Boolean;
  function CanMotaebo(BaseObject: TBaseObject): Boolean;
  var
    nC: Integer;
  begin
    Result := False;
    if (m_Abil.Level > BaseObject.m_Abil.Level) and (not BaseObject.m_boStickMode) then begin
      nC := m_Abil.Level - BaseObject.m_Abil.Level;
      if Random(20) < ((nMagicLevel * 4) + 6 + nC) then begin
        if IsProperTarget(BaseObject) then Result := True;
      end;
    end;
  end;
var
  bo35: Boolean;
  I, n20, n24, n28: Integer;
  PoseCreate: TBaseObject;
  BaseObject_30: TBaseObject;
  BaseObject_34: TBaseObject;
  nX, nY: Integer;
begin
  Result := False;
  bo35 := True;
  m_btDirection := nDir;
  BaseObject_34 := nil;
  n24 := nMagicLevel + 1;
  n28 := n24;
  PoseCreate := GetPoseCreate();
  if PoseCreate <> nil then begin
    for I := 0 to _MAX(2, nMagicLevel + 1) do begin
      PoseCreate := GetPoseCreate();
      if PoseCreate <> nil then begin
        n28 := 0;
        if not CanMotaebo(PoseCreate) then Break;
        if nMagicLevel >= 3 then begin
          if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then begin
            BaseObject_30 := m_PEnvir.GetMovingObject(nX, nY, True);
            if (BaseObject_30 <> nil) and CanMotaebo(BaseObject_30) then
              BaseObject_30.CharPushed(m_btDirection, 1);
          end;
        end;
        BaseObject_34 := PoseCreate;
        if PoseCreate.CharPushed(m_btDirection, 1) <> 1 then Break;
        GetFrontPosition(nX, nY);
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          SendRefMsg(RM_RUSH, nDir, m_nCurrX, m_nCurrY, 0, '');
          bo35 := False;
          Result := True;
        end;
        Dec(n24);
      end; //004C32D7  if PoseCreate <> nil  then begin
    end; //004C32DD for i:=0 to _MAX(2,nMagicLevel + 1) do begin
  end else begin //004C32E8 if PoseCreate <> nil  then begin
    bo35 := False;
    for I := 0 to _MAX(2, nMagicLevel + 1) do begin
      GetFrontPosition(nX, nY); //sub_004B2790
      if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then begin
        m_nCurrX := nX;
        m_nCurrY := nY;
        SendRefMsg(RM_RUSH, nDir, m_nCurrX, m_nCurrY, 0, '');
        Dec(n28);
      end else begin
        if m_PEnvir.CanWalk(nX, nY, True) then n28 := 0
        else begin
          bo35 := True;
          Break;
        end;
      end;
    end;
  end;
  if (BaseObject_34 <> nil) then begin
    if n24 < 0 then n24 := 0;
    n20 := Random((n24 + 1) * 10) + ((n24 + 1) * 10);
    n20 := BaseObject_34.GetHitStruckDamage(Self, n20);
    BaseObject_34.StruckDamage(n20);
    BaseObject_34.SendRefMsg(RM_STRUCK, n20, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Integer(Self), '');
    if BaseObject_34.m_btRaceServer <> RC_PLAYOBJECT then begin
      BaseObject_34.SendMsg(BaseObject_34, RM_STRUCK, n20, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Integer(Self), '');
    end;
  end;
  if bo35 then begin
    GetFrontPosition(nX, nY);
    SendRefMsg(RM_RUSHKUNG, m_btDirection, nX, nY, 0, '');
    SysMsg(sMateDoTooweak {冲撞力不够！！！}, c_Red, t_Hint);
  end;
  if n28 > 0 then begin
    if n24 < 0 then n24 := 0;
    n20 := Random(n24 * 10) + ((n24 + 1) * 3);
    n20 := GetHitStruckDamage(Self, n20);
    StruckDamage(n20);
    SendRefMsg(RM_STRUCK, n20, m_WAbil.HP, m_WAbil.MaxHP, 0, '');
  end;
end;
//增加技能的修练值 20080112
procedure TBaseObject.TrainSkill(UserMagic: pTUserMagic; nTranPoint: Integer);
begin
  if m_boFastTrain then nTranPoint := nTranPoint * 3;
  Inc(UserMagic.nTranPoint, nTranPoint);
end;
//20080111 检查魔法升级
function TBaseObject.CheckMagicLevelup(UserMagic: pTUserMagic): Boolean; //004C7054
var
  n10: Integer;
begin
  Result := False;
  if (UserMagic.btLevel < 4) and (UserMagic.MagicInfo.btTrainLv >= UserMagic.btLevel) then
    n10 := UserMagic.btLevel
  else n10 := 0;

  if (UserMagic.MagicInfo.btTrainLv > UserMagic.btLevel) and
    (UserMagic.MagicInfo.MaxTrain[n10] <= UserMagic.nTranPoint) then begin
    if (UserMagic.MagicInfo.btTrainLv > UserMagic.btLevel) then begin
      //先天元力不减修改经验 20080626
      if UserMagic.MagicInfo.wMagicId <> 67 then Dec(UserMagic.nTranPoint, UserMagic.MagicInfo.MaxTrain[n10]);
      Inc(UserMagic.btLevel);
      if m_btRaceServer = RC_HEROOBJECT then begin //英雄魔法升级
        THeroObject(Self).SendUpdateDelayMsg(m_Master, RM_HEROMAGIC_LVEXP, 0, UserMagic.MagicInfo.wMagicId, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
      end else begin
        SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, 0, UserMagic.MagicInfo.wMagicId, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
      end;
      sub_4C713C(UserMagic);
    end else begin
      UserMagic.nTranPoint := UserMagic.MagicInfo.MaxTrain[n10];
    end;
    Result := True;
  end;
end;

function TPlayObject.DoSpell(UserMagic: pTUserMagic; nTargetX,
  nTargetY: Integer; BaseObject: TBaseObject): Boolean;
var
  nSpellPoint: Integer;
begin
  Result := False;
  try
    if not MagicManager.IsWarrSkill(UserMagic.wMagIdx) then begin
      nSpellPoint := GetSpellPoint(UserMagic);
      if (nSpellPoint > 0) and (UserMagic.wMagIdx <> SKILL_68) and (UserMagic.wMagIdx <> SKILL_50) then begin//酒气护体,无极真气不在此处减HP
        if m_WAbil.MP < nSpellPoint then Exit;
        DamageSpell(nSpellPoint);
        HealthSpellChanged();
      end;
      if m_boTrainingNG then begin//20081003 学过内功心法,每攻击一次减一点内力值
        m_Skill69NH := _MAX(0, m_Skill69NH - g_Config.nHitStruckDecNH);
        SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
      end;
      Result := MagicManager.DoSpell(Self, UserMagic, nTargetX, nTargetY, BaseObject);
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format('{异常} TPlayObject.DoSpell MagID:%d X:%d Y:%d', [UserMagic.wMagIdx, nTargetX, nTargetY]));
    end;
  end;
end;

function TPlayObject.PileStones(nX, nY: Integer): Boolean;
var
  Event: TEvent;
  PileEvent: TEvent;
  s1C: string;
begin
  Result := False;
  s1C := '';
  Event := TEvent(m_PEnvir.GetEvent(nX, nY));
  if (Event <> nil) and (Event.m_nEventType = ET_STONEMINE) then begin
    if TStoneMineEvent(Event).m_nMineCount > 0 then begin
      Dec(TStoneMineEvent(Event).m_nMineCount);
      if Random(g_Config.nMakeMineHitRate {4}) = 0 then begin
        PileEvent := TEvent(m_PEnvir.GetEvent(m_nCurrX, m_nCurrY));
        if PileEvent = nil then begin
          PileEvent := TPileStones.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_PILESTONES, 300000{5 * 60 * 1000});
          g_EventManager.AddEvent(PileEvent);
        end else begin
          if PileEvent.m_nEventType = ET_PILESTONES then
            TPileStones(PileEvent).AddEventParam;
        end;
        if Random(g_Config.nMakeMineRate {12}) = 0 then begin
          MakeMine();
        end;
        s1C := '1';
        DoDamageWeapon(Random(15) + 5);
        Result := True;
      end;
    end else begin
      if (GetTickCount - TStoneMineEvent(Event).m_dwAddStoneMineTick) > 600000{10 * 60 * 1000} then
        TStoneMineEvent(Event).AddStoneMine();
    end;
  end;
  SendRefMsg(RM_HEAVYHIT, m_btDirection, m_nCurrX, m_nCurrY, 0, s1C);
end;
//设置目标
procedure TBaseObject.SetTargetCreat(BaseObject: TBaseObject);
begin
  m_TargetCret := BaseObject;
  m_dwTargetFocusTick := GetTickCount();
end;
//清除目标
procedure TBaseObject.DelTargetCreat();
begin
  m_TargetCret := nil;
end;

function TBaseObject._Attack(var wHitMode: Word; AttackTarget: TBaseObject): Boolean;
var
  nPower, nSecPwr, NGSecPwr, NGSecPwr1, nWeaponDamage: Integer;
  bo21: Boolean;
  n20: Integer;
  nCheckCode: Byte;
  boisBaseObject: Boolean;
resourcestring
  sExceptionMsg = '{异常} TBaseObject::_Attack Name:=%s Code:=%d';
  function MPow(UserMagic: pTUserMagic): Integer;//20080531 计算技能威力
  var nPower:Integer;
  begin
    nPower := UserMagic.MagicInfo.wPower + Random(UserMagic.MagicInfo.wMaxPower - UserMagic.MagicInfo.wPower);
    Result :=Round(nPower / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + (UserMagic.MagicInfo.btDefPower + Random(UserMagic.MagicInfo.btDefMaxPower - UserMagic.MagicInfo.btDefPower));
  end;
  function GetNGPow(BaseObject: TBaseObject; UserMagic: pTUserMagic; Power: Integer): Integer;//内功技能掉内力值
  var nNHPoint:Integer;
  begin
    Result := 0;
    if (UserMagic <> nil) and (BaseObject <> nil) then begin
      if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
        nNHPoint := TPlayObject(BaseObject).GetSpellPoint(UserMagic);//掉内力值
        if TPlayObject(BaseObject).m_Skill69NH >= nNHPoint then begin
          TPlayObject(BaseObject).m_Skill69NH := _MAX(0, TPlayObject(BaseObject).m_Skill69NH - nNHPoint);
          TPlayObject(BaseObject).SendREFMsg( RM_MAGIC69SKILLNH, 0, TPlayObject(BaseObject).m_Skill69NH, TPlayObject(BaseObject).m_Skill69MaxNH, 0, '');
          //Result := MPow(UserMagic);
          Result := Round(Power * ((UserMagic.btLevel + 1) * (g_Config.nNGSkillRate / 100)));//计算攻击力 20081222
          TPlayObject(BaseObject).NGMAGIC_LVEXP(UserMagic);//内功技能升级 20081003
        end;
      end else
      if (BaseObject.m_btRaceServer = RC_HEROOBJECT) then begin
        nNHPoint := THEROOBJECT(BaseObject).GetSpellPoint(UserMagic);
        if THEROOBJECT(BaseObject).m_Skill69NH >= nNHPoint then begin
          THEROOBJECT(BaseObject).m_Skill69NH := _MAX(0, THEROOBJECT(BaseObject).m_Skill69NH - nNHPoint);
          THEROOBJECT(BaseObject).SendREFMsg( RM_MAGIC69SKILLNH, 0, THEROOBJECT(BaseObject).m_Skill69NH, THEROOBJECT(BaseObject).m_Skill69MaxNH, 0, '');
          //Result := MPow(UserMagic);
          Result := Round(Power * ((UserMagic.btLevel + 1) * (g_Config.nNGSkillRate / 100)));//计算攻击力 20081222
          THEROOBJECT(BaseObject).NGMAGIC_LVEXP(UserMagic);//内功技能升级 20081003
        end;
      end;
    end;
  end;
//攻击角色
  function DirectAttack(BaseObject: TBaseObject; nSecPwr: Integer; boIsObject: Boolean): Boolean;
  begin
    Result := False;                           //20080923 增加
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or
      (BaseObject.m_btRaceServer = RC_HEROOBJECT) or //20080923 增加
      (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
      not (InSafeZone and BaseObject.InSafeZone) then begin
      if IsProperTarget(BaseObject) then begin
        if Random(BaseObject.m_btSpeedPoint) < m_btHitPoint then begin
          BaseObject.StruckDamage(nSecPwr);
          BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK),
            RM_10101,
            nSecPwr,
            BaseObject.m_WAbil.HP,
            BaseObject.m_WAbil.MaxHP,
            Integer(Self), '', 500);
          if (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) and //20081005 增加英雄过滤
             (BaseObject.m_btRaceServer <> RC_HEROOBJECT) and (not boIsObject) then begin
            BaseObject.SendMsg(BaseObject,
              RM_STRUCK,
              nSecPwr,
              BaseObject.m_WAbil.HP,
              BaseObject.m_WAbil.MaxHP,
              Integer(Self), '');
          end;
          Result := True;
        end;
      end;
    end;
  end;
  //刺杀前面一个位置的攻击   20080924 修改
  function SwordLongAttack(nSecPwr,nLevel: Integer; Target: TBaseObject): Boolean;
  var
    nX, nY: Integer;
    BaseObject: TBaseObject;
  begin
    Result := False;
    boisBaseObject:= False;
    //Result:=g_boNotLimitSwordLong;
    nSecPwr := Round(nSecPwr * g_Config.nSwordLongPowerRate / 100);
    nSecPwr := Round(nSecPwr * (nLevel * 0.2 + 0.4));//20081208 按技能等级计算攻击力

    if m_btRaceServer = RC_PLAYOBJECT then begin//内功护体,增加普通攻击力 20081020
      if TPlayObject(self).m_boTrainingNG and (TPlayObject(self).m_Skill69NH > 0) then begin
        Inc(nSecPwr ,(TPlayObject(self).m_NGLevel + 4));
      end;
    end else
    if m_btRaceServer = RC_HEROOBJECT then begin
      if THeroObject(self).m_boTrainingNG and (THeroObject(self).m_Skill69NH > 0) then begin
        Inc(nSecPwr ,(THeroObject(self).m_NGLevel + 4));
      end;
    end;

    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if BaseObject <> nil then begin
        if (nSecPwr > 0) and IsProperTarget(BaseObject) then begin
          if Target <> nil then begin//20080930 判断刀尖位置与目标是不是同个对像
            if BaseObject = Target then boisBaseObject:= True;
          end;

          if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin//内功护体,增加防御 20081020
            if TPlayObject(BaseObject).m_boTrainingNG and (TPlayObject(BaseObject).m_Skill69NH > 0) then begin
              nSecPwr := _MAX(0, nSecPwr - (TPlayObject(BaseObject).m_NGLevel + 4));
              TPlayObject(BaseObject).m_Skill69NH:= _MAX(0, TPlayObject(BaseObject).m_Skill69NH - g_Config.nHitStruckDecNH);
              TPlayObject(BaseObject).SendRefMsg( RM_MAGIC69SKILLNH, 0, TPlayObject(BaseObject).m_Skill69NH, TPlayObject(BaseObject).m_Skill69MaxNH, 0, '');
            end;
          end else
          if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin
            if THeroObject(BaseObject).m_boTrainingNG and (THeroObject(BaseObject).m_Skill69NH > 0) then begin
              nSecPwr := _MAX(0, nSecPwr - (THeroObject(BaseObject).m_NGLevel + 4));
              THeroObject(BaseObject).m_Skill69NH:= _MAX(0, THeroObject(BaseObject).m_Skill69NH - g_Config.nHitStruckDecNH);
              THeroObject(BaseObject).SendRefMsg( RM_MAGIC69SKILLNH, 0, THeroObject(BaseObject).m_Skill69NH, THeroObject(BaseObject).m_Skill69MaxNH, 0, '');
            end;
          end;
          if BaseObject.m_boAbilMagBubbleDefence then begin//四级盾可防隔位刺杀 20081217
            if BaseObject.m_btMagBubbleDefenceLevel = 4 then begin
              nSecPwr := Round(nSecPwr * 0.86);//四级盾可以减少隔位刺杀14%的攻击力
            end;
          end;
          Result := DirectAttack(BaseObject, nSecPwr, boisBaseObject);
          {if m_btRaceServer = RC_HEROOBJECT then begin //20080531 修正英雄锁定后,不打锁定怪
             if not THeroObject(self).m_boTarget then SetTargetCreat(BaseObject);
          end else SetTargetCreat(BaseObject);}
          if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := BaseObject;//20080711
          if m_btRaceServer <> RC_HEROOBJECT then  SetTargetCreat(BaseObject);//20080711
        end;
        Result := True;
      end;
    end;
  end;
  //半月攻击
  function SwordWideAttack(nSecPwr: Integer): Boolean;
  var
    nC, n10: Integer;
    nX, nY: Integer;
    BaseObject: TBaseObject;
    nPwr,nSePwr: Integer;
  begin
    Result := False;
    nC := 0;
    while (True) do begin
      n10 := (m_btDirection + g_Config.WideAttack[nC]) mod 8;
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (nSecPwr > 0) and (BaseObject <> nil) then begin
          if IsProperTarget(BaseObject) then begin
            nSePwr:= nSecPwr;
            if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) then begin
              nPwr:= 0;
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                nPwr:= GetNGPow(BaseObject, TPlayObject(BaseObject).m_MagicSkill_203, nSePwr);//静之半月
              end else
              if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin
                nPwr:= GetNGPow(BaseObject, THEROOBJECT(BaseObject).m_MagicSkill_203, nSePwr);//静之半月
              end;
              nSePwr := _MAX(0, nSePwr - nPwr);
            end;

            Result := DirectAttack(BaseObject, nSePwr, False);
            {if m_btRaceServer = RC_HEROOBJECT then begin //20080531 修正英雄锁定后,不打锁定怪
               if not THeroObject(self).m_boTarget then SetTargetCreat(BaseObject);
            end else SetTargetCreat(BaseObject); }
            if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := BaseObject;//20080711
            if m_btRaceServer <> RC_HEROOBJECT then  SetTargetCreat(BaseObject);//20080711
          end;
        end;
      end;
      Inc(nC);
      if nC >= 3 then Break;
    end;
  end;
  //抱月弯刀
  function CrsWideAttack(nSecPwr: Integer): Boolean;
  var
    nC, n10: Integer;
    nX, nY: Integer;
    BaseObject: TBaseObject;
  begin
    Result := False;
    nC := 0;
    while (True) do begin
      n10 := (m_btDirection + g_Config.CrsAttack[nC]) mod 8;
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (nSecPwr > 0) and (BaseObject <> nil) then begin
          if IsProperTarget(BaseObject) then begin
            Result := DirectAttack(BaseObject, nSecPwr, False);
            {if m_btRaceServer = RC_HEROOBJECT then begin //20080531 修正英雄锁定后,不打锁定怪
               if not THeroObject(self).m_boTarget then SetTargetCreat(BaseObject);
            end else SetTargetCreat(BaseObject); }
            if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := BaseObject;//20080711
            if m_btRaceServer <> RC_HEROOBJECT then  SetTargetCreat(BaseObject);//20080711
          end;
        end;
      end;
      Inc(nC);
      if nC >= 6 then Break;
    end;
  end;
//逐日剑法 20080511
  function Attack_74(Target: TBaseObject; nSecPwr: Integer): Boolean;
  var
    I, NGSecPwr, nSePwr, nTwePwr: Integer;
    BaseObjectList: TList;
    TargeTBaseObject: TBaseObject;
    nDamage: Integer;//20080929
    nReadSkill: Boolean;//是否学了怒之技能 20081223
  begin
    Result := False;
    BaseObjectList := TList.Create;
    nTwePwr:= nSecPwr;
    nReadSkill:= False;
    try
      GetDirectionBaseObjects(m_btDirection, 4, BaseObjectList);//同个方向的怪 4格
      if BaseObjectList.Count > 0 then begin//20080629
        if (m_btRaceServer = RC_PLAYOBJECT) then begin
          if TPlayObject(self).m_MagicSkill_206 <> nil then begin//20081223
            NGSecPwr := GetNGPow(self, TPlayObject(self).m_MagicSkill_206,nTwePwr);//怒之逐日
            nSecPwr := _MAX(0, nSecPwr + NGSecPwr);
            nReadSkill:= True;
          end;
        end else
        if (m_btRaceServer = RC_HEROOBJECT) then begin
          if THEROOBJECT(self).m_MagicSkill_206 <> nil then begin//20081223
            NGSecPwr := GetNGPow(self, THEROOBJECT(self).m_MagicSkill_206,nTwePwr);//怒之逐日
            nSecPwr := _MAX(0, nSecPwr + NGSecPwr);
            nReadSkill:= True;
          end;
        end;

        for I := 0 to BaseObjectList.Count - 1 do begin
          TargeTBaseObject := TBaseObject(BaseObjectList.Items[I]);
          if TargeTBaseObject <> nil then begin
            if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := TargeTBaseObject;//20080528
            if IsProperTarget(TargeTBaseObject) then begin
              nDamage:= 0;
              nSePwr:= nSecPwr;
              if ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and nReadSkill then begin
                NGSecPwr:= 0;
                if TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                  NGSecPwr:= GetNGPow(TargeTBaseObject, TPlayObject(TargeTBaseObject).m_MagicSkill_207,nTwePwr);//静之逐日
                end else
                if TargeTBaseObject.m_btRaceServer = RC_HEROOBJECT then begin
                  NGSecPwr:= GetNGPow(TargeTBaseObject, THEROOBJECT(TargeTBaseObject).m_MagicSkill_207,nTwePwr);//静之逐日
                end;
                nSePwr := _MAX(0, nSePwr - NGSecPwr);
              end;

              Inc(nDamage, TargeTBaseObject.GetHitStruckDamage(Self, nSePwr));//20080929 魔法盾,护体神盾减少伤害
              Result := DirectAttack(TargeTBaseObject, nDamage, False);
              //Result := DirectAttack(TargeTBaseObject, nSecPwr);
              if m_btRaceServer <> RC_HEROOBJECT then  SetTargetCreat(TargeTBaseObject);//20080528 不让英雄打一个目标后又换另一个目标
            end;
          end;
        end;
      end;
    finally
      BaseObjectList.Free;
    end;
  end;
//开天斩 20080209
  function Attack_42(nSecPwr,m_n42kill: Integer): Boolean;
  var
    I: Integer;
    BaseObjectList: TList;
    TargeTBaseObject: TBaseObject;
    nDamage: Integer;//20080929
  begin
    Result := False;
    BaseObjectList := TList.Create;
    try
      case m_n42kill of //20080328 轻击重击范围有分别
        1:GetDirectionBaseObjects(m_btDirection, 3, BaseObjectList);//轻击,3格
        2:GetDirectionBaseObjects(m_btDirection, 5, BaseObjectList);//同个方向的怪 重击,5格
      end;
      if BaseObjectList.Count > 0 then begin//20080629
        for I := 0 to BaseObjectList.Count - 1 do begin
          TargeTBaseObject := TBaseObject(BaseObjectList.Items[I]);
          if TargeTBaseObject <> nil then begin
            if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := TargeTBaseObject;//20080528
            if IsProperTarget(TargeTBaseObject) then begin
              nDamage:= 0;
              Inc(nDamage, TargeTBaseObject.GetHitStruckDamage(Self, nSecPwr));//20080929 魔法盾,护体神盾减少伤害
              Result := DirectAttack(TargeTBaseObject, nDamage, False);
              //Result := DirectAttack(TargeTBaseObject, nSecPwr);
              if m_btRaceServer <> RC_HEROOBJECT then  SetTargetCreat(TargeTBaseObject);//20080528 不让英雄打一个目标后又换另一个目标
            end;
          end;
        end;
      end;
    finally
      BaseObjectList.Free;
    end;
  end;
  //龙影剑法 20080209
  function Attack_43(Target: TBaseObject; nSecPwr: Integer): Boolean;
  var
    I: Integer;
    BaseObjectList: TList;
    TargeTBaseObject: TBaseObject;
  begin
    Result := False;
    BaseObjectList := TList.Create;
    try
      GetDirectionBaseObjects_42(m_btDirection, g_Config.nMagicAttackRage_42{龙影剑法范围 20080218}, BaseObjectList);//同个方向的怪  20080405
      if BaseObjectList.Count > 0 then begin//20080629
        for I := 0 to BaseObjectList.Count - 1 do begin
          TargeTBaseObject := TBaseObject(BaseObjectList.Items[I]);
          if TargeTBaseObject <> nil then begin //20080322
            if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := TargeTBaseObject;//20080528
            if IsProperTarget(TargeTBaseObject) then begin
              Result := DirectAttack(TargeTBaseObject, nSecPwr, False);
              if m_btRaceServer <> RC_HEROOBJECT then  SetTargetCreat(TargeTBaseObject);//20080528 不让英雄打一个目标后又换另一个目标
            end;
          end;
        end;
      end;
    finally
      BaseObjectList.Free;
    end;
  end;
  procedure sub_4C1E5C(nSecPwr: Integer);
  var
    btDir: Byte;
    nX, nY: Integer;
    BaseObject: TBaseObject;
    procedure sub_4C1DC0();
    begin
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nX, nY) then begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (nSecPwr > 0) and (BaseObject <> nil) then begin
          Result := DirectAttack(BaseObject, nSecPwr, False);
        end;
      end;
    end;
  begin
    Result := False;
    btDir := m_btDirection;
    m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nX, nY);
    sub_4C1DC0();
    btDir := sub_4B2F80(m_btDirection, 2);
    sub_4C1DC0();
    btDir := sub_4B2F80(m_btDirection, 6);
    sub_4C1DC0();
  end;
begin
  Result := False;
  nCheckCode := 0;
  try
    bo21 := False;
    nWeaponDamage := 0;
    //nPower := 0;//20080522
    //nSecPwr := 0;//20080522
    if AttackTarget <> nil then begin //目标存在
      //nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));//20080530 注释
      case wHitMode of//20080531 按DB库计算攻击力
        3: if m_MagicPowerHitSkill <> nil then nPower := GetAttackPower(MPow(m_MagicPowerHitSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        4: if m_MagicErgumSkill <> nil then nPower := GetAttackPower(MPow(m_MagicErgumSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        5: if m_MagicBanwolSkill <> nil then nPower := GetAttackPower(MPow(m_MagicBanwolSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        7: if m_MagicFireSwordSkill <> nil then nPower := GetAttackPower(MPow(m_MagicFireSwordSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        8: if m_MagicCrsSkill <> nil then nPower := GetAttackPower(MPow(m_MagicCrsSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        9: if m_Magic42Skill <> nil then  nPower := GetAttackPower(MPow(m_Magic42Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        12:if m_Magic43Skill <> nil then nPower := GetAttackPower(MPow(m_Magic43Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        13:if m_Magic74Skill <> nil then  nPower := GetAttackPower(MPow(m_Magic74Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        else nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
      end;
      if (wHitMode = 3) and m_boPowerHit then begin //攻杀
        m_boPowerHit := False;
        if (m_btRaceServer = RC_PLAYOBJECT) then begin
          if TPlayObject(self).m_MagicSkill_200 <> nil then begin//20081223 有怒之技能才进入
            NGSecPwr := GetNGPow(self, TPlayObject(self).m_MagicSkill_200,nPower);//怒之攻杀
            if AttackTarget <> nil then begin
              if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                NGSecPwr:= NGSecPwr - GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_201,nPower);//静之攻杀
              end else
              if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                NGSecPwr:= NGSecPwr - GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_201,nPower);//静之攻杀
              end;
            end;
            nPower := _MAX(0, nPower + NGSecPwr);
          end;
        end else
        if (m_btRaceServer = RC_HEROOBJECT) then begin
          if THEROOBJECT(self).m_MagicSkill_200 <> nil then begin//20081223 有怒之技能才进入
            NGSecPwr := GetNGPow(self, THEROOBJECT(self).m_MagicSkill_200,nPower);//怒之攻杀
            if AttackTarget <> nil then begin
              if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                NGSecPwr:= NGSecPwr - GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_201,nPower);//静之攻杀
              end else
              if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                NGSecPwr:= NGSecPwr - GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_201,nPower);//静之攻杀
              end;
            end;
            nPower := _MAX(0, nPower + NGSecPwr);
          end;
        end;
        Inc(nPower, m_nHitPlus);
        bo21 := True;
      end;
      if (wHitMode = 7) and m_boFireHitSkill then begin //烈火剑法
        m_boFireHitSkill := False;
        m_dwLatestFireHitTick := GetTickCount(); //Jacky 禁止双烈火
        if (m_MagicFireSwordSkill.btLevel = 4) and (THeroObject(self).m_nLoyal >=g_Config.nGotoLV4) then //如果是4级烈火技能 20080113
          nPower := nPower + Round(nPower / 100 * (m_nHitDouble * 10)){ + g_Config.nPowerLv4}//攻击力比普通魔法增加  20081109 烈火不另加攻击力
        else nPower := nPower + Round(nPower / 100 * (m_nHitDouble * 10));//普通烈火的杀伤力 20080112
        nPower := Round(nPower * (g_Config.nAttackRate_26 / 100));//威力倍数 20081208
        bo21 := True;

        if (m_btRaceServer = RC_PLAYOBJECT) then begin
          if TPlayObject(self).m_MagicSkill_204 <> nil then begin//20081223
            NGSecPwr := GetNGPow(self, TPlayObject(self).m_MagicSkill_204,nPower);//怒之烈火
            if AttackTarget <> nil then begin
              if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                NGSecPwr:= NGSecPwr - GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_205,nPower);//静之烈火
              end else
              if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                NGSecPwr:= NGSecPwr - GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_205,nPower);//静之烈火
              end;
            end;
            nPower := _MAX(0, nPower + NGSecPwr);
          end;
        end else
        if (m_btRaceServer = RC_HEROOBJECT) then begin
          if THEROOBJECT(self).m_MagicSkill_204 <> nil then begin//20081223
            NGSecPwr := GetNGPow(self, THEROOBJECT(self).m_MagicSkill_204,nPower);//怒之烈火
            if AttackTarget <> nil then begin
              if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                NGSecPwr:= NGSecPwr - GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_205,nPower);//静之烈火
              end else
              if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                NGSecPwr:= NGSecPwr - GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_205,nPower);//静之烈火
              end;
            end;
            nPower := _MAX(0, nPower + NGSecPwr);
          end;
        end;
      end;

      if (wHitMode = 13) and m_boDailySkill then begin //逐日剑法 20080511
        m_boDailySkill := False;
        m_dwLatestDailyTick := GetTickCount();
        nPower := nPower + Round(nPower / 100 * (m_nHitDouble * 10));
        nPower := Round(nPower * (g_Config.nAttackRate_74 / 100));//威力倍数
        bo21 := True;
      end;

      if (wHitMode = 9) and m_bo42kill then begin //开天斩  20080202
        m_bo42kill := False;
        m_dwLatest42Tick := GetTickCount(); //禁止双开天斩
        case m_n42kill of //20080213
          1: nPower := nPower + Round(nPower / 100 * (m_nHitDouble * 10));//轻击杀伤力 20080202
          2: nPower := (nPower + Round(nPower / 100 * (m_nHitDouble * 10))) * g_Config.n43KillAttackRate;//重击杀伤力 20080213
        end;
        nPower := Round(nPower * (g_Config.nAttackRate_43 / 100));//开天斩威力倍数  20080213
        bo21 := True;
      end;

      if (wHitMode = 12) and m_bo43kill then begin //龙影剑法  20080209
        m_dwLatest43Tick := GetTickCount();//20080619 增加
        m_bo43kill:=False;//20080619 增加
        nPower := nPower + Round(nPower / 100 * (m_nHitDouble * 10));//杀伤力 20080209
        nPower := Round(nPower * (g_Config.nAttackRate_42 / 100));//龙影剑法威力倍数  20080213
        bo21 := True;
      end;

    end else begin
      //nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
      case wHitMode of//20080531 按DB库计算攻击力
        3: if m_MagicPowerHitSkill <> nil then nPower := GetAttackPower(MPow(m_MagicPowerHitSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        4: if m_MagicErgumSkill <> nil then nPower := GetAttackPower(MPow(m_MagicErgumSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        5: if m_MagicBanwolSkill <> nil then nPower := GetAttackPower(MPow(m_MagicBanwolSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        7: if m_MagicFireSwordSkill <> nil then nPower := GetAttackPower(MPow(m_MagicFireSwordSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        8: if m_MagicCrsSkill <> nil then nPower := GetAttackPower(MPow(m_MagicCrsSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        9: if m_Magic42Skill <> nil then nPower := GetAttackPower(MPow(m_Magic42Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        12:if m_Magic43Skill <> nil then nPower := GetAttackPower(MPow(m_Magic43Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        13:if m_Magic74Skill <> nil then  nPower := GetAttackPower(MPow(m_Magic74Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
       else nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
      end;

      if (wHitMode = 3) and m_boPowerHit then begin
        m_boPowerHit := False;
        Inc(nPower, m_nHitPlus);
        bo21 := True;
      end;
      //防止砍空刀刀烈火
      if (wHitMode = 7) and m_boFireHitSkill then begin
        m_boFireHitSkill := False;
        nPower := Round(nPower * (g_Config.nAttackRate_26 / 100));//威力倍数 20081208
        m_dwLatestFireHitTick := GetTickCount(); //禁止双烈火
      end;

      if (wHitMode = 13) and m_boDailySkill then begin //逐日剑法 20080511
        m_boDailySkill := False;
        m_dwLatestDailyTick := GetTickCount();
        //--------------------------------------------
        //以下代码 20080910 修改逐日远程攻击练功师 攻击与近身攻击一样威力
        nPower := nPower + Round(nPower / 100 * (m_nHitDouble * 10));
        nPower := Round(nPower * (g_Config.nAttackRate_74 / 100));//威力倍数
        bo21 := True;
        //--------------------------------------------
      end;

      if (wHitMode = 9) and m_bo42kill then begin //开天斩  20080202
        m_bo42kill := False;
        m_dwLatest42Tick := GetTickCount(); //禁止双开天斩
        //--------------------------------------------
        //以下代码 20080910 修改开天远程攻击练功师 攻击与近身攻击一样威力
        case m_n42kill of //20080213
          1: nPower := nPower + Round(nPower / 100 * (m_nHitDouble * 10));//轻击杀伤力
          2: nPower := (nPower + Round(nPower / 100 * (m_nHitDouble * 10))) * g_Config.n43KillAttackRate;//重击杀伤力 20080213
        end;
        nPower := Round(nPower * (g_Config.nAttackRate_43 / 100));//开天斩威力倍数
        bo21 := True;
        //--------------------------------------------
      end;

      if (wHitMode = 12) and m_bo43kill then begin //龙影剑法  20080619
         m_dwLatest43Tick := GetTickCount();//20080619 增加
         m_bo43kill:=False;//20080619 增加
      end;
    end;

    nCheckCode := 1;
    if (wHitMode = 4) then begin // 刺杀
      nSecPwr := 0;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin //增加分身魔法攻击
        if m_MagicErgumSkill <> nil then begin
          //nSecPwr := Round(nPower / (m_MagicErgumSkill.MagicInfo.btTrainLv + 2) * (m_MagicErgumSkill.btLevel + 2));
          nSecPwr := nPower;
        end;
      end else nSecPwr := nSecPwr;
      if (nSecPwr > 0) and (m_MagicErgumSkill <> nil) then begin
        nCheckCode := 100;
        if not SwordLongAttack(nSecPwr, m_MagicErgumSkill.btLevel, AttackTarget) and g_Config.boLimitSwordLong then wHitMode := 0;
        if boisBaseObject and (AttackTarget.m_btRaceServer <> 55) then nPower:= 0;//20081010 与隔位目标一样,则不再重复让目标掉血
      end;
    end;
    nCheckCode := 2;
    if (wHitMode = 5) then begin//半月
      nSecPwr := 0;
      NGSecPwr1:= 0;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin //增加分身魔法攻击
        if m_MagicBanwolSkill <> nil then begin
          //nSecPwr := Round(nPower / (m_MagicBanwolSkill.MagicInfo.btTrainLv + 10) * (m_MagicBanwolSkill.btLevel + 2));
          if (m_btRaceServer = RC_PLAYOBJECT) then begin
            if TPlayObject(self).m_MagicSkill_202 <> nil then begin//20081223
              NGSecPwr := GetNGPow(self, TPlayObject(self).m_MagicSkill_202,nPower);//怒之半月
              if AttackTarget <> nil then begin
                if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                  NGSecPwr1:= GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_203,nPower);//静之半月
                end else
                if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                  NGSecPwr1:= GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_203,nPower);//静之半月
                end;
              end;
              Inc(nPower, NGSecPwr);
            end;
          end else
          if (m_btRaceServer = RC_HEROOBJECT) then begin
            if THEROOBJECT(self).m_MagicSkill_202 <> nil then begin//20081223
              NGSecPwr := GetNGPow(self, THEROOBJECT(self).m_MagicSkill_202,nPower);//怒之半月
              if (AttackTarget <> nil) then begin
                if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                  NGSecPwr1:= GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_203,nPower);//静之半月
                end else
                if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                  NGSecPwr1:= GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_203,nPower);//静之半月
                end;
              end;
              Inc(nPower, NGSecPwr);
            end;
          end;
          nPower := _MAX(0, nPower - NGSecPwr1);//对面目标掉血值
          //nSecPwr := nPower;//周围目标掉血值
          nSecPwr := Round(nPower * (m_MagicBanwolSkill.btLevel * 0.077 + 0.1538));//周围目标掉血值 20081208
        end;
      end else nSecPwr := nSecPwr;
      if nSecPwr > 0 then SwordWideAttack(nSecPwr);
    end;
    nCheckCode := 3;
    if (wHitMode = 6) then begin
      nSecPwr := 0;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin {增加分身魔法攻击}
      end else nSecPwr := nSecPwr;
      if nSecPwr > 0 then sub_4C1E5C(nSecPwr);
    end;
    nCheckCode := 32;//20080222
    if (wHitMode = 8) then begin //抱月刀法
      nSecPwr := 0;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin {增加分身魔法攻击}
        if m_MagicCrsSkill <> nil then begin
          //nSecPwr := Round(nPower / (m_MagicCrsSkill.MagicInfo.btTrainLv + 10) * (m_MagicCrsSkill.btLevel + 2));
          nSecPwr := nPower;
        end;
      end else nSecPwr := nSecPwr;
      if nSecPwr > 0 then CrsWideAttack(nSecPwr);
    end;

    if (wHitMode = 9) then begin //开天斩 20080209
      nSecPwr := 0;
      nCheckCode := 33;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin {增加分身魔法攻击}
        if m_Magic42Skill <> nil then begin
          //nSecPwr := Round(nPower / (m_Magic42Skill.MagicInfo.btTrainLv + 10) * (m_Magic42Skill.btLevel + 2));
          nSecPwr := nPower;
        end;
      end else nSecPwr := nSecPwr;
      if nSecPwr > 0 then begin
        nCheckCode := 101; 
        Attack_42(nSecPwr,m_n42kill);
      end;
    end;

    if (wHitMode = 13) then begin //逐日剑法 20080511
      nSecPwr := 0;
      nCheckCode := 34;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin
        if m_Magic74Skill <> nil then begin
          //nSecPwr := Round(nPower / (m_Magic74Skill.MagicInfo.btTrainLv + 1) * (m_Magic74Skill.btLevel + 1));
          nSecPwr := nPower;
        end;
      end else nSecPwr := nSecPwr;
      if nSecPwr > 0 then Attack_74(AttackTarget,nSecPwr);
    end;

    if (wHitMode = 12) then begin //龙影剑法 20080209
      nSecPwr := 0;
      nCheckCode := 35;//20080222
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin {增加分身魔法攻击}
        if m_Magic43Skill <> nil then begin
          //nSecPwr := Round(nPower / (m_Magic43Skill.MagicInfo.btTrainLv + 10) * (m_Magic43Skill.btLevel + 2));
          nSecPwr := nPower;
        end;
      end else nSecPwr := nSecPwr;
      if nSecPwr > 0 then Attack_43(AttackTarget,nSecPwr);
    end;

    if AttackTarget = nil then Exit;
    nCheckCode := 4;
    if IsProperTarget(AttackTarget) then begin
      if (Random(AttackTarget.m_btSpeedPoint) >= m_btHitPoint) then nPower := 0;
    end else nPower := 0;
    nCheckCode := 5;
    if nPower > 0 then begin
      if (m_btRaceServer = RC_PLAYOBJECT) then begin
        if TPlayObject(self).m_MagicSkill_236 <> nil then begin//20081223
          NGSecPwr := GetNGPow(self, TPlayObject(self).m_MagicSkill_236,nPower);//怒之内功剑法
          if AttackTarget <> nil then begin
            if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
              NGSecPwr:= NGSecPwr - GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_237,nPower);//静之内功剑法
            end else
            if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
              NGSecPwr:= NGSecPwr - GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_237,nPower);//静之内功剑法
            end;
          end;
          nPower := _MAX(0, nPower + NGSecPwr);
        end;
      end else
      if (m_btRaceServer = RC_HEROOBJECT) then begin
        if THEROOBJECT(self).m_MagicSkill_236 <> nil then begin//20081223
          NGSecPwr := GetNGPow(self, THEROOBJECT(self).m_MagicSkill_236,nPower);//怒之内功剑法
          if AttackTarget <> nil then begin
            if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
              NGSecPwr:= NGSecPwr - GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_237,nPower);//静之内功剑法
            end else
            if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
              NGSecPwr:= NGSecPwr - GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_237,nPower);//静之内功剑法
            end;
          end;
          nPower := _MAX(0, nPower + NGSecPwr);
        end;
      end;

      nPower := AttackTarget.GetHitStruckDamage(Self, nPower);
      nWeaponDamage := (Random(5) + 2) - m_AddAbil.btWeaponStrong;
    end;
    nCheckCode := 60;
    if nPower > 0 then begin
      nCheckCode := 61;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then begin//20080606
        if (wHitMode <> 9) and (wHitMode <> 13) and (wHitMode <> 12) then begin//20081221 过滤龙影剑法
          AttackTarget.StruckDamage(nPower);//减装备持久
          AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nPower, AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '', 200);
        end;
      end else begin
        nCheckCode := 63;
        AttackTarget.StruckDamage(nPower);
        AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nPower, AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '', 200);
      end;

      if (AttackTarget <> nil) and (not AttackTarget.m_boUnParalysis) and m_boParalysis and (Random(AttackTarget.m_btAntiPoison + g_Config.nAttackPosionRate {5}) = 0) then begin
        nCheckCode := 64;
        if (m_btRaceServer = RC_HEROOBJECT) and (m_btJob = 0) then begin//20080609 英雄刺杀位不麻目标
          if (abs(AttackTarget.m_nCurrX - m_nCurrX) = 1) or (abs(AttackTarget.m_nCurrY - m_nCurrY) = 1) then begin//20080803 修改
            AttackTarget.MakePosion(POISON_STONE, g_Config.nAttackPosionTime {5}, 0);//麻痹
          end;
        end else AttackTarget.MakePosion(POISON_STONE, g_Config.nAttackPosionTime {5}, 0);//麻痹
      end;
      nCheckCode := 65;
      //虹魔，吸血
      if m_nHongMoSuite > 0 then begin
        m_db3B0 := nPower / 1.E2 * m_nHongMoSuite;
        if m_db3B0 >= 2.0 then begin
          n20 := Trunc(m_db3B0);
          m_db3B0 := n20;
          DamageHealth(-n20);
        end;
      end;
      nCheckCode := 66;
      if (m_MagicOneSwordSkill <> nil) and
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_MagicOneSwordSkill.btLevel < 3) and
        (m_MagicOneSwordSkill.MagicInfo.TrainLevel[m_MagicOneSwordSkill.btLevel] <= m_Abil.Level) then begin
        nCheckCode := 67;
        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_MagicOneSwordSkill, Random(3) + 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicOneSwordSkill) then begin
            nCheckCode := 68;
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicOneSwordSkill.MagicInfo.wMagicId, m_MagicOneSwordSkill.btLevel, m_MagicOneSwordSkill.nTranPoint, '', 3000);
            RecalcAbilitys;//20080823 增加
            CompareSuitItem(False);//20080823 套装
            SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');//20080823 增加
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_MagicOneSwordSkill, Random(3) + 1);
          if not THeroObject(Self).CheckMagicLevelup(m_MagicOneSwordSkill) then begin
            nCheckCode := 69;
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, 0, m_MagicOneSwordSkill.MagicInfo.wMagicId, m_MagicOneSwordSkill.btLevel, m_MagicOneSwordSkill.nTranPoint, '', 3000);
            THeroObject(Self).RecalcAbilitys;//20080823 增加
            CompareSuitItem(False);//20080823 套装
            THeroObject(Self).SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');//20080823 增加
          end;
        end;
        nCheckCode := 70;
      end;

      if bo21 and (m_MagicPowerHitSkill <> nil) and //攻杀
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_MagicPowerHitSkill.btLevel < 3) and
        (m_MagicPowerHitSkill.MagicInfo.TrainLevel[m_MagicPowerHitSkill.btLevel] <= m_Abil.Level) then begin
        nCheckCode := 71;
        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_MagicPowerHitSkill, Random(3) + 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicPowerHitSkill) then begin
            nCheckCode := 72;
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicPowerHitSkill.MagicInfo.wMagicId, m_MagicPowerHitSkill.btLevel, m_MagicPowerHitSkill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_MagicPowerHitSkill, Random(3) + 1);
          if not THeroObject(Self).CheckMagicLevelup(m_MagicPowerHitSkill) then begin
            nCheckCode := 73;
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, 0, m_MagicPowerHitSkill.MagicInfo.wMagicId, m_MagicPowerHitSkill.btLevel, m_MagicPowerHitSkill.nTranPoint, '', 3000);
          end;
        end;
        nCheckCode := 74;
      end;
      nCheckCode := 75;
      if (wHitMode = 4) and (m_MagicErgumSkill <> nil) and  //刺杀
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_MagicErgumSkill.btLevel < 3) and
        (m_MagicErgumSkill.MagicInfo.TrainLevel[m_MagicErgumSkill.btLevel] <= m_Abil.Level) then begin
        nCheckCode := 76;
        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_MagicErgumSkill, Random(3) + 1);//升1-3点 20080924
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicErgumSkill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicErgumSkill.MagicInfo.wMagicId, m_MagicErgumSkill.btLevel, m_MagicErgumSkill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_MagicErgumSkill, Random(3) + 1);//升1-3点 20080924
          if not THeroObject(Self).CheckMagicLevelup(m_MagicErgumSkill) then begin
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, 0, m_MagicErgumSkill.MagicInfo.wMagicId, m_MagicErgumSkill.btLevel, m_MagicErgumSkill.nTranPoint, '', 3000);
          end;
        end;
      end;
      nCheckCode := 77;
      if (wHitMode = 5) and (m_MagicBanwolSkill <> nil) and //半月弯刀
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_MagicBanwolSkill.btLevel < 3) and
        (m_MagicBanwolSkill.MagicInfo.TrainLevel[m_MagicBanwolSkill.btLevel] <= m_Abil.Level) then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_MagicBanwolSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicBanwolSkill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicBanwolSkill.MagicInfo.wMagicId, m_MagicBanwolSkill.btLevel, m_MagicBanwolSkill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_MagicBanwolSkill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_MagicBanwolSkill) then begin
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, 0, m_MagicBanwolSkill.MagicInfo.wMagicId, m_MagicBanwolSkill.btLevel, m_MagicBanwolSkill.nTranPoint, '', 3000);
          end;
        end;
      end;
      nCheckCode := 8;
      if (wHitMode = 7) and (m_MagicFireSwordSkill <> nil) and  //烈火剑法技能升级 20080112
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_MagicFireSwordSkill.btLevel < 3) and
        (m_MagicFireSwordSkill.MagicInfo.TrainLevel[m_MagicFireSwordSkill.btLevel] <= m_Abil.Level) then begin

        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_MagicFireSwordSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicFireSwordSkill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicFireSwordSkill.MagicInfo.wMagicId, m_MagicFireSwordSkill.btLevel, m_MagicFireSwordSkill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_MagicFireSwordSkill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_MagicFireSwordSkill) then begin
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, 0, m_MagicFireSwordSkill.MagicInfo.wMagicId, m_MagicFireSwordSkill.btLevel, m_MagicFireSwordSkill.nTranPoint, '', 3000);
          end;
        end;
      end;

      if (wHitMode = 13) and (m_Magic74Skill <> nil) and  //逐日剑法技能升级 20080511
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_Magic74Skill.btLevel < 3) and
        (m_Magic74Skill.MagicInfo.TrainLevel[m_Magic74Skill.btLevel] <= m_Abil.Level) then begin

        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_Magic74Skill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_Magic74Skill) then
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_Magic74Skill.MagicInfo.wMagicId, m_Magic74Skill.btLevel, m_Magic74Skill.nTranPoint, '', 3000);
        end else begin
          THeroObject(Self).TrainSkill(m_Magic74Skill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_Magic74Skill) then
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, 0, m_Magic74Skill.MagicInfo.wMagicId, m_Magic74Skill.btLevel, m_Magic74Skill.nTranPoint, '', 3000);
        end;
      end;

      if (wHitMode = 9) and (m_Magic42Skill <> nil) and  //开天斩技能升级 20080202
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_Magic42Skill.btLevel < 3) and
        (m_Magic42Skill.MagicInfo.TrainLevel[m_Magic42Skill.btLevel] <= m_Abil.Level) then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_Magic42Skill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_Magic42Skill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_Magic42Skill.MagicInfo.wMagicId, m_Magic42Skill.btLevel, m_Magic42Skill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_Magic42Skill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_Magic42Skill) then begin
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, 0, m_Magic42Skill.MagicInfo.wMagicId, m_Magic42Skill.btLevel, m_Magic42Skill.nTranPoint, '', 3000);
          end;
        end;
      end;

      if (wHitMode = 12) and (m_Magic43Skill <> nil) and  //龙影剑法技能升级 20080203
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_Magic43Skill.btLevel < 3) and
        (m_Magic43Skill.MagicInfo.TrainLevel[m_Magic43Skill.btLevel] <= m_Abil.Level) then begin

        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_Magic43Skill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_Magic43Skill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_Magic43Skill.MagicInfo.wMagicId, m_Magic43Skill.btLevel, m_Magic43Skill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_Magic43Skill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_Magic43Skill) then begin
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, 0, m_Magic43Skill.MagicInfo.wMagicId, m_Magic43Skill.btLevel, m_Magic43Skill.nTranPoint, '', 3000);
          end;
        end;
      end;

      if (wHitMode = 8) and (m_MagicCrsSkill <> nil) and {抱月弯刀}
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_MagicCrsSkill.btLevel < 3) and
        (m_MagicCrsSkill.MagicInfo.TrainLevel[m_MagicCrsSkill.btLevel] <= m_Abil.Level) then begin

        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_MagicCrsSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicCrsSkill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicCrsSkill.MagicInfo.wMagicId, m_MagicCrsSkill.btLevel, m_MagicCrsSkill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_MagicCrsSkill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_MagicCrsSkill) then begin
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, 0, m_MagicCrsSkill.MagicInfo.wMagicId, m_MagicCrsSkill.btLevel, m_MagicCrsSkill.nTranPoint, '', 3000);
          end;
        end;
      end;

      Result := True;
    end;

    nCheckCode := 9;
    if (nWeaponDamage > 0) and (m_UseItems[U_WEAPON].wIndex > 0) then DoDamageWeapon(nWeaponDamage);

    if (AttackTarget <> nil) and (AttackTarget.m_btRaceServer <> RC_PLAYOBJECT) then begin
        case wHitMode of//20080904 修改 开天,逐日剑法,不重发消息 20081221 过滤龙影剑法
          9,13,12: ;
          else begin
            AttackTarget.SendMsg(AttackTarget, RM_STRUCK, nPower, AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '');
          end;
        end;
      //AttackTarget.SendMsg(AttackTarget, RM_STRUCK, nPower, AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '');
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg, [m_sCharName, nCheckCode]));
    end;
  end;
end;

procedure TBaseObject.SendAttackMsg(wIdent: Word; btDir: Byte; nX, nY: Integer);
begin
  SendRefMsg(wIdent, btDir, nX, nY, 0, '');
end;
//取打击减少的损害
function TBaseObject.GetHitStruckDamage(Target: TBaseObject; nDamage: Integer): Integer;
var
  n14: Integer;
begin
  Try
    //内功护体,增加普通攻击力 20081003
    if Target <> nil then begin
      if Target.m_btRaceServer = RC_PLAYOBJECT then begin
        if TPlayObject(Target).m_boTrainingNG and (TPlayObject(Target).m_Skill69NH > 0) then begin
          //Inc(nDamage ,(TPlayObject(Target).m_NGLevel + 4));
          Inc(nDamage ,((TPlayObject(Target).m_NGLevel div g_Config.nNGLevelDamage) + 1));//20081222 改成8级增加1点攻击力
        end;
      end else
      if Target.m_btRaceServer = RC_HEROOBJECT then begin
        if THeroObject(Target).m_boTrainingNG and (THeroObject(Target).m_Skill69NH > 0) then begin
          //Inc(nDamage ,(THeroObject(Target).m_NGLevel + 4));
          Inc(nDamage ,((THeroObject(Target).m_NGLevel div g_Config.nNGLevelDamage) + 1));//20081222 改成8级增加1点攻击力
        end;
      end;
    end;

    n14 := LoWord(m_WAbil.AC) + Random(SmallInt(HiWord(m_WAbil.AC) - LoWord(m_WAbil.AC)) + 1);
    if n14 < 0 then n14:= 0;//20081020 防止为负数
    nDamage := _MAX(0, nDamage - n14);
    if (m_btLifeAttrib = LA_UNDEAD) and (Target <> nil) then begin
      Inc(nDamage, Target.m_AddAbil.bt1DF);
    end;
    if (nDamage > 0) then begin
      if (Random(g_Config.nProtectionBadRate) = 0) and m_boProtectionDefence  then begin //护体神盾被击破机率 20080109
        m_wStatusTimeArr[STATE_ProtectionDEFENCE]:=1; //触发破盾的动画 20080113
      end else
      //刺杀,开天斩，烈火 必破神盾
      if (m_LastHiter<>nil) and m_boProtectionDefence then begin
        if g_Config.RushkungBadProtection and m_LastHiter.m_boUseThrusting{刺杀} then begin
          m_wStatusTimeArr[STATE_ProtectionDEFENCE]:=1; //触发破盾的动画 20080113
        end else
        if g_Config.FirehitBadProtection and m_LastHiter.m_boFireHitSkill{烈火} then begin
          m_wStatusTimeArr[STATE_ProtectionDEFENCE]:=1; //触发破盾的动画 20080113
        end else
        if g_Config.TwnhitBadProtection and m_LastHiter.m_bo42kill{开天} then begin
          m_wStatusTimeArr[STATE_ProtectionDEFENCE]:=1; //触发破盾的动画 20080113
        end;
      end;

      if m_boProtectionDefence then begin //护体神盾 20080107  每级增加3%的生效机率
        if Random(100) <= (g_Config.nProtectionOKRate + m_boProtectionDefenceLevel * 3) then begin//生效机率 20080929
          if g_Config.nProtectionDefenceTime <> 0 then begin //最长时间不为0 20080218
            if GetTickCount() - m_dwStatusArrTick[STATE_ProtectionDEFENCE] < g_Config.nProtectionDefenceTime then begin //最长时间
              nDamage := Round(nDamage * (1 - g_Config.nProtectionRate / 100));
              //发送护体神盾 受攻击 动画
             if g_Config.boShowProtectionEnv then SendRefMsg(RM_MYSHOW, ET_PROTECTION_STRUCK, 0, 0, 0, '');//20080222
            end  else begin
              m_wStatusTimeArr[STATE_ProtectionDEFENCE]:=1; //触发破盾的动画 20080113
            end;
          end else begin
            nDamage := Round(nDamage * (1 - g_Config.nProtectionRate / 100));
            //发送护体神盾 受攻击 动画
           if g_Config.boShowProtectionEnv then SendRefMsg(RM_MYSHOW, ET_PROTECTION_STRUCK, 0, 0, 0, '');//20080222
          end;
        end;
        DamageProtectionDefence(nDamage);//减少使用时间
      end;

      if m_boAbilMagBubbleDefence then begin //魔法盾 0-15% 1-30% 2-45% 3-60% 4-75%
        if m_btMagBubbleDefenceLevel < 4 then begin//20080829 四级盾可以自己设置比例
          nDamage := Round(nDamage *((100 - (m_btMagBubbleDefenceLevel + 1) * g_Config.nOrdinarySkill66Rate{15})/100));//20080625 修改
          //nDamage := Round((nDamage / 1.0E2) * (m_btMagBubbleDefenceLevel + 2) * 8.0);
        end else begin
          nDamage := Round(nDamage *((100 - g_Config.nSkill66Rate)/100));//四级盾
        end;
        DamageBubbleDefence(nDamage);//减少打击的损害
      end;

      //内功护体,减少普通攻击伤害 20081003
      if (nDamage > 0) then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          if TPlayObject(Self).m_boTrainingNG and (TPlayObject(Self).m_Skill69NH > 0) then begin
            //nDamage := _MAX(0, nDamage - (TPlayObject(Self).m_NGLevel + 4));
            nDamage := _MAX(0, nDamage - ((TPlayObject(Self).m_NGLevel div g_Config.nNGLevelDamage) + 1));//20081222 改成8级增加1点防御力
            TPlayObject(Self).m_Skill69NH:= _MAX(0, TPlayObject(Self).m_Skill69NH - g_Config.nHitStruckDecNH);
            TPlayObject(Self).SendRefMsg( RM_MAGIC69SKILLNH, 0, TPlayObject(Self).m_Skill69NH, TPlayObject(Self).m_Skill69MaxNH, 0, '');
          end;
        end else
        if m_btRaceServer = RC_HEROOBJECT then begin
          if THeroObject(Self).m_boTrainingNG and (THeroObject(Self).m_Skill69NH > 0) then begin
            //nDamage := _MAX(0, nDamage - (THeroObject(Self).m_NGLevel + 4));
            nDamage := _MAX(0, nDamage - ((THeroObject(Self).m_NGLevel div g_Config.nNGLevelDamage) + 1));//20081222 改成8级增加1点防御力
            THeroObject(Self).m_Skill69NH:= _MAX(0, THeroObject(Self).m_Skill69NH - g_Config.nHitStruckDecNH);
            THeroObject(Self).SendRefMsg( RM_MAGIC69SKILLNH, 0, THeroObject(Self).m_Skill69NH, THeroObject(Self).m_Skill69MaxNH, 0, '');
          end;
        end;
      end;
    end;
    //Result := nDamage;
    Result := ItemStruckDamage(nDamage);//20080223 新戒指减少损害值
  except
    MainOutMessage('{异常} TBaseObject.GetHitStruckDamage');
  end;
end;
//取魔法攻击,减少的损害
function TBaseObject.GetMagStruckDamage(BaseObject: TBaseObject; nDamage: Integer): Integer;
var
  n14: Integer;
  nCode: byte;
begin
  Try
    nCode:= 0;
    //内功护体,增加普通攻击力 20081003
    if BaseObject <> nil then begin
      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
        nCode:= 1;
        if TPlayObject(BaseObject).m_boTrainingNG and (TPlayObject(BaseObject).m_Skill69NH > 0) then begin
          nCode:= 2;
          //Inc(nDamage ,(TPlayObject(BaseObject).m_NGLevel + 4));
          Inc(nDamage ,((TPlayObject(BaseObject).m_NGLevel div g_Config.nNGLevelDamage) + 1));//20081222 改成8级增加1点攻击力
        end;
      end else
      if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin
        nCode:= 3;
        if THeroObject(BaseObject).m_boTrainingNG and (THeroObject(BaseObject).m_Skill69NH > 0) then begin
          nCode:= 4;
          //Inc(nDamage ,(THeroObject(BaseObject).m_NGLevel + 4));
          Inc(nDamage ,((THeroObject(BaseObject).m_NGLevel div g_Config.nNGLevelDamage) + 1));//20081222 改成8级增加1点攻击力
        end;
      end;
    end;
    nCode:= 5;
    n14 := LoWord(m_WAbil.MAC) + Random(SmallInt(HiWord(m_WAbil.MAC) - LoWord(m_WAbil.MAC)) + 1);
    if n14 < 0 then n14:= 0;//20081020 防止为负数
    nDamage := _MAX(0, nDamage - n14);
    if (m_btLifeAttrib = LA_UNDEAD) and (BaseObject <> nil) then begin
      Inc(nDamage, m_AddAbil.bt1DF);
    end;
    nCode:= 6;
    if (nDamage > 0) then begin
      if (Random(g_Config.nProtectionBadRate) = 0) and m_boProtectionDefence then begin //护体神盾被击破机率 20080109
        m_wStatusTimeArr[STATE_ProtectionDEFENCE]:=1; //触发破盾的动画 20080114
      end else
      //刺杀,开天斩，烈火 必破神盾  20080114
      if (m_LastHiter <> nil) and m_boProtectionDefence then begin
        if g_Config.RushkungBadProtection and m_LastHiter.m_boUseThrusting{刺杀} then begin
          m_wStatusTimeArr[STATE_ProtectionDEFENCE]:=1; //触发破盾的动画 20080113
        end else
        if g_Config.FirehitBadProtection and m_LastHiter.m_boFireHitSkill{烈火} then begin
          m_wStatusTimeArr[STATE_ProtectionDEFENCE]:=1; //触发破盾的动画 20080113
        end else
        if g_Config.TwnhitBadProtection and m_LastHiter.m_bo42kill{开天} then begin
          m_wStatusTimeArr[STATE_ProtectionDEFENCE]:=1; //触发破盾的动画 20080113
        end;
      end;
      nCode:= 7;
      if m_boProtectionDefence then begin //护体神盾 20080107  每级增加3%的生效机率
        if Random(100) <= (g_Config.nProtectionOKRate + m_boProtectionDefenceLevel * 3) then begin//生效机率 20080929
          if g_Config.nProtectionDefenceTime <> 0 then begin //最长时间不为0 20080218
            if GetTickCount()-m_dwStatusArrTick[STATE_ProtectionDEFENCE] < g_Config.nProtectionDefenceTime then begin //最长时间 20080108
              nDamage := Round(nDamage * (1 - g_Config.nProtectionRate / 100));
              //发送护体神盾 受攻击 动画
              if g_Config.boShowProtectionEnv then SendRefMsg(RM_MYSHOW, ET_PROTECTION_STRUCK, 0, 0, 0, '');//20080222
            end else begin
              m_wStatusTimeArr[STATE_ProtectionDEFENCE]:=1; //触发破盾的动画 20080113
            end;
          end else begin
            nDamage := Round(nDamage * (1 - g_Config.nProtectionRate / 100));
            //发送护体神盾 受攻击 动画
            if g_Config.boShowProtectionEnv then SendRefMsg(RM_MYSHOW, ET_PROTECTION_STRUCK, 0, 0, 0, '');//20080222
          end;
        end;
        DamageProtectionDefence(nDamage);//减少使用时间
      end;
      nCode:= 8;
      if m_boAbilMagBubbleDefence then begin //魔法盾  0-15% 1-30% 2-45% 3-60% 4-75%
        if m_btMagBubbleDefenceLevel < 4 then begin//20080829 四级盾可以自己设置比例
          nDamage :=Round(nDamage *((100 - (m_btMagBubbleDefenceLevel + 1) * g_Config.nOrdinarySkill66Rate{15})/100));//20080625 修改
          //nDamage := Round((nDamage / 1.0E2) * (m_btMagBubbleDefenceLevel + 2) * 8.0);//1.0E2表示100
        end else begin
          nDamage := Round(nDamage *((100 - g_Config.nSkill66Rate)/100));//四级盾
        end;
        DamageBubbleDefence(nDamage);//减少盾的使用时间
      end;
      nCode:= 9;
      //内功护体,减少普通攻击伤害 20081003
      if (nDamage > 0) then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          nCode:= 10;
          if TPlayObject(Self).m_boTrainingNG and (TPlayObject(Self).m_Skill69NH > 0) then begin
            nCode:= 11;
            //nDamage := _MAX(0, nDamage - (TPlayObject(Self).m_NGLevel + 4));
            nDamage := _MAX(0, nDamage - ((TPlayObject(Self).m_NGLevel div g_Config.nNGLevelDamage) + 1));//20081222 改成8级增加1点防御力
            TPlayObject(Self).m_Skill69NH:= _MAX(0, TPlayObject(Self).m_Skill69NH - g_Config.nHitStruckDecNH);
            TPlayObject(Self).SendRefMsg( RM_MAGIC69SKILLNH, 0, TPlayObject(Self).m_Skill69NH, TPlayObject(Self).m_Skill69MaxNH, 0, '');
          end;
        end else
        if m_btRaceServer = RC_HEROOBJECT then begin
          nCode:= 12;
          if THeroObject(Self).m_boTrainingNG and (THeroObject(Self).m_Skill69NH > 0) then begin
            nCode:= 13;
            //nDamage := _MAX(0, nDamage - (THeroObject(Self).m_NGLevel + 4));
            nDamage := _MAX(0, nDamage - ((THeroObject(Self).m_NGLevel div g_Config.nNGLevelDamage) + 1));//20081222 改成8级增加1点防御力
            THeroObject(Self).m_Skill69NH:= _MAX(0, THeroObject(Self).m_Skill69NH - g_Config.nHitStruckDecNH);
            THeroObject(Self).SendRefMsg( RM_MAGIC69SKILLNH, 0, THeroObject(Self).m_Skill69NH, THeroObject(Self).m_Skill69MaxNH, 0, '');
          end;
        end;
      end;
    end;
    nCode:= 14;
    //Result := nDamage;
    Result := ItemStruckDamage(nDamage);//20080223 吸伤减少损害值
  except
    MainOutMessage('{异常} TBaseObject.GetMagStruckDamage Code:'+inttostr(nCode));
  end;
end;
//受攻击,减身上装备的持久
procedure TBaseObject.StruckDamage(nDamage: Integer);
var
  I: Integer;
  nDam: Integer;
  nDura, nOldDura: Integer;
  PlayObject: TPlayObject;
  StdItem: pTStdItem;
  bo19: Boolean;
begin
  if nDamage <= 0 then Exit;
  nDam := Random(10) + 5;
  if m_wStatusTimeArr[POISON_DAMAGEARMOR ] > 0 then begin
    nDam := Round(nDam * (g_Config.nPosionDamagarmor / 10) {1.2});
    nDamage := Round(nDamage * (g_Config.nPosionDamagarmor / 10) {1.2});
  end;
  bo19 := False;
  if m_UseItems[U_DRESS].wIndex > 0 then begin
    nDura := m_UseItems[U_DRESS].Dura;
    nOldDura := Round(nDura / 1000);
    Dec(nDura, nDam);
    if nDura <= 0 then begin
      if m_btRaceServer = RC_PLAYOBJECT then begin
        PlayObject := TPlayObject(Self);
        PlayObject.SendDelItems(@m_UseItems[U_DRESS]);
        StdItem := UserEngine.GetStdItem(m_UseItems[U_DRESS].wIndex);
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('3' + #9 + m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 + StdItem.Name + #9 +
            IntToStr(m_UseItems[U_DRESS].MakeIndex) + #9 +
            '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
            '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
            '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
            '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
            '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
            IntToStr(m_UseItems[U_DRESS].btValue[0])+'/'+IntToStr(m_UseItems[U_DRESS].btValue[1])+'/'+IntToStr(m_UseItems[U_DRESS].btValue[2])+'/'+
            IntToStr(m_UseItems[U_DRESS].btValue[3])+'/'+IntToStr(m_UseItems[U_DRESS].btValue[4])+'/'+IntToStr(m_UseItems[U_DRESS].btValue[5])+'/'+
            IntToStr(m_UseItems[U_DRESS].btValue[6])+'/'+IntToStr(m_UseItems[U_DRESS].btValue[7])+'/'+IntToStr(m_UseItems[U_DRESS].btValue[8])+'/'+
            IntToStr(m_UseItems[U_DRESS].btValue[14])+ #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT));
        m_UseItems[U_DRESS].wIndex := 0;
        FeatureChanged();
      end;
      m_UseItems[U_DRESS].wIndex := 0;
      m_UseItems[U_DRESS].Dura := 0;
      bo19 := True;
    end else begin
      m_UseItems[U_DRESS].Dura := nDura;
    end;
    if nOldDura <> Round(nDura / 1000) then begin
      SendMsg(Self, RM_DURACHANGE, U_DRESS, nDura, m_UseItems[U_DRESS].DuraMax, 0, '');
    end;
  end;
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    if (m_UseItems[I].wIndex > 0) and (Random(8) = 0) then begin
      StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);//20080404
      if (StdItem <> nil) and (((StdItem.StdMode = 2) and (StdItem.AniCount = 21)) or (StdItem.StdMode = 25) or (StdItem.StdMode = 7)) then Continue;//是祝福罐,火龙之心物品则跳过 20080404
      nDura := m_UseItems[I].Dura;
      nOldDura := Round(nDura / 1000);
      Dec(nDura, nDam);
      if nDura <= 0 then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          PlayObject := TPlayObject(Self);
          PlayObject.SendDelItems(@m_UseItems[I]);
          //StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex); //20080404
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('3' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 + StdItem.Name + #9 +
              IntToStr(m_UseItems[I].MakeIndex) + #9 +
              '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
              '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
              '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
              '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
              '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
              IntToStr(m_UseItems[I].btValue[0])+'/'+IntToStr(m_UseItems[I].btValue[1])+'/'+IntToStr(m_UseItems[I].btValue[2])+'/'+
              IntToStr(m_UseItems[I].btValue[3])+'/'+IntToStr(m_UseItems[I].btValue[4])+'/'+IntToStr(m_UseItems[I].btValue[5])+'/'+
              IntToStr(m_UseItems[I].btValue[6])+'/'+IntToStr(m_UseItems[I].btValue[7])+'/'+IntToStr(m_UseItems[I].btValue[8])+'/'+
              IntToStr(m_UseItems[I].btValue[14]) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) );
          m_UseItems[I].wIndex := 0;
          FeatureChanged();
        end;
        m_UseItems[I].wIndex := 0;
        m_UseItems[I].Dura := 0;
        bo19 := True;
      end else begin
        m_UseItems[I].Dura := nDura;
      end;//if nDura <= 0 then begin
      if nOldDura <> Round(nDura / 1000) then begin
        SendMsg(Self, RM_DURACHANGE, I, nDura, m_UseItems[I].DuraMax, 0, '');
      end;
    end;// if (m_UseItems[I].wIndex > 0) and (Random(8) = 0) then begin
  end;//for I := Low(THumanUseItems) to High(THumanUseItems) do begin
  if bo19 then begin
    RecalcAbilitys();
    CompareSuitItem(False);//套装与身上装备对比 20080729
  end;
  DamageHealth(nDamage);
end;

function TBaseObject.GeTBaseObjectInfo(): string;
begin
  Result := m_sCharName + ' ' +
    '地图:' + m_sMapName + '(' + m_PEnvir.sMapDesc + ') ' +
    '座标:' + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY) + ' ' +
    '等级:' + IntToStr(m_Abil.Level) + ' ' +
    '经验:' + IntToStr(m_Abil.Exp) + ' ' +
    '生命值: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP) + ' ' +
    '魔法值: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP) + ' ' +
    '攻击力: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)) + ' ' +
    '魔法力: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)) + ' ' +
    '道术: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)) + ' ' +
    '防御力: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)) + ' ' +
    '魔防力: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)) + ' ' +
    '准确:' + IntToStr(m_btHitPoint) + ' ' +
    '敏捷:' + IntToStr(m_btSpeedPoint);
end;

function TBaseObject.GetBackPosition(var nX, nY: Integer): Boolean;
var
  Envir: TEnvirnoment;
begin
  Envir := m_PEnvir;
  nX := m_nCurrX;
  nY := m_nCurrY;
  case m_btDirection of
    DR_UP{0}: if nY < (Envir.m_nHeight - 1) then Inc(nY);
    DR_DOWN{4}: if nY > 0 then Dec(nY);
    DR_LEFT{6}: if nX < (Envir.m_nWidth - 1) then Inc(nX);
    DR_RIGHT{2}: if nX > 0 then Dec(nX);
    DR_UPLEFT{西北向}: begin
        if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then begin
          Inc(nX);
          Inc(nY);
        end;
      end;
    DR_UPRIGHT{东北向}: begin
        if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then begin
          Dec(nX);
          Inc(nY);
        end
      end;
    DR_DOWNLEFT{西南向}: begin
        if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then begin
          Inc(nX);
          Dec(nY);
        end;
      end;
    DR_DOWNRIGHT{东南向}: begin
        if (nX > 0) and (nY > 0) then begin
          Dec(nX);
          Dec(nY);
        end;
      end;
  end;
  Result := True;
end;
//物理攻击
procedure TAnimalObject.HitMagAttackTarget(TargeTBaseObject: TBaseObject; nHitPower,
  nMagPower: Integer; boFlag: Boolean);
var
  I: Integer;
  nDamage: Integer;
  BaseObjectList: TList;
  BaseObject: TBaseObject;
begin
  m_btDirection := GetNextDirection(m_nCurrX, m_nCurrY, TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY);
  BaseObjectList := TList.Create;
  m_PEnvir.GeTBaseObjects(TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY, False, BaseObjectList);
  if BaseObjectList.Count > 0 then begin//20080629
    for I := 0 to BaseObjectList.Count - 1 do begin
      BaseObject := TBaseObject(BaseObjectList.Items[I]);
      if IsProperTarget(BaseObject) then begin
        nDamage := 0;
        Inc(nDamage, BaseObject.GetHitStruckDamage(Self, nHitPower));
        Inc(nDamage, BaseObject.GetMagStruckDamage(Self, nMagPower));
        if nDamage > 0 then begin
          BaseObject.StruckDamage(nDamage);
          BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nDamage, BaseObject.m_WAbil.HP, BaseObject.m_WAbil.MaxHP, Integer(Self), '', 200);
        end;
      end;
    end;
  end;
  BaseObjectList.Free;
  SendRefMsg(RM_HIT, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TAnimalObject.DelTargetCreat;
begin
  inherited;
  m_nTargetX := -1;
  m_nTargetY := -1;
end;
//搜索目标
procedure TAnimalObject.SearchTarget;
var
  BaseObject, BaseObject18: TBaseObject;
  I, nC, n10: Integer;
begin
  BaseObject18 := nil;
  //n10 := 9999;
  n10 := 11;//20080803
  if m_VisibleActors.Count > 0 then begin//20081214
    for I := 0 to m_VisibleActors.Count - 1 do begin
      BaseObject := TBaseObject(pTVisibleBaseObject(m_VisibleActors.Items[I]).BaseObject);
      if BaseObject <> nil then begin
        //目标为英雄,且等级不超过22级,跟随状态,则不攻击英雄 20080421
        if (BaseObject.m_btRaceServer = RC_HEROOBJECT) and (BaseObject.m_Abil.Level <= 22) and (THEROOBJECT(BaseObject).m_btStatus = 1) then Continue;
        if not BaseObject.m_boDeath then begin
          if IsProperTarget(BaseObject) and
            (not BaseObject.m_boHideMode or m_boCoolEye) then begin
            nC := abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY - BaseObject.m_nCurrY);
            if nC <= n10 then begin
              n10 := nC;
              BaseObject18 := BaseObject;
            end;
          end;
        end;
      end;
    end;
  end;
  if BaseObject18 <> nil then SetTargetCreat(BaseObject18);
end;

procedure TAnimalObject.sub_4C959C;
var
  I, nC, n10: Integer;
  Creat, BaseObject: TBaseObject;
begin
  Creat := nil;
  n10 := 10{9999};//20080629
  if m_VisibleActors.Count > 0 then begin//20080629
    for I := 0 to m_VisibleActors.Count - 1 do begin
      BaseObject := TBaseObject(pTVisibleBaseObject(m_VisibleActors.Items[I]).BaseObject);
      if BaseObject <> nil then begin
        if BaseObject.m_boDeath then Continue;
        if IsProperTarget(BaseObject) then begin
          nC := abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY - BaseObject.m_nCurrY);
          if nC < n10 then begin
            n10 := nC;
            Creat := BaseObject;
          end;
        end;
      end;
    end; // for
  end;
  if Creat <> nil then SetTargetCreat(Creat);
end;

procedure TAnimalObject.SetTargetXY(nX, nY: Integer);
begin
  m_nTargetX := nX;
  m_nTargetY := nY;
end;

procedure TAnimalObject.Wondering;
begin
  if (Random(20) = 0) then
    if (Random(4) = 1) then TurnTo(Random(8))
    else WalkTo(m_btDirection, False);
end;
//中毒
function TBaseObject.MakePosion(nType, nTime, nPoint: Integer): Boolean;
var
  nOldCharStatus: Integer;
  nCheckCode: byte;//测试用 20080528
begin
  Result := False;
  nCheckCode:=0;
try
  if (nType < MAX_STATUS_ATTRIBUTE) and (nType >= 0) then begin//20081203  防止组数越界
    nCheckCode:=1;
    nOldCharStatus := m_nCharStatus;
    nCheckCode:=2;
    if m_wStatusTimeArr[nType] > 0 then begin
      if m_wStatusTimeArr[nType] < nTime then begin //20080330 修改,
        m_wStatusTimeArr[nType] := nTime;
      end;
      //m_wStatusTimeArr[nType] := m_wStatusTimeArr[nType] + nTime;//时间累加 20080330
    end else begin //004C35FF
      m_wStatusTimeArr[nType] := nTime;
    end;
    nCheckCode:=3;
    m_dwStatusArrTick[nType] := GetTickCount();
    m_nCharStatus := GetCharStatus();
    m_btGreenPoisoningPoint := nPoint;
    nCheckCode:=4;
    if nOldCharStatus <> m_nCharStatus then StatusChanged('');
    if m_btRaceServer = RC_PLAYOBJECT then begin
     nCheckCode:=5;
{$IF DEBUG = 1}
      SysMsg(Format(sYouPoisoned{'中毒了！！！%d秒 %d点'}, [nTime, nPoint]), c_Red, t_Hint);
{$ELSE}
      SysMsg(sYouPoisoned {中毒了！！！}, c_Red, t_Hint);
{$IFEND}
    end else
    if m_btRaceServer = RC_HEROOBJECT then begin//20080425 英雄中毒提示
    nCheckCode:=6;
{$IF DEBUG = 1}
     if m_Master <> nil then m_Master.SysMsg(Format('(英雄) '+sYouPoisoned, [nTime, nPoint]), c_Red, t_Hint);
{$ELSE}
     if m_Master <> nil then m_Master.SysMsg('(英雄) '+ sYouPoisoned, c_Red, t_Hint);
{$IFEND}
    end;
    Result := True;
  end;
  except
    MainOutMessage('{异常} TBaseObject.MakePosion Code:'+inttostr(nCheckCode));
  end;
end;

//中蛛网，不能跑动 20080811
function TBaseObject.MakeSpiderMag(nTime: Integer): Boolean;
var
  nOldCharStatus: Integer;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_LOCKRUN] <> 0 then Exit;
  nOldCharStatus := m_nCharStatus;
  m_wStatusTimeArr[STATE_LOCKRUN] := nTime; //持继多少久(秒)
  m_dwStatusArrTick[STATE_LOCKRUN] := GetTickCount();//人物状态持续的开始时间
  m_nCharStatus := GetCharStatus();
  if nOldCharStatus <> m_nCharStatus then StatusChanged('');
  if m_btRaceServer = RC_PLAYOBJECT then begin
    TPlayObject(self).m_boCanRun:= False;//是否允许跑
    SysMsg(sYouPoisonedSpider, c_Red, t_Hint);//中蛛网提示
  end else
  if m_btRaceServer = RC_HEROOBJECT then begin
    THeroObject(self).m_boCanRun:= False;//是否允许跑
    if m_Master <> nil then m_Master.SysMsg('(英雄) '+ sYouPoisonedSpider, c_Red, t_Hint);//中蛛网提示
  end;
  Result := True;
end;

function TBaseObject.sub_4DD704: Boolean;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := False;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    if m_MsgList.Count > 0 then begin//20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage <> nil) and (SendMessage.wIdent = RM_10401) then begin
          Result := True;
          Break;
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;
//发送保存到普通仓库的物品 
procedure TPlayObject.SendSaveItemList(nBaseObject: Integer);
var
  I : Integer;
  Item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  StdItem: TStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if m_nSoftVersionDateEx = 0 then begin
    sSENDMSG := '';
    if m_StorageItemList.Count > 0 then begin//20080629
      for I := 0 to m_StorageItemList.Count - 1 do begin
        UserItem := m_StorageItemList.Items[I];
        Item := UserEngine.GetStdItem(UserItem.wIndex);
        if Item <> nil then begin
          StdItem := Item^;
          ItemUnit.GetItemAddValue(UserItem, StdItem);
          CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName <> '' then
            OClientItem.s.Name := sUserItemName;
          OClientItem.Dura := UserItem.Dura;
          OClientItem.DuraMax := UserItem.DuraMax;
          OClientItem.MakeIndex := UserItem.MakeIndex;
          sSENDMSG := sSENDMSG + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
        end;
      end;//for
    end;
    m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 0, 0, m_StorageItemList.Count, 0);
    SendSocket(@m_DefMsg, sSENDMSG);
  end else begin
    sSENDMSG := '';
    if m_StorageItemList.Count > 0 then begin//20080629
      for I := 0 to m_StorageItemList.Count - 1 do begin
        UserItem := m_StorageItemList.Items[I];
        Item := UserEngine.GetStdItem(UserItem.wIndex);
        if Item <> nil then begin
          StdItem := Item^;
          ItemUnit.GetItemAddValue(UserItem, StdItem);
          Move(StdItem, ClientItem.s, SizeOf(TStdItem));
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;

          if UserItem.btValue[12] = 1 then ClientItem.s.Reserved1:=1 //物品发光 20080708
           else ClientItem.s.Reserved1:= 0;

          if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080708
            if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//酒的品质
            if UserItem.btValue[1] <> 0 then ClientItem.s.MAC:=UserItem.btValue[1];//酒的酒精度
          end;

          if StdItem.StdMode = 8 then begin//酿酒材料 20080708
            if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//材料的品质
          end;

          ClientItem.Dura := UserItem.Dura;
          ClientItem.DuraMax := UserItem.DuraMax;
          ClientItem.MakeIndex := UserItem.MakeIndex;
          sSENDMSG := sSENDMSG + EncodeBuffer(@ClientItem, SizeOf(TClientItem)) + '/';
        end;
      end;//for
    end;
    m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 0, 0, m_StorageItemList.Count, 0);
    SendSocket(@m_DefMsg, sSENDMSG);
  end;
end;
//发送保存到无限仓库的物品 
procedure TPlayObject.SendSaveBigStorageItemList(nBaseObject: Integer; nPage: Integer);
var
  I: Integer;
  Item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  StdItem: TStdItem;
  sUserItemName: string;
  BigStorage: pTBigStorage;
  nCount: Integer;
  nIndex: Integer;
  function GetPageCount(nListCount: Integer): Integer;
  begin
    Result := 0;
    if nListCount > 0 then begin
      Result := nListCount div 50;
      if (nListCount mod 50) > 0 then Inc(Result);
    end;
  end;
begin
  if m_nSoftVersionDateEx = 0 then begin
    sSENDMSG := '';
    nCount := 0;
    nIndex := 0;//20080522
    if m_BigStorageItemList <> nil then begin
      if nPage = 0 then nIndex := 0;
      if nPage > 0 then nIndex := nPage * 50;
      if nIndex > m_BigStorageItemList.Count - 1 then begin
        m_nBigStoragePage := GetPageCount(m_BigStorageItemList.Count);
        Exit;
      end;
      for I := nIndex to m_BigStorageItemList.Count - 1 do begin
        BigStorage := m_BigStorageItemList.Items[I];
        Item := UserEngine.GetStdItem(BigStorage.UseItems.wIndex);
        if Item <> nil then begin
          Inc(nCount);
          StdItem := Item^;
          ItemUnit.GetItemAddValue(@BigStorage.UseItems, StdItem);
          CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
          //取自定义物品名称
          sUserItemName := '';
          if BigStorage.UseItems.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(BigStorage.UseItems.MakeIndex, BigStorage.UseItems.wIndex);
          if sUserItemName <> '' then
            OClientItem.s.Name := sUserItemName;
          OClientItem.Dura := BigStorage.UseItems.Dura;
          OClientItem.DuraMax := BigStorage.UseItems.DuraMax;
          OClientItem.MakeIndex := BigStorage.UseItems.MakeIndex;
          sSENDMSG := sSENDMSG + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
          if nCount >= 50 then Break;
        end;
      end;
    end;
    m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 0, 0, nCount, 0);
    SendSocket(@m_DefMsg, sSENDMSG);
  end else begin
    sSENDMSG := '';
    nCount := 0;
    nIndex := 0;//20080522
    if m_BigStorageItemList <> nil then begin
      if nPage = 0 then nIndex := 0;
      if nPage > 0 then nIndex := nPage * 50;
      if nIndex > m_BigStorageItemList.Count - 1 then begin
        m_nBigStoragePage := GetPageCount(m_BigStorageItemList.Count);
        Exit;
      end;
      for I := nIndex to m_BigStorageItemList.Count - 1 do begin
        BigStorage := m_BigStorageItemList.Items[I];
        Item := UserEngine.GetStdItem(BigStorage.UseItems.wIndex);
        if Item <> nil then begin
          Inc(nCount);
          StdItem := Item^;
          ItemUnit.GetItemAddValue(@BigStorage.UseItems, StdItem);
          Move(StdItem, ClientItem.s, SizeOf(TStdItem));
          //取自定义物品名称
          sUserItemName := '';
          if BigStorage.UseItems.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(BigStorage.UseItems.MakeIndex, BigStorage.UseItems.wIndex);
          if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;

          if BigStorage.UseItems.btValue[12] = 1 then ClientItem.s.Reserved1:=1 //物品发光 20080708
           else ClientItem.s.Reserved1:= 0;

          if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080708
            if BigStorage.UseItems.btValue[0] <> 0 then ClientItem.s.AC:=BigStorage.UseItems.btValue[0];//酒的品质
            if BigStorage.UseItems.btValue[1] <> 0 then ClientItem.s.MAC:=BigStorage.UseItems.btValue[1];//酒的酒精度
          end;

          if StdItem.StdMode = 8 then begin//酿酒材料 20080708
            if BigStorage.UseItems.btValue[0] <> 0 then ClientItem.s.AC:=BigStorage.UseItems.btValue[0];//材料的品质
          end;

          ClientItem.Dura := BigStorage.UseItems.Dura;
          ClientItem.DuraMax := BigStorage.UseItems.DuraMax;
          ClientItem.MakeIndex := BigStorage.UseItems.MakeIndex;
          sSENDMSG := sSENDMSG + EncodeBuffer(@ClientItem, SizeOf(TClientItem)) + '/';
          if nCount >= 50 then Break;
        end;
      end;
    end;
    m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 0, 0, nCount, 0);
    SendSocket(@m_DefMsg, sSENDMSG);
  end;
end;

procedure TPlayObject.SendChangeGuildName;
begin
  if m_MyGuild <> nil then begin
    SendDefMessage(SM_CHANGEGUILDNAME, 0, 0, 0, 0, TGUild(m_MyGuild).sGuildName + '/' + m_sGuildRankName);
  end else begin
    SendDefMessage(SM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.SendDelItemList(ItemList: TStringList);
var
  I: Integer;
  s10: string;
begin
  s10 := '';
  if ItemList.Count > 0 then begin//20080629
    for I := 0 to ItemList.Count - 1 do begin
      s10 := s10 + ItemList.Strings[I] + '/' + IntToStr(Integer(ItemList.Objects[I])) + '/';
    end;
  end;
  m_DefMsg := MakeDefaultMsg(SM_DELITEMS, 0, 0, 0, ItemList.Count, 0);
  SendSocket(@m_DefMsg, EncodeString(s10));
end;

procedure TPlayObject.SendDelItems(UserItem: pTUserItem);
var
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  //sItemNewName:=GetItemName(UserItem.MakeIndex);
  if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then begin
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(@UserItem, StdItem80);
      //Move(StdItem80,ClientItem.S,SizeOf(TStdItem));
      CopyStdItemToOStdItem(@StdItem80, @OClientItem.s);

      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        OClientItem.s.Name := sUserItemName;

      OClientItem.MakeIndex := UserItem.MakeIndex;
      OClientItem.Dura := UserItem.Dura;
      OClientItem.DuraMax := UserItem.DuraMax;
      {if StdItem.StdMode = 50 then begin//20080808 注释
        OClientItem.s.Name := OClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
      end;}
      m_DefMsg := MakeDefaultMsg(SM_DELITEM, Integer(Self), 0, 0, 1, 0);
      SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
    end;
  end else begin
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(@UserItem, StdItem80);
      Move(StdItem80, ClientItem.s, SizeOf(TStdItem));
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.s.Name := sUserItemName;
      if UserItem.btValue[12] = 1 then ClientItem.s.Reserved1:=1//物品发光 20080224
       else ClientItem.s.Reserved1:= 0;

      if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080622
        if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//酒的品质
        if UserItem.btValue[1] <> 0 then ClientItem.s.MAC:=UserItem.btValue[1];//酒的酒精度
      end;

      ClientItem.MakeIndex := UserItem.MakeIndex;
      ClientItem.Dura := UserItem.Dura;
      ClientItem.DuraMax := UserItem.DuraMax;
      {if StdItem.StdMode = 50 then begin //20080808 注释
        ClientItem.s.Name := ClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
      end;}
      m_DefMsg := MakeDefaultMsg(SM_DELITEM, Integer(Self), 0, 0, 1, 0);
      SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
    end;
  end;
end;

procedure TPlayObject.SendUpdateItem(UserItem: pTUserItem);
var
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then begin
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem80);
      //Move(StdItem80,ClientItem.S,SizeOf(TStdItem));
      CopyStdItemToOStdItem(@StdItem80, @OClientItem.s);

      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        OClientItem.s.Name := sUserItemName;
      OClientItem.MakeIndex := UserItem.MakeIndex;
      OClientItem.Dura := UserItem.Dura;
      OClientItem.DuraMax := UserItem.DuraMax;
      {if StdItem.StdMode = 50 then begin //20080808 注释
        OClientItem.s.Name := ClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
      end;}
      m_DefMsg := MakeDefaultMsg(SM_UPDATEITEM, Integer(Self), 0, 0, 1, 0);
      SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
    end;
  end else begin
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem80);
      ClientItem.s := StdItem80;

      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.s.Name := sUserItemName;
      if UserItem.btValue[12] = 1 then ClientItem.s.Reserved1:=1//物品发光 20080223
       else ClientItem.s.Reserved1:=0 ;

      if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080622
        if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//酒的品质
        if UserItem.btValue[1] <> 0 then ClientItem.s.MAC:=UserItem.btValue[1];//酒的酒精度
      end;

      ClientItem.MakeIndex := UserItem.MakeIndex;
      ClientItem.Dura := UserItem.Dura;
      ClientItem.DuraMax := UserItem.DuraMax;
      {if StdItem.StdMode = 50 then begin //20080808 注释
        ClientItem.s.Name := ClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
      end;}
      m_DefMsg := MakeDefaultMsg(SM_UPDATEITEM, Integer(Self), 0, 0, 1, 0);
      SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
    end;
  end;
end;
//检查装备是否可以穿上身
function TPlayObject.CheckTakeOnItems(nWhere: Integer; var StdItem: TStdItem): Boolean; //004C5084
var
  Castle: TUserCastle;
begin
  Result := False;
  if (StdItem.StdMode = 10) and (m_btGender <> 0) then begin
    SysMsg(sWearNotOfWoMan, c_Red, t_Hint);
    Exit;
  end;
  if (StdItem.StdMode = 11) and (m_btGender <> 1) then begin
    SysMsg(sWearNotOfMan, c_Red, t_Hint);
    Exit;
  end;
  if (nWhere = 1) or (nWhere = 2) then begin
    if StdItem.Weight > m_WAbil.MaxHandWeight then begin
      SysMsg(sHandWeightNot, c_Red, t_Hint);
      Exit;
    end;
  end else begin
    if (StdItem.Weight + GetUserItemWeitht(nWhere)) > m_WAbil.MaxWearWeight then begin
      SysMsg(sWearWeightNot, c_Red, t_Hint);//负重不足
      Exit;
    end;
  end;
  Castle := g_CastleManager.IsCastleMember(Self);
  case StdItem.Need of //
    0: begin//等级
        if m_Abil.Level >= StdItem.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sLevelNot, c_Red, t_Hint);
        end;
      end;
    1: begin//攻击力
        if HiWord(m_WAbil.DC) >= StdItem.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sDCNot, c_Red, t_Hint);
        end;
      end;
    10: begin//职业+等级
        if (m_btJob = LoWord(StdItem.NeedLevel)) and (m_Abil.Level >= HiWord(StdItem.NeedLevel)) then begin
          Result := True;
        end else begin
          SysMsg(g_sJobOrLevelNot, c_Red, t_Hint);
        end;
      end;
    11: begin//职业+攻击力
        if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.DC) >= HiWord(StdItem.NeedLevel)) then begin
          Result := True;
        end else begin
          SysMsg(g_sJobOrDCNot, c_Red, t_Hint);
        end;
      end;
    12: begin//职业+魔法力
        if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.MC) >= HiWord(StdItem.NeedLevel)) then begin
          Result := True;
        end else begin
          SysMsg(g_sJobOrMCNot, c_Red, t_Hint);
        end;
      end;
    13: begin//职业+道术
        if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.SC) >= HiWord(StdItem.NeedLevel)) then begin
          Result := True;
        end else begin
          SysMsg(g_sJobOrSCNot, c_Red, t_Hint);
        end;
      end;
    2: begin//魔法力
        if HiWord(m_WAbil.MC) >= StdItem.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sMCNot, c_Red, t_Hint);
        end;
      end;
    3: begin//道术
        if HiWord(m_WAbil.SC) >= StdItem.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sSCNot, c_Red, t_Hint);
        end;
      end;
    4: begin//转生等级
        if m_btReLevel >= StdItem.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    40: begin//转生等级+等级
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
          if m_Abil.Level >= HiWord(StdItem.NeedLevel) then begin
            Result := True;
          end else begin
            SysMsg(g_sLevelNot, c_Red, t_Hint);
          end;
        end else begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    41: begin//转生等级+攻击力
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
          if HiWord(m_WAbil.DC) >= HiWord(StdItem.NeedLevel) then begin
            Result := True;
          end else begin
            SysMsg(g_sDCNot, c_Red, t_Hint);
          end;
        end else begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    42: begin//转生等级+魔法
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
          if HiWord(m_WAbil.MC) >= HiWord(StdItem.NeedLevel) then begin
            Result := True;
          end else begin
            SysMsg(g_sMCNot, c_Red, t_Hint);
          end;
        end else begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    43: begin//转生等级
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
          if HiWord(m_WAbil.SC) >= HiWord(StdItem.NeedLevel) then begin
            Result := True;
          end else begin
            SysMsg(g_sSCNot, c_Red, t_Hint);
          end;
        end else begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    44: begin//所需声望和转生等级
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
          if m_btCreditPoint >= HiWord(StdItem.NeedLevel) then begin 
            Result := True;
          end else begin
            SysMsg(g_sCreditPointNot, c_Red, t_Hint);
          end;
        end else begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    5: begin//所需声望
        if m_btCreditPoint >= StdItem.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sCreditPointNot, c_Red, t_Hint);
        end;
      end;
    6: begin//行会物品
        if (m_MyGuild <> nil) then begin
          Result := True;
        end else begin
          SysMsg(g_sGuildNot, c_Red, t_Hint);
        end;
      end;
    60: begin//行会掌门物品
        if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then begin
          Result := True;
        end else begin
          SysMsg(g_sGuildMasterNot, c_Red, t_Hint);
        end;
      end;
    7: begin//沙城成员物品
        //      if (m_MyGuild <> nil) and (UserCastle.m_MasterGuild = m_MyGuild) then begin
        if (m_MyGuild <> nil) and (Castle <> nil) then begin
          Result := True;
        end else begin
          SysMsg(g_sSabukHumanNot, c_Red, t_Hint);
        end;
      end;
    70: begin//沙城城主物品
        //      if (m_MyGuild <> nil) and (UserCastle.m_MasterGuild = m_MyGuild) and (m_nGuildRankNo = 1) then begin
        if (m_MyGuild <> nil) and (Castle <> nil) and (m_nGuildRankNo = 1) then begin
          if m_Abil.Level >= StdItem.NeedLevel then begin
            Result := True;
          end else begin
            SysMsg(g_sLevelNot, c_Red, t_Hint);
          end;
        end else begin
          SysMsg(g_sSabukMasterManNot, c_Red, t_Hint);
        end;
      end;
    8: begin//会员物品
        if m_nMemberType <> 0 then begin
          Result := True;
        end else begin
          SysMsg(g_sMemberNot, c_Red, t_Hint);
        end;
      end;
    81: begin//指定类型的会员物品
        if (m_nMemberType = LoWord(StdItem.NeedLevel)) and (m_nMemberLevel >= HiWord(StdItem.NeedLevel)) then begin
          Result := True;
        end else begin
          SysMsg(g_sMemberTypeNot, c_Red, t_Hint);
        end;
      end;
    82: begin//指定类型的会员物品
        if (m_nMemberType >= LoWord(StdItem.NeedLevel)) and (m_nMemberLevel >= HiWord(StdItem.NeedLevel)) then begin
          Result := True;
        end else begin
          SysMsg(g_sMemberTypeNot, c_Red, t_Hint);
        end;
      end;
  end;
  //if not Result then SysMsg(g_sCanottWearIt,c_Red,t_Hint);
end;

function TBaseObject.sub_4C5370(nX, nY: Integer; nRange: Integer; var nDX, nDY: Integer): Boolean; //004C5370
var
  I: Integer;
  II: Integer;
  III: Integer;
begin
  Result := False;
  if m_PEnvir.GetMovingObject(nX, nY, True) = nil then begin
    Result := True;
    nDX := nX;
    nDY := nY;
  end;
  if not Result then begin
    for I := 1 to nRange do begin
      for II := -I to I do begin
        for III := -I to I do begin
          nDX := nX + III;
          nDY := nY + II;
          if m_PEnvir.GetMovingObject(nDX, nDY, True) = nil then begin
            Result := True;
            Break;
          end;
        end;
        if Result then Break;
      end;
      if Result then Break;
    end;
  end;
  if not Result then begin
    nDX := nX;
    nDY := nY;
  end;
end;
//取装备物品的重量
function TPlayObject.GetUserItemWeitht(nWhere: Integer): Integer;
var
  I: Integer;
  n14: Integer;
  StdItem: pTStdItem;
begin
  n14 := 0;
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    if (nWhere = -1) or (not (I = nWhere) and not (I = 1) and not (I = 2)) then begin
      StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
      if StdItem <> nil then Inc(n14, StdItem.Weight);
    end;
  end;
  Result := n14;
end;

function TPlayObject.EatItems(StdItem: pTStdItem): Boolean;
var
  bo06: Boolean;
  nOldStatus: Integer;
  dwExp: LongWord;//20081021
begin
  Result := False;
  if m_PEnvir.m_boNODRUG then begin
    SysMsg(sCanotUseDrugOnThisMap, c_Red, t_Hint);
    Exit;
  end;
  case StdItem.StdMode of
    0: begin
        case StdItem.Shape of
          1: begin
              IncHealthSpell(StdItem.AC, StdItem.MAC);
              Result := True;
            end;
          2: begin
              m_boUserUnLockDurg := True;
              Result := True;
            end;
          3: begin//增加内功经验物品 20081002
              if m_boTrainingNG then begin
                dwExp:= StdItem.AC * 1000 + abs(Round(StdItem.AC * m_NGLevel * 3.92));//20081021 每级加的内功经验不同
                GetNGExp(dwExp, 1);
                Result := True;
              end;
            end;
        else begin
            if (StdItem.AC > 0) then begin
              Inc(m_nIncHealth, StdItem.AC);
            end;
            if (StdItem.MAC > 0) then begin
              Inc(m_nIncSpell, StdItem.MAC);
            end;
            Result := True;
          end;
        end;
      end;
    1: begin
        nOldStatus := GetMyStatus();
        Inc(m_nHungerStatus, StdItem.DuraMax div 10);
        m_nHungerStatus := _MIN(5000, m_nHungerStatus);
        if nOldStatus <> GetMyStatus() then
          RefMyStatus();
        Result := True;
      end;
    2: Result := True;
    3: begin
        if StdItem.Shape = 12 then begin
          bo06 := False;
          if LoWord(StdItem.DC) > 0 then begin
            m_wStatusArrValue[0] := LoWord(StdItem.DC);
            m_dwStatusArrTimeOutTick[0] := GetTickCount + HiWord(StdItem.MAC) * 1000;
            SysMsg('攻击力增加' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
            bo06 := True;
          end;
          if LoWord(StdItem.MC) > 0 then begin
            m_wStatusArrValue[1] := LoWord(StdItem.MC);
            m_dwStatusArrTimeOutTick[1] := GetTickCount + HiWord(StdItem.MAC) * 1000;
            SysMsg('魔法力增加' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
            bo06 := True;
          end;
          if LoByte(StdItem.SC) > 0 then begin
            m_wStatusArrValue[2] := LoWord(StdItem.SC);
            m_dwStatusArrTimeOutTick[2] := GetTickCount + HiWord(StdItem.MAC) * 1000;
            SysMsg('道术增加' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
            bo06 := True;
          end;
          if HiWord(StdItem.AC) > 0 then begin
            m_wStatusArrValue[3] := HiWord(StdItem.AC);
            m_dwStatusArrTimeOutTick[3] := GetTickCount + HiWord(StdItem.MAC) * 1000;
            SysMsg('攻击速度增加' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
            bo06 := True;
          end;
          if LoWord(StdItem.AC) > 0 then begin
            m_wStatusArrValue[4] := LoWord(StdItem.AC);
            m_dwStatusArrTimeOutTick[4] := GetTickCount + HiWord(StdItem.MAC) * 1000;
            SysMsg('生命值增加' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
            bo06 := True;
          end;
          if LoWord(StdItem.MAC) > 0 then begin
            m_wStatusArrValue[5 ] := LoWord(StdItem.MAC);
            m_dwStatusArrTimeOutTick[5] := GetTickCount + HiWord(StdItem.MAC) * 1000;
            SysMsg('魔法值增加' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
            bo06 := True;
          end;
          if bo06 then begin
            RecalcAbilitys();
            CompareSuitItem(False);//套装与身上装备对比 20080729
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
            Result := True;
          end;
        end else begin
          Result := EatUseItems(StdItem.Shape);
        end;
      end;
  end;
end;
//学习技能书
function TPlayObject.ReadBook(StdItem: pTStdItem): Boolean;
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
  //PlayObject: TPlayObject;
begin
  Result := False;
  Magic := UserEngine.FindMagic(StdItem.Name);
  if Magic <> nil then begin
    if not IsTrainingSkill(Magic.wMagicId) then begin                                {护体神盾不限制职业 20080229}
      if ((Magic.sDescr = '') or (Magic.sDescr = '内功')) and ((Magic.btJob = 99) or (Magic.btJob = m_btJob) or (Magic.wMagicId =75)) then begin
        if (Magic.sDescr = '内功') then begin//内功技能
          if m_boTrainingNG then begin//学过内功心法才能学习技能
            if m_NGLevel >= Magic.TrainLevel[0] then begin//等级达到最低要求
              New(UserMagic);
              UserMagic.MagicInfo := Magic;
              UserMagic.wMagIdx := Magic.wMagicId;
              UserMagic.btKey := 0;
              UserMagic.btLevel := 0;
              UserMagic.nTranPoint := 0;
              m_MagicList.Add(UserMagic);
              AddSkillFunc(Magic.wMagicId);//人物学技能触发  20080324
              RecalcAbilitys();
              CompareSuitItem(False);//套装与身上装备对比 20080729
              SendAddMagic(UserMagic);
              Result := True;
            end else SysMsg(Format('您的内功心法等级没有达到 %d,不能学习此内功技能！！！',[Magic.TrainLevel[0]]), c_Red, t_Hint);
          end else SysMsg('您没学过内功心法,不能学习此内功技能！！！', c_Red, t_Hint);
        end else begin//普通技能
          if m_Abil.Level >= Magic.TrainLevel[0] then begin
            if (Magic.wMagicId = 68) and ((m_MaxExp68 <> 0) or (m_Exp68 <> 0)) then begin//是酒气护体 20080625
              m_MaxExp68:= 0;
              m_Exp68:= 0;
            end;
            New(UserMagic);
            UserMagic.MagicInfo := Magic;
            UserMagic.wMagIdx := Magic.wMagicId;
            UserMagic.btKey := 0;
            UserMagic.btLevel := 0;
            UserMagic.nTranPoint := 0;
            m_MagicList.Add(UserMagic);
            AddSkillFunc(Magic.wMagicId);//人物学技能触发  20080324
            RecalcAbilitys();
            CompareSuitItem(False);//套装与身上装备对比 20080729
            if (m_MagicBanwolSkill <> nil) and (Magic.wMagicId = 25) then begin//开启半月 20080606
              if not m_boUseHalfMoon then begin
                HalfMoonOnOff(True);
                SendSocket(nil, '+WID');
              end;
            end;
            if (m_MagicErgumSkill <> nil) and (Magic.wMagicId = 12) then begin //开启刺杀 20080606
              if not m_boUseThrusting then begin
                ThrustingOnOff(True);
                SendSocket(nil, '+LNG');
              end;
            end;
            SendAddMagic(UserMagic);
            Result := True;
          end;
        end;
      end else SysMsg('您的职业不能学习此技能！！！', c_Red, t_Hint);
    end else SysMsg('已经学过此技能,不能再学习！！！', c_Red, t_Hint);
  end else SysMsg('您不能学习英雄的技能！！！', c_Red, t_Hint);
end;
//是否学习过某个技能
function TBaseObject.IsTrainingSkill(nIndex: Integer): Boolean;
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  Result := False;
  if nIndex <> 31 then begin //不是魔法盾
    if m_MagicList.Count > 0 then begin//20080629
      for I := 0 to m_MagicList.Count - 1 do begin
        UserMagic := m_MagicList.Items[I];
        if (UserMagic <> nil) and (UserMagic.wMagIdx = nIndex) then begin
          Result := True;
          Break;
        end;
      end;
    end;
  end else begin//是魔法盾则判断是不是有4级魔法盾或普通魔法盾
    if m_MagicList.Count > 0 then begin//20080628
      for I := 0 to m_MagicList.Count - 1 do begin
        UserMagic := m_MagicList.Items[I];
        if (UserMagic <> nil) and ((UserMagic.wMagIdx = 31) or (UserMagic.wMagIdx = 66)) then begin
          Result := True;
          Break;
        end;
      end;
    end;
  end;
end;

procedure TPlayObject.SendAddMagic(UserMagic: pTUserMagic);
var
  ClientMagic: TClientMagic;
begin
  ClientMagic.Key := Char(UserMagic.btKey);
  ClientMagic.Level := UserMagic.btLevel;
  ClientMagic.CurTrain := UserMagic.nTranPoint;
  ClientMagic.Def := UserMagic.MagicInfo^;
  m_DefMsg := MakeDefaultMsg(SM_ADDMAGIC, 0, 0, 0, 1, 0);
  SendSocket(@m_DefMsg, EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)));
end;

procedure TPlayObject.SendDelMagic(UserMagic: pTUserMagic);
begin
  m_DefMsg := MakeDefaultMsg(SM_DELMAGIC, UserMagic.wMagIdx, 0, 0, 1, 0);
  SendSocket(@m_DefMsg, '');
end;

function TPlayObject.EatUseItems(nShape: Integer): Boolean;
var
  Castle: TUserCastle;
begin
  Result := False;
  case nShape of //
    1: begin
        SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        BaseObjectMove(m_sHomeMap, '', '');
        Result := True;
      end;
    2: begin//随机传送卷
        if not m_PEnvir.m_boNORANDOMMOVE then begin
          SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
          BaseObjectMove(m_sMapName, '', '');
          Result := True;
        end;
      end;
    3: begin
        SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        if PKLevel < 2 then begin
          BaseObjectMove(m_sHomeMap, IntToStr(m_nHomeX), IntToStr(m_nHomeY));
        end else begin
          BaseObjectMove(g_Config.sRedHomeMap, IntToStr(g_Config.nRedHomeX), IntToStr(g_Config.nRedHomeY));
        end;
        Result := True;
      end;
    4: begin
        if WeaptonMakeLuck() then Result := True;
      end;
    5: begin
        if m_MyGuild <> nil then begin
          if not m_boInFreePKArea then begin
            Castle := g_CastleManager.IsCastleMember(Self);
            
            {if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) then begin
              BaseObjectMove(UserCastle.m_sHomeMap,IntToStr(UserCastle.GetHomeX),IntToStr(UserCastle.GetHomeY));}
            
            if (Castle <> nil) and Castle.IsMasterGuild(TGUild(m_MyGuild)) then begin
              BaseObjectMove(Castle.m_sHomeMap, IntToStr(Castle.GetHomeX), IntToStr(Castle.GetHomeY));
            end else begin
              SysMsg('无效', c_Red, t_Hint);
            end;
            Result := True;
          end else begin
            SysMsg('此处无法使用', c_Red, t_Hint);
          end;
        end;
      end;
    9: begin
        if RepairWeapon() then Result := True;
      end;
    10: begin
        if SuperRepairWeapon() then Result := True;
      end;
    11: begin
        if WinLottery() then Result := True;
      end;
  end;
end;

procedure TPlayObject.MoveToHome;
begin
  SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
  BaseObjectMove(m_sHomeMap, IntToStr(m_nHomeX), IntToStr(m_nHomeY));
end;

procedure TPlayObject.BaseObjectMove(sMAP, sX, sY: string);
var
  Envir: TEnvirnoment;
  nX, nY: Integer;
begin
  Envir := m_PEnvir;
  if sMAP = '' then sMAP := m_sMapName;
  if (sX <> '') and (sY <> '') then begin
    nX := Str_ToInt(sX, 0);
    nY := Str_ToInt(sY, 0);
    SpaceMove(sMAP, nX, nY, 0);
  end else begin
    MapRandomMove(sMAP, 0);
  end;
  if (Envir <> m_PEnvir) and (m_btRaceServer = RC_PLAYOBJECT) then begin
    m_boTimeRecall := False;
  end;
end;
//使用祝福油,给武器加幸运
function TPlayObject.WeaptonMakeLuck: Boolean;
var
  StdItem: pTStdItem;
  nRand: Integer;
  boMakeLuck: Boolean;
  nCode: Byte;
begin
  Result := False;
  nCode:= 0;
  try
    if m_UseItems[U_WEAPON].wIndex <= 0 then Exit;
    nCode:= 1;
    nRand := 0;
    StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
    nCode:= 2;
    if StdItem <> nil then begin
      nRand := abs((HiWord(StdItem.DC) - LoWord(StdItem.DC))) div 5;
    end;
    nCode:= 3;
    if Random(g_Config.nWeaponMakeUnLuckRate {20}) = 1 then begin
      nCode:= 4;
      MakeWeaponUnlock();//武器加诅咒
    end else begin
      nCode:= 5;
      boMakeLuck := False;
      if m_UseItems[U_WEAPON].btValue[4] > 0 then begin
        nCode:= 6;
        Dec(m_UseItems[U_WEAPON].btValue[4]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green, t_Hint);
        boMakeLuck := True;
      end else if m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint1 {1} then begin
        nCode:= 7;
        Inc(m_UseItems[U_WEAPON].btValue[3]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green, t_Hint);
        boMakeLuck := True;
      end else if (m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint2 {3}) and (Random(nRand + g_Config.nWeaponMakeLuckPoint2Rate {6}) = 1) then begin
        nCode:= 8;
        Inc(m_UseItems[U_WEAPON].btValue[3]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green, t_Hint);
        boMakeLuck := True;
      end else if (m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint3 {7}) and (Random(nRand * g_Config.nWeaponMakeLuckPoint3Rate {10 + 30}) = 1) then begin
        nCode:= 9;
        Inc(m_UseItems[U_WEAPON].btValue[3]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green, t_Hint);
        boMakeLuck := True;
      end;
      nCode:= 10;
      if m_btRaceServer = RC_PLAYOBJECT then begin
        nCode:= 11;
        RecalcAbilitys();
        nCode:= 12;
        CompareSuitItem(False);//套装与身上装备对比 20080729
        nCode:= 13;
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
        //SendMsg(self, RM_DURACHANGE,m_UseItems[U_WEAPON].wIndex, m_UseItems[U_WEAPON].Dura, m_UseItems[U_WEAPON].DuraMax, 0, ''); //20071229 增加
      end;
      nCode:= 14;
      if not boMakeLuck then SysMsg(g_sWeaptonNotMakeLuck {'无效'}, c_Green, t_Hint);
    end;
  except
    MainOutMessage('{异常} TPlayObject.WeaptonMakeLuck Code:'+inttostr(nCode));
  end;
  Result := True;
end;
//修复武器
function TPlayObject.RepairWeapon: Boolean;
var
  nDura: Integer;
  UserItem: pTUserItem;
begin
  Result := False;
  UserItem := @m_UseItems[U_WEAPON];
  //if (UserItem.wIndex <= 0) or (UserItem.DuraMax <= UserItem.Dura) then Exit;
  if (UserItem.wIndex <= 0) or ((UserItem.DuraMax div 1000) <= (UserItem.Dura div 1000)) then Exit;//20080415 
  if CheckItemValue(UserItem , 3) then Exit;//20080314 禁止修
  Dec(UserItem.DuraMax, (UserItem.DuraMax - UserItem.Dura) div g_Config.nRepairItemDecDura {30});
  nDura := _MIN(5000, UserItem.DuraMax - UserItem.Dura);
  if nDura > 0 then begin
    Inc(UserItem.Dura, nDura);
    SendMsg(Self, RM_DURACHANGE, 1, UserItem.Dura, UserItem.DuraMax, 0, '');
    SysMsg(g_sWeaponRepairSuccess {'武器修复成功...'}, c_Green, t_Hint);
    Result := True;
  end;
end;

function TPlayObject.SuperRepairWeapon: Boolean;
begin
  Result := False;
  if m_UseItems[U_WEAPON].wIndex <= 0 then Exit;
  if CheckItemValue(@m_UseItems[U_WEAPON] , 3) then Exit;//20080314 禁止修
  m_UseItems[U_WEAPON].Dura := m_UseItems[U_WEAPON].DuraMax;
  SendMsg(Self, RM_DURACHANGE, 1, m_UseItems[U_WEAPON].Dura, m_UseItems[U_WEAPON].DuraMax, 0, '');
  SysMsg(g_sWeaponRepairSuccess {'武器修复成功...'}, c_Green, t_Hint);
  Result := True;
end;
//赢彩票
function TPlayObject.WinLottery: Boolean;
var
  nGold, nWinLevel, nRate: Integer;
begin
  nGold := 0;
  nWinLevel := 0;
  nRate := Random(g_Config.nWinLotteryRate);
  if (nRate >= g_Config.nWinLottery6Min) and (nRate <= g_Config.nWinLottery6Max) then begin//20080725 修改
  //if nRate in [g_Config.nWinLottery6Min..g_Config.nWinLottery6Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold := g_Config.nWinLottery6Gold;
      nWinLevel := 6;
      Inc(g_Config.nWinLotteryLevel6);
      Inc(g_Config.nWinLotteryCount);//20080725 中奖人数
      Dec(g_Config.nNoWinLotteryCount);//20080725 未中奖人数
    end;
  end else
    if (nRate >= g_Config.nWinLottery5Min) and (nRate <= g_Config.nWinLottery5Max) then begin//20080725 修改
    //if nRate in [g_Config.nWinLottery5Min..g_Config.nWinLottery5Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold := g_Config.nWinLottery5Gold;
      nWinLevel := 5;
      Inc(g_Config.nWinLotteryLevel5);
      Inc(g_Config.nWinLotteryCount);//20080725 中奖人数
      Dec(g_Config.nNoWinLotteryCount);//20080725 未中奖人数
    end;
  end else
    if (nRate >= g_Config.nWinLottery4Min) and (nRate <= g_Config.nWinLottery4Max) then begin//20080725 修改
    //if nRate in [g_Config.nWinLottery4Min..g_Config.nWinLottery4Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold := g_Config.nWinLottery4Gold;
      nWinLevel := 4;
      Inc(g_Config.nWinLotteryLevel4);
      Inc(g_Config.nWinLotteryCount);//20080725 中奖人数
      Dec(g_Config.nNoWinLotteryCount);//20080725 未中奖人数
    end;
  end else
    if (nRate >= g_Config.nWinLottery3Min) and (nRate <= g_Config.nWinLottery3Max) then begin//20080725 修改
    //if nRate in [g_Config.nWinLottery3Min..g_Config.nWinLottery3Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold := g_Config.nWinLottery3Gold;
      nWinLevel := 3;
      Inc(g_Config.nWinLotteryLevel3);
      Inc(g_Config.nWinLotteryCount);//20080725 中奖人数
      Dec(g_Config.nNoWinLotteryCount);//20080725 未中奖人数
    end;
  end else
    if (nRate >= g_Config.nWinLottery2Min) and (nRate <= g_Config.nWinLottery2Max) then begin//20080725 修改
    //if nRate in [g_Config.nWinLottery2Min..g_Config.nWinLottery2Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold := g_Config.nWinLottery2Gold;
      nWinLevel := 2;
      Inc(g_Config.nWinLotteryLevel2);
      Inc(g_Config.nWinLotteryCount);//20080725 中奖人数
      Dec(g_Config.nNoWinLotteryCount);//20080725 未中奖人数
    end;
  end else
    if (nRate >= g_Config.nWinLottery1Min) and (nRate <= g_Config.nWinLottery1Max) then begin//20080725 修改
    //if nRate in [g_Config.nWinLottery1Min + g_Config.nWinLottery1Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold := g_Config.nWinLottery1Gold;
      nWinLevel := 1;
      Inc(g_Config.nWinLotteryLevel1);
      Inc(g_Config.nWinLotteryCount);//20080725 中奖人数
      Dec(g_Config.nNoWinLotteryCount);//20080725 未中奖人数
    end;
  end;
  if nGold > 0 then begin
    case nWinLevel of //
      1: SysMsg(g_sWinLottery1Msg {'祝贺您，中了一等奖。'}, c_Green, t_Hint);
      2: SysMsg(g_sWinLottery2Msg {'祝贺您，中了二等奖。'}, c_Green, t_Hint);
      3: SysMsg(g_sWinLottery3Msg {'祝贺您，中了三等奖。'}, c_Green, t_Hint);
      4: SysMsg(g_sWinLottery4Msg {'祝贺您，中了四等奖。'}, c_Green, t_Hint);
      5: SysMsg(g_sWinLottery5Msg {'祝贺您，中了五等奖。'}, c_Green, t_Hint);
      6: SysMsg(g_sWinLottery6Msg {'祝贺您，中了六等奖。'}, c_Green, t_Hint);
    end;
    if IncGold(nGold) then begin
      GoldChanged();
    end else begin
      DropGoldDown(nGold, True, nil, nil);
    end;
  end else begin
    Inc(g_Config.nNoWinLotteryCount, 500);
    SysMsg(g_sNotWinLotteryMsg {'等下次机会吧！！！'}, c_Red, t_Hint);
  end;
  Result := True;
end;

procedure TBaseObject.DamageBubbleDefence(nInt: Integer);
begin
  if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP ] > 0 then begin
    if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP ] > 3 then
      Dec(m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP ], 3)
    else m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP ] := 1;
  end;
end;

//护体神盾 20080108
procedure TBaseObject.DamageProtectionDefence(nInt: Integer);
begin
  if g_Config.nProtectionDefenceTime > 0 then begin //20080218 护体神盾,最长时间大于0
    if m_wStatusTimeArr[STATE_ProtectionDEFENCE] > 0 then
        Dec(m_wStatusTimeArr[STATE_ProtectionDEFENCE], 1)
      else m_wStatusTimeArr[STATE_ProtectionDEFENCE] := 1;
  end;
end;
//是否是行会主人
function TBaseObject.IsGuildMaster: Boolean;
begin
  Result := False;
  if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then
    Result := True;
end;
(*
Function TBaseObject.IsCastleMaster:Integer;//判断是不是城主或精英团 20080330
var Castle: TUserCastle;
begin
  Result := 0;
  if (m_MyGuild <> nil) then begin
    Castle := g_CastleManager.IsCastleMember(Self);
    if Castle <> nil then
    if  (CompareText(Castle.m_sOwnGuild,TGUild(m_MyGuild).sGuildName)= 0 ) and (Castle.m_MasterGuild = TGUild(m_MyGuild)) then begin
      Result := 1;//是精英团
      if (CompareText(m_sGuildRankName, g_Config.sGuildChief{掌门人})= 0) and IsGuildMaster then Result := 2;//是城主
    end;
  end;
end; *)

procedure TPlayObject.ChangeServerMakeSlave(SalveInfo: pTSlaveInfo);
var
  nSlavecount: Integer;
  BaseObject: TBaseObject;
begin
  if m_btJob = 2 then begin
    nSlavecount := 1;
  end else begin
    nSlavecount := 5;
  end;
  BaseObject := MakeSlave(SalveInfo.sSalveName, 3, SalveInfo.btSalveLevel, nSlavecount, SalveInfo.dwRoyaltySec);
  if BaseObject <> nil then begin
    BaseObject.n294 := SalveInfo.nKillCount;
    BaseObject.m_btSlaveExpLevel := SalveInfo.btSlaveExpLevel;
    BaseObject.m_WAbil.HP := SalveInfo.nHP;
    BaseObject.m_WAbil.MP := SalveInfo.nMP;
    if (1500 - SalveInfo.btSalveLevel * 200) < BaseObject.m_nWalkSpeed then begin
      BaseObject.m_nWalkSpeed := 1500 - SalveInfo.btSalveLevel * 200;
    end;
    if Integer(2000 - SalveInfo.btSalveLevel * 200) < BaseObject.m_nNextHitTime then begin
      BaseObject.m_nWalkSpeed := 2000 - SalveInfo.btSalveLevel * 200;
    end;
    RecalcAbilitys();
    CompareSuitItem(False);//套装与身上装备对比 20080729
  end;
end;

procedure TPlayObject.SendDelDealItem(UserItem: pTUserItem);
var
  StdItem: pTStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  SendDefMessage(SM_DEALDELITEM_OK, 0, 0, 0, 0, '');
  if m_DealCreat <> nil then begin
    if m_DealCreat.m_nSoftVersionDateEx = 0 then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        //ClientItem.S:=StdItem^;
        CopyStdItemToOStdItem(StdItem, @OClientItem.s);
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          OClientItem.s.Name := sUserItemName;

        OClientItem.MakeIndex := UserItem.MakeIndex;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
      end;
      m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEDELITEM, Integer(Self), 0, 0, 1, 0);
      m_DealCreat.SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
    end else begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        ClientItem.s := StdItem^;
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.s.Name := sUserItemName;
        if UserItem.btValue[12] = 1 then ClientItem.s.Reserved1:=1//物品发光 20080223
         else ClientItem.s.Reserved1:= 0;

        if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080622
          if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//酒的品质
          if UserItem.btValue[1] <> 0 then ClientItem.s.MAC:=UserItem.btValue[1];//酒的酒精度
        end;

        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
      end;
      m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEDELITEM, Integer(Self), 0, 0, 1, 0);
      TPlayObject(m_DealCreat).SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
    end;
    m_DealCreat.m_DealLastTick := GetTickCount();
    m_DealLastTick := GetTickCount();
  end;
end;
//发送交易物品
procedure TPlayObject.SendAddDealItem(UserItem: pTUserItem); //004DD464
var
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
 // sCheckItemName: string;
begin
  SendDefMessage(SM_DEALADDITEM_OK, 0, 0, 0, 0, '');
  if m_DealCreat <> nil then begin
    if m_DealCreat.m_nSoftVersionDateEx = 0 then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        StdItem80 := StdItem^;
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          StdItem80.Name := sUserItemName;

        ItemUnit.GetItemAddValue(UserItem, StdItem80);
        //OClientItem.S:=StdItem80;
        CopyStdItemToOStdItem(@StdItem80, @OClientItem.s);
        //if sItemNewName <> '' then
        //  OClientItem.S.Name:=sItemNewName;
        OClientItem.MakeIndex := UserItem.MakeIndex;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
        m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEADDITEM, Integer(Self), 0, 0, 1, 0);
        m_DealCreat.SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
        m_DealCreat.m_DealLastTick := GetTickCount();
        m_DealLastTick := GetTickCount();
      end;
    end else begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        StdItem80 := StdItem^;
        ItemUnit.GetItemAddValue(UserItem, StdItem80);

        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          StdItem80.Name := sUserItemName;
        if UserItem.btValue[12] = 1 then StdItem80.Reserved1:=1//物品发光 20080223
         else StdItem80.Reserved1:= 0;

        if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080622
          if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//酒的品质
          if UserItem.btValue[1] <> 0 then ClientItem.s.MAC:=UserItem.btValue[1];//酒的酒精度
        end;

        ClientItem.s := StdItem80;
        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEADDITEM, Integer(Self), 0, 0, 1, 0);
        m_DealCreat.SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
        m_DealCreat.m_DealLastTick := GetTickCount();
        m_DealLastTick := GetTickCount();
      end;
    end;
  end;
end;

procedure TPlayObject.OpenDealDlg(PlayObject: TPlayObject);
begin
  m_boDealing := True;
  m_DealCreat := PlayObject;
  GetBackDealItems();
  SendDefMessage(SM_DEALMENU, 0, 0, 0, 0, m_DealCreat.m_sCharName);
  m_DealLastTick := GetTickCount();
end;
//加入小组
procedure TPlayObject.JoinGroup(PlayObject: TPlayObject);
begin
  m_GroupOwner := PlayObject;
  SendGroupText(Format(g_sJoinGroup, [m_sCharName]));
end;
//魔法能打到目标
function TBaseObject.MagCanHitTarget(nX, nY: Integer; TargeTBaseObject: TBaseObject): Boolean;
var
  n14, n18, n1C, n20: Integer;
begin
  Result := False;
  if TargeTBaseObject = nil then Exit;
  n20 := abs(nX - TargeTBaseObject.m_nCurrX) + abs(nY - TargeTBaseObject.m_nCurrY);
  n14 := 0;
  while (n14 < 13) do begin
    n18 := GetNextDirection(nX, nY, TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY);
    if m_PEnvir.GetNextPosition(nX, nY, n18, 1, nX, nY) and m_PEnvir.sub_4B5FC8(nX, nY) then begin
      if (nX = TargeTBaseObject.m_nCurrX) and (nY = TargeTBaseObject.m_nCurrY) then begin
        Result := True;
        Break;
      end else begin
        n1C := abs(nX - TargeTBaseObject.m_nCurrX) + abs(nY - TargeTBaseObject.m_nCurrY);
        if n1C > n20 then begin
          Result := True;
          Break;
        end;
        //n1C := n20;
      end;
    end else begin
      Break;
    end;
    Inc(n14);
  end;
end;

//是否是适当的朋友
function TBaseObject.IsProperFriend(BaseObject: TBaseObject): Boolean;
  function IsFriend(cret: TBaseObject): Boolean;//是否是朋友
  var
    I: Integer;
    nCode:Byte;
  begin
    Result := False;
    nCode:=0;
    try
    if m_btRaceServer = RC_HEROOBJECT  then begin //20080630 英雄给自己的宝宝加防
      if cret.m_Master <> nil then begin
         if m_Master = cret.m_Master then Result := True;
         if cret.m_Master = self then Result := True;
      end else
      if m_Master = cret then Result := True;
    end;
    nCode:=21;
    if cret.m_btRaceServer = RC_HEROOBJECT  then begin//20080902 主人给英雄宝宝加防
      if cret.m_Master = self then Result := True;
    end;
    nCode:=1;
    if (cret.m_btRaceServer = RC_PLAYOBJECT) and (m_btRaceServer = RC_PLAYOBJECT) then begin //如果对象是人物
      case m_btAttatckMode of
        HAM_ALL: Result := True;
        HAM_PEACE: begin//和平攻击
             nCode:=2;
             Result := True;
             if (cret.m_btRaceServer = RC_PLAYOBJECT) and (m_btRaceServer = RC_HEROOBJECT) then  Result := False; // 20080424 英雄和平模式下不攻击人物
             nCode:=3;
            end;
        HAM_DEAR: begin
            nCode:=4;
            if (Self = cret) or (cret = TPlayObject(Self).m_DearHuman) then begin
              Result := True;
            end;
          end;
        HAM_MASTER: begin //师徒攻击
            nCode:=5;
            if (Self = cret) then begin
              Result := True;
            end else                                   
            if TPlayObject(Self).m_boMaster then begin
              nCode:=6;
              if TPlayObject(Self).m_MasterList.Count > 0 then begin//20080629
                for I := 0 to TPlayObject(Self).m_MasterList.Count - 1 do begin
                  nCode:=7;
                  if TPlayObject( Self).m_MasterList.Items[I] = cret then begin
                    nCode:=8;
                    Result := True;
                    Break;
                  end;
                end;//for
              end;
            end else
            if TPlayObject(cret).m_boMaster then begin
              nCode:=9;
              if TPlayObject(cret).m_MasterList.Count > 0 then begin//20080629
                for I := 0 to TPlayObject(cret).m_MasterList.Count - 1 do begin
                  nCode:=10;
                  if TPlayObject(cret).m_MasterList.Items[I] = Self then begin
                    nCode:=11;
                    Result := True;
                    Break;
                  end;
                end;//for
              end;
            end;
          end;
        HAM_GROUP: begin
            nCode:=12;
            if cret = Self then
              Result := True;
            nCode:=13;
            if TPlayObject(Self).IsGroupMember(TPlayObject(cret)) then
              Result := True;
          end;
        HAM_GUILD: begin
            nCode:=14;
            if cret = Self then
              Result := True;
            nCode:=15;
            if m_MyGuild <> nil then begin
              nCode:=16;
              if TGUild(m_MyGuild).IsMember(cret.m_sCharName) then
                Result := True;
              nCode:=17;
              if m_boGuildWarArea and (cret.m_MyGuild <> nil) then begin
                nCode:=18;
                if TGUild(m_MyGuild).IsAllyGuild(TGUild(cret.m_MyGuild)) then
                  Result := True;
                nCode:=19;
              end;
            end;
          end;
        HAM_PKATTACK: begin
            nCode:=20;
            if cret = Self then Result := True;
            if PKLevel >= 2 then begin
              if cret.PKLevel < 2 then Result := True;
            end else begin
              if cret.PKLevel >= 2 then Result := True;
            end;
          end;
      end;
    end;
    except
      MainOutMessage('{异常} TBaseObject.IsProperFriend  Code:'+inttostr(nCode));
    end;
  end;
begin
  Result := False;
  if BaseObject = nil then Exit;

  if (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin //分身检测
    if m_Master = nil then begin
      if (BaseObject.m_btRaceServer >= RC_ANIMAL) then
        Result := True;
      if (BaseObject.m_Master <> nil) or (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
        Result := False;
    end else begin
      if (BaseObject.m_btRaceServer >= RC_ANIMAL) then
        Result := False;
      if BaseObject.m_Master <> nil then
        Result := IsFriend(BaseObject.m_Master);
      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
        Result := IsFriend(BaseObject);
      if BaseObject = m_Master then
        Result := True;
    end;
    Exit;
  end;

  if (m_btRaceServer >= RC_ANIMAL) then begin
    if (BaseObject.m_btRaceServer >= RC_ANIMAL) then
      Result := True;
    if BaseObject.m_Master <> nil then
      Result := False;
    Exit;
  end;

  if m_btRaceServer = RC_PLAYOBJECT then begin
    Result := IsFriend(BaseObject);
    if BaseObject.m_btRaceServer < RC_ANIMAL then Exit;
    if BaseObject.m_Master = Self then begin
      Result := True;
      Exit;
    end;
    if BaseObject.m_Master <> nil then begin
      Result := IsFriend(BaseObject.m_Master);
      Exit;
    end;
  end else Result := True;
end;
//幽灵盾  神圣战甲术  btState=1 幽灵盾 0 神圣战甲术
function TBaseObject.MagMakeDefenceArea(nX, nY, nRange, nSec: Integer;
  btState: Byte): Integer;
var
  III: Integer;
  I,II: Integer;
  nStartX,nStartY,nEndX,nEndY: Integer;
  MapCellInfo:pTMapCellinfo;
  OSObject:pTOSObject;
  BaseObject:TBaseObject;
begin
  Result := 0;
  nStartX := nX - nRange;
  nEndX := nX + nRange;
  nStartY := nY - nRange;
  nEndY := nY + nRange;
  for I := nStartX to nEndX do begin
    for II := nStartY to nEndY do begin
      if m_PEnvir.GetMapCellInfo(I, II, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin//20080629
          for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := MapCellInfo.ObjList.Items[III];
            if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
              BaseObject := TBaseObject(OSObject.CellObj);
              if (BaseObject <> nil) and (not BaseObject.m_boGhost) then begin
                if IsProperFriend(BaseObject) then begin
                  if btState = 0 then begin
                    BaseObject.DefenceUp(nSec);
                  end else begin
                    BaseObject.MagDefenceUp(nSec);
                  end;
                  Inc(Result);
                end
              end;
            end;
          end;//for
        end;
      end;
    end;
  end;
end;

//诅咒术 
function TBaseObject.MagMakeAbilityArea(nX, nY, nRange, nSec: Integer): Integer;
var
  III: Integer;
  I, II: Integer;
  nStartX, nStartY, nEndX, nEndY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  bo06: Boolean;
begin
  Result := 0;
  nStartX := nX - nRange;
  nEndX := nX + nRange;
  nStartY := nY - nRange;
  nEndY := nY + nRange;
  for I := nStartX to nEndX do begin
    for II := nStartY to nEndY do begin
      if m_PEnvir.GetMapCellInfo(I, II, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin//20080629
          for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := MapCellInfo.ObjList.Items[III];
            if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
              BaseObject := TBaseObject(OSObject.CellObj);
              if (BaseObject <> nil) and (not BaseObject.m_boGhost) then begin
                if IsProperTarget(BaseObject) then begin
                  bo06 := False;
                  case BaseObject.m_btJob of
                    0: begin
                        if BaseObject.m_wStatusArrValue[6] = 0 then begin
                          BaseObject.m_wStatusArrValue[6] := MakeLong(LoWord(BaseObject.m_WAbil.DC), HiWord(BaseObject.m_WAbil.DC) - 2 - (BaseObject.m_Abil.Level div 7));
                          BaseObject.m_dwStatusArrTimeOutTick[6] := GetTickCount + nSec * 1000;
                          if BaseObject.m_btRaceServer = RC_HEROOBJECT then
                            BaseObject.m_Master.SysMsg('(英雄) 攻击力减少' + IntToStr(nSec) + '秒', c_Green, t_Hint)
                          else BaseObject.SysMsg('攻击力减少' + IntToStr(nSec) + '秒', c_Green, t_Hint);
                          bo06 := True;
                        end;
                      end;
                    1: begin
                        if BaseObject.m_wStatusArrValue[7] = 0 then begin
                          BaseObject.m_wStatusArrValue[7] := MakeLong(LoWord(BaseObject.m_WAbil.MC), HiWord(BaseObject.m_WAbil.MC) - 2 - (BaseObject.m_Abil.Level div 7));
                          BaseObject.m_dwStatusArrTimeOutTick[7] := GetTickCount + nSec * 1000;
                          if BaseObject.m_btRaceServer = RC_HEROOBJECT then
                            BaseObject.m_Master.SysMsg('(英雄) 魔法力减少' + IntToStr(nSec) + '秒', c_Green, t_Hint)
                          else BaseObject.SysMsg('魔法力减少' + IntToStr(nSec) + '秒', c_Green, t_Hint);
                          bo06 := True;
                        end;
                      end;
                    2: begin
                        if BaseObject.m_wStatusArrValue[8] = 0 then begin
                          BaseObject.m_wStatusArrValue[8] := MakeLong(LoWord(BaseObject.m_WAbil.SC), HiWord(BaseObject.m_WAbil.SC) - 2 - (BaseObject.m_Abil.Level div 7));
                          BaseObject.m_dwStatusArrTimeOutTick[8] := GetTickCount + nSec * 1000;
                          if BaseObject.m_btRaceServer = RC_HEROOBJECT then
                            BaseObject.m_Master.SysMsg('(英雄) 道术减少' + IntToStr(nSec) + '秒', c_Green, t_Hint)
                          else BaseObject.SysMsg('道术减少' + IntToStr(nSec) + '秒', c_Green, t_Hint);
                          bo06 := True;
                        end;
                      end;
                    {3: begin//刺客(暂时用战士参数)
                        if BaseObject.m_wStatusArrValue[6] = 0 then begin
                          BaseObject.m_wStatusArrValue[6] := MakeLong(LoWord(BaseObject.m_WAbil.DC), HiWord(BaseObject.m_WAbil.DC) - 2 - (BaseObject.m_Abil.Level div 7));
                          BaseObject.m_dwStatusArrTimeOutTick[6] := GetTickCount + nSec * 1000;
                          if BaseObject.m_btRaceServer = RC_HEROOBJECT then
                            BaseObject.m_Master.SysMsg('(英雄) 攻击力减少' + IntToStr(nSec) + '秒', c_Green, t_Hint)
                          else BaseObject.SysMsg('攻击力减少' + IntToStr(nSec) + '秒', c_Green, t_Hint);
                          bo06 := True;
                        end;
                      end; }
                  end;
                  if bo06 then begin
                    if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin
                       THeroObject(BaseObject).RecalcAbilitys();
                       BaseObject.CompareSuitItem(False);//套装与身上装备对比 20080729
                       THeroObject(BaseObject).SendMsg(BaseObject.m_Master, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性  20080430
                    end else begin
                       BaseObject.RecalcAbilitys();
                       BaseObject.CompareSuitItem(False);//套装与身上装备对比 20080729
                       BaseObject.SendMsg(BaseObject{self}, RM_ABILITY, 0, 0, 0, 0, '');//20081010 修改
                    end;
                  end;
                  Inc(Result);
                end
              end;
            end;
          end;//for
        end;
      end;
    end;
  end;
end;
//人物的无极真气  每次使用间隔28秒
//0级提升道术40%(2秒)   1级提升60%(4秒)   2级提升80%(6秒)  3级提升100%(8秒)
function TPlayObject.AbilityUp(UserMagic: pTUserMagic): Boolean;
var
  nSpellPoint, n14: Integer;
begin
  Result := False;
  nSpellPoint := GetSpellPoint(UserMagic);
  if nSpellPoint > 0 then begin
    if (GetTickCount - m_dwStatusArrTimeOutTick[2] > g_Config.nAbilityUpTick * 1000) and (m_wStatusArrValue[2] = 0) then begin //时间间隔
      if m_WAbil.MP < nSpellPoint then Exit;
      DamageSpell(nSpellPoint);
      HealthSpellChanged();
      if g_Config.boAbilityUpFixMode then begin//无极真气使用固定时长模式 20081109
        n14:= g_Config.nAbilityUpFixUseTime;//无极真气使用固定时长 20081109
      end else n14:=(UserMagic.btLevel * 2) + 2 + g_Config.nAbilityUpUseTime;
      m_dwStatusArrTimeOutTick[2] := GetTickCount + n14 * 1000;//使用时间 20080427
      //m_wStatusArrValue[2] := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) - 2 - (m_Abil.Level div 7)) * 2;//提升值
      m_wStatusArrValue[2] := Round(HiWord(m_WAbil.SC)*(UserMagic.btLevel * 0.2 + 0.4));//提升值 20080827
      SysMsg('道术瞬时提升' + IntToStr(m_wStatusArrValue[2]) + '，持续 ' + IntToStr(n14) + ' 秒', c_Green, t_Hint);//20080319
      RecalcAbilitys();
      CompareSuitItem(False);//套装与身上装备对比 20080729
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      Result := True;
    end else SysMsg('精神力凝聚失败', c_Red, t_Hint);
  end;
end;
//减少掉蓝时间
procedure TBaseObject.MagDownHealth(nType, nTime, nPoint: Integer);
var
  nHealthType: Integer;
begin
  nHealthType := 9 + nType;
  if (nHealthType >=0) and (nHealthType < MAX_STATUS_ATTRIBUTE) then begin//20081203 防止组数越界
    if m_wStatusArrValue[nHealthType] = 0 then begin
      m_wStatusArrValue[nHealthType] := nPoint;
      m_dwStatusArrTimeOutTick[nHealthType] := GetTickCount + nTime * 1000;
    end;
  end;
end;

(*//未使用 20080329
function TBaseObject.DefenceDown(nSec: Integer): Boolean;
begin
  {Result := False; //此段原来注释的
  if m_wStatusTimeArr2[STATE_DEFENCEUP] > 0 then begin
    if m_wStatusTimeArr2[STATE_DEFENCEUP] < nSec then begin
      m_wStatusTimeArr2[STATE_DEFENCEUP] := nSec;
      Result := True;
    end;
  end else begin
    m_wStatusTimeArr2[STATE_DEFENCEUP] := nSec;
    Result := True;
  end;
  m_dwStatusArrTick2[STATE_DEFENCEUP] := GetTickCount;
  SysMsg(Format(g_sDefenceDownTime, [nSec]), c_Green, t_Hint);
  RecalcAbilitys();
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, ''); }
end; *)
(*//未使用 20080329
function TBaseObject.MagDefenceDown(nSec: Integer): Boolean;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_MAGDEFENCEUP] > 0 then begin
    if m_wStatusTimeArr[STATE_MAGDEFENCEUP] < nSec then begin
      m_wStatusTimeArr[STATE_MAGDEFENCEUP] := nSec;
      Result := True;
    end;
  end else begin
    m_wStatusTimeArr[STATE_MAGDEFENCEUP] := nSec;
    Result := True;
  end;
  m_dwStatusArrTick[STATE_MAGDEFENCEUP] := GetTickCount;
  SysMsg(Format(g_sMagDefenceDownTime, [nSec]), c_Green, t_Hint);
  RecalcAbilitys();
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
end;*)

function TBaseObject.DefenceUp(nSec: Integer): Boolean;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_DEFENCEUP] > 0 then begin
    if m_wStatusTimeArr[STATE_DEFENCEUP] < nSec then begin
      m_wStatusTimeArr[STATE_DEFENCEUP] := nSec;
      Result := True;
    end;
  end else begin
    m_wStatusTimeArr[STATE_DEFENCEUP] := nSec;
    Result := True;
  end;
  m_dwStatusArrTick[STATE_DEFENCEUP] := GetTickCount;
  SysMsg(Format(g_sDefenceUpTime, [nSec]), c_Green, t_Hint);
  if m_btRaceServer = RC_HEROOBJECT then begin
    THeroObject(self).RecalcAbilitys();
    CompareSuitItem(False);//套装与身上装备对比 20080729
    THeroObject(self).SendMsg(m_Master, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性  20080506
  end else begin
    RecalcAbilitys();
    CompareSuitItem(False);//套装与身上装备对比 20080729
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  end;
end;

function TBaseObject.MagDefenceUp(nSec: Integer): Boolean;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_MAGDEFENCEUP] > 0 then begin
    if m_wStatusTimeArr[STATE_MAGDEFENCEUP] < nSec then begin
      m_wStatusTimeArr[STATE_MAGDEFENCEUP] := nSec;
      Result := True;
    end;
  end else begin
    m_wStatusTimeArr[STATE_MAGDEFENCEUP] := nSec;
    Result := True;
  end;
  m_dwStatusArrTick[STATE_MAGDEFENCEUP] := GetTickCount;
  SysMsg(Format(g_sMagDefenceUpTime, [nSec]), c_Green, t_Hint);
  if m_btRaceServer = RC_HEROOBJECT then begin
    THeroObject(self).RecalcAbilitys();
    CompareSuitItem(False);//套装与身上装备对比 20080729
    THeroObject(self).SendMsg(m_Master, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性  20080506
  end else begin
    RecalcAbilitys();
    CompareSuitItem(False);//套装与身上装备对比 20080729
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  end;
end;

//魔法盾  道力盾
function TBaseObject.MagBubbleDefenceUp(nLevel, nSec: Integer): Boolean;
var
  nOldStatus: Integer;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] <> 0 then Exit;
  nOldStatus := m_nCharStatus;
  m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] := nSec; //持继多少久(秒)
  m_dwStatusArrTick[STATE_BUBBLEDEFENCEUP] := GetTickCount();//人物状态持续的开始时间
  m_nCharStatus := GetCharStatus();
  if nOldStatus <> m_nCharStatus then begin
    if nLevel = 4 then StatusChanged('444')//20080811 4级盾,发个消息给客户端显示特有的效果
    else StatusChanged('');
  end;
  m_boAbilMagBubbleDefence := True; //是否使用魔法盾
  m_btMagBubbleDefenceLevel := nLevel;//魔法盾等级
  Result := True;
end;
//------------------------------------------------------------------------------
//护体神盾 20080107
function TBaseObject.MagProtectionDefenceUp(nLevel: Integer): Boolean;
var
  nOldStatus: Integer;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_ProtectionDEFENCE] <> 0 then Exit;
  nOldStatus := m_nCharStatus;
   m_boProtectionDefence := True; //使用护体神盾
  if g_Config.nProtectionDefenceTime <> 0  then//20080218
  //持继多少久(秒):护体神盾最长时间 + 等级 * 0.5秒
  m_wStatusTimeArr[STATE_ProtectionDEFENCE] :=(g_Config.nProtectionDefenceTime + nLevel * 500) div 1000
  else m_wStatusTimeArr[STATE_ProtectionDEFENCE] := 6;

  m_dwStatusArrTick[STATE_ProtectionDEFENCE] := GetTickCount();//人物状态持续的开始时间
  m_nCharStatus := GetCharStatus();
  if nOldStatus <> m_nCharStatus then begin
    StatusChanged('');
  end;
  m_boProtectionDefenceLevel := nLevel;//护体神盾等级 20080929
  Result := True;
end;
//------------------------------------------------------------------------------
//挖矿,给玩家矿石
procedure TPlayObject.MakeMine;
  function RandomDrua(): Integer;
  begin
    Result := Random(g_Config.nStoneGeneralDuraRate {13000}) + g_Config.nStoneMinDura {3000};
    if Random(g_Config.nStoneAddDuraRate {20}) = 0 then begin
      Result := Result + Random(g_Config.nStoneAddDuraMax {10000});
    end;
  end;
var
  UserItem: pTUserItem;
  nRANDOM: Integer;
begin
  if m_ItemList.Count >= MAXBAGITEM then Exit;
  nRANDOM := Random(g_Config.nStoneTypeRate {120});
  if nRANDOM in [g_Config.nGoldStoneMin {1}..g_Config.nGoldStoneMax {2}] then begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sGoldStone, UserItem) then begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end else Dispose(UserItem);
    Exit;
  end;
  if nRANDOM in [g_Config.nSilverStoneMin {3}..g_Config.nSilverStoneMax {20}] then begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sSilverStone, UserItem) then begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end else Dispose(UserItem);
    Exit;
  end;
  if nRANDOM in [g_Config.nSteelStoneMin {21}..g_Config.nSteelStoneMax {45}] then begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sSteelStone, UserItem) then begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end else Dispose(UserItem);
    Exit;
  end;
  if nRANDOM in [g_Config.nBlackStoneMin {46}..g_Config.nBlackStoneMax {56}] then begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sBlackStone, UserItem) then begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end else Dispose(UserItem);
    Exit;
  end;
  New(UserItem);
  if UserEngine.CopyToUserItemFromName(g_Config.sCopperStone, UserItem) then begin
    UserItem.Dura := RandomDrua();
    m_ItemList.Add(UserItem);
    WeightChanged();
    SendAddItem(UserItem);
  end else Dispose(UserItem);


  {
  case Random(120) of    //
    1..2: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sGoldStone,UserItem) then begin
        UserItem.Dura:=RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
      end else Dispose(UserItem);
    end;
    3..20: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sSilverStone,UserItem) then begin
        UserItem.Dura:=RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
      end else Dispose(UserItem);
    end;
    21..45: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sSteelStone,UserItem) then begin
        UserItem.Dura:=RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
      end else Dispose(UserItem);
    end;
    46..56: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sBlackStone,UserItem) then begin
        UserItem.Dura:=RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
      end else Dispose(UserItem);
    end;
    else begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sCopperStone,UserItem) then begin
        UserItem.Dura:=RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
      end else Dispose(UserItem);
    end;
  end;
  }
end;

function TPlayObject.QuestCheckItem(sItemName: string; var nCount,
  nParam: Integer; var nDura: Integer): pTUserItem;
var
  I: Integer;
  UserItem: pTUserItem;
  s1C: string;
begin
  Result := nil;
  nParam := 0;
  nDura := 0;
  nCount := 0;
  if m_ItemList.Count > 0 then begin//20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      s1C := UserEngine.GetStdItemName(UserItem.wIndex);
      if CompareText(s1C, sItemName) = 0 then begin
        if UserItem.Dura > nDura then begin
          nDura := UserItem.Dura;
          Result := UserItem;
        end;
        Inc(nParam, UserItem.Dura);
        if Result = nil then Result := UserItem;
        Inc(nCount);
      end;
    end;
  end;
end;

function TBaseObject.sub_4C4CD4(sItemName: string;
  var nCount: Integer): pTUserItem;
var
  I: Integer;
  sName: string;
begin
  Result := nil;
  nCount := 0;
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    sName := UserEngine.GetStdItemName(m_UseItems[I].wIndex);
    if CompareText(sName, sItemName) = 0 then begin
      Result := @m_UseItems[I];
      Inc(nCount);
    end;
  end;
end;

function TPlayObject.QuestTakeCheckItem(CheckItem: pTUserItem): Boolean;
var
  I: Integer;
  UserItem: pTUserItem;
begin
  Result := False;
  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    UserItem := m_ItemList.Items[I];
    if UserItem = CheckItem then begin
      SendDelItems(UserItem);
      m_ItemList.Delete(I);
      Dispose(UserItem);
      Result := True;
      Break;
    end;
  end;

  for I := Low(m_UseItems) to High(m_UseItems) do begin
    if @m_UseItems[I] = CheckItem then begin
      SendDelItems(@m_UseItems[I]);
      m_UseItems[I].wIndex := 0;
      Result := True;
      Break;
    end;
  end;
end;

procedure TPlayObject.ClientQueryRepairCost(nParam1, nInt: Integer;
  sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  UserItemA: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  UserItemA := nil;
  if m_ItemList.Count > 0 then begin//20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if UserItem = nil then Continue;
      if (UserItem.MakeIndex = nInt) then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if (CompareText(sUserItemName, sMsg) = 0) then begin
          UserItemA := UserItem;
          Break;
        end;
      end;
    end;
  end;
  if UserItemA = nil then Exit;
  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and
    ((Merchant.m_PEnvir = m_PEnvir) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQueryRepairCost(Self, UserItemA);
end;
//客户端修复物品
procedure TPlayObject.ClientRepairItem(nParam1, nInt: Integer;
  sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
  sCheckItemName: string;
  bo19: Boolean;
begin
  UserItem := nil;
  bo19 := False;
  if m_ItemList.Count > 0 then begin//20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if UserItem.MakeIndex = nInt then begin
        if CheckItemValue(UserItem, 3) then begin
           SendMsg(Self, RM_USERREPAIRITEM_FAIL, 0, 0, 0, 0, '');
           Break //20080314 禁止修
        end else begin
        {if Assigned(zPlugOfEngine.CheckCanRepairItem) then begin
          sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
          if not zPlugOfEngine.CheckCanRepairItem(Self, PChar(sCheckItemName)) then begin
            SendMsg(Self, RM_USERREPAIRITEM_FAIL, 0, 0, 0, 0, ''); //20080409
            Break;
          end;
        end;}
          sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
          if PlugOfCheckCanItem(3, sCheckItemName, False, 0, 0) then begin//禁止物品规则(管理插件功能) 20080729
            SendMsg(Self, RM_USERREPAIRITEM_FAIL, 0, 0, 0, 0, ''); //20080409
            Break;
          end;
        end;
      end;
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      if (UserItem.MakeIndex = nInt) and
        (CompareText(sUserItemName, sMsg) = 0) then begin
        bo19 := True;
        Break;
      end;
    end; // for
  end;
  if (UserItem = nil) or (not bo19) then Exit;

  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and
    ((Merchant.m_PEnvir = m_PEnvir) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientRepairItem(Self, UserItem);
end;
//客户端存物品至仓库
procedure TPlayObject.ClientStorageItem(NPC: TObject; nItemIdx: Integer; sMsg: string);
var
  Merchant: TMerchant;
  I: Integer;
  UserItem: pTUserItem;
  bo19: Boolean;
  StdItem: pTStdItem;
  sUserItemName: string;
  sCheckItemName: string;
  nCode: Byte;
begin
  nCode:= 0;
  m_boCanQueryBag:= True;//出售物品时,不能刷新包裹 20080917
  Try
    try
      Merchant := UserEngine.FindMerchant(NPC);
      nCode:= 1;
      if (Merchant <> nil) and (Merchant.m_boBigStorage) then begin //无限仓库
        nCode:= 2;
        bo19 := False;
        //UserItem := nil;//未使用 20080411
        if Pos(' ', sMsg) >= 0 then //折分物品名称(信件物品的名称后面加了使用次数)
          GetValidStr3(sMsg, sMsg, [' ']);
        if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
          SysMsg(g_sTryModeCanotUseStorage {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
          SendDefMessage(SM_STORAGE_FAIL, 0, 0, 0, 0, '');
          Exit;
        end;
        nCode:= 3;
        if (m_BigStorageItemList <> nil) and (m_BigStorageItemList.Count > g_Config.nBigStorageLimitCount) then begin
          SysMsg(Format(g_sBigStorageCountIsNul, [g_Config.nBigStorageLimitCount]), c_Red, t_Hint);
          SendDefMessage(SM_STORAGE_FAIL, 0, 0, 0, 0, '');
          Exit;
        end;
        nCode:= 4;
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          if UserItem.MakeIndex = nItemIdx then begin
            nCode:= 5;
            if CheckItemValue(UserItem,2) then Break //20080314 禁止存
            else begin
              nCode:= 6;
              sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
              if PlugOfCheckCanItem(2, sCheckItemName, False, 0, 0) then Break;//禁止物品规则(禁止存) 20080729
            end;
          end;
          //取自定义物品名称
          nCode:= 7;
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
          nCode:= 8;
          if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin
            nCode:= 9;
            if (Merchant.m_boBigStorage) and //检查NPC是否允许存物品
              (((Merchant.m_PEnvir = m_PEnvir) and
              (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
              (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
              nCode:= 10;
              if g_Storage.Add(m_BigStorageItemList, m_sCharName, UserItem) then begin
                nCode:= 11;
                m_ItemList.Delete(I);
                ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
                Dispose(UserItem);
                WeightChanged();
                SendDefMessage(SM_STORAGE_OK, 0, 0, 0, 0, '');
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                nCode:= 12;
                if StdItem <> nil then begin//20080722 增加
                  nCode:= 23;
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLog('1' + #9 + m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                      m_sCharName + #9 + StdItem.Name + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 +
                      '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                      '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                      '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                      '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                      '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                      IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                      IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                      IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                      IntToStr(UserItem.btValue[14])+ #9 + Merchant.m_sCharName);
                 end;
              end else begin
                SendDefMessage(SM_STORAGE_FULL, 0, 0, 0, 0, '');
              end;
              bo19 := True;
            end;
            Break;
          end;
        end;//for
      end else begin
        bo19 := False;
        nCode:= 13;
        //UserItem := nil; //未使用 20080411
        if Pos(' ', sMsg) >= 0 then //折分物品名称(信件物品的名称后面加了使用次数)
          GetValidStr3(sMsg, sMsg, [' ']);
        if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
          SysMsg(g_sTryModeCanotUseStorage {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
          Exit;
        end;
        nCode:= 14;
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          nCode:= 15;
          if UserItem.MakeIndex = nItemIdx then begin
            if CheckItemValue(UserItem,2) then Break //20080314 禁止存
            else begin
              nCode:= 16;
              sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
              if PlugOfCheckCanItem(2, sCheckItemName, False, 0, 0) then Break;//禁止物品规则(禁止存) 20080729
            end;
          end;
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
          nCode:= 17;
          if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin
            nCode:= 18;
            Merchant := UserEngine.FindMerchant(NPC);
            if (Merchant <> nil) and
              (Merchant.m_boStorage) and //检查NPC是否允许存物品
              (((Merchant.m_PEnvir = m_PEnvir) and
              (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
              (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
              nCode:= 19;
              if m_StorageItemList.Count < MAXBAGITEM then begin
                nCode:= 20;
                m_StorageItemList.Add(UserItem);
                m_ItemList.Delete(I);
                WeightChanged();
                SendDefMessage(SM_STORAGE_OK, 0, 0, 0, 0, '');
                nCode:= 21;
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                nCode:= 22;
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('1' + #9 + m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + StdItem.Name + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +
                    '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                    '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                    '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                    '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                    '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                    IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                    IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                    IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                    IntToStr(UserItem.btValue[14])+ #9 + Merchant.m_sCharName);
              end else begin
                SendDefMessage(SM_STORAGE_FULL, 0, 0, 0, 0, '');
              end;
              bo19 := True;
            end;
            Break;
          end;
        end;//for
      end;
      if not bo19 then SendDefMessage(SM_STORAGE_FAIL, 0, 0, 0, 0, '');
    except
      MainOutMessage('{异常} TPlayObject.ClientStorageItem  Code:'+inttostr(nCode));
    end;
  finally
    m_boCanQueryBag:= False;//出售物品时,不能刷新包裹 20080917
  end;
end;
//仓库取物品
procedure TPlayObject.ClientTakeBackStorageItem(NPC: TObject;
  nItemIdx: Integer; sMsg: string);
var
  Merchant: TMerchant;
  I: Integer;
  UserItem: pTUserItem;
  Item: TUserItem;
  bo19: Boolean;
  StdItem: pTStdItem;
  sUserItemName: string;
begin
  if m_boCanQueryBag then Exit;//使用物品时,不能取出物品 20081009
  Merchant := UserEngine.FindMerchant(NPC);
  if (Merchant <> nil) and (Merchant.m_boBigGetBack) then begin //无限仓库
    bo19 := False;
    if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
      SysMsg(g_sTryModeCanotUseStorage {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
      Exit;
    end;
    if not m_boCanGetBackItem then begin
      SendMsg(Merchant, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sStorageIsLockedMsg + '\ \'
        + '仓库开锁命令: @' + g_GameCommand.UNLOCKSTORAGE.sCmd + '\'
        + '仓库加锁命令: @' + g_GameCommand.Lock.sCmd + '\'
        + '设置密码命令: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
        + '修改密码命令: @' + g_GameCommand.CHGPASSWORD.sCmd);
      Exit;
    end;
    if g_Storage.GetItem(m_BigStorageItemList, sMsg, nItemIdx, Item) then begin
      New(UserItem);
      FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
      UserItem^ := Item;
      if (IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex))) then begin
        if (Merchant <> nil) and (Merchant.m_boBigGetBack) and //检查NPC是否允许取物品
          (((Merchant.m_PEnvir = m_PEnvir) and
          (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
          (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
          ClearCopyItem(0,UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
          if AddItemToBag(UserItem) then begin
            SendAddItem(UserItem);
            g_Storage.Delete(m_BigStorageItemList, sMsg, nItemIdx);
            SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('0' + #9 + m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 + StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                IntToStr(UserItem.btValue[14])+ #9 + Merchant.m_sCharName);
          end else begin
            Dispose(UserItem);
            SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, '');
          end;
          bo19 := True;
        end;
      end else begin
        Dispose(UserItem);
        SysMsg(g_sCanotGetItems {'无法携带更多的东西！！！'}, c_Red, t_Hint);
      end;
    end;
  end else begin
    bo19 := False;
    //UserItem := nil;//未使用 20080411
    Merchant := UserEngine.FindMerchant(NPC);
    if Merchant = nil then Exit;
    if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
      SysMsg(g_sTryModeCanotUseStorage {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
      Exit;
    end;
    if not m_boCanGetBackItem then begin
      SendMsg(Merchant, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sStorageIsLockedMsg + '\ \'
        + '仓库开锁命令: @' + g_GameCommand.UNLOCKSTORAGE.sCmd + '\'
        + '仓库加锁命令: @' + g_GameCommand.Lock.sCmd + '\'
        + '设置密码命令: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
        + '修改密码命令: @' + g_GameCommand.CHGPASSWORD.sCmd);
      Exit;
    end;
    //I := 0;
    if  m_StorageItemList.Count > 0 then begin
      for I:= m_StorageItemList.Count - 1 downto 0 do begin//20081009
      //while True do begin
      //  if I >= m_StorageItemList.Count then Break;
      //  if m_StorageItemList.Count <= 0 then Break;
        UserItem := m_StorageItemList.Items[I];
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin
          if (IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex))) then begin
            if (Merchant <> nil) and (Merchant.m_boGetback) and //检查NPC是否允许取物品
              (((Merchant.m_PEnvir = m_PEnvir) and
              (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
              (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
              ClearCopyItem(0,UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
              if AddItemToBag(UserItem) then begin
                SendAddItem(UserItem);
                m_StorageItemList.Delete(I);
                SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');              
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('0' + #9 + m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                    '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                    '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                    '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                    '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                    '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                    IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                    IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                    IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                    IntToStr(UserItem.btValue[14])+ #9 + Merchant.m_sCharName);
              end else begin
                SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, '');
              end;
              bo19 := True;
            end;
          end else begin
            SysMsg(g_sCanotGetItems {'无法携带更多的东西！！！'}, c_Red, t_Hint);
          end;
          Break;
        end;
      //  Inc(I);
      //end;
      end;//for
    end;
  end;
  if Merchant = nil then Exit;
  if not bo19 then SendDefMessage(SM_TAKEBACKSTORAGEITEM_FAIL, 0, 0, 0, 0, '');
end;

function TBaseObject.CheckItems(sItemName: string): pTUserItem;
var
  I: Integer;
  UserItem: pTUserItem;
begin
  Result := nil;
  if m_ItemList.Count > 0 then begin//20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0 then begin
        Result := UserItem;
        Break;
      end;
    end; // for
  end;
end;

procedure TPlayObject.MakeSaveRcd(var HumanRcd: THumDataInfo);
var
  I, J, K: Integer;
  HumData: pTHumData;
  HumItems: pTHumItems;
  HumAddItems: pTHumAddItems;
  BagItems: pTBagItems;
  HumMagics: pTHumMagics;
  HumNGMagics: pTHumNGMagics;//20081001
  UserMagic: pTUserMagic;
  StorageItems: pTStorageItems;
begin
  HumanRcd.Header.boIsHero := False;
  HumData := @HumanRcd.Data;
  HumData.sChrName := m_sCharName;
  HumData.sCurMap := m_sMapName;
  HumData.wCurX := m_nCurrX;
  HumData.wCurY := m_nCurrY;
  HumData.btDir := m_btDirection;
  HumData.btHair := m_btHair;
  HumData.btSex := m_btGender;
  HumData.btJob := m_btJob;
  HumData.nGold := m_nGold;

  HumData.Abil.Level := m_Abil.Level;
  HumData.Abil.HP := m_Abil.HP;
  HumData.Abil.MP := m_Abil.MP;
  HumData.Abil.MaxHP := m_Abil.MaxHP;
  HumData.Abil.MaxMP := m_Abil.MaxMP;
  HumData.Abil.Exp := m_Abil.Exp;
  HumData.Abil.MaxExp := m_Abil.MaxExp;
  HumData.Abil.Weight := m_Abil.Weight;
  HumData.Abil.MaxWeight := m_Abil.MaxWeight;
  HumData.Abil.WearWeight := m_Abil.WearWeight;
  HumData.Abil.MaxWearWeight := m_Abil.MaxWearWeight;
  HumData.Abil.HandWeight := m_Abil.HandWeight;
  HumData.Abil.MaxHandWeight := m_Abil.MaxHandWeight;

  HumData.Abil.NG := m_Skill69NH;//内功当前内力值 20080930
  HumData.Abil.MaxNG := m_Skill69MaxNH;//内力值上限 20081001

  HumData.n_Reserved:= m_Abil.Alcohol;//酒量 20080622
  HumData.n_Reserved1:= m_Abil.MaxAlcohol;//酒量上限 20080622
  HumData.n_Reserved2 := m_Abil.WineDrinkValue;//醉酒度 2008623
  HumData.btUnKnow2[2] := n_DrinkWineQuality;//饮酒时酒的品质
  HumData.UnKnow[4] := n_DrinkWineAlcohol;//饮酒时酒的度数 20080624
  HumData.UnKnow[5] := m_btMagBubbleDefenceLevel;//魔法盾等级 20080811

  HumData.nReserved1:= m_Abil.MedicineValue; //当前药力值 20080623
  HumData.nReserved2:= m_Abil.MaxMedicineValue; //药力值上限 20080623
  HumData.boReserved3:= n_DrinkWineDrunk;//人是否喝酒醉了 20080627
  HumData.nReserved3:= dw_UseMedicineTime; //使用药酒时间,计算长时间没使用药酒 20080623
  HumData.n_Reserved3:= n_MedicineLevel;  //药力值等级 20080623

  HumData.Exp68:= m_Exp68;//酒气护体当前经验 20080625
  HumData.MaxExp68:= m_MaxExp68;//酒气护体升级经验 20080625

  HumData.UnKnow[6] := Integer(m_boTrainingNG);//是否学习过内功 20081002
  if m_boTrainingNG then HumData.UnKnow[7] := m_NGLevel//内功等级 20081204
  else HumData.UnKnow[7] := 0;
  HumData.nExpSkill69 := m_ExpSkill69;//内功当前经验 20080930

  //HumData.Abil:=m_Abil;
  HumData.Abil.HP := m_WAbil.HP;
  HumData.Abil.MP := m_WAbil.MP;

  HumData.wStatusTimeArr := m_wStatusTimeArr;
  HumData.sHomeMap := m_sHomeMap;
  HumData.wHomeX := m_nHomeX;
  HumData.wHomeY := m_nHomeY;
  HumData.nPKPOINT := m_nPkPoint;
  HumData.BonusAbil := m_BonusAbil; // 08/09
  HumData.nBonusPoint := m_nBonusPoint; // 08/09
  HumData.sStoragePwd := m_sStoragePwd;
  HumData.btCreditPoint := m_btCreditPoint;
  HumData.btReLevel := m_btReLevel;

  HumData.sMasterName := m_sMasterName;
  HumData.boMaster := m_boMaster;
  HumData.sDearName := m_sDearName;

  HumData.nGameGold := m_nGameGold;
  HumData.nGameDiaMond:= m_nGameDiaMond; //20071226 金刚石
  HumData.nGameGird:= m_nGameGird; //20071226 灵符
  HumData.btGameGlory := m_btGameGlory; // 20080511 荣誉
  HumData.nGamePoint := m_nGamePoint;

  if g_Config.boSaveExpRate then begin //是否保存双倍经验时间 20080412
    HumData.nEXPRATE:= m_nKillMonExpRate - m_nItmeIncMonExpRate;//20071230 经验倍数
    if HumData.nEXPRATE <= 0 then HumData.nEXPRATE:=100;//20081229 临时处理用
    HumData.nExpTime:= m_dwKillMonExpRateTime;//20071230 双倍经验时间
  end else begin
    HumData.nEXPRATE:= 100;//20080506
    HumData.nExpTime:= 0;//20080506
  end;

  if m_boAllowGroup then HumData.btAllowGroup := 1
  else HumData.btAllowGroup := 0;
  HumData.btF9 := btB2;
  HumData.btAttatckMode := m_btAttatckMode;
  HumData.btIncHealth := m_nIncHealth;
  HumData.btIncSpell := m_nIncSpell;
  HumData.btIncHealing := m_nIncHealing;
  HumData.btFightZoneDieCount := m_nFightZoneDieCount;
  HumData.sAccount := m_sUserID;
  //HumData.btEE := nC4;//20081007 注释，nC4无实际用处
  HumData.boLockLogon := m_boLockLogon;
  HumData.wContribution := m_wContribution;
  HumData.nHungerStatus := m_nHungerStatus;
  HumData.boAllowGuildReCall := m_boAllowGuildReCall;
  HumData.wGroupRcallTime := m_wGroupRcallTime;
  HumData.dBodyLuck := m_dBodyLuck;
  HumData.boAllowGroupReCall := m_boAllowGroupReCall;
  //HumData.QuestUnitOpen := m_QuestUnitOpen;
  //HumData.QuestUnit := m_QuestUnit;
  HumData.btLastOutStatus := m_btLastOutStatus; //2006-01-12增加 退出状态 1为死亡退出
  HumData.wMasterCount := m_wMasterCount; //出师徒弟数
  HumData.btUnKnow2[0]:= Integer(bo_YBDEAL);//是否开通元宝寄售 20080316
  HumData.n_WinExp:= m_nWinExp ;//20080221 聚灵珠  累计经验
  HumData.n_UsesItemTick:= n_UsesItemTick;//聚灵珠聚集时间 20080221
  HumData.QuestFlag := m_QuestFlag;
  HumData.boHasHero := m_boHasHero;
  HumData.boReserved1:= m_boHasHeroTwo;
  HumData.boIsHero := False;
  HumData.sHeroChrName := m_sHeroCharName;
  HumData.btUnKnow2[1] := n_HeroSave;//是否保存英雄 20080514
  HumData.btEF := n_myHeroTpye;//角色身上带的英雄所属的类型  20080515
  HumData.boReserved:= m_boPlayDrink;//是否请过酒 T-请过酒 20080515

  HumData.m_GiveDate:= m_GiveGuildFountationDate;//人物领取行会酒泉日期 20080625
  HumData.boReserved2:= m_boMakeWine;//是否酿酒 20080620
  HumData.nReserved:= m_MakeWineTime;//酿酒的时间,即还有多长时间可以取回酒 20080620
  HumData.UnKnow[0]:= n_MakeWineItmeType;//酿酒后,应该可以得到酒的类型 2008020
  HumData.UnKnow[1]:= n_MakeWineType;//酿酒的类型 1-普通酒 2-药酒  20080620
  HumData.UnKnow[2]:= n_MakeWineQuality;//酿酒后,应该可以得到酒的品质 20080620
  HumData.UnKnow[3]:= n_MakeWineAlcohol;//酿酒后,应该可以得到酒的酒精度 20080620

  HumItems := @HumanRcd.Data.HumItems;
  HumItems[U_DRESS] := m_UseItems[U_DRESS];
  HumItems[U_WEAPON] := m_UseItems[U_WEAPON];
  HumItems[U_RIGHTHAND] := m_UseItems[U_RIGHTHAND];

  HumItems[U_HELMET] := m_UseItems[U_NECKLACE];
  HumItems[U_NECKLACE] := m_UseItems[U_HELMET];

  HumItems[U_ARMRINGL] := m_UseItems[U_ARMRINGL];
  HumItems[U_ARMRINGR] := m_UseItems[U_ARMRINGR];
  HumItems[U_RINGL] := m_UseItems[U_RINGL];
  HumItems[U_RINGR] := m_UseItems[U_RINGR];

  HumAddItems := @HumanRcd.Data.HumAddItems;
  HumAddItems[U_BUJUK] := m_UseItems[U_BUJUK];
  HumAddItems[U_BELT] := m_UseItems[U_BELT];
  HumAddItems[U_BOOTS] := m_UseItems[U_BOOTS];
  HumAddItems[U_CHARM] := m_UseItems[U_CHARM];
  HumAddItems[U_ZHULI] := m_UseItems[U_ZHULI];//20080416 斗笠
  BagItems := @HumanRcd.Data.BagItems;
  if m_ItemList.Count > 0 then begin //20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      if I >= MAXBAGITEM then Break;
      if pTUserItem(m_ItemList.Items[I]).wIndex = 0 then Continue;//20080915 ID为0的物品则不保存
      BagItems[I] := pTUserItem(m_ItemList.Items[I])^;
    end;
  end;
  HumMagics := @HumanRcd.Data.HumMagics;
  HumNGMagics:= @HumanRcd.Data.HumNGMagics;//20081001 内功技能
  if m_MagicList.Count > 0 then begin//20080629
    J:= 0;
    K:= 0;
    for I := 0 to m_MagicList.Count - 1 do begin
      UserMagic := m_MagicList.Items[I];
      if (UserMagic.MagicInfo.sDescr <> '内功') then begin
        if J >= MAXMAGIC then Continue{Break};
        HumMagics[J].wMagIdx := UserMagic.wMagIdx;
        HumMagics[J].btLevel := UserMagic.btLevel;
        HumMagics[J].btKey := UserMagic.btKey;
        HumMagics[J].nTranPoint := UserMagic.nTranPoint;
        Inc(J);
      end else begin
        if K >= MAXMAGIC then Continue{Break};
        HumNGMagics[K].wMagIdx := UserMagic.wMagIdx;
        HumNGMagics[K].btLevel := UserMagic.btLevel;
        HumNGMagics[K].btKey := UserMagic.btKey;
        HumNGMagics[K].nTranPoint := UserMagic.nTranPoint;
        Inc(K);
      end;
    end;
  end;
  StorageItems := @HumanRcd.Data.StorageItems;
  if m_StorageItemList.Count > 0 then begin//20080629
    for I := 0 to m_StorageItemList.Count - 1 do begin
      if I >= MAXBAGITEM then Break;
      if pTUserItem(m_StorageItemList.Items[I]).wIndex = 0 then Continue;//20080915 ID为0的物品则不保存
      StorageItems[I] := pTUserItem(m_StorageItemList.Items[I])^;
    end;
  end;
end;

function TBaseObject.sub_4C3538: Integer;
var
  nC, n10: Integer;
begin
  Result := 0;
  nC := -1;
  while (nC <> 2) do begin
    n10 := -1;
    while (n10 <> 2) do begin
      if not m_PEnvir.CanWalk(m_nCurrX + nC, m_nCurrY + n10, False) then begin
        if (nC <> 0) or (n10 <> 0) then
          Inc(Result);
      end;
      Inc(n10);
    end;
    Inc(nC);
  end;
end;

procedure TPlayObject.RefRankInfo(nRankNo: Integer; sRankName: string);
begin
  m_nGuildRankNo := nRankNo;
  m_sGuildRankName := sRankName;
  SendMsg(Self, RM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
end;

function TBaseObject.DelBagItem(nIndex: Integer): Boolean;
begin
  Result := False;
  if (nIndex < 0) or (nIndex >= m_ItemList.Count) then Exit;
  if pTUserItem(m_ItemList.Items[nIndex]) <> nil then begin
    Dispose(pTUserItem(m_ItemList.Items[nIndex]));
    m_ItemList.Delete(nIndex);
    Result := True;
  end;
  if Result then WeightChanged();
end;

function TBaseObject.DelBagItem(nItemIndex: Integer;
  sItemName: string): Boolean;
var
  I: Integer;
  UserItem: pTUserItem;
begin
  Result := False;
  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    UserItem := m_ItemList.Items[I];
    if (UserItem.MakeIndex = nItemIndex) and
      (CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0) then begin
      m_ItemList.Delete(I);
      Dispose(UserItem);
      Result := True;
      Break;
    end;
  end;
  if Result then WeightChanged();
end;

function TBaseObject.DelBagItem(UserItem: pTUserItem): Boolean;
var
  I: Integer;
  Item: pTUserItem;
begin
  Result := False;
  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    Item := m_ItemList.Items[I];
    if UserItem.wIndex = Item.wIndex then begin
      m_ItemList.Delete(I);
      Dispose(Item);
      Result := True;
      Break;
    end;
  end;
  if Result then WeightChanged();
end;

procedure TPlayObject.GetOldAbil(var OAbility: TOAbility);
begin
  FillChar(OAbility, SizeOf(TOAbility), #0);
  OAbility.Level := m_WAbil.Level;
  OAbility.AC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.AC)), _MIN(High(Byte), HiWord(m_WAbil.AC)));
  OAbility.MAC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.MAC)), _MIN(High(Byte), HiWord(m_WAbil.MAC)));
  OAbility.DC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.DC)), _MIN(High(Byte), HiWord(m_WAbil.DC)));
  OAbility.MC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.MC)), _MIN(High(Byte), HiWord(m_WAbil.MC)));
  OAbility.SC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.SC)), _MIN(High(Byte), HiWord(m_WAbil.SC)));
  OAbility.HP := m_WAbil.HP;
  OAbility.MP := m_WAbil.MP;
  OAbility.MaxHP := m_WAbil.MaxHP;
  OAbility.MaxMP := m_WAbil.MaxMP;
  OAbility.Exp := m_WAbil.Exp;
  OAbility.MaxExp := m_WAbil.MaxExp;
  OAbility.Weight := m_WAbil.Weight;
  OAbility.MaxWeight := m_WAbil.MaxWeight;
  OAbility.WearWeight := _MIN(High(Byte), m_WAbil.WearWeight);
  OAbility.MaxWearWeight := _MIN(High(Byte), m_WAbil.MaxWearWeight);
  OAbility.HandWeight := _MIN(High(Byte), m_WAbil.HandWeight);
  OAbility.MaxHandWeight := _MIN(High(Byte), m_WAbil.MaxHandWeight);
end;

function TPlayObject.GetHitMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin//20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = CM_HIT) or
          (SendMessage.wIdent = CM_HEAVYHIT) or
          (SendMessage.wIdent = CM_BIGHIT) or
          (SendMessage.wIdent = CM_POWERHIT) or
          (SendMessage.wIdent = CM_LONGHIT) or
          (SendMessage.wIdent = CM_WIDEHIT) or
          (SendMessage.wIdent = CM_CRSHIT) or
          (SendMessage.wIdent = CM_DAILY) or //逐日剑法 20080511
          (SendMessage.wIdent = CM_FIREHIT){烈火} or
          (SendMessage.wIdent = CM_4FIREHIT){4级烈火 20080112} then begin
          Inc(Result);
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;
//取攻击消息数量
function TPlayObject.GetSpellMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin//20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = CM_SPELL) then begin
          Inc(Result);
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetRunMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin//20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = CM_RUN) then begin
          Inc(Result);
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetWalkMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin//20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = CM_WALK) then begin
          Inc(Result);
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetTurnMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin//20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = CM_TURN) then begin
          Inc(Result);
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetSiteDownMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    if m_MsgList.Count > 0 then begin//20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = CM_SITDOWN) then begin
          Inc(Result);
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.CheckActionStatus(wIdent: Word; var dwDelayTime: LongWord): Boolean;
var
  dwCheckTime: LongWord;
//  dwCurrTick: LongWord;
  dwActionIntervalTime: LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  //检查人物弯腰停留时间
  if not g_Config.boDisableStruck then begin
    dwCheckTime := GetTickCount - m_dwStruckTick;
    if g_Config.dwStruckTime > dwCheckTime then begin
      dwDelayTime := g_Config.dwStruckTime - dwCheckTime;
      m_btOldDir := m_btDirection;
      Exit;
    end;
  end;

  //检查二个不同操作之间所需间隔时间
  dwCheckTime := GetTickCount - m_dwActionTick;

  if m_boTestSpeedMode then begin
    SysMsg('间隔: ' + IntToStr(dwCheckTime), c_Blue, t_Notice);
  end;

  if m_wOldIdent = wIdent then begin //当二次操作一样时，则将 boFirst 设置为 真 ，退出由调用函数本身检查二个相同操作之间的间隔时间
    Result := True;
    Exit;
  end;
  if not g_Config.boControlActionInterval then begin
    Result := True;
    Exit;
  end;

  dwActionIntervalTime := m_dwActionIntervalTime;
  case wIdent of
    CM_LONGHIT: begin
        //跑位刺杀
        if g_Config.boControlRunLongHit and (m_wOldIdent = CM_RUN) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunLongHitIntervalTime;
        end;
      end;
    CM_HIT: begin
        //走位攻击
        if g_Config.boControlWalkHit and (m_wOldIdent = CM_WALK) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwWalkHitIntervalTime;
        end;
        //跑位攻击
        if g_Config.boControlRunHit and (m_wOldIdent = CM_RUN) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunHitIntervalTime;
        end;
      end;
    CM_RUN: begin
        //跑位刺杀
        if g_Config.boControlRunLongHit and (m_wOldIdent = CM_LONGHIT) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunLongHitIntervalTime;
        end;
        //跑位攻击
        if g_Config.boControlRunHit and (m_wOldIdent = CM_HIT) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunHitIntervalTime;
        end;
        //跑位魔法
        if g_Config.boControlRunMagic and (m_wOldIdent = CM_SPELL) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunMagicIntervalTime;
        end;
      end;
    CM_WALK: begin
        //走位攻击
        if g_Config.boControlWalkHit and (m_wOldIdent = CM_HIT) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwWalkHitIntervalTime;
        end;
        //跑位刺杀
        if g_Config.boControlRunLongHit and (m_wOldIdent = CM_LONGHIT) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunLongHitIntervalTime;
        end;
      end;
    CM_SPELL: begin
        //跑位魔法
        if g_Config.boControlRunMagic and (m_wOldIdent = CM_RUN) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunMagicIntervalTime;
        end;
      end;
  end;

  //将几个攻击操作合并成一个攻击操作代码
  if (wIdent = CM_HIT) or
    (wIdent = CM_HEAVYHIT) or
    (wIdent = CM_BIGHIT) or
    (wIdent = CM_POWERHIT) or
    //(wIdent = CM_LONGHIT) or

    (wIdent = CM_WIDEHIT) or
    (wIdent = CM_CRSHIT) or
    (wIdent = CM_DAILY) or //逐日剑法 20080511
    (wIdent = CM_FIREHIT){烈火} or
    (wIdent = CM_4FIREHIT){4级烈火 20080112} then begin

    wIdent := CM_HIT;
  end;

  if dwCheckTime >= dwActionIntervalTime then begin
    m_dwActionTick := GetTickCount();
    Result := True;
  end else begin
    dwDelayTime := dwActionIntervalTime - dwCheckTime;
  end;
  m_wOldIdent := wIdent;
  m_btOldDir := m_btDirection;
  {
  dwCheckTime:=GetTickCount - m_dwActionTick;
  if dwCheckTime >= m_dwActionTime then begin
    m_dwActionTick:=GetTickCount();
    m_wOldIdent:=wIdent;
    Result:=True;
  end else begin
    dwDelayTime:=m_dwActionTime - dwCheckTime;
//    m_dwActionTime:=m_dwActionTime + 20;
  end;
  }
end;

procedure TPlayObject.SetScriptLabel(sLabel: string);
begin
  m_CanJmpScriptLableList.Clear;
  m_CanJmpScriptLableList.Add(sLabel);
end;
//取得当前脚本可以跳转的标签
procedure TPlayObject.GetScriptLabel(sMsg: string);
var
  sText: string;
  sData: string;
  sCmdStr, sLabel: string;
begin
  m_CanJmpScriptLableList.Clear;
  while (True) do begin
    if sMsg = '' then Break;
    sMsg := GetValidStr3(sMsg, sText, ['\']);
    if sText <> '' then begin
      sData := '';
      while (Pos('<', sText) > 0) and (Pos('>', sText) > 0) and (sText <> '') do begin
        if sText[1] <> '<' then begin
          sText := '<' + GetValidStr3(sText, sData, ['<']);
        end;
        sText := ArrestStringEx(sText, '<', '>', sCmdStr);
        sLabel := GetValidStr3(sCmdStr, sCmdStr, ['/']);
        if sLabel <> '' then
          m_CanJmpScriptLableList.Add(sLabel);
      end;
    end;
  end;
end;

function TPlayObject.LableIsCanJmp(sLabel: string): Boolean;
var
  I: Integer;
begin
  Result := False;
  if CompareText(sLabel, '@main') = 0 then begin
    Result := True;
    Exit;
  end;
  if m_CanJmpScriptLableList.Count > 0 then begin//20080629
    for I := 0 to m_CanJmpScriptLableList.Count - 1 do begin
      if CompareText(sLabel, m_CanJmpScriptLableList.Strings[I]) = 0 then begin
        Result := True;
        Break;
      end;
    end;
  end;
  if CompareText(sLabel, m_sPlayDiceLabel) = 0 then begin
    m_sPlayDiceLabel := '';
    Result := True;
    Exit;
  end;
end;

procedure TPlayObject.RecalcAbilitys;
begin
  inherited;
  RecalcAdjusBonus();
end;
//挂机后,清除相关列表
procedure TPlayObject.ClearViewRange;
var
  I: Integer;
begin
  try
    m_VisibleHumanList.Clear;
    if m_VisibleItems.Count > 0 then begin//20080629
      for I := 0 to m_VisibleItems.Count - 1 do begin
        if pTVisibleMapItem(m_VisibleItems.Items[I]) <> nil then
           Dispose(pTVisibleMapItem(m_VisibleItems.Items[I]));
      end;
    end;
    m_VisibleItems.Clear;
    if m_VisibleActors.Count > 0 then begin//20080629
      for I := 0 to m_VisibleActors.Count - 1 do begin
        if pTVisibleBaseObject(m_VisibleActors.Items[I]) <> nil then
           Dispose(pTVisibleBaseObject(m_VisibleActors.Items[I]));
      end;
    end;
    m_VisibleActors.Clear; //清除人物列表
    if m_VisibleEvents.Count > 0 then begin//20080629
      for I := 0 to m_VisibleEvents.Count - 1 do begin
        if pTVisibleMapEvent(m_VisibleEvents.Items[I]) <> nil then
           Dispose(pTVisibleMapEvent(m_VisibleEvents.Items[I]));
      end;
    end;
    m_VisibleEvents.Clear;
  except
    KickException();
  end;
end;

procedure TPlayObject.SearchViewRange;
var
  I: Integer;
  nStartX: Integer;
  nEndX: Integer;
  nStartY: Integer;
  nEndY: Integer;
  n18: Integer;
  n1C: Integer;
  nIdx: Integer;
  n24: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  MapItem: PTMapItem;
  MapEvent: TEvent;
  VisibleMapEvent: pTVisibleMapEvent;
  VisibleBaseObject: pTVisibleBaseObject;
  VisibleMapItem: pTVisibleMapItem;
  nCheckCode: Byte;
  btType: Byte;
  nVisibleFlag: Integer;
resourcestring
  sExceptionMsg1 = '{异常} TPlayObject::SearchViewRange Code:%d';
  sExceptionMsg2 = '{异常} TPlayObject::SearchViewRange 1-%d %s %s %d %d %d';
begin
  nCheckCode := 1;
  n24 := 0;
  try
    if m_boNotOnlineAddExp then Exit; //2006-10-22 叶随风飘 修改 离线挂机不搜索
    nCheckCode := 2;
    if m_VisibleItems.Count > 0 then begin//20080629
      for I := 0 to m_VisibleItems.Count - 1 do begin
        pTVisibleMapItem(m_VisibleItems.Items[I]).nVisibleFlag := 0;
      end;
    end;
    nCheckCode := 3;
    if m_VisibleEvents.Count > 0 then begin//20080629
      for I := 0 to m_VisibleEvents.Count - 1 do begin
        pTVisibleMapEvent(m_VisibleEvents.Items[I]).nVisibleFlag := 0;
      end;
    end;
    nCheckCode := 4;
    if m_VisibleActors.Count > 0 then begin//20080629
      for I := 0 to m_VisibleActors.Count - 1 do begin
        pTVisibleBaseObject(m_VisibleActors.Items[I]).nVisibleFlag := 0;
      end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg1, [nCheckCode]));
    KickException();
  end;
  nCheckCode := 6;

  try
    nStartX := m_nCurrX - m_nViewRange;
    nEndX := m_nCurrX + m_nViewRange;
    nStartY := m_nCurrY - m_nViewRange;
    nEndY := m_nCurrY + m_nViewRange;
    nCheckCode := 7;
    for n18 := nStartX to nEndX do begin
      for n1C := nStartY to nEndY do begin
        nCheckCode := 8;
        if m_PEnvir.GetMapCellInfo(n18, n1C, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
          nCheckCode := 9;
          n24 := 1;
          nIdx := 0;
          while (True) do begin
            if MapCellInfo <> nil then begin//20080910 增加
              if (MapCellInfo.ObjList <> nil) and (MapCellInfo.ObjList.Count <= 0) then begin //200-11-1 增加
                nCheckCode := 10;
                FreeAndNil(MapCellInfo.ObjList);
                Break;
              end;
            end;
            nCheckCode := 11;
            if MapCellInfo.ObjList.Count <= nIdx then Break;
            OSObject := MapCellInfo.ObjList.Items[nIdx];
            nCheckCode := 12;
            if OSObject = nil then begin//传世处理代码 20080916
              MapCellInfo.ObjList.Delete(nIdx);
              if MapCellInfo.ObjList.Count > 0 then Continue;
              FreeAndNil(MapCellInfo.ObjList);
              break;
            end;
            if OSObject <> nil then begin
              nCheckCode := 0;  //20080923 
              try //20080913
                btType := OSObject.btType; //2006-10-14 防止内存出错
              except
                MapCellInfo.ObjList.Delete(nIdx);
                if MapCellInfo.ObjList.Count > 0 then Continue;
                FreeAndNil(MapCellInfo.ObjList);
                break;
              end;
              if {OSObject.btType}btType = OS_MOVINGOBJECT then begin
                nCheckCode := 13;
                if (GetTickCount - OSObject.dwAddTime) >= 60000{60 * 1000} then begin
                  DisPoseAndNil(OSObject);
                  MapCellInfo.ObjList.Delete(nIdx);
                  if MapCellInfo.ObjList.Count <= 0 then begin
                    FreeAndNil(MapCellInfo.ObjList);
                    Break;
                  end;
                  Continue;
                end;
                nCheckCode := 14;
                BaseObject := TBaseObject(OSObject.CellObj);
                if BaseObject <> nil then begin
                  if not BaseObject.m_boGhost and not BaseObject.m_boFixedHideMode and not BaseObject.m_boObMode then begin
                    nCheckCode := 15;
                    if (m_btRaceServer < RC_ANIMAL) or (m_Master <> nil) or m_boCrazyMode or m_boWantRefMsg or
                      ((BaseObject.m_Master <> nil) and (abs(BaseObject.m_nCurrX - m_nCurrX) <= 3) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 3)) or
                      (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
                      nCheckCode := 16;
                      UpdateVisibleGay(BaseObject);
                    end;
                  end;
                end; //if BaseObject <> nil then begin
              end; //if OSObject.btType = OS_MOVINGOBJECT then begin
              if m_btRaceServer = RC_PLAYOBJECT then begin
                if (OSObject <> nil) and (OSObject.btType = OS_ITEMOBJECT) then begin
                  nCheckCode := 17;
                  if (GetTickCount - OSObject.dwAddTime) > g_Config.dwClearDropOnFloorItemTime {60 * 60 * 1000} then begin
                    nCheckCode := 18;
                    if PTMapItem(OSObject.CellObj) <> nil then DisPoseAndNil(PTMapItem(OSObject.CellObj)); //防止占用内存不释放现象 20080702
                    nCheckCode := 19;
                    DisPoseAndNil(OSObject);
                    nCheckCode := 20;
                    MapCellInfo.ObjList.Delete(nIdx);
                    nCheckCode := 21;
                    if MapCellInfo.ObjList.Count <= 0 then begin
                      FreeAndNil(MapCellInfo.ObjList);
                      Break;
                    end;
                    Continue;
                  end;
                  MapItem := PTMapItem(OSObject.CellObj);
                  nCheckCode := 22;
                  UpdateVisibleItem(n18, n1C, MapItem);
                  if (MapItem.OfBaseObject <> nil) or (MapItem.DropBaseObject <> nil) then begin
                    if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then begin
                      MapItem.OfBaseObject := nil;
                      MapItem.DropBaseObject := nil;
                    end else begin
                      nCheckCode := 23;
                      if TBaseObject(MapItem.OfBaseObject) <> nil then begin
                        if TBaseObject(MapItem.OfBaseObject).m_boGhost then MapItem.OfBaseObject := nil;
                      end;
                      if TBaseObject(MapItem.DropBaseObject) <> nil then begin
                        if TBaseObject(MapItem.DropBaseObject).m_boGhost then MapItem.DropBaseObject := nil;
                      end;
                    end;
                  end;
                end; //if OSObject.btType = OS_ITEMOBJECT then begin
                if (OSObject <> nil) and (OSObject.btType = OS_EVENTOBJECT) then begin
                  nCheckCode := 24;
                  if OSObject.CellObj <> nil then begin//20080913
                    MapEvent := TEvent(OSObject.CellObj);
                    if MapEvent.m_boVisible then begin
                      nCheckCode := 25;
                      UpdateVisibleEvent(n18, n1C, MapEvent);
                    end;
                  end;
                end;
              end
            end; //if OSObject <> nil then begin
            Inc(nIdx);
          end; //while (True) do begin
        end;
      end; //for n1C:= n10 to n14  do begin
    end; //for n18:= n8 to nC do begin
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg2, [n24, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      KickException();
    end;
  end;
  nCheckCode := 26;
  n24 := 2;
  try
    n18 := 0;
    while (True) do begin
      if m_VisibleActors.Count <= n18 then Break;
      nCheckCode := 27;
      VisibleBaseObject := m_VisibleActors.Items[n18];
      nCheckCode := 28;

      try//20081017 去注释
        nVisibleFlag := VisibleBaseObject.nVisibleFlag; //2006-10-14 防止内存出错
      except
        m_VisibleActors.Delete(n18);
        Continue;
      end; 

      if VisibleBaseObject.nVisibleFlag = 0 then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          nCheckCode := 29;
          BaseObject := TBaseObject(VisibleBaseObject.BaseObject);
          nCheckCode := 30;
          if BaseObject <> nil then begin
            if not BaseObject.m_boFixedHideMode and (not BaseObject.m_boGhost) then begin //01/21 修改防止人物退出时发送重复的消息占用带宽，人物进入隐身模式时人物不消失问题
              nCheckCode := 31;
              SendMsg(BaseObject, RM_DISAPPEAR, 0, 0, 0, 0, '');
            end;
          end;
        end;
        m_VisibleActors.Delete(n18);
        nCheckCode := 32;
        DisPoseAndNil(VisibleBaseObject);
        Continue;
      end;
      nCheckCode := 33;
      if (m_btRaceServer = RC_PLAYOBJECT) and (VisibleBaseObject.nVisibleFlag = 2) then begin
        nCheckCode := 34;
        BaseObject := TBaseObject(VisibleBaseObject.BaseObject);
        if (BaseObject <> nil) then begin
          if (BaseObject <> Self) then begin
            if BaseObject.m_boDeath then begin
              if BaseObject.m_boSkeleton then begin
                nCheckCode := 35;
                SendMsg(BaseObject, RM_SKELETON, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
              end else begin
                nCheckCode := 36;
                SendMsg(BaseObject, RM_DEATH, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
              end;
            end else begin
              nCheckCode := 37;
              SendMsg(BaseObject, RM_TURN, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, BaseObject.GetShowName);
              nCheckCode := 38;
              if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
                nCheckCode := 39;
                if TPlayObject(BaseObject).m_boTrainingNG then
                  SendMsg(BaseObject, RM_MAGIC69SKILLNH, 0, TPlayObject(BaseObject).m_Skill69NH, TPlayObject(BaseObject).m_Skill69MaxNH, 0, '');
              end else
              if (BaseObject.m_btRaceServer = RC_HEROOBJECT) then begin
                nCheckCode := 41;
                if THeroObject(BaseObject).m_boTrainingNG then
                  SendMsg(BaseObject, RM_MAGIC69SKILLNH, 0, THeroObject(BaseObject).m_Skill69NH, THeroObject(BaseObject).m_Skill69MaxNH, 0, '');
              end else
              if (BaseObject.m_btRaceServer = RC_PLAYMOSTER) and (BaseObject.m_Master <> nil) then begin//学过内功人物的分身也显示黄条值 20081226
                if (BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                  if TPlayObject(BaseObject.m_Master).m_boTrainingNG then begin
                    nCheckCode := 42;
                    SendMsg(BaseObject, RM_MAGIC69SKILLNH, 0, TPlayObject(BaseObject.m_Master).m_Skill69NH, TPlayObject(BaseObject.m_Master).m_Skill69MaxNH, 0, '');
                  end;
                end else
                if (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) then begin
                  if THeroObject(BaseObject.m_Master).m_boTrainingNG then begin
                    nCheckCode := 43;
                    SendMsg(BaseObject, RM_MAGIC69SKILLNH, 0, THeroObject(BaseObject.m_Master).m_Skill69NH, THeroObject(BaseObject.m_Master).m_Skill69MaxNH, 0, '');
                  end;
                end;
              end;
              
            end;
          end;
        end;
      end;
      Inc(n18);
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg2, [n24, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      KickException();
    end;
  end;
  try
    //    if (m_btRaceServer = RC_PLAYOBJECT) then begin
    I := 0;
    while (True) do begin
      if m_VisibleItems.Count <= I then Break;
      VisibleMapItem := m_VisibleItems.Items[I];

      try //20081017 去注释
        nVisibleFlag := VisibleMapItem.nVisibleFlag; //2006-10-14 防止内存出错
      except
        m_VisibleItems.Delete(I);
        Continue;
      end;
      
      nCheckCode := 38;
      if VisibleMapItem.nVisibleFlag = 0 then begin
        nCheckCode := 39;
        SendMsg(Self, RM_ITEMHIDE, 0, Integer(VisibleMapItem.MapItem), VisibleMapItem.nX, VisibleMapItem.nY, '');
        nCheckCode := 40;
        m_VisibleItems.Delete(I);
        nCheckCode := 41;
        try
          DisPoseAndNil(VisibleMapItem);
        except
          VisibleMapItem := nil;
        end;
        Continue;
      end;
      nCheckCode := 42;
      if VisibleMapItem.nVisibleFlag = 2 then begin
        SendMsg(Self, RM_ITEMSHOW, VisibleMapItem.wLooks, Integer(VisibleMapItem.MapItem), VisibleMapItem.nX, VisibleMapItem.nY, VisibleMapItem.sName);
      end;
      Inc(I);
    end;
    I := 0;
    while (True) do begin //2006-01-20 修改
      if m_VisibleEvents.Count <= I then Break;
      nCheckCode := 43;
      VisibleMapEvent := m_VisibleEvents.Items[I];

      try //20081017 去注释
        nVisibleFlag := VisibleMapEvent.nVisibleFlag;
      except
        m_VisibleEvents.Delete(I);
        Continue;
      end;

      nCheckCode := 44;
      if VisibleMapEvent.nVisibleFlag = 0 then begin
        nCheckCode := 45;
        SendMsg(Self, RM_HIDEEVENT, 0, Integer(VisibleMapEvent.MapEvent), VisibleMapEvent.nX, VisibleMapEvent.nY, '');
        nCheckCode := 46;
        m_VisibleEvents.Delete(I);
        nCheckCode := 47;
        DisPoseAndNil(VisibleMapEvent);
        Continue;
      end;
      nCheckCode := 48;
      if VisibleMapEvent.nVisibleFlag = 2 then begin
        SendMsg(Self, RM_SHOWEVENT, TEvent(VisibleMapEvent.MapEvent).m_nEventType, Integer(VisibleMapEvent.MapEvent), MakeLong(VisibleMapEvent.nX, TEvent(VisibleMapEvent.MapEvent).m_nEventParam), VisibleMapEvent.nY, '');
      end;

      {nCheckCode := 103;
      MapEvent := m_VisibleEvents.Items[i];
      nCheckCode := 104;
      try
        nVisibleFlag := MapEvent.nVisibleFlag; //2006-10-14 防止内存出错
      except
        m_VisibleEvents.Delete(i);
        Continue;
      end;
      nCheckCode := 105;
      if MapEvent.nVisibleFlag = 0 then begin
        nCheckCode := 1050;
        SendMsg(Self, RM_HIDEEVENT, 0, Integer(MapEvent), MapEvent.m_nX, MapEvent.m_nY, '');
        nCheckCode := 1051;
        m_VisibleEvents.Delete(i);
        nCheckCode := 1052;
        Continue;
      end;
      nCheckCode := 106;
      if MapEvent.nVisibleFlag = 2 then begin
        SendMsg(Self, RM_SHOWEVENT, MapEvent.m_nEventType, Integer(MapEvent), MakeLong(MapEvent.m_nX, MapEvent.m_nEventParam), MapEvent.m_nY, '');
      end;
      nCheckCode := 107; }
      Inc(I);
    end;
  except
    MainOutMessage(m_sCharName + ',' + m_sMapName + ',' +IntToStr(m_nCurrX) + ',' +
      IntToStr(m_nCurrY) + ',' +' SearchViewRange 3 CheckCode:' + IntToStr(nCheckCode));
    KickException();
  end;
end;
//人物显示名字 20080330
function TPlayObject.GetShowName: string;
var
  sShowName: string;
  sCharName: string;
  sGuildName: string;
  sDearName: string;
  sMasterName: string;
  Castle: TUserCastle;
  nCode: Byte;
begin
  nCode:= 0;
  try
    //sShowName:=m_sCharName;
    sCharName := '';
    sGuildName := '';
    sDearName := '';
    sMasterName := '';
    nCode:= 1;
    if m_MyGuild <> nil then begin
      Castle := g_CastleManager.IsCastleMember(Self);
      {
      if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) then begin
        sGuildName:=AnsiReplaceText(g_sCastleGuildName,'%castlename',UserCastle.m_sName);
        sGuildName:=AnsiReplaceText(sGuildName,'%guildname',TGuild(m_MyGuild).sGuildName);
        sGuildName:=AnsiReplaceText(sGuildName,'%rankname',m_sGuildRankName);
        }
      nCode:= 2;
      if Castle <> nil then begin
        sGuildName := AnsiReplaceText(g_sCastleGuildName, '%castlename', Castle.m_sName);//城堡名字
        sGuildName := AnsiReplaceText(sGuildName, '%guildname', TGUild(m_MyGuild).sGuildName);//行会名字
        sGuildName := AnsiReplaceText(sGuildName, '%rankname', m_sGuildRankName);//行会封号
      end else begin
        Castle := g_CastleManager.InCastleWarArea(Self);
        //01/25 多城堡
        //if g_Config.boShowGuildName or (UserCastle.m_boUnderWar and (m_boInFreePKArea or UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY))) then begin
        if g_Config.boShowGuildName or (((Castle <> nil) and Castle.m_boUnderWar) or m_boInFreePKArea) then begin
          sGuildName := AnsiReplaceText(g_sNoCastleGuildName, '%guildname', TGUild(m_MyGuild).sGuildName);
          sGuildName := AnsiReplaceText(sGuildName, '%rankname', m_sGuildRankName);
        end;
      end;
    end;
    nCode:= 3;
    if not g_Config.boShowRankLevelName then begin
      if m_btReLevel > 0 then begin
        case m_btJob of
          0: sCharName := AnsiReplaceText(g_sWarrReNewName, '%chrname', m_sCharName);
          1: sCharName := AnsiReplaceText(g_sWizardReNewName, '%chrname', m_sCharName);
          2: sCharName := AnsiReplaceText(g_sTaosReNewName, '%chrname', m_sCharName);
          //3:;//刺客
        end;
      end else begin
        sCharName := m_sCharName;
      end;
    end else begin
      sCharName := Format(m_sRankLevelName, [m_sCharName]);
    end;
    nCode:= 4;
    if m_sMasterName <> '' then begin
      if m_boMaster then begin
        sMasterName := Format(g_sMasterName{'的师傅'}, [m_sMasterName]);
      end else begin
        sMasterName := Format(g_sNoMasterName{'的徒弟'}, [m_sMasterName, MoneyToCharacter(m_nMasterNo)]);//20080530
      end;
    end;
    nCode:= 5;
    if m_sDearName <> '' then begin
      if m_btGender = 0 then begin
        sDearName := Format(g_sManDearName, [m_sDearName]);//+ '的老公';
      end else begin
        sDearName := Format(g_sWoManDearName, [m_sDearName]); // + '的老婆';
      end;
    end;
    nCode:= 6;
    sShowName := AnsiReplaceText(g_sHumanShowName, '%chrname', sCharName);//人物名
    sShowName := AnsiReplaceText(sShowName, '%guildname', sGuildName);//行会名
    sShowName := AnsiReplaceText(sShowName, '%dearname', sDearName);//夫妻名
    sShowName := AnsiReplaceText(sShowName, '%mastername', sMasterName);//师徒名
    Result := sShowName;
    nCode:= 7;
    if g_Config.boUnKnowHum and IsUsesZhuLi then Result :='神秘人';//带上斗笠即显示神秘人 20080424    
  except
    on E: Exception do begin
      MainOutMessage('{异常} TPlayObject::GetShowName Code:'+inttostr(nCode));
    end;
  end;
end;

function TPlayObject.CheckItemsNeed(StdItem: pTStdItem): Boolean;
var
  Castle: TUserCastle;
begin
  Result := True;
  Castle := g_CastleManager.IsCastleMember(Self);
  case StdItem.Need of
    6: begin
        if (m_MyGuild = nil) then begin
          Result := False;
        end;
      end;
    60: begin
        if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then begin
          Result := False;
        end;
      end;
    7: begin
        //if (m_MyGuild = nil) or (UserCastle.m_MasterGuild <> m_MyGuild) then begin
        if Castle = nil then begin
          Result := False;
        end;
      end;
    70: begin
        //if (m_MyGuild = nil) or (UserCastle.m_MasterGuild <> m_MyGuild) or (m_nGuildRankNo <> 1) then begin
        if (Castle = nil) or (m_nGuildRankNo <> 1) then begin
          Result := False;
        end;
      end;
    8: begin
        if m_nMemberType = 0 then Result := False;
      end;
    81: begin
        if (m_nMemberType <> LoWord(StdItem.NeedLevel)) or (m_nMemberLevel < HiWord(StdItem.NeedLevel)) then
          Result := False;
      end;
    82: begin
        if (m_nMemberType < LoWord(StdItem.NeedLevel)) or (m_nMemberLevel < HiWord(StdItem.NeedLevel)) then
          Result := False;
      end;
  end;
end;

procedure TPlayObject.CheckMarry;
var
  boIsfound: Boolean;
  sUnMarryFileName: string;
  LoadList: TStringList;
  I: Integer;
  sSayMsg: string;
begin
  boIsfound := False;
  sUnMarryFileName := g_Config.sEnvirDir + 'UnMarry.txt';
  if FileExists(sUnMarryFileName) then begin
    LoadList := TStringList.Create;
    LoadList.LoadFromFile(sUnMarryFileName);
    for I := LoadList.Count - 1 downto 0 do begin
      if LoadList.Count <= 0 then Break;
      if CompareText(LoadList.Strings[I], m_sCharName) = 0 then begin
        LoadList.Delete(I);
        boIsfound := True;
        Break;
      end;
    end;
    LoadList.SaveToFile(sUnMarryFileName);
    LoadList.Free;
  end;
  if boIsfound then begin
    if m_btGender = 0 then begin
      sSayMsg := AnsiReplaceText(g_sfUnMarryManLoginMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sDearName);
    end else begin
      sSayMsg := AnsiReplaceText(g_sfUnMarryWoManLoginMsg, '%d', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
    end;
    SysMsg(sSayMsg, c_Red, t_Hint);
    m_sDearName := '';
    RefShowName;
  end;
  m_DearHuman := UserEngine.GetPlayObject(m_sDearName);
  if m_DearHuman <> nil then begin
    m_DearHuman.m_DearHuman := Self;
    if m_btGender = 0 then begin
      sSayMsg := AnsiReplaceText(g_sManLoginDearOnlineSelfMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_DearHuman.m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_DearHuman.m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_DearHuman.m_nCurrY));
      SysMsg(sSayMsg, c_Blue, t_Hint);

      sSayMsg := AnsiReplaceText(g_sManLoginDearOnlineDearMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
      m_DearHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
    end else begin
      sSayMsg := AnsiReplaceText(g_sWoManLoginDearOnlineSelfMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_DearHuman.m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_DearHuman.m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_DearHuman.m_nCurrY));
      SysMsg(sSayMsg, c_Blue, t_Hint);

      sSayMsg := AnsiReplaceText(g_sWoManLoginDearOnlineDearMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
      m_DearHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
    end;
  end else begin
    if m_btGender = 0 then begin
      SysMsg(g_sManLoginDearNotOnlineMsg, c_Red, t_Hint);
    end else begin
      SysMsg(g_sWoManLoginDearNotOnlineMsg, c_Red, t_Hint);
    end;
  end;
end;
//检查师傅
procedure TPlayObject.CheckMaster;
var
  boIsfound: Boolean;
  sSayMsg: string;
  I: Integer;
  Human: TPlayObject;
  s01,s02,s03:string;
begin
  //处理强行脱离师徒关系
  boIsfound := False;
  g_UnForceMasterList.Lock;
  try
    for I := g_UnForceMasterList.Count - 1 downto 0 do begin
      if g_UnForceMasterList.Count <= 0 then Break;
      s01 := Trim(g_UnForceMasterList.Strings[I]);
      if (s01 <> '') and (s01[1] <> ';') then begin
        s01 := GetValidStr3(s01, s02, [' ', #9]);//师傅名
        s01 := GetValidStr3(s01, s03, [' ', #9]);//徒弟名
        if CompareText(s02, m_sCharName) = 0 then begin
          g_UnForceMasterList.Delete(I);
          SaveUnForceMasterList();
          boIsfound := True;
          Break;
        end;
      end;
    end;
  finally
    g_UnForceMasterList.UnLock;
  end;

  if boIsfound then begin
    if m_boMaster then begin
      sSayMsg := AnsiReplaceText(g_sfUnMasterLoginMsg, '%d', s03);//20080603
      //sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sMasterName);
      DelMaster(s03);//出师 20080530
      if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@UnMasterEnd', False);//师傅触发 20080530
    end else begin
      sSayMsg := AnsiReplaceText(g_sfUnMasterListLoginMsg, '%d', m_sMasterName);
      //sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sMasterName);
    end;
    SysMsg(sSayMsg, c_Red, t_Hint);
    m_sMasterName := '';
    RefShowName;
  end;

  if (m_sMasterName <> '') and not m_boMaster then begin
    if m_Abil.Level >= g_Config.nMasterOKLevel then begin
      Human := UserEngine.GetPlayObject(m_sMasterName);
      if (Human <> nil) and (not Human.m_boDeath) and (not Human.m_boGhost) then begin
        sSayMsg := AnsiReplaceText(g_sYourMasterListUnMasterOKMsg, '%d',MoneyToCharacter(m_nMasterNo));//20080603
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);//20080603
        Human.SysMsg(sSayMsg, c_Red, t_Hint);
        SysMsg(g_sYouAreUnMasterOKMsg, c_Red, t_Hint);
        Human.DelMaster(m_sCharName);//出师 20080603

        //如果大徒弟则将师父上的名字去掉
        if m_sCharName = Human.m_sMasterName then begin
          Human.m_sMasterName := '';
          Human.RefShowName;
        end;
        for I := Human.m_MasterList.Count - 1 downto 0 do begin
          if Human.m_MasterList.Count <= 0 then Break;
          if Human.m_MasterList.Items[I] = Self then begin
            Human.m_MasterList.Delete(I);
            Break;
          end;
        end;
        m_sMasterName := '';
        RefShowName;
        Inc(Human.m_wMasterCount); //增加出师徒弟数
        //if Human.m_btCreditPoint + g_Config.nMasterOKCreditPoint <= High(Integer{Byte}) then begin //20080522
          Inc(Human.m_btCreditPoint, g_Config.nMasterOKCreditPoint);//增加师傅的声望
        //end;
        Inc(Human.m_nBonusPoint, g_Config.nMasterOKBonusPoint);
        Human.SendMsg(Human, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      end else begin
        //如果师父不在线则保存到记录表中
        g_UnMasterList.Lock;
        try
          boIsfound := False;
          if g_UnMasterList.Count > 0 then begin//20080629
            for I := 0 to g_UnMasterList.Count - 1 do begin
              s01 := Trim(g_UnMasterList.Strings[I]);
              if (s01 <> '') and (s01[1] <> ';') then begin//20080603 增加
                s01 := GetValidStr3(s01, s02, [' ', #9]);//师傅名
                s01 := GetValidStr3(s01, s03, [' ', #9]);
                if CompareText({g_UnMasterList.Strings[I]}s02, m_sCharName) = 0 then begin
                  boIsfound := True;
                  Break;
                end;
              end;
            end;//for
          end;
          if not boIsfound then begin
            g_UnMasterList.Add(m_sMasterName+' '+m_sCharName);//20080603 修改
          end;
        finally
          g_UnMasterList.UnLock;
        end;
        if not boIsfound then SaveUnMasterList();
        SysMsg(g_sYouAreUnMasterOKMsg, c_Red, t_Hint);
        m_sMasterName := '';
        RefShowName;
      end;
    end;
  end;

  //处理出师记录
  boIsfound := False;
  g_UnMasterList.Lock;
  try
    for I := g_UnMasterList.Count - 1 downto 0 do begin
      if g_UnMasterList.Count <= 0 then Break;//20080917
      s01 := Trim(g_UnMasterList.Strings[I]);
      if (s01 <> '') and (s01[1] <> ';') then begin//20080603 增加
        s01 := GetValidStr3(s01, s02, [' ', #9]);//师傅名
        s01 := GetValidStr3(s01, s03, [' ', #9]);//徒弟名
        if CompareText({g_UnMasterList.Strings[I]}s02, m_sCharName) = 0 then begin
          g_UnMasterList.Delete(I);
          SaveUnMasterList();
          boIsfound := True;
          Break;
        end;
      end;
    end;
  finally
    g_UnMasterList.UnLock;
  end;

  if boIsfound and m_boMaster then begin
    sSayMsg := AnsiReplaceText(g_sUnMasterLoginMsg, '%s', s03);//20080603 修改
    SysMsg(sSayMsg , c_Red, t_Hint);
    DelMaster(s03);//出师 20080603
    m_sMasterName := '';
    RefShowName;

    Inc(m_wMasterCount); //增加出师徒弟数
    //if m_btCreditPoint + g_Config.nMasterOKCreditPoint <= High(Integer{Byte}) then begin //20080522
      Inc(m_btCreditPoint, g_Config.nMasterOKCreditPoint);
    //end;
    Inc(m_nBonusPoint, g_Config.nMasterOKBonusPoint);
    SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
  end;

  //if m_sMasterName = '' then Exit; //20080512\
  if m_boMaster then begin//是师傅
    //师父上线通知
    //m_MasterHuman := UserEngine.GetPlayObject(m_sMasterName);
    m_MasterHuman := UserEngine.GetMasterObject(m_sCharName);//20080512
    if m_MasterHuman <> nil then begin
      m_MasterHuman.m_MasterHuman := Self;
      m_MasterList.Add(m_MasterHuman);

      sSayMsg := AnsiReplaceText(g_sMasterOnlineSelfMsg, '%d', MoneyToCharacter(m_nMasterNo){m_sMasterName});//20080603
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_MasterHuman.m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_MasterHuman.m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_MasterHuman.m_nCurrY));
      SysMsg(sSayMsg, c_Blue, t_Hint);

      sSayMsg := AnsiReplaceText(g_sMasterOnlineMasterListMsg, '%d', m_sMasterName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
      m_MasterHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
    end else begin
      if m_MasterNoList.Count <> 0 then SysMsg(g_sMasterNotOnlineMsg{您的徒弟现不在线}, c_Red, t_Hint);//20080530
    end;
  end else begin
    //徒弟上线通知
    if m_sMasterName <> '' then begin
      m_MasterHuman := UserEngine.GetPlayObject(m_sMasterName);
      if m_MasterHuman <> nil then begin

        if m_MasterHuman.m_sMasterName = m_sCharName then begin
          m_MasterHuman.m_MasterHuman := Self;
        end;

        m_MasterHuman.m_MasterList.Add(Self);

        sSayMsg := AnsiReplaceText(g_sMasterListOnlineSelfMsg, '%d', m_sMasterName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_MasterHuman.m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_MasterHuman.m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_MasterHuman.m_nCurrY));
        SysMsg(sSayMsg, c_Blue, t_Hint);

        //sSayMsg := AnsiReplaceText(g_sMasterListOnlineMasterMsg, '%d', m_sMasterName);
        sSayMsg := AnsiReplaceText(g_sMasterListOnlineMasterMsg, '%d', MoneyToCharacter(m_nMasterNo));//20080602
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_MasterHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
      end else begin
        SysMsg(g_sMasterListNotOnlineMsg{您的师父现不在线}, c_Red, t_Hint);
      end;
    end;
  end;
end;

procedure TPlayObject.MakeGhost;
var
  I: Integer;
  sSayMsg: string;
  Human: TPlayObject;
resourcestring
  sExceptionMsg = '{异常} TPlayObject::MakeGhost';
begin
  try
    if (g_HighLevelHuman = Self) then g_HighLevelHuman := nil;
    if (g_HighPKPointHuman = Self) then g_HighPKPointHuman := nil;
    if (g_HighDCHuman = Self) then g_HighDCHuman := nil;
    if (g_HighMCHuman = Self) then g_HighMCHuman := nil;
    if (g_HighSCHuman = Self) then g_HighSCHuman := nil;
    if (g_HighOnlineHuman = Self) then g_HighOnlineHuman := nil;
    //人物下线后通知配偶，并把对方的相关记录清空
    if m_DearHuman <> nil then begin
      if m_btGender = 0 then begin
        sSayMsg := AnsiReplaceText(g_sManLongOutDearOnlineMsg, '%d', m_sDearName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_DearHuman.SysMsg(sSayMsg, c_Red, t_Hint);
      end else begin
        sSayMsg := AnsiReplaceText(g_sWoManLongOutDearOnlineMsg, '%d', m_sDearName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_DearHuman.SysMsg(sSayMsg, c_Red, t_Hint);
      end;
      m_DearHuman.m_DearHuman := nil;
      m_DearHuman := nil;
    end;
    if (m_MasterHuman <> nil) or (m_MasterList.Count > 0) then begin
      if m_boMaster then begin
        if m_MasterList.Count > 0 then begin//2008629
          for I := 0 to m_MasterList.Count - 1 do begin
            Human := TPlayObject(m_MasterList.Items[I]);
            sSayMsg := AnsiReplaceText(g_sMasterLongOutMasterListOnlineMsg, '%s', m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
            sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
            sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
            Human.SysMsg(sSayMsg, c_Red, t_Hint);
            Human.m_MasterHuman := nil;
          end;
        end;
      end else begin
        if m_MasterHuman = nil then Exit;
        sSayMsg := AnsiReplaceText(g_sMasterListLongOutMasterOnlineMsg, '%d', MoneyToCharacter(m_nMasterNo){m_sMasterName});//20080603
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_MasterHuman.SysMsg(sSayMsg, c_Red, t_Hint);

        //如果为大徒弟则将对方的记录清空
        if m_MasterHuman.m_sMasterName = m_sCharName then begin
          m_MasterHuman.m_MasterHuman := nil;
        end;

        for I := m_MasterHuman.m_MasterList.Count - 1 downto 0 do begin
          if m_MasterHuman.m_MasterList.Count <= 0 then Break;
          if m_MasterHuman.m_MasterList.Items[I] = Self then begin
            m_MasterHuman.m_MasterList.Delete(I);
            Break;
          end;
        end;//for
      end;
    end;
  except
    on E: Exception do begin
      MainOutMessage(sExceptionMsg);
      //MainOutMessage(E.Message);
    end;
  end;
  inherited;
end;
//取玩家数据
function TPlayObject.GetMyInfo: string;
var
  sMyInfo: string;
begin
  sMyInfo := g_sMyInfo;
  sMyInfo := AnsiReplaceText(sMyInfo, '%name', m_sCharName);
  sMyInfo := AnsiReplaceText(sMyInfo, '%map', m_PEnvir.sMapDesc);
  sMyInfo := AnsiReplaceText(sMyInfo, '%x', IntToStr(m_nCurrX));
  sMyInfo := AnsiReplaceText(sMyInfo, '%y', IntToStr(m_nCurrY));
  sMyInfo := AnsiReplaceText(sMyInfo, '%level', IntToStr(m_Abil.Level));
  sMyInfo := AnsiReplaceText(sMyInfo, '%gold', IntToStr(m_nGold));
  sMyInfo := AnsiReplaceText(sMyInfo, '%pk', IntToStr(m_nPkPoint));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minhp', IntToStr(m_WAbil.HP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxhp', IntToStr(m_WAbil.MaxHP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minmp', IntToStr(m_WAbil.MP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxmp', IntToStr(m_WAbil.MaxMP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%mindc', IntToStr(LoWord(m_WAbil.DC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxdc', IntToStr(HiWord(m_WAbil.DC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minmc', IntToStr(LoWord(m_WAbil.MC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxmc', IntToStr(HiWord(m_WAbil.MC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minsc', IntToStr(LoWord(m_WAbil.SC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxsc', IntToStr(HiWord(m_WAbil.SC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%logontime', DateTimeToStr(m_dLogonTime));
  sMyInfo := AnsiReplaceText(sMyInfo, '%logonlong', IntToStr((GetTickCount - m_dwLogonTick) div 60000));
  Result := sMyInfo;
end;
//检查物品是当前账号的捆绑物品
function TPlayObject.CheckItemBindUse(UserItem: pTUserItem): Boolean;
var
  I: Integer;
  ItemBind: pTItemBind;
begin
  Result := True;
  g_ItemBindAccount.Lock;
  try
    if g_ItemBindAccount.Count > 0 then begin//20080629
      for I := 0 to g_ItemBindAccount.Count - 1 do begin
        ItemBind := g_ItemBindAccount.Items[I];
        if ItemBind <> nil then begin
          if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
            (ItemBind.nItemIdx = UserItem.wIndex) then begin
            Result := False;
            if (CompareText(ItemBind.sBindName, m_sUserID) = 0) then begin
              Result := True;
            end else begin
              SysMsg(g_sItemIsNotThisAccount, c_Red, t_Hint);
            end;
            Exit;
          end;
        end;
      end;
    end;
  finally
    g_ItemBindAccount.UnLock;
  end;

  g_ItemBindIPaddr.Lock;
  try
    if g_ItemBindIPaddr.Count > 0 then begin//20080629
      for I := 0 to g_ItemBindIPaddr.Count - 1 do begin
        ItemBind := g_ItemBindIPaddr.Items[I];
        if ItemBind <> nil then begin
          if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
            (ItemBind.nItemIdx = UserItem.wIndex) then begin
            Result := False;
            if (CompareText(ItemBind.sBindName, m_sIPaddr) = 0) then begin
              Result := True;
            end else begin
              SysMsg(g_sItemIsNotThisIPaddr, c_Red, t_Hint);
            end;
            Exit;
          end;
        end;
      end;
    end;
  finally
    g_ItemBindIPaddr.UnLock;
  end;
  g_ItemBindCharName.Lock;
  try
    if g_ItemBindCharName.Count > 0 then begin//20080629
      for I := 0 to g_ItemBindCharName.Count - 1 do begin
        ItemBind := g_ItemBindCharName.Items[I];
        if ItemBind <> nil then begin
          if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
            (ItemBind.nItemIdx = UserItem.wIndex) then begin
            Result := False;
            if (CompareText(ItemBind.sBindName, m_sCharName) = 0) then begin
              Result := True;
            end else begin
              SysMsg(g_sItemIsNotThisCharName, c_Red, t_Hint);
            end;
            Exit;
          end;
        end;
      end;
    end;
  finally
    g_ItemBindCharName.UnLock;
  end;
end;

procedure TPlayObject.ProcessClientPassword(ProcessMsg: pTProcessMessage);
var
  nLen: Integer;
  sData: string;
begin
  if ProcessMsg.wParam = 0 then begin
    ProcessUserLineMsg('@' + g_GameCommand.UnLock.sCmd);
    Exit;
  end;
  sData := ProcessMsg.sMsg;
  nLen := Length(sData);
  if m_boSetStoragePwd then begin
    m_boSetStoragePwd := False;
    if (nLen > 3) and (nLen < 8) then begin
      m_sTempPwd := sData;
      m_boReConfigPwd := True;
      SysMsg(g_sReSetPasswordMsg, c_Green, t_Hint); {'请重复输入一次仓库密码：'}
      SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
    end else begin
      SysMsg(g_sPasswordOverLongMsg, c_Red, t_Hint); {'输入的密码长度不正确！！！，密码长度必须在 4 - 7 的范围内，请重新设置密码。'}
    end;
    Exit;
  end;
  if m_boReConfigPwd then begin
    m_boReConfigPwd := False;
    if CompareStr(m_sTempPwd, sData) = 0 then begin
      m_sStoragePwd := sData;
      m_boPasswordLocked := True;
      m_sTempPwd := '';
      SysMsg(g_sReSetPasswordOKMsg, c_Blue, t_Hint); {'密码设置成功！！，仓库已经自动上锁，请记好您的仓库密码，在取仓库时需要使用此密码开锁。'}
    end else begin
      m_sTempPwd := '';
      SysMsg(g_sReSetPasswordNotMatchMsg, c_Red, t_Hint);
    end;
    Exit;
  end;
  if m_boUnLockPwd or m_boUnLockStoragePwd then begin
    if CompareStr(m_sStoragePwd, sData) = 0 then begin
      m_boPasswordLocked := False;
      if m_boUnLockPwd then begin
        if g_Config.boLockDealAction then m_boCanDeal := True;
        if g_Config.boLockDropAction then m_boCanDrop := True;
        if g_Config.boLockWalkAction then m_boCanWalk := True;
        if g_Config.boLockRunAction then m_boCanRun := True;
        if g_Config.boLockHitAction then m_boCanHit := True;
        if g_Config.boLockSpellAction then m_boCanSpell := True;
        if g_Config.boLockCallHeroAction then m_boCallHero := True;//是否锁定召唤英雄操作  20080529
        if g_Config.boLockSendMsgAction then m_boCanSendMsg := True;
        if g_Config.boLockUserItemAction then m_boCanUseItem := True;
        if g_Config.boLockInObModeAction then begin
          m_boObMode := False;
          m_boAdminMode := False;
        end;
        m_boLockLogoned := True;
        SysMsg(g_sPasswordUnLockOKMsg, c_Blue, t_Hint);
      end;
      if m_boUnLockStoragePwd then begin
        if g_Config.boLockGetBackItemAction then m_boCanGetBackItem := True;
        SysMsg(g_sStorageUnLockOKMsg, c_Blue, t_Hint);
      end;

    end else begin
      Inc(m_btPwdFailCount);
      SysMsg(g_sUnLockPasswordFailMsg, c_Red, t_Hint);
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
      end;
    end;
    m_boUnLockPwd := False;
    m_boUnLockStoragePwd := False;
    Exit;
  end;

  if m_boCheckOldPwd then begin
    m_boCheckOldPwd := False;
    if m_sStoragePwd = sData then begin
      SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
      SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
      m_boSetStoragePwd := True;
    end else begin
      Inc(m_btPwdFailCount);
      SysMsg(g_sOldPasswordIncorrectMsg, c_Red, t_Hint);
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
      end;
    end;
    Exit;
  end;
end;
//人物死亡掉背包物品 20080120
procedure TPlayObject.ScatterBagItems(ItemOfCreat: TBaseObject);
var
  I, DropWide: Integer;
  pu: pTUserItem;
  DelList: TStringList;
  boDropall: Boolean;
  sCheckItemName: string;
  StdItem: pTStdItem;
resourcestring
  sExceptionMsg = '{异常} TPlayObject::ScatterBagItems';
begin
  m_boCanQueryBag:= True;//死亡掉背包时,不能刷新包裹 20080917
  Try
    DelList := nil;
    if m_boAngryRing or m_boNoDropItem then Exit; //不死戒指
    if m_PEnvir.m_boNODROPITEM then Exit;//地图禁止死亡掉物品则退出 20080503
    boDropall := False;
    DropWide := 2;
    if g_Config.boDieRedScatterBagAll and (PKLevel >= 2) then begin
      boDropall := True;
    end;
    //非红名掉1/3 //红名全掉
    try
      for I := m_ItemList.Count - 1 downto 0 do begin
        if m_ItemList.Count <= 0 then Break;
        if boDropall or (Random(g_Config.nDieScatterBagRate) = 0) then begin
          if m_ItemList[I] <> nil then begin
            pu := pTUserItem(m_ItemList[I]);
            sCheckItemName:=UserEngine.GetStdItemName(pu.wIndex);
            if PlugOfCheckCanItem(6, sCheckItemName, False, 0, 0) then Continue;//禁止物品规则(永不爆出) 20080729
            if CheckItemBindDieNoDrop(m_ItemList[I]) then Continue;//人物装备绑定死亡不爆 20081127

            StdItem := UserEngine.GetStdItem(pu.wIndex);
            if StdItem <> nil then begin
              if (StdItem.StdMode = 51) and (StdItem.Shape = 0) and (pu.Dura > 0) and (pu.btValue[20]= 1) then begin//是聚灵珠 20080611
                n_UsesItemTick:= 0;//时间初始
                pu.btValue[12]:= 2;//不能聚集的标识
              end;
            end;
            if DropItemDown(pTUserItem(m_ItemList[I]), DropWide, True, True, ItemOfCreat, Self) then begin
              if m_btRaceServer = RC_PLAYOBJECT then begin
                if DelList = nil then DelList := TStringList.Create;
                DelList.AddObject(UserEngine.GetStdItemName(pu.wIndex), TObject(pu.MakeIndex));
              end;
              Dispose(pTUserItem(m_ItemList[I])); //修改
              m_ItemList.Delete(I);
            end;
          end;
        end;
      end;//for
      if DelList <> nil then begin
        SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  finally
    m_boCanQueryBag:= False;//死亡掉背包时,不能刷新包裹 20080917
  end;
end;

procedure TPlayObject.RecallHuman(sHumName: string);
var
  PlayObject: TPlayObject;
  nX, nY, n18, n1C: Integer;
begin
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    if GetFrontPosition(nX, nY) then begin
      if sub_4C5370(nX, nY, 3, n18, n1C) then begin
        PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        PlayObject.SpaceMove(m_sMapName, n18, n1C, 0);
      end;
    end else begin
      SysMsg('召唤失败！！！', c_Red, t_Hint);
    end;
  end else begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;
//申请行会战
procedure TPlayObject.ReQuestGuildWar(sGuildName: string);
var
  Guild: TGUild;
  WarGuild: pTWarGuild;
  boReQuestOK: Boolean;
begin
  if not IsGuildMaster then begin
    SysMsg('只有行会掌门人才能申请！！！', c_Red, t_Hint);
    Exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg('这个命令不能在本服务器上使用！！！', c_Red, t_Hint);
    Exit;
  end;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild = nil then begin
    SysMsg('行会不存在！！！', c_Red, t_Hint);
    Exit;
  end;
  boReQuestOK := False;
  WarGuild := TGUild(m_MyGuild).AddWarGuild(Guild);
  if WarGuild <> nil then begin
    if Guild.AddWarGuild(TGUild(m_MyGuild)) = nil then begin
      WarGuild.dwWarTick := 0;
    end else begin
      boReQuestOK := True;
    end;
  end;
  if boReQuestOK then begin
    UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);
    UserEngine.SendServerGroupMsg(SS_207, nServerIndex, Guild.sGuildName);
  end;
end;

function TPlayObject.CheckDenyLogon(): Boolean;
begin
  Result := False;
  if GetDenyIPaddrList(m_sIPaddr) then begin
    SysMsg(g_sYourIPaddrDenyLogon, c_Red, t_Hint);
    Result := True;
  end else
    if GetDenyAccountList(m_sUserID) then begin
    SysMsg(g_sYourAccountDenyLogon, c_Red, t_Hint);
    Result := True;
  end else
    if GetDenyChrNameList(m_sCharName) then begin
    SysMsg(g_sYourCharNameDenyLogon, c_Red, t_Hint);
    Result := True;
  end;
  if Result then begin
    m_boEmergencyClose := True;
    m_boPlayOffLine := False;
  end;
end;

function TPlayObject.IsGotoLabel(sMapName: string; nX, nY, nRange, nQuestFalgStatus: Integer; boQuestFalgStatus: Boolean; sItemName1, sItemName2: string; boNeedGroup: Boolean; nRandomCount: Integer): Boolean;
var
  n01: Integer;
  nMaxCurrX, nMaxCurrY, nMinCurrX, nMinCurrY: Integer;
  function GetAllowItem: Boolean;
  begin
    Result := False;
    if sItemName1 = '*' then begin
      Result := True;
    end else
      if CompareText(sItemName1, sItemName2) = 0 then begin
      Result := True;
    end;
  end;
  function GetRandomCount: Boolean;
  begin
    Result := False;
    if nRandomCount = 0 then Result := True
    else if (nRandomCount > 0) and (Random(nRandomCount div 2 + nRandomCount) = nRandomCount) then Result := True;
  end;
  function GetGroup: Boolean;
  begin
    Result := False;
    if not boNeedGroup then Result := True
    else if m_GroupOwner <> nil then Result := True;
  end;
begin
  Result := False;
  nMaxCurrX := nX + nRange;
  nMaxCurrY := nY + nRange;
  nMinCurrX := nX - nRange;
  nMinCurrY := nY - nRange;
  if (CompareText(sMapName, m_sMapName) = 0) and (m_nCurrX <= nMaxCurrX) and (m_nCurrX >= nMinCurrX) and (m_nCurrY <= nMaxCurrY) and (m_nCurrY >= nMinCurrY) then begin
    if nQuestFalgStatus > 0 then begin
      n01 := GetQuestFalgStatus(nQuestFalgStatus);
      if (n01 = 0) and (not boQuestFalgStatus) then begin
        if GetAllowItem and GetGroup and GetRandomCount then begin
          Result := True;
        end;
      end else
        if (n01 <> 0) and (boQuestFalgStatus) then begin
        if GetAllowItem and GetGroup and GetRandomCount then begin
          Result := True;
        end;
      end;
    end else begin
      if GetAllowItem and GetGroup and GetRandomCount then begin
        Result := True;
      end;
    end;
  end;
end;

procedure TPlayObject.StartMapEventOfDropItem(sItemName: string);
var
  I: Integer;
  boGotoLabel: Boolean;
  MapEvent: pTMapEvent;
  nCode: Byte;
begin
  try
    nCode:= 0;
    {g_MapEventListOfDropItem.Lock;
    try }
    MapEvent:= nil;//20080529
    boGotoLabel := False;
    if g_MapEventListOfDropItem.Count > 0 then begin//20080629
      nCode:= 1;
      for I := 0 to g_MapEventListOfDropItem.Count - 1 do begin
        nCode:= 2;
        MapEvent := pTMapEvent(g_MapEventListOfDropItem.Items[I]);
        nCode:= 3;
        if MapEvent <> nil then begin
          nCode:= 4;
          if IsGotoLabel(MapEvent.m_sMapName,
            MapEvent.m_nCurrX,
            MapEvent.m_nCurrY,
            MapEvent.m_nRange,
            MapEvent.m_MapFlag.nQuestUnit,
            MapEvent.m_MapFlag.boOpen,
            MapEvent.m_Condition.sItemName,
            sItemName,
            MapEvent.m_Condition.boNeedGroup, MapEvent.m_nRandomCount) then begin
            boGotoLabel := True;
            Break;
          end;
        end;
      end;
    end;
    if boGotoLabel and (MapEvent <> nil) then begin
      case MapEvent.m_StartScript.nLable of
        0: ;
        1: begin
            if g_FunctionNPC <> nil then begin
              nCode:= 5;
              g_FunctionNPC.GotoLable(Self, MapEvent.m_StartScript.sLable, False);
            end;
          end;
      end;
    end;
    {finally
      g_MapEventListOfDropItem.UnLock;
    end; }
  except
    MainOutMessage('{异常} TPlayObject.StartMapEventOfDropItem Code:'+inttostr(nCode));
  end;
end;

procedure TPlayObject.StartMapEventOfPickUpItem(sItemName: string);
var
  I: Integer;
  boGotoLabel: Boolean;
  MapEvent: pTMapEvent;
  nCode: Byte;
begin
  try
    nCode:= 0;
    {g_MapEventListOfPickUpItem.Lock;
    try}
    MapEvent:= nil;//20080529
    boGotoLabel := False;
    nCode:= 1;
    if g_MapEventListOfPickUpItem.Count > 0 then begin//20080629
      nCode:= 2;
      for I := 0 to g_MapEventListOfPickUpItem.Count - 1 do begin
        nCode:= 3;
        MapEvent := pTMapEvent(g_MapEventListOfPickUpItem.Items[I]);
        nCode:= 4;
        if MapEvent <> nil then begin
          nCode:= 5;
          if IsGotoLabel(MapEvent.m_sMapName,
            MapEvent.m_nCurrX,
            MapEvent.m_nCurrY,
            MapEvent.m_nRange,
            MapEvent.m_MapFlag.nQuestUnit,
            MapEvent.m_MapFlag.boOpen,
            MapEvent.m_Condition.sItemName,
            sItemName,
            MapEvent.m_Condition.boNeedGroup, MapEvent.m_nRandomCount) then begin
            boGotoLabel := True;
            Break;
          end;
        end;
      end;
    end;
    if boGotoLabel and (MapEvent <> nil) then begin
      case MapEvent.m_StartScript.nLable of
        0: ;
        1: begin
            if g_FunctionNPC <> nil then begin
              nCode:= 6;
              g_FunctionNPC.GotoLable(Self, MapEvent.m_StartScript.sLable, False);
            end;
          end;
      end;
    end;
   { finally
      g_MapEventListOfPickUpItem.UnLock;
    end;}
  except
    MainOutMessage('{异常} TPlayObject.StartMapEventOfPickUpItem Code:'+inttostr(nCode));
  end;
end;

procedure TPlayObject.StartMapEventOfMine();
var
  I: Integer;
  boGotoLabel: Boolean;
  MapEvent: pTMapEvent;
  nCode: Byte;
begin
  try
    nCode:= 0;
   { g_MapEventListOfMine.Lock;
    try}
    MapEvent:= nil;//20080529
    boGotoLabel := False;
    nCode:= 1;
    if g_MapEventListOfMine.Count > 0 then begin//20080629
      nCode:= 2;
      for I := 0 to g_MapEventListOfMine.Count - 1 do begin
        nCode:= 3;
        MapEvent := pTMapEvent(g_MapEventListOfMine.Items[I]);
        nCode:= 4;
        if MapEvent <> nil then begin
          nCode:= 5;
          if IsGotoLabel(MapEvent.m_sMapName,
            MapEvent.m_nCurrX,
            MapEvent.m_nCurrY,
            MapEvent.m_nRange,
            MapEvent.m_MapFlag.nQuestUnit,
            MapEvent.m_MapFlag.boOpen,
            MapEvent.m_Condition.sItemName,
            '*',
            MapEvent.m_Condition.boNeedGroup, MapEvent.m_nRandomCount) then begin
            boGotoLabel := True;
            Break;
          end;
        end;
      end;
    end;
    if boGotoLabel and (MapEvent <> nil) then begin
      case MapEvent.m_StartScript.nLable of
        0: ;
        1: begin
            if g_FunctionNPC <> nil then begin
              nCode:= 6;
              g_FunctionNPC.GotoLable(Self, MapEvent.m_StartScript.sLable, False);
            end;
          end;
      end;
    end;
    {finally
      g_MapEventListOfMine.UnLock;
    end;}
  except
    MainOutMessage('{异常} TPlayObject.StartMapEventOfMine Code:'+inttostr(nCode));
  end;
end;

procedure TPlayObject.StartMapEventOfWalk();
var
  I: Integer;
  boGotoLabel: Boolean;
  MapEvent: pTMapEvent;
  nCode: Byte;
begin
  try
    nCode:= 0;
    {g_MapEventListOfWalk.Lock;
    try}
    MapEvent:= nil;//20080529
    boGotoLabel := False;
    nCode:= 1;
    if g_MapEventListOfWalk.Count > 0 then begin//20081223
      nCode:= 2;
      for I := 0 to g_MapEventListOfWalk.Count - 1 do begin
        nCode:= 3;
        MapEvent := pTMapEvent(g_MapEventListOfWalk.Items[I]);
        nCode:= 4;
        if MapEvent <> nil then begin
          nCode:= 5;
          if IsGotoLabel(MapEvent.m_sMapName,
            MapEvent.m_nCurrX,
            MapEvent.m_nCurrY,
            MapEvent.m_nRange,
            MapEvent.m_MapFlag.nQuestUnit,
            MapEvent.m_MapFlag.boOpen,
            MapEvent.m_Condition.sItemName,
            '*',
            MapEvent.m_Condition.boNeedGroup, MapEvent.m_nRandomCount) then begin
            boGotoLabel := True;
            Break;
          end;
        end;
      end;
    end;
    if boGotoLabel and (MapEvent <> nil) then begin
      case MapEvent.m_StartScript.nLable of
        0: ;
        1: begin
            if g_FunctionNPC <> nil then begin
              nCode:= 6; 
              g_FunctionNPC.GotoLable(Self, MapEvent.m_StartScript.sLable, False);
            end;
          end;
      end;
    end;
    {finally
      g_MapEventListOfWalk.UnLock;
    end;}
  except
    MainOutMessage('{异常} TPlayObject.StartMapEventOfWalk nCode:'+inttostr(nCode));
  end;
end;

procedure TPlayObject.StartMapEventOfRun();
var
  I: Integer;
  boGotoLabel: Boolean;
  MapEvent: pTMapEvent;
  nCode: Byte;
begin
  try
    nCode:= 0;
   { g_MapEventListOfRun.Lock;
    try}
    MapEvent:= nil;//20080529
    boGotoLabel := False;
    nCode:= 1;
    if g_MapEventListOfRun.Count > 0 then begin//20080629
      nCode:= 2;
      for I := 0 to g_MapEventListOfRun.Count - 1 do begin
        nCode:= 3;
        MapEvent := pTMapEvent(g_MapEventListOfRun.Items[I]);
        nCode:= 4;
        if MapEvent <> nil then begin
          nCode:= 5;
          if IsGotoLabel(MapEvent.m_sMapName,
            MapEvent.m_nCurrX,
            MapEvent.m_nCurrY,
            MapEvent.m_nRange,
            MapEvent.m_MapFlag.nQuestUnit,
            MapEvent.m_MapFlag.boOpen,
            MapEvent.m_Condition.sItemName,
            '*',
            MapEvent.m_Condition.boNeedGroup, MapEvent.m_nRandomCount) then begin
            boGotoLabel := True;
            Break;
          end;
        end;
      end;
    end;
    if boGotoLabel and (MapEvent <> nil) then begin
      case MapEvent.m_StartScript.nLable of
        0: ;
        1: begin
            if g_FunctionNPC <> nil then begin
              nCode:= 6;
              g_FunctionNPC.GotoLable(Self, MapEvent.m_StartScript.sLable, False);
            end;
          end;
      end;
    end;
    {finally
      g_MapEventListOfRun.UnLock;
    end;}
  except
    MainOutMessage('{异常} TPlayObject.StartMapEventOfRun Code:'+inttostr(nCode));
  end;
end;

procedure TPlayObject.ProcessUserCmd(sParam1, sParam2, sParam3, sParam4,
  sParam5, sParam6, sParam7: string);
begin
  SysMsg(sParam2, c_Green, t_Hint);
end;

function TPlayObject.WearDragon: Boolean;
var
  StdItem: pTStdItem;
begin
// 20080102修改成下面那段,以支持祝福罐.魔令包功
  Result := False;
  if m_UseItems[U_BUJUK].wIndex > 0 then begin
    StdItem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);              //20080704 去掉除泉水罐外
    if (StdItem <> nil) and (StdItem.StdMode = 2) and (StdItem.AniCount= 21) {and (StdItem.Reserved <> 56)} then begin //20080622 修改 StdItem.Shape=3  StdItem.Reserved=56为泉水罐
       Result := True;//祝福罐.魔令包
    end;
  end;
end;
//支持祝福罐.魔令包功能 20080102  btType:2--主人  4--英雄
procedure TPlayObject.RepairDragon(btType: Byte; nItemIdx: Integer; sItemName: string);
var
  I, n14: Integer;
  UserItem: pTUserItem;
  StdItem, StdItem1: pTStdItem;//20080313
  sUserItemName: string;
  boRepairOK: Boolean;
  ItemList: TList;
  OldDura: Word;
begin
  boRepairOK := False;
  ItemList := nil;
  StdItem := nil;
  StdItem1 := nil;
  UserItem := nil;
  OldDura:= 0;
  n14 := -1;
  if {(m_Master <> nil) and }WearDragon then begin
    if m_UseItems[U_BUJUK].Dura < m_UseItems[U_BUJUK].DuraMax then begin
      OldDura := m_UseItems[U_BUJUK].Dura;
      case btType of
        2: ItemList := m_Master.m_ItemList;
        4: ItemList := m_ItemList;
      end;
      if ItemList <> nil then begin
        if ItemList.Count > 0 then begin//20080629
          for I := 0 to ItemList.Count - 1 do begin
            UserItem := ItemList.Items[I];
            if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
              //取自定义物品名称
              sUserItemName := '';
              if UserItem.btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              if sUserItemName = '' then
                sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if CompareText(sUserItemName, sItemName) = 0 then begin
                  n14 := I;
                  StdItem1:= UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex); //20080313
                  Break;
                end;
              end;
            end;
            UserItem := nil;
          end;//for
        end;

                                                                     {存的物品的外观要对罐的Source属性,罐物品的Shape=放入物品的StdMode ,衣服武器不能存 20080315}
        if (StdItem <> nil) and (UserItem <> nil) and (StdItem.Shape = StdItem1.Source) and (StdItem.StdMode  = StdItem1.Shape) and (not (StdItem.StdMode in [5,6,10,11])) then begin
          Inc(m_UseItems[U_BUJUK].Dura, {UserItem.DuraMax*1000}1000);
          if m_UseItems[U_BUJUK].Dura > m_UseItems[U_BUJUK].DuraMax then m_UseItems[U_BUJUK].Dura:=m_UseItems[U_BUJUK].DuraMax;
          boRepairOK := True;
          case btType of
            2: m_Master.DelBagItem(n14);
            4: DelBagItem(n14);
          end;
        end;
      end;
    end;
  end;
  if boRepairOK then begin
    if OldDura <> m_UseItems[U_BUJUK].Dura then
      SendMsg(Self, RM_DURACHANGE, U_BUJUK, m_UseItems[U_BUJUK].Dura, m_UseItems[U_BUJUK].DuraMax, 0, '');
      SendDefMessage(SM_REPAIRDRAGON_OK, btType, 0, 0, 0, '');
  end else begin
    SendDefMessage(SM_REPAIRDRAGON_FAIL, btType, 0, 0, 0, '');
  end;
end;

//-----------------------------------宝箱系统-----------------------------------
//判断宝箱和钥匙是否对应,20080305
procedure TPlayObject.ClientSendBoxItem(BoxsIdx: Integer; str:string{str为客户端传来的钥匙makeidx20080306});
var
  I : Integer;
  UserItem: pTUserItem;
  StdItemBox,StdItemKey: pTStdItem;
  KeysIdx: Integer;
begin
  StdItemBox:= nil ;
  StdItemKey:= nil;
  KeysIdx := StrToInt(trim(str));
 // if m_boCanUseItem then begin//宝箱随机可以打开,不用控制 20080429
    if not m_boDeath then begin
      if IsEnoughBag then begin //包裹不满时
      if m_ItemList.Count > 0 then begin//20080629
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          if UserItem = nil then Continue;
          if (UserItem <> nil) and (UserItem.MakeIndex = BoxsIdx) then begin //得到宝箱
            StdItemBox := UserEngine.GetStdItem(UserItem.wIndex);
            if (StdItemBox <> nil) and (StdItemBox.StdMode = 48) then  Break;
          end;
        end;//for

        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          if UserItem = nil then Continue;
          if (UserItem <> nil) and (UserItem.MakeIndex = KeysIdx) then begin //得到钥匙
            StdItemKey := UserEngine.GetStdItem(UserItem.wIndex);
            if (StdItemKey <> nil) and (StdItemKey.StdMode = 49 ) then  Break;
          end;
        end;//for
      end;

      if (StdItemBox<> nil) and  (StdItemKey <> nil) and (StdItemBox.AniCount = StdItemKey.Shape) then begin //宝箱和钥匙对应,则打开宝箱,删除物品
        if ClientOpenBoxs(StdItemBox.Source) then begin//宝箱开启 20080618
          for I := m_ItemList.Count - 1 downto 0 do begin //删除物品  20080308
            if m_ItemList.Count <= 0 then Break;
            UserItem := m_ItemList.Items[I];
            if UserItem = nil then Continue;
            if (UserItem <> nil) then begin
              if (UserItem.MakeIndex = BoxsIdx) then begin
                if StdItemBox.NeedIdentify = 1 then
                  AddGameDataLog('11' + #9 + m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + StdItemBox.Name + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +'(开宝箱)'+ #9 +'0');
                m_ItemList.Delete(I);
              end else
              if (UserItem.MakeIndex = KeysIdx) then begin
                if StdItemKey.NeedIdentify = 1 then
                  AddGameDataLog('11' + #9 + m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + StdItemKey.Name + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +'(开宝箱)'+ #9 +'0');
                m_ItemList.Delete(I);
              end;
            end;//if (UserItem <> nil) then begin
          end;
          //SendMsg(SM_OPENBOXS_OK, 0, 0, 0, 0, '');    //成功 20080306   不用返回
        end else  begin
          SendMsg(Self, RM_OPENBOXS_FAIL, 0, 0, 0, 0, '');  //失败 20080306
          SysMsg('开启宝箱失败!', c_Red, t_Hint);//20080415
        end;
      end else begin
      //发送打开失败消息
        SendMsg(Self, RM_OPENBOXS_FAIL, 0, 0, 0, 0, '');  //失败 20080306
        SysMsg('您的宝箱和钥匙不对应,不能打开宝箱!', c_Red, t_Hint);
      end;
     end else begin //if IsEnoughBag then begin //包裹不满时
       SendMsg(Self, RM_OPENBOXS_FAIL, 0, 0, 0, 0, '');  //失败 20080306
       SysMsg('您的包裹已满,不能开启宝箱!', c_Red, t_Hint);
     end;
    end;//if not m_boDeath
  //end;//if m_boCanUseItem then begin
end;

//宝箱开启,随机取出9件物品 20080115
Function TPlayObject.ClientOpenBoxs(SBoxsID{宝箱类型,即Source}:Integer):Boolean;
var
  vList1,vList2,vList3,vList4:TList;
  I,T:Integer;
  BoxsInfo:TBoxsInfo;
  BoxsInfo1:pTBoxsInfo;
  sSendStr:string;
begin
  Result:= False;
  sSendStr:='';
  if BoxsList = nil then Exit;
  if m_boOpenBox then Exit;//如果有宝箱正在操作,则退出,一次只能开一个宝箱 20080407

  n_OpenBox:=0;
  n_IncUsesGameGold:=0;
  n_IncUsesGold:=0;
  n_BoxsItmeID:= 0;//初始化给人物物品的ID

  Randomize;//播下随机种子
  vList1:=TList.Create;
  vList2:=TList.Create;
  vList3:=TList.Create;
  vList4:=TList.Create;
  try
    if BoxsList.Count > 0 then begin//20080629
      for T := 0 to BoxsList.Count - 1 do begin
        BoxsInfo1 := pTBoxsInfo(BoxsList.Items[T]);
        if BoxsInfo1.SBoxsID <> SBoxsID then  Continue; //如果不是Source对应的txt文件则跳过
        case BoxsInfo1.nItemType of
          0: vList3.Add(BoxsInfo1); //物品类型 0 的写入vList3
          1: vList2.Add(BoxsInfo1); //物品类型 1 的写入vList2
          2: vList1.Add(BoxsInfo1); //物品类型 2 的写入vList1
          3: vList4.Add(BoxsInfo1); //物品类型 3 的写入vList4
        end;
      end;
    end;
    {要求,类型为2的要有最少1件,1的最少要有2件,0的最少要有4件,3的最少要2件,    分开取,使显示的位置不同 20080606}
    if (vList1.Count > 0) and (vList2.Count > 1) and (vList3.Count > 4) and (vList4.Count > 1) then begin
      m_Boxs.Clear;
      case Random(2) of
        0:begin//第一种显示方式
            I:= Random(vList3.Count); //物品类型为0的1条记录
            BoxsInfo1:= pTBoxsInfo(vList3.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList3.Delete(I);   //抽取完后从临时列表中删除数据

            I:= Random(vList2.Count); //物品类型为1
            BoxsInfo1:= pTBoxsInfo(vList2.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList2.Delete(I);   //抽取完后从临时列表中删除数据

            I:= Random(vList3.Count); //物品类型为0的1条记录
            BoxsInfo1:= pTBoxsInfo(vList3.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList3.Delete(I);   //抽取完后从临时列表中删除数据

            I:= Random(vList4.Count); //物品类型为3
            BoxsInfo1:= pTBoxsInfo(vList4.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList4.Delete(I);   //抽取完后从临时列表中删除数据

            I:= Random(vList3.Count); //物品类型为0的1条记录
            BoxsInfo1:= pTBoxsInfo(vList3.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList3.Delete(I);   //抽取完后从临时列表中删除数据

            I:= Random(vList2.Count); //物品类型为1
            BoxsInfo1:= pTBoxsInfo(vList2.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList2.Delete(I);   //抽取完后从临时列表中删除数据

            I:= Random(vList3.Count); //物品类型为0的1条记录
            BoxsInfo1:= pTBoxsInfo(vList3.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList3.Delete(I);   //抽取完后从临时列表中删除数据            

            I:= Random(vList4.Count); //物品类型为3
            BoxsInfo1:= pTBoxsInfo(vList4.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList4.Delete(I);   //抽取完后从临时列表中删除数据
        end;//0
        1:begin//第二种显示方式
            I:= Random(vList2.Count); //物品类型为1
            BoxsInfo1:= pTBoxsInfo(vList2.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList2.Delete(I);   //抽取完后从临时列表中删除数据

            I:= Random(vList3.Count); //物品类型为0的1条记录
            BoxsInfo1:= pTBoxsInfo(vList3.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList3.Delete(I);   //抽取完后从临时列表中删除数据

            I:= Random(vList4.Count); //物品类型为3
            BoxsInfo1:= pTBoxsInfo(vList4.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList4.Delete(I);   //抽取完后从临时列表中删除数据

            I:= Random(vList3.Count); //物品类型为0的1条记录
            BoxsInfo1:= pTBoxsInfo(vList3.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList3.Delete(I);   //抽取完后从临时列表中删除数据

            I:= Random(vList2.Count); //物品类型为1
            BoxsInfo1:= pTBoxsInfo(vList2.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList2.Delete(I);   //抽取完后从临时列表中删除数据

            I:= Random(vList3.Count); //物品类型为0的1条记录
            BoxsInfo1:= pTBoxsInfo(vList3.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList3.Delete(I);   //抽取完后从临时列表中删除数据            

            I:= Random(vList4.Count); //物品类型为3
            BoxsInfo1:= pTBoxsInfo(vList4.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList4.Delete(I);   //抽取完后从临时列表中删除数据

            I:= Random(vList3.Count); //物品类型为0的1条记录
            BoxsInfo1:= pTBoxsInfo(vList3.Items[I]);
            BoxsInfo := BoxsInfo1^;
            m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
            vList3.Delete(I);   //抽取完后从临时列表中删除数据
        end;//1
      end;

      I:= Random(vList1.Count); //取出一条物品类型为2的数据
      BoxsInfo1:= pTBoxsInfo(vList1.Items[I]);
      BoxsInfo:= BoxsInfo1^;
      n_BoxsItmeID:= BoxsInfo.StdItem.MakeIndex;//20080118  得到中间物品的ID
      sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo))+'/';
      m_Boxs.Add(BoxsInfo1); //保存随机取出的宝箱物品 20080116
   end;
  finally
   vList1.Free;
   vList2.Free;
   vList3.Free;
  end;
  if sSendStr <> '' then  begin
    SendMsg(Self, RM_OPENBOXS, 0, 0, 0, 0, sSendStr);
    m_boOpenBox:= True;//宝箱正在打开中 20080407
    Result:= True;
  end;   
end;

//转动宝箱,随机给客户端一件物品,并减少一定的金币或元宝 20080116
procedure TPlayObject.ClientGetBoxs();
  Function GetItemID(BoxS: TList;ItemType: Integer):Integer;
   Var pBoxsInfo: pTBoxsInfo;
       I,T:Integer;
       sTemp: TList;
  begin
    Result:=0;
    Randomize;//播下随机种子
    sTemp:= TList.Create;
    if Boxs.Count > 0 then begin
      for I:=0 to Boxs.Count-1 do begin
        pBoxsInfo := pTBoxsInfo(Boxs.Items[I]);
        if pBoxsInfo.nItemType <> ItemType then Continue;
        sTemp.Add(pBoxsInfo);
      end;
    end;
    if sTemp.Count > 0 then begin
      for I:= 0 to sTemp.Count -1 do begin
        T:= Random(sTemp.Count);
        pBoxsInfo := pTBoxsInfo(sTemp.Items[T]);
        Result:= pBoxsInfo.StdItem.MakeIndex;
        if Result <> 0 then Break;
      end;
    end;
    sTemp.Free;
  end;
var
  I :Integer;
  BoxsInfo1: pTBoxsInfo;
  UsesGold,UsesGameGold:Integer;
  OpenBox_OK:Boolean;//打开宝箱是否成功
begin
  OpenBox_OK:= False;
  UsesGold:= 0;
  UsesGameGold := 0;
  Try
    if (m_Boxs = nil) or (m_Boxs.Count = 0)  then Exit;
    n_BoxsItmeID:= 0;
    Inc(n_OpenBox);//开宝箱记数 20080116
    Randomize;//播下随机种子
    I:= Random(m_Boxs.Count);
    BoxsInfo1 := pTBoxsInfo(m_Boxs.Items[I]);
    if n_OpenBox=1 then begin //免费转动一次
     UsesGold:= BoxsInfo1.nGold;//转动所需的金币数
     UsesGameGold:= BoxsInfo1.nGameGold;//转动所需的元宝数
     n_BoxsItmeID:=GetItemID(m_Boxs,0);
     OpenBox_OK:= True;
    end else begin //收费转动
     if not (n_OpenBox > BoxsInfo1.nUses) then begin //没有超过最大使用次数
       UsesGold:= (BoxsInfo1.nGold+BoxsInfo1.nIncGold*(n_OpenBox - 2));//转动所需的金币数   [起始值+累计值*(次数-2)]
       UsesGameGold:= BoxsInfo1.nGameGold+BoxsInfo1.nIncGameGold*(n_OpenBox - 2);//转动所需的元宝数
       if (m_nGold >= UsesGold) and (m_nGameGold >= UsesGameGold) then begin
          Dec(m_nGold,UsesGold);
          Dec(m_nGameGold,UsesGameGold);
          Inc(n_IncUsesGold,UsesGold);
          Inc(n_IncUsesGameGold,UsesGameGold);
          GoldChanged(); //更新客户端金币
          GameGoldChanged(); //更新客户端元宝
          OpenBox_OK:= True;
          //物消费总值大于或等于有效金币数和元宝数,则给玩家 不可得的物品
          if (n_IncUsesGold >= BoxsInfo1.nEffectiveGold) and (n_IncUsesGameGold >= BoxsInfo1.nEffectiveGameGold) then begin
            n_BoxsItmeID:=GetItemID(m_Boxs,1);
          end else begin
            n_BoxsItmeID:=GetItemID(m_Boxs,0);
          end;
        end else begin //人物的金币或元宝数不足
         SysMsg('您的金币或元宝数不足,不能再转动宝箱!', c_Red, t_Hint);
        end;
      end else begin//超过最大使用次数
        SysMsg('宝箱已无法再使用!', c_Red, t_Hint);
      end;
    end;
    if OpenBox_OK  then begin//发消息给客户端
     if n_OpenBox=1 then
       SendMsg(Self, RM_MOVEBOXS, 0, n_BoxsItmeID, UsesGold, UsesGameGold, '')
     else
       SendMsg(Self, RM_MOVEBOXS, 0, n_BoxsItmeID, (BoxsInfo1.nGold+BoxsInfo1.nIncGold*(n_OpenBox - 1)), (BoxsInfo1.nGameGold+BoxsInfo1.nIncGameGold*(n_OpenBox - 1)), '');
    end;
  except
    on E: Exception do begin
      MainOutMessage('{异常} TPlayObject::ClientGetBoxs');
    end;
  end;
end;

//宝箱给玩家物品 20080117
procedure TPlayObject.ClientGetBoxsItme();
var
  I,ItemNum: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  BoxsInfo:TBoxsInfo;
  ItemName: string;
  sCheckItemName,szString: string;
begin
  if not m_boOpenBox then Exit;//20080924
  Try
    m_boOpenBox:= False;//20080407
    ItemNum:= 0;
    if n_BoxsItmeID <> 0 then begin
     //if IsEnoughBag then begin //包裹不满时
      if BoxsList.Count > 0 then begin//20080629
        for I := 0 to BoxsList.Count - 1 do begin
          BoxsInfo := pTBoxsInfo(BoxsList.Items[I])^;
          if BoxsInfo.StdItem.MakeIndex = n_BoxsItmeID then begin
           ItemName:= BoxsInfo.StdItem.s.Name; //物品名称
           ItemNum:= BoxsInfo.nItemNum;//物品数量
          end;
          if ItemName <> '' then break;
        end;
      end;

      StdItem := UserEngine.GetStdItem(ItemName);
      if (StdItem <> nil) then begin
        if ItemNum <= 0 then ItemNum:=1;//20080629
        for I := 0 to ItemNum - 1 do begin //支持物品的多数量获取 20080221
          New(UserItem);
          if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem) then begin
            UserItem.Dura:=BoxsInfo.StdItem.Dura;//20080328
            if IsEnoughBag and IsAddWeightAvailable(StdItem.Weight) then begin//包裹有位置则放到包裹里,没有则扔出物品 20080616
              m_ItemList.Add(UserItem);
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('40' + #9 + m_sMapName+ #9 +
                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 + StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                  '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                  '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                  '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                  '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                  IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                  IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                  IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                  IntToStr(UserItem.btValue[14])+ #9 + '0');

              if m_btRaceServer = RC_PLAYOBJECT then begin
                SendAddItem(UserItem);
                SendUpdateItem(UserItem);//更新物品
                sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                PlugOfCheckCanItem(5, sCheckItemName, False, 0, 0);//禁止物品规则(管理插件功能) 20080729
              end;
            end else begin//扔出物品
              DropItemDown(UserItem, 3, False, False, self, self);//20080616
            end;
          end else begin
            Dispose(UserItem);
            Break;
          end;
        end;
        //UserEngine.SendBroadCastMsgExt('系统：恭喜玩家 '+m_sCharName+' 开启宝箱获得'+inttostr(ItemNum)+'件【'+StdItem.Name+'】', t_Say);//向每个人物发送消息
      end else begin //不是数据库里的物品
        if CompareText(Trim(ItemName), '经验')= 0  then begin
          GetExpToItem(ItemNum);//取得的经验,累积到聚灵珠 20080817
          if m_MyHero <> nil then begin
            THeroObject(m_MyHero).GetExp(abs(Round((g_Config.nHeroNoKillMonExpRate / 100) * ItemNum)));//20081018 修改
            ItemNum:= abs(Round(((100 - g_Config.nHeroNoKillMonExpRate) / 100) * ItemNum));//20081018 修改
          end;
          Inc(m_Abil.Exp, ItemNum);
          SendMsg(self, RM_WINEXP, 0, ItemNum, 0, 0, '');
        end else
        if CompareText(Trim(ItemName), '声望')= 0 then begin
          Inc(m_btCreditPoint,ItemNum);
          szString := AnsiReplaceText(g_sBoxsItemHintMsg, '%name', m_sCharName); //20080617
          szString := AnsiReplaceText(szString, '%s', '声望  '+IntToStr(ItemNum));//20080617
          UserEngine.SendBroadCastMsgExt(szString, t_Say);//向每个人物发送消息
        end else
        if CompareText(Trim(ItemName), g_Config.sGameDiaMond)= 0 then begin
          Inc(m_nGAMEDIAMOND ,ItemNum);
          GameGoldChanged;//更新金刚石数量
          szString := AnsiReplaceText(g_sBoxsItemHintMsg, '%name', m_sCharName);//20080617
          szString := AnsiReplaceText(szString, '%s', g_Config.sGameDiaMond+'  '+IntToStr(ItemNum));//20080617
          UserEngine.SendBroadCastMsgExt(szString, t_Say);//向每个人物发送消息
        end;
      end;
     //end else begin //if IsEnoughBag then begin //包裹不满时
     //  SysMsg('您的包裹已没有办法装下任何物品!', c_Red, t_Hint);
     //end;
    end;//if n_BoxsItmeID<> 0 then begin
  except
    on E: Exception do begin
      MainOutMessage('{异常} TPlayObject::ClientGetBoxsItme');
    end;
  end;
end;
//----------------------------------------------------------------------------
//---------------------------淬炼系统 20080502--------------------------------
//客户端增加物品到淬炼框中
Function TPlayObject.ClientAddRefineItem(sItemIdx: string):Boolean;
var
  I: Integer;
  UserItem: pTUserItem;
  nItemIdx, nItemIdx1, nItemIdx2: Integer;
  Str,Str1:String;
begin
  Result := False;
  nItemIdx := 0;
  nItemIdx1 := 0;
  nItemIdx2 := 0;
  if sItemIdx <> '' then begin
    sItemIdx := GetValidStr3(sItemIdx, Str,  ['/', #9]);
    sItemIdx := GetValidStr3(sItemIdx, Str1,  ['/', #9]);
    nItemIdx := Str_ToInt(Str,0);
    nItemIdx1 := Str_ToInt(Str1,0);
    nItemIdx2 := Str_ToInt(sItemIdx,0);
  end;

  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    UserItem := m_ItemList.Items[I];
    if UserItem = nil then Continue;
    if (UserItem.MakeIndex = nItemIdx) or (UserItem.MakeIndex = nItemIdx1) or (UserItem.MakeIndex = nItemIdx2) then begin
      if (m_RefineItemList.Count < 4) then begin
        m_RefineItemList.Add(UserItem);
        m_ItemList.Delete(I);
        if m_RefineItemList.Count = 3 then begin
          Result := True;
          Break;
        end;
      end;
    end;
  end;
end;

//取淬练列表物品
procedure TPlayObject.GetBackRefineItem();
var
  I: Integer;
  ClientItem: TClientItem;
  StdItem: TStdItem;
  pStdItem: pTStdItem;
  UserItem: pTUserItem;
  sSENDMSG, sUserItemName: string;
begin
  sSENDMSG:='';
  if m_RefineItemList.Count > 0 then begin
    for I := 0 to m_RefineItemList.Count - 1 do begin
      UserItem := m_RefineItemList.Items[I];
      if UserItem.MakeIndex > 0 then begin
        m_ItemList.Add(UserItem);
        pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if pStdItem <> nil then begin
          StdItem := pStdItem^;
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('41' + #9 + m_sMapName+ #9 +
              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 + StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
              '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
              '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
              '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
              '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
              IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
              IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
              IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
              IntToStr(UserItem.btValue[14])+ #9 + IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax));

          ItemUnit.GetItemAddValue(UserItem, StdItem);
          Move(StdItem, ClientItem.s, SizeOf(TStdItem));

          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if UserItem.btValue[12] = 1 then ClientItem.s.Reserved1:=1 //物品发光 20080223
            else ClientItem.s.Reserved1:=0;
          if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;

          ClientItem.Dura := UserItem.Dura;
          ClientItem.DuraMax := UserItem.DuraMax;
          ClientItem.MakeIndex := UserItem.MakeIndex;
          {if StdItem.StdMode = 50 then begin //20080808 注释
            ClientItem.s.Name := ClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
          end;}
          sSENDMSG := sSENDMSG + EncodeBuffer(@ClientItem, SizeOf(TClientItem)) + '/';
         end;
      end;
    end;
  end;
  //if sSENDMSG <> '' then begin//20080523 注释,修正失败后,三件物品都消失,客户端还有物品显示
    m_DefMsg := MakeDefaultMsg(SM_UPDATERYREFINEITEM, Integer(Self), 0, 0, 0, 0);
    SendSocket(@m_DefMsg, sSENDMSG);
    m_RefineItemList.Clear;
  //end;
end;

//取淬练列表物品的名称
procedure TPlayObject.GetBackRefineItemName(var sItemName, sItemName1, sItemName2: string);
var
  I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  str: String;
begin
  str:='';
  if m_RefineItemList.Count > 0 then begin
    for I := 0 to m_RefineItemList.Count - 1 do begin
      UserItem := m_RefineItemList.Items[I];
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if str <> '' then str:= str + '+';
      if StdItem <> nil then str:= Str + StdItem.Name;
    end;
  end;
  if str <> '' then begin
    str := GetValidStr3(str, sItemName,  ['+']);
    str := GetValidStr3(str, sItemName1, ['+']);
    str := GetValidStr3(str, sItemName2, ['+']);
  end;
end;

//淬练过程
procedure TPlayObject.ClientRefineItem;
var
  RefineItemList: TList;
  RefineItemInfo: pTRefineItemInfo;
  I, K, T, addValue: Integer;
  UserItem,UserItem1,UserItem2: pTUserItem;
  StdItem, StdItem1: pTStdItem;
  sItemName, sItemName1, sItemName2, str: string;
  boOK:Boolean;
begin
  boOK:= False;
  Try
    if (g_RefineItemList = nil) or (g_RefineItemList.Count = 0) then Exit;
    if (m_RefineItemList = nil) or (m_RefineItemList.Count = 0) then Exit;
    GetBackRefineItemName(sItemName, sItemName1, sItemName2);//取出粹练框中的物品名称
    RefineItemList:= GetRefineItemInfo(sItemName, sItemName1, sItemName2);//取出对应配方的物品配置列表
    if RefineItemList <> nil then begin
      if RefineItemList.Count > 1 then begin //当淬炼原料下列表有多个物品，将随机抽取
        for I:= 0 to RefineItemList.Count -1 do begin
          T:= Random(RefineItemList.Count);
          RefineItemInfo := pTRefineItemInfo(RefineItemList.Items[T]);
          if RefineItemInfo <> nil then Break;
        end;
      end else RefineItemInfo := pTRefineItemInfo(RefineItemList.Items[0]);

      //不管成功以否,火云石都要掉持久或消失
      if RefineItemInfo.boDisappear then begin//掉持久
        for I := m_RefineItemList.Count - 1 downto 0 do begin//20080917 修改
          if m_RefineItemList.Count <= 0 then Break;//20080917
          UserItem :=  pTUserItem(m_RefineItemList.Items[I]);
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (StdItem.StdMode = 25) and ((StdItem.Shape = 10) or (StdItem.Shape = 11)) then begin
            if UserItem.Dura >= 100 then begin//20080826 修改
              Dec(UserItem.Dura,100);//掉持久
              if UserItem.Dura <= 0 then begin
                 m_RefineItemList.Delete(I);//20080917
                 DisPoseAndNil(UserItem);//20080917
                 //UserItem.MakeIndex:= 0;
                 //UserItem.wIndex :=0;
              end;
            end else begin
              m_RefineItemList.Delete(I);//20080917
              DisPoseAndNil(UserItem);//20080917
              //UserItem.MakeIndex:= 0;
              //UserItem.wIndex :=0;
            end;
            Break;
          end;
        end;
      end else begin//消失
        for I := m_RefineItemList.Count - 1 downto 0 do begin//20080917 修改
          if m_RefineItemList.Count <= 0 then Break;//20080917
          UserItem := m_RefineItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (StdItem.StdMode = 25) and ((StdItem.Shape = 10) or (StdItem.Shape = 11)) then begin
            m_RefineItemList.Delete(I);//20080917
            DisPoseAndNil(UserItem);//20080917
            //UserItem.MakeIndex:= 0;
            //UserItem.wIndex :=0;
            boOK:= True;
            Break;
          end;
        end;//for
      end;

      if (Random(100) <= RefineItemInfo.nRefineRate) then begin//淬练成功率
        New(UserItem1);
        if UserEngine.CopyToUserItemFromName(RefineItemInfo.sItemName, UserItem1) then begin
          for K:= 0 to 13 do begin
            if RefineItemInfo.nAttribute[K].nPoints = 0 then Continue;//最高限制升点数为零时,跳过
            if Random(RefineItemInfo.nAttribute[K].nDifficult)= 0 then begin//淬炼难度
               addValue:= RefineItemInfo.nAttribute[K].nPoints - UserItem1.btValue[K];
               UserItem1.btValue[K]:= RefineItemInfo.nAttribute[K].nPoints;
            end else begin
               addValue:= UserItem1.btValue[K];
               UserItem1.btValue[K]:= UserItem1.btValue[K] + Random(RefineItemInfo.nAttribute[K].nPoints - 1) + 1;//随机加点数 20080915 加1,防止随机值为0
               UserItem1.btValue[K]:= _MIN(RefineItemInfo.nAttribute[K].nPoints - 1,UserItem1.btValue[K]);
               addValue:= UserItem1.btValue[K] - addValue;
            end;
            if addValue > 0 then begin
              StdItem1 := UserEngine.GetStdItem(UserItem1.wIndex);
              if Str <> '' then Str:= Str+' ';
              case StdItem1.StdMode of
                 19:begin
                    Case K of
                      0: Str:= Str+' 魔法躲避增加'+inttostr(addValue)+'点';
                      1: Str:= Str+' 幸运增加'+inttostr(addValue)+'点';
                      2: Str:= Str+' 攻击增加'+inttostr(addValue)+'点';
                      3: Str:= Str+' 魔法增加'+inttostr(addValue)+'点';
                      4: Str:= Str+' 道术增加'+inttostr(addValue)+'点';
                      14:Str:= Str+' 持久增加'+inttostr(addValue)+'点';
                    end;
                 end;
                 20,24:begin
                    Case K of
                      0: Str:= Str+' 准确增加'+inttostr(addValue)+'点';
                      1: Str:= Str+' 敏捷增加'+inttostr(addValue)+'点';
                      2: Str:= Str+' 攻击增加'+inttostr(addValue)+'点';
                      3: Str:= Str+' 魔法增加'+inttostr(addValue)+'点';
                      4: Str:= Str+' 道术增加'+inttostr(addValue)+'点';
                      14:Str:= Str+' 持久增加'+inttostr(addValue)+'点';
                    end;
                 end;
                 21:begin
                    Case K of
                      0: Str:= Str+' 体力恢复增加'+inttostr(addValue)+'点';
                      1: Str:= Str+' 魔法恢复增加'+inttostr(addValue)+'点';
                      2: Str:= Str+' 攻击增加'+inttostr(addValue)+'点';
                      3: Str:= Str+' 魔法增加'+inttostr(addValue)+'点';
                      4: Str:= Str+' 道术增加'+inttostr(addValue)+'点';
                      14:Str:= Str+' 持久增加'+inttostr(addValue)+'点';
                    end;
                 end;
                 23:begin
                    Case K of
                      0: Str:= Str+' 毒物躲避增加'+inttostr(addValue)+'点';
                      1: Str:= Str+' 中毒恢复增加'+inttostr(addValue)+'点';
                      2: Str:= Str+' 攻击增加'+inttostr(addValue)+'点';
                      3: Str:= Str+' 魔法增加'+inttostr(addValue)+'点';
                      4: Str:= Str+' 道术增加'+inttostr(addValue)+'点';
                      14:Str:= Str+' 持久增加'+inttostr(addValue)+'点';
                    end;
                 end;
                 5,6:begin
                    Case K of
                      0: Str:= Str+' 攻击增加'+inttostr(addValue)+'点';
                      1: Str:= Str+' 魔法增加'+inttostr(addValue)+'点';
                      2: Str:= Str+' 道术增加'+inttostr(addValue)+'点';
                      3: Str:= Str+' 幸运增加'+inttostr(addValue)+'点';
                      4: Str:= Str+' 诅咒增加'+inttostr(addValue)+'点';
                      5: Str:= Str+' 准确增加'+inttostr(addValue)+'点';
                      6: Str:= Str+' 攻击速度增加'+inttostr(addValue)+'点';
                      7: Str:= Str+' 强度增加'+inttostr(addValue)+'点';
                      14:Str:= Str+' 持久增加'+inttostr(addValue)+'点';
                    end;
                 end;
                 else begin
                   Case K of
                      0: Str:= Str+' 防御增加'+inttostr(addValue)+'点';
                      1: Str:= Str+' 魔御增加'+inttostr(addValue)+'点';
                      2: Str:= Str+' 攻击增加'+inttostr(addValue)+'点';
                      3: Str:= Str+' 魔法增加'+inttostr(addValue)+'点';
                      4: Str:= Str+' 道术增加'+inttostr(addValue)+'点';
                      14:Str:= Str+' 持久增加'+inttostr(addValue)+'点';
                    end;
                 end;
              end;//case StdItem1.StdMode of
            end;
          end;
          if (Random(100) <= RefineItemInfo.nNeedRate) then UserEngine.RandomUpgradeItem(UserItem1);//极品属性几率,附加极品属性
          if not boOK then begin
            for I := m_RefineItemList.Count - 1 downto 0 do begin//在成功率内,则删除除火云石外的物品 //20080917
              if m_RefineItemList.Count <= 0 then Break;//20080917
              UserItem2 :=  pTUserItem(m_RefineItemList.Items[I]);
              if (UserItem2 <> nil) and (UserItem2.MakeIndex > 0) then begin
                StdItem1 := UserEngine.GetStdItem(UserItem2.wIndex);
                if (StdItem1 <> nil) and (StdItem1.StdMode <> 25) and (StdItem1.Name <> '') then begin
                  m_RefineItemList.Delete(I);//20080917
                  DisPoseAndNil(UserItem2);//20080917
                 //UserItem2.MakeIndex:=0;
                 //UserItem2.wIndex :=0;
                end;
              end;
            end;//for
          end else  m_RefineItemList.Clear;
          m_RefineItemList.Add(UserItem1);//物品保存到列表中
          //SysMsg('恭喜,粹练'+RefineItemInfo.sItemName+'成功,'+ Str, c_Green, t_Hint);//成功提示
          SysMsg(Format(sRefineItemSuccessMsg + Str ,[RefineItemInfo.sItemName]), c_Green, t_Hint);//成功提示 20081224
        end;
      end else begin
        if (Random(100) <= RefineItemInfo.nReductionRate) then begin//失败后,在还原成功率内,则删除弩牌或封印装备
          for I :=m_RefineItemList.Count - 1 downto 0 do begin//20080917 修改
            if  m_RefineItemList.Count <= 0 then Break;//20080917
            UserItem := pTUserItem(m_RefineItemList.Items[I]);
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if (StdItem <> nil) and ((StdItem.StdMode = 47) or (Pos(StdItem.Name,'封印') > 0)) then begin
              m_RefineItemList.Delete(I);
              DisPoseAndNil(UserItem);//20080917
              //UserItem.MakeIndex:= 0;
              //UserItem.wIndex :=0;
            end;
          end;
        end else begin //失败后,不在还原成功率内,1-合成新物品,则删除物品,除火去石外  2-升级物品,则初始属性
          if (CompareText(RefineItemInfo.sItemName, sItemName) = 0) or (CompareText(RefineItemInfo.sItemName, sItemName1) = 0) or (CompareText(RefineItemInfo.sItemName, sItemName2) = 0) then begin
            for I := m_RefineItemList.Count - 1 downto 0 do begin//20080917 修改
              if m_RefineItemList.Count <= 0 then Break;//20080917
              UserItem := m_RefineItemList.Items[I];
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if (StdItem <> nil) then begin
                if (CompareText(StdItem.Name, RefineItemInfo.sItemName)= 0) then begin
                  //m_RefineItemList.Delete(I);
                  for K:= 0 to 13 do UserItem.btValue[K]:= 0;//初始属性
                  //m_RefineItemList.Add(UserItem);
                end else
                if (StdItem.StdMode <> 25) then begin
                  m_RefineItemList.Delete(I);//20080917
                  DisPoseAndNil(UserItem);//20080917
                  //UserItem.MakeIndex:=0;
                  //UserItem.wIndex :=0;
                end;
              end;
            end;//for
          end else begin
            for I := m_RefineItemList.Count - 1 downto 0 do begin//20080917 修改
              if m_RefineItemList.Count <= 0 then Break;//20080917
              UserItem := m_RefineItemList.Items[I];
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if (StdItem <> nil) and (StdItem.StdMode <> 25) then begin
                m_RefineItemList.Delete(I);
                DisPoseAndNil(UserItem);//20080917
                //UserItem.MakeIndex:=0;
                //UserItem.wIndex :=0;
              end;
            end;//for
          end;
        end;
        SysMsg(sRefineItemFailMsg{'粹练装备失败!'}, c_Red, t_Hint);//失败提示 20081224
      end;
      GetBackRefineItem();//发消息,更新粹练框中的物品
    end else begin//if RefineItemList <> nil then begin
      if m_RefineItemList.Count > 0 then begin
        for I := 0 to m_RefineItemList.Count - 1 do begin
          UserItem := m_RefineItemList.Items[I];
          if UserItem.MakeIndex > 0 then  m_ItemList.Add(UserItem);
        end;
      end;
      SysMsg(sRefineItemErrorMsg{'这次无法控制火云石的力量，淬炼失败了'}, c_Red, t_Hint);//物品不是配方里的物品,失败提示 20081224
      m_RefineItemList.Clear;
    end;  
  except
    on E: Exception do begin
      MainOutMessage('{异常} TPlayObject.ClientRefineItem');
    end;
  end;
end;
//------------------------------------------------------------------------------
function TPlayObject.WearRefineItem: Boolean; //是火云石
var
  StdItem: pTStdItem;
begin
 Result := False;
  if m_UseItems[U_BUJUK].wIndex > 0 then begin
    StdItem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
    if (StdItem <> nil) and (StdItem.StdMode = 25) and (StdItem.Shape = 10) then begin
      Result := True;
    end;
  end;
end;
//修补火云石
procedure TPlayObject.RepairRefineItem(nItemIdx: Integer; sItemName: string);
var
  I, n14: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  sUserItemName: string;
  boRepairOK: Boolean;
  OldDura: Word;
begin
  boRepairOK := False;
  StdItem := nil;
  UserItem := nil;
  OldDura := 0;
  n14 := -1;
  if WearRefineItem then begin
    if (m_UseItems[U_BUJUK].Dura < m_UseItems[U_BUJUK].DuraMax) and (m_UseItems[U_BUJUK].Dura >= 500) then begin
      OldDura := m_UseItems[U_BUJUK].Dura;
      if m_ItemList.Count > 0 then begin
        for I := 0 to m_ItemList.Count - 1 do begin
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName = '' then
              sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem <> nil then begin
              if CompareText(sUserItemName, sItemName) = 0 then begin
                n14 := I;
                Break;
              end;
            end;
          end;
        end;
        if (StdItem <> nil) and (UserItem <> nil) and (StdItem.StdMode = 43) and (StdItem.Shape = 1) then begin
          Inc(m_UseItems[U_BUJUK].Dura, 500);
          if m_UseItems[U_BUJUK].Dura > m_UseItems[U_BUJUK].DuraMax then m_UseItems[U_BUJUK].Dura:=m_UseItems[U_BUJUK].DuraMax;
          boRepairOK := True;
          DelBagItem(n14);
        end;
      end;
    end;
  end;
  if boRepairOK then begin
    if OldDura <> m_UseItems[U_BUJUK].Dura then
      SendMsg(Self, RM_DURACHANGE, U_BUJUK, m_UseItems[U_BUJUK].Dura, m_UseItems[U_BUJUK].DuraMax, 0, '');
      SendDefMessage(SM_REPAIRFINEITEM_OK, 0, 0, 0, 0, '');
  end else begin
    SendDefMessage(SM_REPAIRFINEITEM_FAIL, 0, 0, 0, 0, '');
    SysMsg('修补火云石失败!', BB_Fuchsia, t_Hint);//20071231
  end;
end;
//------------------------------------------------------------------------------
//取回英雄 20080514
procedure TPlayObject.ClientGETHERO(sHeroName: string; nHeroTpye:Byte);
begin
  if sHeroName <> '' then begin
    m_sHeroCharName:= sHeroName;
    n_myHeroTpye:= nHeroTpye;//20080515 英雄的类型
    Case n_myHeroTpye of
      0: m_boHasHero := True;
      1: m_boHasHeroTwo := True;
    end;
    if g_FunctionNPC <> nil then
        g_FunctionNPC.GotoLable(self, '@GetHeroOk', False);
  end else begin
    if g_FunctionNPC <> nil then
      g_FunctionNPC.GotoLable(self, '@GetHeroBak', False);
  end;
end;
//请酒 20080515
procedure TPlayObject.ClientPlayDrinkItem(NPC: TObject; nItemIdx: Integer; sMsg: string);
var
  Merchant: TMerchant;
  I: Integer;
  UserItem: pTUserItem;
  bo19: Boolean;
  StdItem: pTStdItem;
  sUserItemName: string;
begin
  bo19 := False;
  Merchant := UserEngine.FindMerchant(NPC);
  if (Merchant <> nil) and (Merchant.m_boPlayDrink) then begin //请酒斗酒NPC
    //折分物品名称(信件物品的名称后面加了使用次数)
    if Pos(' ', sMsg) >= 0 then GetValidStr3(sMsg, sMsg, [' ']);
    for I := m_ItemList.Count - 1 downto 0 do begin
      if m_ItemList.Count <= 0 then Break;
      UserItem := m_ItemList.Items[I];
      if UserItem.MakeIndex = nItemIdx then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
           sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
           sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
           
        if CompareText(sUserItemName, sMsg) = 0 then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem.StdMode=60) and (StdItem.Shape = 0 ) then begin//是烧酒
             m_ItemList.Delete(I);//删除物品
             bo19 := True;
          end;
        end;
        Break;
      end;
    end;  
  end;
  if bo19 then begin
     SendDefMessage(SM_USERPLAYDRINK_OK, 0, 0, 0, 0, '');
     if Merchant <> nil then
     Merchant.GotoLable(self, '~PlayDrink_Game', False);
  end else SendDefMessage(SM_USERPLAYDRINK_FAIL, 0, 0, 0, 0, '');
end;

//请酒信息跳转 20080515
procedure TPlayObject.ClientPlayDrinkLable(nParam1: Integer; sMsg: string);
var
  NPC: TNormNpc;
  sLabel: string;
begin
  if m_boDeath or m_boGhost then Exit;
  NPC := UserEngine.FindMerchant(TObject(nParam1));
  if NPC = nil then NPC := UserEngine.FindNPC(TObject(nParam1));
  if NPC = nil then Exit;
  if (sMsg <> '') and (sMsg[1] = '@') then begin
     GetValidStr3(sMsg, sLabel, [#13]);
     NPC.GotoLable(self, sLabel, False);
  end;
end;
//比较NPC与玩家出码数,并判断输赢 20080516
//码值:0-石 1-剪刀 2-布  nCode 0-赢  1-输  2-平
procedure TPlayObject.ClientPlayDrinkToDrink(nParam1: Integer; nPlayNum: Byte);
var
  nNpcNum, nCode:Byte;
  NPC: TNormNpc;
begin
  nCode:= 3;//猜码结果
  Randomize(); //随机种子
  nNpcNum := Random(3);//随机取NPC出码值
  case nPlayNum of
    0:begin
       case nNpcNum of
         0: nCode:= 2;//平
         1: nCode:= 0;//输
         2: nCode:= 1;//赢
       end;
     end;
    1:begin
       case nNpcNum of
         0: nCode:= 1;//输
         1: nCode:= 2;//平
         2: nCode:= 0;//赢
       end;
     end;
    2:begin
       case nNpcNum of
         0: nCode:= 0;//赢
         1: nCode:= 1;//输
         2: nCode:= 2;//平
       end;
     end;
  end;//case nPlayNum of
  if {nCode in [0..2]}(nCode < 3) then begin//有了结果,发消息给客户端
     NPC := UserEngine.FindMerchant(TObject(nParam1));
     if NPC = nil then NPC := UserEngine.FindNPC(TObject(nParam1));
     case nCode of
       0: NPC.GotoLable(self, '~PlayDrink_PlayWil', False);//玩家赢
       1: NPC.GotoLable(self, '~PlayDrink_NpcWil', False);//NPC赢
     end;
     SendMsg(Self, RM_PlayDrinkToDrink, 0, nPlayNum, nNpcNum, nCode, '');
  end;
end;
//喝酒并增加醉酒值 20080517
//参数:nPlayNum--谁喝酒(0-玩家喝 1-NPC喝)  nCode--谁赢(0-NPC 1-玩家)
//如果NPC胜,则随机选择谁喝酒,玩家胜,则以玩家的选择来决定
procedure TPlayObject.ClientDrinkUpdateValue(nParam1: Integer;nPlayNum,nCode: Byte);
var
  NPC: TNormNpc;
  boDrinkLoss: Boolean;
begin
  if n_DrinkCount < 7 then begin
    boDrinkLoss:= True;
    NPC := UserEngine.FindMerchant(TObject(nParam1));
    if NPC = nil then NPC := UserEngine.FindNPC(TObject(nParam1));
    Inc(n_DrinkCount);//累积喝酒次数,即喝了几瓶酒
    Randomize(); //随机种子
    case nCode of
      0: begin//NPC胜
         case Random(2) of
           0: begin//玩家喝
              n_DrinkValue[1]:= n_DrinkValue[1]+ Random(25)+ 8;
              if n_DrinkValue[1] > 100 then n_DrinkValue[1]:=100;
              nPlayNum:= 0;
              NPC.GotoLable(self, '~PlayDrink_NpcToSelf', False);
            end;
           1: begin//NPC喝
              n_DrinkValue[0]:= n_DrinkValue[0]+ Random(25)+ 8;
              if n_DrinkValue[0] > 100 then n_DrinkValue[0]:=100;
              nPlayNum:= 1;
              NPC.GotoLable(self, '~PlayDrink_NpcToNpc', False);
            end;
         end;
       end;
      1: begin//玩家胜
         case nPlayNum of
           0:begin//玩家喝
               n_DrinkValue[1]:= n_DrinkValue[1]+ Random(30)+ 10;
               if n_DrinkValue[1] > 100 then n_DrinkValue[1]:=100;
               NPC.GotoLable(self, '~PlayDrink_SelfToSelf', False);
            end;
           1:begin//NPC喝
               n_DrinkValue[0]:= n_DrinkValue[0]+ Random(30)+ 10;
               if n_DrinkValue[0] > 100 then n_DrinkValue[0]:=100;
               NPC.GotoLable(self, '~PlayDrink_SelfToNpc', False);
            end;
         end;
       end;
    end;//case nCode of
    
    if n_DrinkValue[0] >= 92 then begin//NPC喝醉,斗酒失败
      NPC.GotoLable(self, '~PlayDrink_Npc_Drunk', False);
      boDrinkLoss:= False;
    end else
    if n_DrinkValue[1] >= 92 then begin//玩家喝醉
      NPC.GotoLable(self, '~PlayDrink_Self_Drunk', False);
      boDrinkLoss:= False;
    end else
    if n_DrinkCount = 6 then begin//喝完酒,判断结果
      if n_DrinkValue[0] > n_DrinkValue[1] then //玩家斗酒胜
         NPC.GotoLable(self, '~PlayDrink_Npc_Loss', False)
      else NPC.GotoLable(self, '~PlayDrink_Self_Loss', False);
      boDrinkLoss:= False;
    end;

    if boDrinkLoss then       //参数0-可以继续喝 1-斗酒结束
      SendMsg(Self, RM_DrinkUpdateValue, 0, nPlayNum, n_DrinkValue[0], n_DrinkValue[1], '')
    else SendMsg(Self, RM_DrinkUpdateValue, 1, nPlayNum, n_DrinkValue[0], n_DrinkValue[1], '');  
  end;
end;
//请酒 20080517
//判断放上的两物品是不是烧酒,如果是则删除物品,触发脚本段
procedure TPlayObject.ClientPlayDrink(sMsg: String);
var
  Merchant: TMerchant;
  I: Integer;
  UserItem: pTUserItem;
  bo19,bo20: Boolean;
  StdItem: pTStdItem;
  nItemIdx,nItemIdx1,NPCID: Integer;
  Str,Str1: String;
begin
  NPCID := 0;
  nItemIdx := 0;
  nItemIdx1 := 0;
  bo19 := False;
  bo20 := False;
  if sMsg <> '' then begin
    sMsg := GetValidStr3(sMsg, Str,  ['/', #9]);
    sMsg := GetValidStr3(sMsg, Str1,  ['/', #9]);
    NPCID := Str_ToInt(Str,0);
    nItemIdx := Str_ToInt(Str1,0);
    nItemIdx1 := Str_ToInt(sMsg,0);
  end;

  if (NPCID <> 0) and (nItemIdx <> 0) and  (nItemIdx1 <> 0) then begin
    Merchant := UserEngine.FindMerchant(TObject(NPCID));
    if (Merchant <> nil) and (Merchant.m_boPlayDrink) then begin //请酒NPC
      for I := m_ItemList.Count - 1 downto 0 do begin
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem.MakeIndex = nItemIdx then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem.StdMode=60) and (StdItem.Shape = 0 ) then begin//是烧酒
             bo19 := True;
          end;
        end else
        if UserItem.MakeIndex = nItemIdx1 then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem.StdMode=60) and (StdItem.Shape = 0 ) then begin//是烧酒
             bo20 := True;
          end;
        end;
        if bo19 and bo20 then Break;
      end;//for I := m_ItemList.Count - 1 downto 0 do begin
    end;//if (Merchant <> nil) and (Merchant.m_boPlayDrink) then begin

    if bo19 and bo20 then begin
       for I := m_ItemList.Count - 1 downto 0 do begin//删除物品
         if m_ItemList.Count <= 0 then Break;
         UserItem := m_ItemList.Items[I];
         if (UserItem.MakeIndex = nItemIdx) or (UserItem.MakeIndex = nItemIdx1) then m_ItemList.Delete(I);
       end;
       SendDefMessage(SM_USERPLAYDRINKITEM_OK, 0, 0, 0, 0, '');
       m_boPlayDrink:= True;//是否请过酒 T-请过酒 20080518
       if Merchant <> nil then Merchant.GotoLable(self, '~PlayDrink_Ok', False);
    end else begin
      SendDefMessage(SM_USERPLAYDRINKITEM_FAIL, 0, 0, 0, 0, '');
    end;  
  end;
end;
//------------------------------------------------------------------------------
//读取师徒文件 20080530
Function TPlayObject.GetMasterNoList:Boolean;
var
  I: Integer;
  LoadList: TStringList;
  sFileName: string;
  s01,s02,s03:string;
  TMasterList: pTMasterList;  
begin
  Result:=False;
  try
    sFileName :=  g_Config.sEnvirDir + 'MasterNo';
    if not DirectoryExists(sFileName) then CreateDir(sFileName); //目录不存在,则创建
    if m_sMasterName <> '' then begin//有师傅,取排名
      sFileName := sFileName+'\'+m_sMasterName+'.txt';
      LoadList := TStringList.Create;
      if FileExists(sFileName) then begin
        LoadList.LoadFromFile(sFileName);
        if LoadList.Count > 0 then begin//20080629
          for I := 0 to LoadList.Count - 1 do begin
           s01 := Trim(LoadList.Strings[I]);
           if (s01 <> '') and (s01[1] <> ';') then begin
              s01 := GetValidStr3(s01, s02, [' ', #9]);//徒弟名
              s01 := GetValidStr3(s01, s03, [' ', #9]);//排行
              if s02 <> '' then begin
                 if CompareText(m_sCharName, s02) = 0 then begin
                   m_nMasterNo := Str_ToInt(s03, 0);
                   Result:= True;
                   Break;
                 end;
              end;
           end;//if (s01 <> '') and (s01[1] <> ';') then begin
          end;//for
        end;
      end;//if FileExists(sFileName)
      LoadList.Free;
    end else
    if m_boMaster then begin//有徒弟,取列表内容
      sFileName := sFileName+'\'+m_sCharName+'.txt';
      LoadList := TStringList.Create;
      if FileExists(sFileName) then begin
        LoadList.LoadFromFile(sFileName);
        if LoadList.Count > 0 then begin//20080629
          for I := 0 to LoadList.Count - 1 do begin
           s01 := Trim(LoadList.Strings[I]);
           if (s01 <> '') and (s01[1] <> ';') then begin
              s01 := GetValidStr3(s01, s02, [' ', #9]);//徒弟名
              s01 := GetValidStr3(s01, s03, [' ', #9]);//排行
              if s02 <> '' then begin
                New(TMasterList);
                TMasterList.ID:=strtoint(s03);
                TMasterList.sChrName:= s02;
                m_MasterNoList.AddObject(s03, TObject(TMasterList));
              end;
           end;//if (s01 <> '') and (s01[1] <> ';') then begin
          end;//for
        end;
        Result:= True;
      end;//if FileExists(sFileName)
      LoadList.Free;
    end;
  except
    MainOutMessage('{异常} TPlayObject.GetMasterNoList');
  end;
end;

//保存师徒文件 20080530
procedure TPlayObject.SaveMasterNoList();
var
  I: Integer;
  SaveList: TStringList;
  sFileName: string;
  TMasterList: pTMasterList;
begin
  try
    sFileName :=  g_Config.sEnvirDir + 'MasterNo';
    if not DirectoryExists(sFileName) then CreateDir(sFileName); //目录不存在,则创建
    if m_boMaster then begin//有徒弟才能保存列表
      sFileName := sFileName+'\'+m_sCharName+'.txt';
      SaveList := TStringList.Create();
      MasterNoListQuickSort(m_MasterNoList,True);//排序
      if m_MasterNoList.Count > 0 then begin//20080629
        for I := 0 to m_MasterNoList.Count - 1 do begin
          TMasterList:= PTMasterList(m_MasterNoList.Objects[I]);
          SaveList.Add(TMasterList.sChrName+' '+inttostr(TMasterList.ID));
        end;
      end;
      SaveList.SaveToFile(sFileName);
      SaveList.Free;
    end;
  except
    MainOutMessage('{异常} TPlayObject.SaveMasterNoList');
  end;
end;
//收徒 20080530
procedure TPlayObject.AddMaster(MasterName: String);
var
 TMasterList:pTMasterList;
begin
  new(TMasterList);
  TMasterList.sChrName:= MasterName;
  TMasterList.ID := m_MasterNoList.Count+1;
  m_MasterNoList.AddObject(inttostr(TMasterList.ID),TObject(TMasterList));
  SaveMasterNoList();//保存师徒文件 20080530
end;

//出师 20080530
procedure TPlayObject.DelMaster(MasterName: String);
var
 I:integer;
 TMasterList:pTMasterList;
begin
  for I:= m_MasterNoList.Count -1 downto 0 do begin
    if m_MasterNoList.Count <= 0 then Break;//20080917
    TMasterList:= PTMasterList(m_MasterNoList.Objects[I]);
    if CompareText(Trim(TMasterList.sChrName) , Trim(MasterName))= 0 then begin
      Dispose(TMasterList);
      m_MasterNoList.Delete(I);
      break;
    end;
  end;
  SaveMasterNoList();//保存师徒文件 20080530
end;

//师徒数据排序 20080530 (用于徒弟出师,收徒后进行排名的排序)
procedure TPlayObject.MasterNoListQuickSort(sList: TStringList; Order: Boolean);
  procedure QuickSortStrListCase(List: TStringList; l, r: Integer);
  var
    I, j: Integer;
    p: string;
  begin
    if List.Count <= 0 then Exit;
    repeat
      I := l;
      j := r;
      p := List[(l + r) shr 1];
      repeat
        if Order then begin //升序
          while CompareStr(List[I], p) < 0 do Inc(I);
          while CompareStr(List[j], p) > 0 do Dec(j);
        end else begin //降序
          while CompareStr(p, List[I]) < 0 do Inc(I);
          while CompareStr(p, List[j]) > 0 do Dec(j);
        end;
        if I <= j then begin
          List.Exchange(I, j);
          Inc(I);
          Dec(j);
        end;
      until I > j;
      if l < j then QuickSortStrListCase(List, l, j);
      l := I;
    until I >= r;
  end;
  procedure AddList(TempList: TStringList; slen: string; s: string; AObject: TObject);
  var
    I: Integer;
    List: TStringList;
    boFound: Boolean;
  begin
    boFound := False;
    if TempList.Count > 0 then begin
      for I := 0 to TempList.Count - 1 do begin
        if CompareText(TempList.Strings[I], slen) = 0 then begin
          List := TStringList(TempList.Objects[I]);
          List.AddObject(s, AObject);
          boFound := True;
          Break;
        end;
      end;
    end;
    if not boFound then begin
      List := TStringList.Create;
      List.AddObject(s, AObject);
      TempList.AddObject(slen, List);
    end;
  end;
var
  TempList: TStringList;
  List: TStringList;
  I: Integer;
  nLen: Integer;
  TMasterList:pTMasterList;
begin
  TempList := TStringList.Create;
  if sList.Count > 0 then begin//20080629
    for I := 0 to sList.Count - 1 do begin
      nLen := Length(sList.Strings[I]);
      AddList(TempList, IntToStr(nLen), Inttostr(I+1){sList.Strings[I]}, sList.Objects[I]);
    end;
  end;
  QuickSortStrListCase(TempList, 0, TempList.Count - 1);
  sList.Clear;
  if TempList.Count > 0 then begin//20080629
    for I := 0 to TempList.Count - 1 do begin
      List := TStringList(TempList.Objects[I]);
      QuickSortStrListCase(List, 0, List.Count - 1);
      sList.AddStrings(List);
      List.Free;
    end;
  end;
  TempList.Free;
  if m_MasterNoList.Count > 0 then begin//20080629
    for I:=0 to m_MasterNoList.Count -1 do begin
      TMasterList:= PTMasterList(m_MasterNoList.Objects[I]);
      TMasterList.ID:=I+1;
    end;
  end;
end;
//--------------------------酿酒系统-------------------------------------------
//客户端开始酿酒  nCode酿酒种类 0-普通 1-药酒  nParam1-NPC标识
procedure TPlayObject.ClientPlayMakeWine(nCode:Byte; sMsg: String);
  function GetRandomRange(nCount, nRate: Integer): Integer;
  var
    I: Integer;
  begin
    Result := 0;
    if nCount <= 0 then Exit;
    for I := 0 to nCount - 1 do
      if Random(nRate) = 0 then Inc(Result);
  end;
var
  nItemId, nItemId1, nItemId2,nItemId3, nItemId4, nItemId5, nItemId6: Integer;
  Str,Str1,Str2,Str3,Str4,Str5,Str6:String;
  StdItem,StdItem1,StdItem2,StdItem3,StdItem4,StdItem5,StdItem6: pTStdItem;
  UserItem: pTUserItem;
  I,nC: Integer;
  boMakeWine, boMakeWineOK: Boolean;
  Check:Byte;
begin
  boMakeWine:= False;
  boMakeWineOK:= False;
  Check:= 0;
  try
    if (nCode in [0,1]) and (sMsg <> '') and (not m_boMakeWine) then begin
      case nCode of
        0:begin//普通酒
          sMsg := GetValidStr3(sMsg, Str,  ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str1,  ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str2,  ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str3,  ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str4,  ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str5,  ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str6,  ['/', #9]);
          nItemId  := Str_ToInt(Str,0);//主材料
          nItemId1 := Str_ToInt(Str1,0);//酒曲
          nItemId2 := Str_ToInt(Str2,0);//水
          nItemId3 := Str_ToInt(Str3,0);//酒坛
          nItemId4 := Str_ToInt(Str4,0);//辅助材料1
          nItemId5 := Str_ToInt(Str5,0);//辅助材料2
          nItemId6 := Str_ToInt(Str6,0);//辅助材料3
          Check:= 1;
          if m_ItemList.Count > 0 then begin//20080628
            for I :=0 to m_ItemList.Count - 1 do begin
              Check:= 2;
              UserItem := m_ItemList.Items[I];
              Check:= 3;
              if UserItem <> nil then begin
                if UserItem.MakeIndex = nItemId  then StdItem := UserEngine.GetStdItem(UserItem.wIndex)
                else if UserItem.MakeIndex = nItemId1 then StdItem1 := UserEngine.GetStdItem(UserItem.wIndex)
                else if UserItem.MakeIndex = nItemId2 then StdItem2 := UserEngine.GetStdItem(UserItem.wIndex)
                else if UserItem.MakeIndex = nItemId3 then StdItem3 := UserEngine.GetStdItem(UserItem.wIndex)
                else if UserItem.MakeIndex = nItemId4 then StdItem4 := UserEngine.GetStdItem(UserItem.wIndex)
                else if UserItem.MakeIndex = nItemId5 then StdItem5 := UserEngine.GetStdItem(UserItem.wIndex)
                else if UserItem.MakeIndex = nItemId6 then StdItem6 := UserEngine.GetStdItem(UserItem.wIndex);
              end;
            end;//for I := m_ItemList.Count - 1 downto 0 do begin
          end;
          Check:= 4;
          if (StdItem <> nil) and (StdItem2 <> nil) and (StdItem3 <> nil) and (StdItem4 <> nil) and (StdItem5<> nil) and (StdItem6<> nil) then begin
             Check:= 5;
             if (StdItem.StdMode = 8) and (StdItem2.StdMode = 9) and ((StdItem3.StdMode =12) and (StdItem3.Shape =0)) and
                (StdItem4.StdMode = 8) and (StdItem5.StdMode = 8) and (StdItem6.StdMode = 8) then begin
                n_MakeWineQuality:= StdItem.AC;//主料的品质值
               { if StdItem4.Source = 1 then n_MakeWineQuality:= n_MakeWineQuality + 1;//主料为精制材料
                if StdItem5.Source = 1 then n_MakeWineQuality:= n_MakeWineQuality + 1;//主料为精制材料
                if StdItem6.Source = 1 then n_MakeWineQuality:= n_MakeWineQuality + 1;//主料为精制材料}
                if StdItem2.Shape = 1 then n_MakeWineQuality:= n_MakeWineQuality + 1;//使用泉水品质+1
                Check:= 6;
                m_boMakeWine:= True;//是否酿酒
                m_MakeWineTime:= g_Config.nMakeWineTime;//酿酒等待的时间
                n_MakeWineItmeType:= StdItem.AniCount ;//酿酒后,应该可以得到酒的类型
                n_MakeWineType:= 1;//酿酒的类型 1-普通酒 2-药酒
                Randomize(); //随机种子
                if StdItem1 <> nil then begin//判断酒曲是否是与主材料对应,对应则加品质+1
                  if (StdItem1.Shape = StdItem.AniCount) and (Random(3)=0) then n_MakeWineQuality:=n_MakeWineQuality + 1;
                end;
                if StdItem.Source = 1 then begin //精制材料可以得到酒的品质
                   nC:= GetRandomRange(3,5);
                   n_MakeWineQuality:=n_MakeWineQuality + nC;
                   if n_MakeWineQuality > 10 then n_MakeWineQuality:=10;
                end else begin //普通材料
                   nC:= GetRandomRange(3,4);
                   n_MakeWineQuality:=n_MakeWineQuality + nC;//可以得到酒的品质
                   if n_MakeWineQuality > 5 then n_MakeWineQuality:=5;
                end;
                if n_MakeWineQuality = 0 then n_MakeWineQuality:= 1;

                //n_MakeWineAlcohol:=StdItem.Reserved + StdItem4.Reserved + StdItem5.Reserved + StdItem6.Reserved;//可以得到酒的酒精度
                n_MakeWineAlcohol:=StdItem.Reserved + StdItem4.Reserved + Random(StdItem5.Reserved) + Random(StdItem6.Reserved);//可以得到酒的酒精度
                if n_MakeWineAlcohol > 100 then n_MakeWineAlcohol:= Random(30)+ 30;//20080827 增加
                boMakeWine:= True;
                Check:= 7;
             end;
          end;
          if boMakeWine then begin
            for I := m_ItemList.Count - 1 downto 0 do begin
              if m_ItemList.Count <= 0 then Break;
              Check:= 8;
              UserItem := m_ItemList.Items[I];
              Check:= 9;
              if UserItem <> nil then begin
                if (UserItem.MakeIndex = nItemId) or (UserItem.MakeIndex = nItemId1) or
                   (UserItem.MakeIndex = nItemId2) or (UserItem.MakeIndex = nItemId3) or
                   (UserItem.MakeIndex = nItemId4) or (UserItem.MakeIndex = nItemId5) or
                   (UserItem.MakeIndex = nItemId6) then begin
                    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                    if StdItem <> nil then begin
                       Check:= 10;
                       SendDelItems(UserItem);
                       Check:= 11;
                       Dispose(UserItem);
                       Check:= 12;
                       m_ItemList.Delete(I);
                    end;
                end;
              end;
            end;
          end;
        end;
        1:begin//药酒
          sMsg := GetValidStr3(sMsg, Str,  ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str1,  ['/', #9]);
          nItemId  := Str_ToInt(Str,0);//药材
          nItemId1 := Str_ToInt(Str1,0);//酒
          nItemId2 := Str_ToInt(sMsg,0);//酒瓶
          if m_ItemList.Count > 0 then begin//20080628
            for I := 0 to m_ItemList.Count - 1 do begin
              UserItem := m_ItemList.Items[I];
              if UserItem <> nil then begin
                if UserItem.MakeIndex = nItemId  then StdItem := UserEngine.GetStdItem(UserItem.wIndex)
                else if UserItem.MakeIndex = nItemId1 then begin
                   StdItem1 := UserEngine.GetStdItem(UserItem.wIndex);
                   if (StdItem1.StdMode = 60) and (StdItem1.Shape <> 0) then begin//普通酒
                     if (UserItem.btValue[0] > 5) and (UserItem.Dura = UserItem.DuraMax) then begin//普通酒品质达6以上,并且没喝过,才做酿造药酒
                        boMakeWineOK:= True;
                        n_MakeWineQuality:= UserItem.btValue[0];//可以得到酒的品质
                        n_MakeWineAlcohol:= UserItem.btValue[1];//可以得到酒的酒精度
                        if n_MakeWineAlcohol >100 then n_MakeWineAlcohol:= Random(30)+ 30;//20080827 增加
                      end;
                   end;
                end
                else if UserItem.MakeIndex = nItemId2 then StdItem2 := UserEngine.GetStdItem(UserItem.wIndex);
              end;
            end;//for
          end;
          if (StdItem <> nil) and (StdItem1 <> nil) and (StdItem2 <> nil) then begin
             if (StdItem.StdMode = 14) and boMakeWineOK and ((StdItem2.StdMode =12) and (StdItem2.Shape =1)) then begin
                m_boMakeWine:= True;//是否酿酒
                m_MakeWineTime:= g_Config.nMakeWineTime1;//酿药酒等待的时间
                n_MakeWineItmeType:= StdItem.AniCount ;//酿酒后,应该可以得到酒的类型
                n_MakeWineType:= 2;//酿酒的类型 1-普通酒 2-药酒
                boMakeWine:= True;
             end;
          end;//if (StdItem <> nil) and (StdItem1 <> nil) and (StdItem2 <> nil) then begin
          if not boMakeWine then begin
            n_MakeWineQuality:= 0;//可以得到酒的品质
            n_MakeWineAlcohol:= 0;//可以得到酒的酒精度
          end else begin
            for I := m_ItemList.Count - 1 downto 0 do begin
              if m_ItemList.Count <= 0 then Break;
              Check:= 18;
              UserItem := m_ItemList.Items[I];
              Check:= 19;
              if UserItem <> nil then begin
                if (UserItem.MakeIndex = nItemId) or (UserItem.MakeIndex = nItemId1) or
                   (UserItem.MakeIndex = nItemId2) then begin
                    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                    if StdItem <> nil then begin
                       Check:= 20;
                       SendDelItems(UserItem);
                       Check:= 21;
                       Dispose(UserItem);
                       Check:= 22;
                       m_ItemList.Delete(I);
                    end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;

    //材料全对应上后,提示玩家开始酿造,需等待一会,并发个消息给客户端把窗口关掉
    if boMakeWine then begin//酿造成功
      SendMsg(Self, RM_MAKEWINE_OK, 0, nCode, 0, 0, '');//酿造成功
      if g_FunctionNPC <> nil then begin
        g_FunctionNPC.GotoLable(Self, '@BeginMakeWine', False);//酿造成功
      end;
    end else begin//酿酒失败
      SendMsg(Self, RM_MAKEWINE_FAIL, 0, nCode, 0, 0, '');//酿造失败
      if m_boMakeWine then begin//已经有酒在酿中
        if g_FunctionNPC <> nil then begin
          g_FunctionNPC.GotoLable(Self, '@MakeWineFail', False);//酿造失败
        end;
      end else begin
        if g_FunctionNPC <> nil then begin
          g_FunctionNPC.GotoLable(Self, '@MakeWineFail1', False);//酿造失败
        end;
      end;
    end;
  except
    MainOutMessage('{异常} TPlayObject.ClientPlayMakeWine Code:'+inttostr(Check));
  end;
end;  
//-----------------------------------------------------------------------------
//收集泉水 20080624      n_InFountainTime:= 0;//站在泉水眼的时间 20080624
//先判断玩家毒符位是否有泉水罐,然后判断是否在泉眼上,最后记时,到时间加泉水
procedure TPlayObject.PlayGatherFountain;
var
  StdItem: pTStdItem;
begin
  if (m_UseItems[U_BUJUK].wIndex > 0) and (m_UseItems[U_BUJUK].Dura <> m_UseItems[U_BUJUK].DuraMax) then begin
    StdItem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
    if StdItem <> nil then begin
      if (StdItem.StdMode = 2) and (StdItem.AniCount= 21) and (StdItem.Reserved = 56) then begin//有泉水罐
        if g_EventManager.GetEvent(m_PEnvir, m_nCurrX, m_nCurrY, ET_FOUNTAIN) <> nil then begin//判断玩家是在泉眼上
           Inc(n_InFountainTime);//累积站在泉眼上的时间
           if n_InFountainTime >= g_Config.nInFountainTime then begin//达到累积时间,则增加泉水罐的持久
             Inc(m_UseItems[U_BUJUK].Dura,100);
             if m_MyGuild <> nil then begin
               TGUild(m_MyGuild).boChanged:=True;
               Inc(TGUild(m_MyGuild).m_nGuildFountain);//累积行会泉水 20080625
             end;                      
             if m_UseItems[U_BUJUK].Dura > m_UseItems[U_BUJUK].DuraMax then m_UseItems[U_BUJUK].Dura:= m_UseItems[U_BUJUK].DuraMax;
             SendMsg(self, RM_DURACHANGE, U_BUJUK, m_UseItems[U_BUJUK].Dura, m_UseItems[U_BUJUK].DuraMax, 0, '');
             SendRefMsg(RM_MYSHOW, 10, 0, 0, 0, ''); //采集到泉水动画  20080624
             n_InFountainTime:= 0;
           end;
        end else n_InFountainTime:= 0;
      end;
    end;
  end else
  if n_InFountainTime <> 0 then n_InFountainTime:= 0;
end;
//------------------------------挑战系统---------------------------------------
//发送删除挑战框中物品后,给客户端更新
procedure TPlayObject.SendDelChallengeItem(UserItem: pTUserItem);
var
  StdItem: pTStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  SendDefMessage(SM_CHALLENGEDELITEM_OK, 0, 0, 0, 0, '');
  if m_ChallengeCreat <> nil then begin
    if m_ChallengeCreat.m_nSoftVersionDateEx = 0 then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        CopyStdItemToOStdItem(StdItem, @OClientItem.s);
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then OClientItem.s.Name := sUserItemName;

        OClientItem.MakeIndex := UserItem.MakeIndex;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
      end;
      m_DefMsg := MakeDefaultMsg(SM_CHALLENGEREMOTEDELITEM, Integer(Self), 0, 0, 1, 0);
      m_ChallengeCreat.SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
    end else begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        ClientItem.s := StdItem^;
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;
        if UserItem.btValue[12] = 1 then ClientItem.s.Reserved1:=1//物品发光 20080223
         else ClientItem.s.Reserved1:= 0;

        if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080622
          if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//酒的品质
          if UserItem.btValue[1] <> 0 then ClientItem.s.MAC:=UserItem.btValue[1];//酒的酒精度
        end;

        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
      end;
      m_DefMsg := MakeDefaultMsg(SM_CHALLENGEREMOTEDELITEM, Integer(Self), 0, 0, 1, 0);
      TPlayObject(m_ChallengeCreat).SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
    end;
    m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();
    m_ChallengeLastTick := GetTickCount();
  end;
end;

//发送抵押的挑战物品
procedure TPlayObject.SendAddChallengeItem(UserItem: pTUserItem);
var
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  SendDefMessage(SM_CHALLENGEADDITEM_OK, 0, 0, 0, 0, '');
  if m_ChallengeCreat <> nil then begin
    if m_ChallengeCreat.m_nSoftVersionDateEx = 0 then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        StdItem80 := StdItem^;
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          StdItem80.Name := sUserItemName;

        ItemUnit.GetItemAddValue(UserItem, StdItem80);
        CopyStdItemToOStdItem(@StdItem80, @OClientItem.s);
        OClientItem.MakeIndex := UserItem.MakeIndex;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
        m_DefMsg := MakeDefaultMsg(SM_CHALLENGEREMOTEADDITEM, Integer(Self), 0, 0, 1, 0);
        m_ChallengeCreat.SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
        m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();
        m_ChallengeLastTick := GetTickCount();
      end;
    end else begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        StdItem80 := StdItem^;
        ItemUnit.GetItemAddValue(UserItem, StdItem80);

        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then StdItem80.Name := sUserItemName;
        if UserItem.btValue[12] = 1 then StdItem80.Reserved1:=1//物品发光 20080223
         else StdItem80.Reserved1:= 0;

        if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080622
          if UserItem.btValue[0] <> 0 then ClientItem.s.AC:=UserItem.btValue[0];//酒的品质
          if UserItem.btValue[1] <> 0 then ClientItem.s.MAC:=UserItem.btValue[1];//酒的酒精度
        end;

        ClientItem.s := StdItem80;
        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        m_DefMsg := MakeDefaultMsg(SM_CHALLENGEREMOTEADDITEM, Integer(Self), 0, 0, 1, 0);
        m_ChallengeCreat.SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
        m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();
        m_ChallengeLastTick := GetTickCount();
      end;
    end;
  end;
end;

//判断玩家是否面对面,是则弹出抵物品窗口 20080704
procedure TPlayObject.ClientChallenge;
var
  BaseObject: TBaseObject;
  PlayObject: TPlayObject;
begin
  if m_boChallengeing or (m_ChallengeCreat <> nil) then Exit;//如果正在挑战则退出
  if GetTickCount - m_ChallengeLastTick < 3000 then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sPleaseTryChallengeLaterMsg{'请稍后再挑战'});
    Exit;
  end;
  BaseObject := GetPoseCreate();//取面前对像
  if (BaseObject <> nil) and (BaseObject <> Self) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
    PlayObject := TPlayObject(BaseObject);
    if (PlayObject <> nil) and (PlayObject.GetPoseCreate = Self) then begin
      TPlayObject(Self).OpenChallengeDlg(PlayObject);//打开挑战抵押物品窗口
      PlayObject.OpenChallengeDlg(Self);//打开挑战抵押物品窗口
    end else begin
      SendDefMessage(SM_CHALLENGE_FAIL, 0, 0, 0, 0, '');
    end;
  end else begin
    SendDefMessage(SM_CHALLENGE_FAIL, 0, 0, 0, 0, '');
  end;
end;
//打开挑战抵押物品窗口
procedure TPlayObject.OpenChallengeDlg(PlayObject: TPlayObject);
begin
  m_boChallengeing := True;
  m_ChallengeCreat := PlayObject;
  GetBackChallengeItems();
  SendDefMessage(SM_CHALLENGEMENU, 0, 0, 0, 0, m_ChallengeCreat.m_sCharName);
  m_ChallengeLastTick := GetTickCount();
end;
//取回之前抵押物品
procedure TPlayObject.GetBackChallengeItems;
var
  I: Integer;
  UserItem: pTUserItem;
begin
  if m_ChallengeItemList.Count > 0 then begin
    for I := 0 to m_ChallengeItemList.Count - 1 do begin
      UserItem:= m_ChallengeItemList.Items[I];
      if UserItem <> nil then begin
         m_ItemList.Add(UserItem);
         SendAddItem(UserItem);
      end;
    end;
  end;
  m_ChallengeItemList.Clear;
  Inc(m_nGold, m_nChallengeGolds);
  m_nChallengeGolds := 0;
  Inc(m_nGAMEDIAMOND, m_nChallengeGAMEDIAMOND);
  m_nChallengeGAMEDIAMOND := 0;
  m_boChallengeOK := False;
end;

//客户端增加抵押物品到挑战框中
procedure TPlayObject.ClientAddChallengeItem(nItemIdx: Integer; sItemName: string);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if (m_ChallengeCreat = nil) or (not m_boChallengeing) then Exit;
  m_boCanQueryBag:= True;//增加挑战物品时,不能刷新包裹 20080917
  Try
    if Pos(' ', sItemName) >= 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
      GetValidStr3(sItemName, sItemName, [' ']);
    end;
    bo11 := False;
    if not m_ChallengeCreat.m_boChallengeOK then begin
      for I := m_ItemList.Count - 1 downto 0 do begin
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem = nil then Continue;
        if UserItem.MakeIndex = nItemIdx then begin
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

          if (CompareText(sUserItemName, sItemName) = 0) and (m_ChallengeItemList.Count < 5) then begin
            if CheckItemValue(UserItem ,1) then Break //20080314 禁止交易
            else
            {if Assigned(zPlugOfEngine.CheckCanDealItem) then begin //20080308 禁止交易物品
              if not zPlugOfEngine.CheckCanDealItem(Self, PChar(sUserItemName)) then Break;
            end;}
            if PlugOfCheckCanItem(1, sUserItemName, False, 0, 0) then Break;//禁止物品规则(管理插件功能) 20080729
            
            m_ChallengeItemList.Add(UserItem);
            TPlayObject(Self).SendAddChallengeItem(UserItem);//发送抵押的挑战物品
            m_ItemList.Delete(I);
            ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
            bo11 := True;
            Break;
          end;
        end;
      end;
    end;
    if not bo11 then SendDefMessage(SM_CHALLENGEADDITEM_FAIL, 0, 0, 0, 0, '');
  finally
    m_boCanQueryBag:= False;//增加挑战物品时,不能刷新包裹 20080917
  end;
end;
//客户端删除抵押的挑战物品
procedure TPlayObject.ClientDelChallengeItem(nItemIdx: Integer; sItemName: string);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if (m_ChallengeCreat = nil) or (not m_boChallengeing) then Exit;
  if Pos(' ', sItemName) >= 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
    GetValidStr3(sItemName, sItemName, [' ']);
  end;
  bo11 := False;
  if not m_ChallengeCreat.m_boChallengeOK then begin
    for I := m_ChallengeItemList.Count - 1 downto 0 do begin
      if m_ChallengeItemList.Count <= 0 then Break;
      UserItem := m_ChallengeItemList.Items[I];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nItemIdx then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then begin
          m_ItemList.Add(UserItem);
          TPlayObject(Self).SendDelChallengeItem(UserItem);//发送删除抵押的挑战物品
          m_ChallengeItemList.Delete(I);
          bo11 := True;
          Break;
        end;
      end;
    end;//for
  end;
  if not bo11 then SendDefMessage(SM_CHALLENGEDELITEM_FAIL, 0, 0, 0, 0, '');
end;

//挑战取消
procedure TPlayObject.ChallengeCancel;
begin
  if not m_boChallengeing then Exit;
  m_boChallengeing := False;
  SendDefMessage(SM_CHALLENGECANCEL, 0, 0, 0, 0, '');
  if m_ChallengeCreat <> nil then  m_ChallengeCreat.ChallengeCancel;
  m_ChallengeCreat := nil;
  GetBackChallengeItems();
  SysMsg(g_sChallengeActionCancelMsg{'挑战取消'}, c_Green, t_Hint);
  m_ChallengeLastTick := GetTickCount();
end;

//客户端取消挑战
procedure TPlayObject.ClientCancelChallenge;
begin
  ChallengeCancel;
end;

//客户端把金币放到挑战框中
procedure TPlayObject.ClientChangeChallengeGold(nGold: Integer);
var
  bo09: Boolean;
begin
  //禁止取回放入挑战栏内的金币
  if (m_nChallengeGolds > 0) and g_Config.boCanNotGetBackDeal then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sChallengeItemsDenyGetBackMsg);
    SendDefMessage(SM_CHALLENGEDELITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
  if nGold < 0 then begin
    SendDefMessage(SM_CHALLENCHGGOLD_FAIL, m_nChallengeGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
    Exit;
  end;
  bo09 := False;
  if (m_ChallengeCreat <> nil) and (GetPoseCreate = m_ChallengeCreat) then begin
    if not m_ChallengeCreat.m_boChallengeOK then begin
      if (m_nGold + m_nChallengeGolds) >= nGold then begin
        m_nGold := (m_nGold + m_nChallengeGolds) - nGold;
        m_nChallengeGolds := nGold;
        SendDefMessage(SM_CHALLENCHGGOLD_OK, m_nChallengeGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
        m_ChallengeCreat.SendDefMessage(SM_CHALLENREMOTECHGGOLD, m_nChallengeGolds, 0, 0, 0, '');
        m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();
        bo09 := True;
        m_ChallengeLastTick := GetTickCount();
      end;
    end;
  end;
  if not bo09 then  SendDefMessage(SM_CHALLENCHGGOLD_FAIL, m_nChallengeGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
end;

//客户端把金刚石放到挑战框中
procedure TPlayObject.ClientChangeChallengeDIAMOND(nDIAMOND: Integer);
var
  bo09: Boolean;
begin
  if nDIAMOND < 0 then begin
    SendDefMessage(SM_CHALLENCHGDIAMOND_FAIL, m_nChallengeGAMEDIAMOND, LoWord(m_nGAMEDIAMOND), HiWord(m_nGAMEDIAMOND), 0, '');
    Exit;
  end;
  bo09 := False;
  if (m_ChallengeCreat <> nil) and (GetPoseCreate = m_ChallengeCreat) then begin
    if not m_ChallengeCreat.m_boChallengeOK then begin
      if (m_nGAMEDIAMOND + m_nChallengeGAMEDIAMOND) >= nDIAMOND then begin
        m_nGAMEDIAMOND := (m_nGAMEDIAMOND + m_nChallengeGAMEDIAMOND) - nDIAMOND;
        m_nChallengeGAMEDIAMOND := nDIAMOND;
        SendDefMessage(SM_CHALLENCHGDIAMOND_OK, m_nChallengeGAMEDIAMOND, LoWord(m_nGAMEDIAMOND), HiWord(m_nGAMEDIAMOND), 0, '');
        m_ChallengeCreat.SendDefMessage(SM_CHALLENREMOTECHGDIAMOND, m_nChallengeGAMEDIAMOND, 0, 0, 0, '');
        m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();
        bo09 := True;
        m_ChallengeLastTick := GetTickCount();
      end;
    end;
  end;
  if not bo09 then  SendDefMessage(SM_CHALLENCHGDIAMOND_FAIL, m_nChallengeGAMEDIAMOND, LoWord(m_nGAMEDIAMOND), HiWord(m_nGAMEDIAMOND), 0, '');
end;

//挑战抵押物品结束
procedure TPlayObject.ClientChallengeEnd;
var
  bo11: Boolean;
begin
  m_boChallengeOK := True;
  if m_ChallengeCreat = nil then Exit;
  if ((GetTickCount - m_ChallengeLastTick) < 1000) or ((GetTickCount - m_ChallengeCreat.m_ChallengeLastTick) < 1000) then begin
    SysMsg(g_sChallengeOKTooFast{'过早按了确定按钮。'}, c_Red, t_Hint);
    ChallengeCancel();
    Exit;
  end;
  if m_ChallengeCreat.m_boChallengeOK then begin
    bo11 := True;
    if (MAXBAGITEM - m_ItemList.Count) < m_ChallengeCreat.m_ChallengeItemList.Count then begin
      bo11 := False;
      SysMsg(g_sChallengeYourBagSizeTooSmall, c_Red, t_Hint);
    end;
    if (m_nGoldMax - m_nGold) < m_ChallengeCreat.m_nChallengeGolds then begin
      SysMsg(g_sChallengeYourGoldLargeThenLimit, c_Red, t_Hint);
      bo11 := False;
    end;
    if (MAXBAGITEM - m_ChallengeCreat.m_ItemList.Count) < m_ChallengeItemList.Count then begin
      SysMsg(g_sChallengeHumanBagSizeTooSmall, c_Red, t_Hint);
      bo11 := False;
    end;
    if (m_ChallengeCreat.m_nGoldMax - m_ChallengeCreat.m_nGold) < m_nChallengeGolds then begin
      SysMsg(g_sChallengeHumanGoldLargeThenLimit, c_Red, t_Hint);
      bo11 := False;
    end;

    if bo11 then begin
      SendDefMessage(SM_CLOSECHALLENGE, 0, 0, 0, 0, '');//关闭挑战抵押物品窗口
      m_ChallengeCreat.SendDefMessage(SM_CLOSECHALLENGE, 0, 0, 0, 0, '');//关闭挑战抵押物品窗口
      if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@Challenge', False);//进入触发段(传送挑战地图)
    end else begin
      ChallengeCancel();
    end;
  end else begin
    SysMsg(g_sYouChallengeOKMsg, c_Green, t_Hint);
    m_ChallengeCreat.SysMsg(g_sPoseChallengeOKMsg, c_Green, t_Hint);
  end;
end;
//胜方取得物品
procedure TPlayObject.WinGetChallengeItems;
var
  I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  if m_ChallengeCreat <> nil then begin
    m_ChallengeCreat.m_boChallengeing := False;
    m_boChallengeing := False;
    m_ChallengeCreat.m_ChallengeTime :=0;
    m_ChallengeTime :=0;
    if m_ChallengeCreat.m_ChallengeItemList.Count > 0 then begin
      for I := 0 to m_ChallengeCreat.m_ChallengeItemList.Count - 1 do begin
        UserItem:= m_ChallengeCreat.m_ChallengeItemList.Items[I];
        if UserItem <> nil then begin
           StdItem := UserEngine.GetStdItem(UserItem.wIndex);
           if StdItem <> nil then begin
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('36' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                  IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                  '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                  '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                  '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                  '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                  IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                  IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                  IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                  IntToStr(UserItem.btValue[14])+ #9 + m_ChallengeCreat.m_sCharName);
           end;
           if IsEnoughBag then begin //人物的包裹是否满了
             ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
             m_ItemList.Add(UserItem);
             SendAddItem(UserItem);
           end else
           if m_StorageItemList.Count < MAXBAGITEM then begin//保存到仓库里 20080713
              ClearCopyItem(1, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
              m_StorageItemList.Add(UserItem);
           end;
        end;
      end;
    end;
    m_ChallengeCreat.m_ChallengeItemList.Clear;
    if m_ChallengeCreat.m_nChallengeGolds > 0 then begin
      Inc(m_nGold, m_ChallengeCreat.m_nChallengeGolds);
      if g_boGameLogGold then
        AddGameDataLog('36' + #9 +m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
          sSTRING_GOLDNAME + #9 + IntToStr(m_ChallengeCreat.m_nChallengeGolds) + #9 +'1' + #9 + m_ChallengeCreat.m_sCharName);
      m_ChallengeCreat.m_nChallengeGolds := 0;
    end;
    if m_ChallengeCreat.m_nChallengeGAMEDIAMOND > 0 then begin
      Inc(m_nGAMEDIAMOND, m_ChallengeCreat.m_nChallengeGAMEDIAMOND);
      if g_boGameLogGold then
        AddGameDataLog('36' + #9 + m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 + g_Config.sGameDiaMond + #9 +
          IntToStr(m_ChallengeCreat.m_nChallengeGAMEDIAMOND) + #9 +'1' + #9 + m_ChallengeCreat.m_sCharName);
      m_ChallengeCreat.m_nChallengeGAMEDIAMOND := 0;
    end;
    m_ChallengeCreat.m_boChallengeOK := False;
    m_ChallengeCreat.m_WAbil.HP := m_ChallengeCreat.m_WAbil.MaxHP;
    m_ChallengeCreat.m_WAbil.MP := m_ChallengeCreat.m_WAbil.MaxMP;
    m_ChallengeCreat.HealthSpellChanged();
    m_ChallengeCreat.m_ChallengeCreat:=nil;
    m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();

    if m_ChallengeItemList.Count > 0 then begin
      for I := 0 to m_ChallengeItemList.Count - 1 do begin
        UserItem:= m_ChallengeItemList.Items[I];
        if UserItem <> nil then begin
           if IsEnoughBag then begin //人物的包裹是否满了
             m_ItemList.Add(UserItem);
             SendAddItem(UserItem);
           end else
           if m_StorageItemList.Count < MAXBAGITEM then begin//保存到仓库里 20080713
              m_StorageItemList.Add(UserItem);
           end;
        end;
      end;
    end;
    m_ChallengeItemList.Clear;
    Inc(m_nGold, m_nChallengeGolds);
    m_nChallengeGolds := 0;
    Inc(m_nGAMEDIAMOND, m_nChallengeGAMEDIAMOND);
    m_nChallengeGAMEDIAMOND := 0;
    m_boChallengeOK := False;
    m_WAbil.HP := m_WAbil.MaxHP;
    m_WAbil.MP := m_WAbil.MaxMP;
    HealthSpellChanged();
    m_ChallengeCreat:=nil;
    m_ChallengeLastTick := GetTickCount();
    GoldChanged();
    GameGoldChanged;//更新金刚石和金币
  end;
end;

//气血石功能 20080729
procedure TPlayObject.PlaySuperRock;
var
  StdItem: pTStdItem;
  nTempDura: Integer;
begin
  Try
    //气血石 魔血石                                                                                                  //20080611
    if (not m_boDeath) and (not m_boGhost) and (m_WAbil.HP > 0) then begin
      if (m_UseItems[U_CHARM].wIndex > 0) and (m_UseItems[U_CHARM].Dura > 0) then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_CHARM].wIndex);
        if (StdItem <> nil) and (StdItem.Shape > 0) and m_PEnvir.AllowStdItems(StdItem.Name) then begin
          case StdItem.Shape of
            1: begin //气血石
                //if m_WAbil.HP <= ((m_WAbil.MaxHP * g_Config.nStartHPRock) div 100) then begin
                if (m_WAbil.MaxHP - m_WAbil.HP) >= g_Config.nStartHPRock then begin//200081215 改成掉点数启用
                  if GetTickCount - dwRockAddHPTick > g_Config.nHPRockSpell then begin
                    dwRockAddHPTick:= GetTickCount();//气石加HP间隔
                    if m_UseItems[U_CHARM].Dura * 10 > g_Config.nHPRockDecDura then begin
                      Inc(m_WAbil.HP, g_Config.nRockAddHP);
                      nTempDura := m_UseItems[U_CHARM].Dura * 10;
                      Dec(nTempDura, g_Config.nHPRockDecDura);
                      m_UseItems[U_CHARM].Dura := Round(nTempDura / 10);
                      if m_UseItems[U_CHARM].Dura > 0 then begin
                         SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                      end else begin
                         SendDelItems(@m_UseItems[U_CHARM]);
                         m_UseItems[U_CHARM].wIndex:= 0;
                      end;
                    end else begin
                      Inc(m_WAbil.HP, g_Config.nRockAddHP);
                      m_UseItems[U_CHARM].Dura := 0;
                      SendDelItems(@m_UseItems[U_CHARM]);
                      m_UseItems[U_CHARM].wIndex:= 0;
                    end;
                    if m_WAbil.HP > m_WAbil.MaxHP then m_WAbil.HP := m_WAbil.MaxHP;
                    PlugHealthSpellChanged();
                  end;
                end;
              end;
            2: begin
                //if m_WAbil.MP <= ((m_WAbil.MaxMP * g_Config.nStartMPRock) div 100) then begin
                if (m_WAbil.MaxMP - m_WAbil.MP) >= g_Config.nStartMPRock then begin//200081215 改成掉点数启用
                  if GetTickCount - dwRockAddMPTick > g_Config.nMPRockSpell then begin
                    dwRockAddMPTick:= GetTickCount;//气石加MP间隔
                    if m_UseItems[U_CHARM].Dura * 10 > g_Config.nMPRockDecDura then begin
                      Inc(m_WAbil.MP, g_Config.nRockAddMP);
                      nTempDura := m_UseItems[U_CHARM].Dura * 10;
                      Dec(nTempDura, g_Config.nMPRockDecDura);
                      m_UseItems[U_CHARM].Dura := Round(nTempDura / 10);
                      if m_UseItems[U_CHARM].Dura > 0 then begin
                         SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                      end else begin
                         SendDelItems(@m_UseItems[U_CHARM]);
                         m_UseItems[U_CHARM].wIndex:= 0;
                      end;
                    end else begin
                      Inc(m_WAbil.MP, g_Config.nRockAddMP);
                      m_UseItems[U_CHARM].Dura := 0;
                      SendDelItems(@m_UseItems[U_CHARM]);
                      m_UseItems[U_CHARM].wIndex:= 0;
                    end;
                    if m_WAbil.MP > m_WAbil.MaxMP then  m_WAbil.MP:= m_WAbil.MaxMP ;
                    PlugHealthSpellChanged();
                  end;
                end;
              end;
            3: begin 
              //if m_WAbil.HP <= ((m_WAbil.MaxHP * g_Config.nStartHPMPRock) div 100) then begin
              if (m_WAbil.MaxHP - m_WAbil.HP) >= g_Config.nStartHPMPRock then begin//200081215 改成掉点数启用
                  if GetTickCount - dwRockAddHPTick > g_Config.nHPMPRockSpell then begin
                    dwRockAddHPTick:= GetTickCount;//气石加HP间隔
                    if m_UseItems[U_CHARM].Dura * 10 > g_Config.nHPMPRockDecDura then begin
                      Inc(m_WAbil.HP, g_Config.nRockAddHPMP);
                      nTempDura := m_UseItems[U_CHARM].Dura * 10;
                      Dec(nTempDura, g_Config.nHPMPRockDecDura);
                      m_UseItems[U_CHARM].Dura := Round(nTempDura / 10);
                      if m_UseItems[U_CHARM].Dura > 0 then begin
                         SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                      end else begin
                         SendDelItems(@m_UseItems[U_CHARM]);
                         m_UseItems[U_CHARM].wIndex:= 0;
                      end;
                    end else begin
                      Inc(m_WAbil.HP, g_Config.nRockAddHPMP);
                      m_UseItems[U_CHARM].Dura := 0;
                      SendDelItems(@m_UseItems[U_CHARM]);
                      m_UseItems[U_CHARM].wIndex:= 0;
                    end;
                    if m_WAbil.HP > m_WAbil.MaxHP then m_WAbil.HP := m_WAbil.MaxHP;
                    PlugHealthSpellChanged();
                  end;
                end;
              //======================================================================
              //if m_WAbil.MP <= ((m_WAbil.MaxMP * g_Config.nStartHPMPRock) div 100) then begin
              if (m_WAbil.MaxMP - m_WAbil.MP) >= g_Config.nStartHPMPRock then begin//200081215 改成掉点数启用
                  if GetTickCount - dwRockAddMPTick > g_Config.nHPMPRockSpell then begin
                    dwRockAddMPTick:= GetTickCount;//气石加MP间隔
                    if m_UseItems[U_CHARM].Dura * 10 > g_Config.nHPMPRockDecDura then begin
                      Inc(m_WAbil.MP, g_Config.nRockAddHPMP);
                      nTempDura := m_UseItems[U_CHARM].Dura * 10;
                      Dec(nTempDura, g_Config.nHPMPRockDecDura);
                      m_UseItems[U_CHARM].Dura := Round(nTempDura / 10);
                      if m_UseItems[U_CHARM].Dura > 0 then begin
                         SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                      end else begin
                         SendDelItems(@m_UseItems[U_CHARM]);
                         m_UseItems[U_CHARM].wIndex:= 0;
                      end;
                    end else begin
                      Inc(m_WAbil.MP, g_Config.nRockAddHPMP);
                      m_UseItems[U_CHARM].Dura := 0;
                      SendDelItems(@m_UseItems[U_CHARM]);
                      m_UseItems[U_CHARM].wIndex:= 0;
                    end;
                    if m_WAbil.MP > m_WAbil.MaxMP then m_WAbil.MP := m_WAbil.MaxMP;
                    PlugHealthSpellChanged();
                  end;
                end;
            end;//3 begin
          end;
        end;
      end;
    end;
  except
    MainOutMessage('{异常} TPlayObject.PlaySuperRock');
  end;
end;

//客户端取商铺物品列表 20080730
procedure TPlayObject.ClientGetShopItemList(nPage,nType: Integer);
  function GetPageCount(nItemListCount: Integer): Integer;
  begin
    Result := 0;
    if nItemListCount > 0 then begin
      Result := nItemListCount div 10;
      if (nItemListCount mod 10) > 0 then Inc(Result);
    end;
  end;
var
  I: Integer;
  n01,n02,n03: Integer;
  sSendStr,sSendStr1: string;
  pShopInfo: pTShopInfo;
  ShopInfo: TShopInfo;
  nPageCount: Integer;
  TempList: Classes.TList;
begin
  if m_boCanQueryShopItme then Exit;//是否可以刷新商铺 20080907
  m_boCanQueryShopItme:= True;//是否可以刷新商铺 20080907
  Try
    Try
    if g_ShopItemList = nil then Exit;
    n01 := 0;
    n02 := 0;
    n03 := 0;
    sSendStr := '';
    sSendStr1 := '';

    if g_ShopItemList.Count > 0 then begin//20080629
      for I := 0 to g_ShopItemList.Count - 1 do begin
          pShopInfo := pTShopInfo(g_ShopItemList.Items[I]);
          ShopInfo := pShopInfo^;
          if strtoint(ShopInfo.Idx) = nType then Inc(n03);
      end;
    end;
    nPageCount := GetPageCount(n03);
    if nPage > 0 then begin
      if g_ShopItemList.Count >= nPage * 10 then begin
        TempList := TList.Create;
        for I := 0 to g_ShopItemList.Count - 1 do begin
          pShopInfo := pTShopInfo(g_ShopItemList.Items[I]);
          ShopInfo := pShopInfo^;
          if StrToInt(ShopInfo.Idx) = nType then TempList.Add(pShopInfo);
        end;
        for I:= nPage * 10 to TempList.Count -1 do begin
          pShopInfo := pTShopInfo(TempList.Items[I]);
          ShopInfo := pShopInfo^;
          Inc(n01);
          sSendStr := sSendStr + EncodeBuffer(@ShopInfo,SizeOf(TShopInfo))+'/';
          if n01 >= 10 then break;
        end;
        TempList.Free;
      end;
    end else begin
      if g_ShopItemList.Count > 0 then begin//20080629
        for I := 0 to g_ShopItemList.Count - 1 do begin
          pShopInfo := pTShopInfo(g_ShopItemList.Items[I]);
          ShopInfo := pShopInfo^;

          if strtoint(ShopInfo.Idx) = nType then begin
            Inc(n01);
            sSendStr := sSendStr + EncodeBuffer(@ShopInfo,SizeOf(TShopInfo))+'/';
            if n01 >= 10 then break;
          end;
        end;
      end;
    end;
    if sSendStr <> '' then begin
      SendMsg(Self, RM_OPENSHOP, 0, nPageCount, nPage + 1, n01, sSendStr);
    end;
    // 齐珍类型
    if g_ShopItemList.Count > 0 then begin//20080629
      for I := 0 to g_ShopItemList.Count - 1 do begin
          pShopInfo := pTShopInfo(g_ShopItemList.Items[I]);
          ShopInfo := pShopInfo^;
          if strtoint(ShopInfo.Idx) = 5 then begin
            Inc(n02);
            sSendStr1 := sSendStr1 + EncodeBuffer(@ShopInfo,SizeOf(TShopInfo))+'/';
            if n02 >= 5 then break;
          end;
      end;
    end;
    if sSendStr1 <> '' then begin
      SendMsg(Self, RM_OPENSHOPSPECIALLY, 0, nPageCount, nPage + 1, n02, sSendStr1);
    end;
    except
      MainOutMessage('{异常} TPlayObject.ClientGetShopItemList');
    end;
  finally
    m_boCanQueryShopItme:= False;//是否可以刷新商铺 20080907
  end;
end;

//客户端购买商铺物品 20080730
procedure TPlayObject.ClientBuyShopItem(sItemName: String);
var
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  nPrice: Integer;
begin
  Try
  StdItem := UserEngine.GetShopStdItem(sItemName);
  if StdItem <> nil then begin
    nPrice := StdItem.Price div 100;
    if (m_nGameGold >= nPrice) and (nPrice >= 0) then begin
      if IsEnoughBag then begin
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
           if (StdItem.StdMode = 60) and (StdItem.shape <> 0) and (StdItem.Anicount = 2) then begin//购买药酒时，品质低于5时，重新计算 20081210
             if UserItem.btValue[0] < 5 then UserItem.btValue[0]:= Random(3) + 5;
           end;
           if AddItemToBag(UserItem) then begin
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('30' + #9 + m_sMapName+ #9 +
                IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 + StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                IntToStr(UserItem.btValue[14])+ #9 + IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax));

             DecGameGold(nPrice);
             SendAddItem(UserItem);
             GameGoldChanged;
             SysMsg('[成功] '+ sItemName +' 购买成功！', c_Blue, t_Hint);
           end;
        end else DisPose(UserItem);
      end else begin
        SendMsg(self, RM_BUYSHOPITEM_FAIL, 0, 2, 0, 0, sItemName);//包裹满
      end;
    end else begin
      SendMsg(self, RM_BUYSHOPITEM_FAIL, 0, 1, 0, 0, sItemName);
    end;
  end else begin
    SendMsg(self, RM_BUYSHOPITEM_FAIL, 0, 3, 0, 0, sItemName);
  end;

  except
    MainOutMessage('{异常} TPlayObject.ClientBuyShopItem');
  end;
end;

//客户端商铺赠送 20080730
procedure TPlayObject.ClientBuyShopItemGive(sMsg: String);
var
  GiveUseName,GiveItemName,GiveMyName: string;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  nPrice: Integer;
  PlayObjectGive:TPlayObject;
begin
Try
  sMsg := GetValidStr3(sMsg, GiveItemName, ['/']);
  sMsg := GetValidStr3(sMsg, GiveUseName, ['/']);
  sMsg := GetValidStr3(sMsg, GiveMyName, ['/']);

  GiveUseName:= DeCodeString(GiveUseName);
  GiveItemName:= DeCodeString(GiveItemName);
  GiveMyName:= DeCodeString(GiveMyName);
  StdItem := UserEngine.GetShopStdItem(GiveItemName);
  if StdItem <> nil then begin
    PlayObjectGive:= UserEngine.GetPlayObject(GiveUseName);
    if PlayObjectGive = nil then begin  //角色没在线
      SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 4, 0, 0, GiveUseName);//赠送的人没在线
      Exit;
    end;
    nPrice := StdItem.Price div 100;
    if (m_nGameGold >= nPrice) and (nPrice >= 0) then begin
       if PlayObjectGive.IsEnoughBag then begin//人物背包
           New(UserItem);
           if UserEngine.CopyToUserItemFromName(GiveItemName, UserItem) then begin
             if PlayObjectGive.AddItemToBag(UserItem) then begin
               if StdItem.NeedIdentify = 1 then
                AddGameDataLog('30' + #9 + m_sMapName+ #9 +
                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                  PlayObjectGive.m_sCharName + #9 + StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+ //攻
                  '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+ //魔法
                  '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+ //道术
                  '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+ //防御
                  '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+//魔御
                  IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                  IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                  IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                  IntToStr(UserItem.btValue[14])+ #9 +m_sCharName+'(赠)');

               DecGameGold(nPrice);
               GameGoldChanged;
               PlayObjectGive.SendAddItem(UserItem);
               SendMsg(self, RM_BUYSHOPITEMGIVE_SUCCESS, 0, 1, 0, 0, '[成功]赠送给 '+GiveItemName+' 物品 '+GiveUseName+' 成功！');
               PlayObjectGive.SysMsg('[恭喜]你的朋友 '+GiveMyName+' 在商铺里给你买了 '+GiveItemName+' 请您查收！', c_Blue, t_Hint);
             end;
           end else DisPose(UserItem);
       end else begin //背包满
         SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 3, 0, 0, GiveItemName);
       end;
    end else begin //元宝不够
      SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 1, 0, 0, GiveItemName);
    end;
  end else begin //没有找到这个物品
    SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 2, 0, 0, GiveItemName);
  end;
  except
    MainOutMessage('{异常} TPlayObject.ClientBuyShopItemGive');
  end;
end;

//客户端商铺兑换灵符 20080730
procedure TPlayObject.ClientExchangeGameGird(nGameGird: Integer);
begin
  Try
    if not g_Config.g_boGameGird then begin
      SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, '[失败]对不起，本服务没有开放');
      Exit;
    end;
    if m_nGameGold <= 0 then begin
      SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, '[失败]您的'+g_Config.sGameGoldName+ '不够，请冲值！ 本服'+IntToStr(g_Config.g_nGameGold)+'个'+g_Config.sGameGoldName+'兑换1个灵符！');
      Exit;
    end;
    if m_nGameGold >= nGameGird * g_Config.g_nGameGold then begin    //当前元宝>兑换数量*每个灵符单价
      DecGameGold(nGameGird * g_Config.g_nGameGold);//给角色减元宝
      IncGameGird(nGameGird);
      GameGoldChanged;
      SendMsg(self, RM_EXCHANGEGAMEGIRD_SUCCESS, 0, {nGameGird}0, 0, 0, '[成功]您成功的兑换了 '+ IntToStr(nGameGird)+' 个灵符');
    end else SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0,'[失败]您的'+g_Config.sGameGoldName+ '不够，请冲值！ 本服'+IntToStr(g_Config.g_nGameGold)+'个'+g_Config.sGameGoldName+'兑换1个灵符！');//元宝不足
  except
    MainOutMessage('{异常} TPlayObject.ClientExchangeGameGird');
  end;
end;

//清理包裹和仓库复制物品 20080816
procedure TPlayObject.ClearCopyItem(nCode:Byte;wIndex, MakeIndex: Integer);
var
  I: Integer;
  UserItem: pTUserItem;
begin
  Try
    m_boOperationItemList:= True;//20080928 防止同时操作背包列表时保存
    case nCode of
      0:begin//检查背包中是否有复制品
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem := m_ItemList.Items[I];
            if (UserItem.wIndex = wIndex) and (UserItem.MakeIndex = MakeIndex) then begin
              SendDelItems(UserItem);
              MainOutMessage('[清理包裹复制品]('+ m_sCharName+')'+ UserEngine.GetStdItemName(UserItem.wIndex)+'('+IntToStr(UserItem.MakeIndex)+')['+
                        IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                        IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                        IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                        IntToStr(UserItem.btValue[14])+'/#'+IntToStr(UserItem.btValue[15])+'/'+IntToStr(UserItem.btValue[16])+'/'+
                        IntToStr(UserItem.btValue[17])+'/'+IntToStr(UserItem.btValue[18])+'/'+IntToStr(UserItem.btValue[19]));//20081225
              m_ItemList.Delete(I);
              Break;//20081014 只找到一件则退出，提高效率
            end;
          end;
       end;//0
      1:begin
         for I := m_StorageItemList.Count - 1 downto 0 do begin
           if m_StorageItemList.Count <= 0 then Break;
           UserItem := m_StorageItemList.Items[I];
           if (UserItem.wIndex = wIndex) and (UserItem.MakeIndex = MakeIndex) then begin
              MainOutMessage('[清理仓库复制品]('+ m_sCharName+')'+ UserEngine.GetStdItemName(UserItem.wIndex)+'('+IntToStr(UserItem.MakeIndex)+')['+
                        IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                        IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                        IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                        IntToStr(UserItem.btValue[14])+'/#'+IntToStr(UserItem.btValue[15])+'/'+IntToStr(UserItem.btValue[16])+'/'+
                        IntToStr(UserItem.btValue[17])+'/'+IntToStr(UserItem.btValue[18])+'/'+IntToStr(UserItem.btValue[19]));//20081225           
              m_StorageItemList.Delete(I);
              Break;//20081014 只找到一件则退出，提高效率
           end;
         end;//for I
       end;//1
    end;
    m_boOperationItemList:= False;//20080928 防止同时操作背包列表时保存
  except
    MainOutMessage('{异常} TPlayObject.ClearCopyItem');
    m_boOperationItemList:= False;//20080928 防止同时操作背包列表时保存
  end;
end;

//检查人物装备死亡物品是否爆 20081127
function TPlayObject.CheckItemBindDieNoDrop(UserItem: pTUserItem): Boolean;
var
  I: Integer;
  ItemBind: pTItemBind;
begin
  Result := False;
  g_ItemBindDieNoDropName.Lock;
  try
    if g_ItemBindDieNoDropName.Count > 0 then begin
      for I := 0 to g_ItemBindDieNoDropName.Count - 1 do begin
        ItemBind := g_ItemBindDieNoDropName.Items[I];
        if ItemBind <> nil then begin
          if ItemBind.nItemIdx = UserItem.wIndex then begin
            if (CompareText(ItemBind.sBindName, m_sCharName) = 0) then Result := True;
            Exit;
          end;
        end;
      end;
    end;
  finally
    g_ItemBindDieNoDropName.UnLock;
  end;
end;

//禁止物品规则(管理插件功能) 20080729
//boCanHit:掉落是否需要提示
//nCode:0-物品禁止扔 1-物品禁止交易 2-物品禁止存  3-物品禁止修 4-物品掉落提示  5-开启宝箱提示
//      6-永不暴出   7-挖取提示    8-禁止英雄使用 9-禁止捡起(除GM外) 10-死亡掉落
function TBaseObject.PlugOfCheckCanItem(nCode: Byte; ItemName: String; boCanHit: Boolean; dx, dy:Integer): Boolean;
var
  I: Integer;
  CheckItem: pTCheckItem;
  sMsg: String;
begin
  Result:= False;
  Try
    if g_CheckItemList = nil then Exit;
    if g_CheckItemList.Count > 0 then begin
      for I := 0 to g_CheckItemList.Count - 1 do begin
        CheckItem := g_CheckItemList.Items[I];
        if CheckItem <> nil then begin
          if CompareText(CheckItem.szItemName, ItemName) = 0 then begin
             Case nCode of
               0: begin//物品禁止扔
                  if CheckItem.boCanDrop then begin
                     if g_ManageNPC <> nil then begin
                       if m_btRaceServer = RC_PLAYOBJECT then begin
                         SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(self), 0, 0, '此物品禁止扔在地上！！！');                       end else                       if (m_btRaceServer = RC_HEROOBJECT) then begin                         THeroObject(self).SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(self), 0, 0, '此物品禁止扔在地上！！！');                       end;                     end;                      Result:= True;
                     break;
                  end;
               end;//0
               1: begin//物品禁止交易  *
                  if CheckItem.boCanDeal then begin
                     if (g_ManageNPC <> nil) and (not boCanHit) then//20080913 修改
                       SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(self), 0, 0, '此物品禁止交易！！！');                     Result:= True;
                     break;
                  end;
               end;//1
               2: begin//物品禁止存
                  if CheckItem.boCanStorage then begin
                     if g_ManageNPC <> nil then
                       SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(self), 0, 0, '此物品禁止存仓库！！！');                     Result:= True;
                     break;
                  end;
               end;//2
               3: begin//物品禁止修  *
                  if CheckItem.boCanRepair then begin
                     Result:= True;
                     break;
                  end;
               end;
               4: begin//物品掉落提示 *
                  if CheckItem.boCanDropHint and boCanHit then begin
                     sMsg := AnsiReplaceText(g_sItmeDropHintMsg, '%X', IntTostr(dx));
                     sMsg := AnsiReplaceText(sMsg, '%Y', IntTostr(dy));
                     sMsg := AnsiReplaceText(sMsg, '%map', m_PEnvir.sMapDesc);
                     sMsg := AnsiReplaceText(sMsg, '%item', ItemName);
                     sMsg := AnsiReplaceText(sMsg, '%name', m_sCharName);
                     UserEngine.SendBroadCastMsgExt(sMsg, t_Say);
                     Result:= True;
                     break;
                  end;
               end;//4
               5: begin//开启宝箱提示  *
                  if CheckItem.boCanOpenBoxsHint then begin
                     sMsg := AnsiReplaceText(g_sBoxsItemHintMsg, '%name', m_sCharName);
                     sMsg := AnsiReplaceText(sMsg, '%s', ItemName);
                     UserEngine.SendBroadCastMsgExt(sMsg, t_Say);
                     Result:= True;
                     break;
                  end;
               end;//5
               6: begin//永不暴出  *
                  if CheckItem.boCanNoDropItem then begin
                     Result:= True;
                     break;
                  end;
               end;//6
               7: begin//挖取提示 *
                  if CheckItem.boCanButchHint then begin
                    sMsg := AnsiReplaceText(g_sButchItemHintMsg, '%s', m_sCharName);
                    sMsg := AnsiReplaceText(sMsg, '%map', m_PEnvir.sMapDesc);
                    sMsg := AnsiReplaceText(sMsg, '%item', ItemName);
                    sMsg := AnsiReplaceText(sMsg, '%x', IntToStr(m_nCurrX));
                    sMsg := AnsiReplaceText(sMsg, '%y', IntToStr(m_nCurrY));
                    UserEngine.SendBroadCastMsgExt(sMsg, t_Say);
                    Result:= True;
                    break;
                  end;
               end;//7
               8: begin//禁止英雄使用
                  if CheckItem.boCanHeroUse then begin
                    if m_btRaceServer = RC_PLAYOBJECT then begin
                      SysMsg('此物品禁止英雄使用!', c_Red, t_Hint);                    end else                    if m_btRaceServer = RC_HEROOBJECT then begin                      THeroObject(self).SysMsg('此物品禁止英雄使用!', c_Red, t_Hint);                    end;
                    Result:= True;
                    break;
                  end;
               end;//8
               9: begin//禁止捡起(除GM外) *
                  if CheckItem.boPickUpItem then begin
                    Result:= True;
                    break;
                  end;
               end;//9
               10: begin//死亡掉落  *
                 if CheckItem.boDieDropItems then begin
                    Result:= True;
                    break;
                 end;
               end;//10
             end;//Case
          end;
        end;//CheckItem <> nil
      end;//for
    end;
  except
    MainOutMessage('{异常} TBaseObject.PlugOfCheckCanItem Code:'+inttostr(nCode));
  end;
end;

end.

